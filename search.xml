<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我</title>
    <url>/%E6%88%91.html</url>
    <content><![CDATA[<p>你好，我是一名程序员。</p>
<h1 id="技能领域">技能领域</h1>
<p>Android 应用开发、Android
Framework、音视频、OpenGL、OpenCV、WebRTC、FFmpeg</p>
<h1 id="编程语言">编程语言</h1>
<p>Java、C++、Kotlin、C、Python、JavaScript</p>
<h1 id="业余研究">业余研究</h1>
<p>哲学、数学</p>
]]></content>
  </entry>
  <entry>
    <title>教程合集</title>
    <url>/%E6%95%99%E7%A8%8B%E5%90%88%E9%9B%86.html</url>
    <content><![CDATA[<h1 id="opengl">OpenGL</h1>
<p><a
href="https://github.com/Canber/OpenGL-ES-for-android/tree/master">OpenGL-ES-for-android</a></p>
<h1 id="音视频">音视频</h1>
<p>《流媒体原理与应用》庄捷 《音视频开发进阶指南》展晓凯（在读）</p>
<h1 id="java">Java</h1>
<h1 id="android-应用">Android 应用</h1>
<p>《Jetpack Compose 从入门到实战》（在读）</p>
<h1 id="c">C++</h1>
<h1 id="c-1">C</h1>
<h1 id="kotlin">Kotlin</h1>
<p>《深入理解 Kotlin 协程》（在读）</p>
<h1 id="linux">Linux</h1>
<p>《Linux 运维之道》</p>
<p><a
href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/index.html">鸟哥的Linux私房菜：基础学习篇</a></p>
<h1 id="android-framework">Android Framework</h1>
<p><a
href="http://ahaoframework.tech/000.%20%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E4%B8%8E%E6%8C%87%E5%8D%97/Android%20Framework%20%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html">阿豪讲Framework
系统教程</a></p>
<p><a
href="https://juejin.cn/post/7171648372086931486?searchId=20250826095721F60E1F9CFF88E484D66E">framework学习路线和方法</a></p>
<p>《深入理解Android内核设计思想》</p>
]]></content>
  </entry>
  <entry>
    <title>学习和实践计划</title>
    <url>/%E7%A0%94%E7%A9%B6%E5%92%8C%E5%AE%9E%E8%B7%B5.html</url>
    <content><![CDATA[<h1 id="学习">学习</h1>
<p>OpenGL</p>
<p>HLS 协议：https://www.jianshu.com/p/2ce402a485ca</p>
<p>Dash 协议</p>
<p>ExoPlayer 源码研究</p>
<p>Java，C++，Kotlin，GLSL，CMake，Gradle，C，Python，JS，汇编</p>
<p>Compose，OKHttp，Retrofit，EventBus，LeakCanary，RxJava，GreenDao，Glide，ARouter，Coil，Okio，Hilt，Dagger
2，Room，CameraX/Camera2/Camera1，组件化，插件化，AspectJ</p>
<p>Java 并发编程</p>
<h1 id="android">Android</h1>
<p>Android UI</p>
<p>Android 库</p>
<p>Android 性能优化</p>
<p>Android 数据存储</p>
<p>Android 网络通信</p>
<h1 id="实践">实践</h1>
<p>基于 FFmpeg 实现一个播放器</p>
<p>视频编辑器</p>
<p>H264 解码器</p>
<p>操作系统</p>
]]></content>
  </entry>
  <entry>
    <title>程序员健康全栈手册</title>
    <url>/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%81%A5%E5%BA%B7%E5%85%A8%E6%A0%88%E6%89%8B%E5%86%8C.html</url>
    <content><![CDATA[<p>程序员的工作特点：久坐、高强度脑力、屏幕时间长、偶有通宵 / on‑call /
出差。本文按“系统 → 风险 → 维护动作 → 红旗症状 →
工具/习惯”组织，并提供可执行清单。并非诊断或处方，若有基础病或症状请及时就医并遵循当地指南。</p>
<hr />
<h2 id="可执行健康计划速览">0. 可执行健康计划速览</h2>
<ul>
<li><strong>每日三件事</strong>：</li>
</ul>
<ol type="1">
<li><strong>步数≥8000</strong>（或中高强度20–30分钟）</li>
<li><strong>力量 10–20 分钟</strong>（核心/背/臀/肩胛/前臂）</li>
<li><strong>睡眠 7–9 小时</strong>（固定起床时刻）。</li>
</ol>
<ul>
<li><p><strong>工位三法</strong>：<strong>视线水平、前臂平、脚掌实</strong>（显示器上缘≈眼高；键鼠同高、手腕中立；双脚踩满地面或脚踏）。</p></li>
<li><p><strong>微休息</strong>：每 <strong>25–50 分钟</strong>起身
<strong>2–5 分钟</strong>；眼睛 <strong>20‑20‑20</strong>（每连续盯屏 20
分钟，看向 20 英尺（约 6 米）外的物体至少 20 秒）；颈肩/腕手快速拉伸
60–90 秒。</p></li>
<li><p><strong>饮食三要素</strong>：<strong>足蛋白</strong>（≈1.2–1.6
g/kg）、<strong>足蔬果/纤维</strong>（25–38
g/天）、<strong>控能量密度</strong>（少糖少超加工）。</p></li>
<li><p><strong>编程高频急救</strong>：</p>
<ul>
<li>眼干/酸：人工泪液+加湿+20‑20‑20；晚间调低亮度/对比度；</li>
<li>腕痛/麻：改鼠标/键盘、腕中立、任务轮换；早期做神经滑动；</li>
<li>颈肩背痛：久坐打断+臀桥/鸟狗式/胸椎伸展；</li>
<li>通宵后：<strong>≤90
分钟补觉</strong>、上午日光、下午轻运动、当天<strong>不再咖啡因</strong>≥14:00后。</li>
</ul></li>
</ul>
<hr />
<h2 id="职业特殊性与总原则">1. 职业特殊性与总原则</h2>
<p><strong>编程职业主要负荷：</strong>长时坐姿→代谢/心血管风险↑；重复小幅用力→上肢肌筋膜/神经卡压；持续近距注视→视觉疲劳/干眼；高认知负荷→睡眠/情绪/注意力波动；不规律作息/外卖→体重与胃食管反流；耳机使用→听力风险。</p>
<p><strong>五大总原则：</strong></p>
<ol type="1">
<li><strong>节律先行</strong>：固定起床时刻&gt;固定就寝；晨间自然光；晚间暗光与电子屏限时。</li>
<li><strong>坐姿是过渡，不是常态</strong>：<strong>坐/站/走</strong>在一天内切换（参考
20‑8‑2 或 30‑5‑2 模式）。</li>
<li><strong>先大肌群、后小细活</strong>：先把<strong>心肺+下肢+背臀</strong>练到位，再精修前臂/手指。</li>
<li><strong>把健康嵌入流程</strong>：代码评审前后走两圈；编译/跑单测时做拉伸；会议改为行走会议。</li>
<li><strong>可持续而非极端</strong>：小步快跑，最小可行改变（例如先保证晚
23:30 前下线蓝光）。</li>
</ol>
<hr />
<h2 id="系统分区维护指南器官腺体脏器">2.
系统分区维护指南（器官/腺体/脏器）</h2>
<h3 id="眼睛与视觉系统角结膜泪膜睫状肌视网膜">2.1
眼睛与视觉系统（角结膜、泪膜、睫状肌、视网膜）</h3>
<ul>
<li><p><strong>风险</strong>：干眼、视疲劳、近视加深、夜间眩光、偏头痛诱发。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li>20‑20‑20（20 分钟看 20 英尺以外 20 秒）+
<strong>主动眨眼</strong>（每分钟 15–20 次）。</li>
<li>屏幕亮度≈环境；避免强背光；晚间启用<strong>暖色温</strong>。</li>
<li>显示器距离 <strong>50–70 cm</strong>，上缘≈眼高；文字≥12–14
pt。</li>
<li><strong>加湿</strong>（≥40%）与人工泪液备用；角膜接触镜尽量降频率。</li>
<li>户外日光 <strong>≥60–120
分钟/日</strong>（有助节律与视疲劳改善）。</li>
</ul></li>
<li><p><strong>红旗</strong>：持续视物模糊、飞蚊闪光、眼痛畏光、视野缺损→眼科。</p></li>
</ul>
<h3 id="颈肩背脊柱与肌肉骨骼">2.2 颈/肩/背/脊柱与肌肉骨骼</h3>
<ul>
<li><p><strong>风险</strong>：圆肩/头前伸、胸椎僵硬、颈源性头痛、腰痛、梨状肌/髂腰肌紧张。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li><p><strong>力量</strong>：</p>
<ul>
<li>背臀链：硬拉/臀桥/罗马椅；</li>
<li>核心抗伸展/抗旋转：死虫/鸟狗式/平板支撑；</li>
<li>肩胛稳定：面拉/下拉/划船/“Y‑T‑W”练习。</li>
</ul></li>
<li><p><strong>灵活度</strong>：胸椎伸展（泡沫轴）、髂腰肌拉伸、腘绳肌与小腿后侧拉伸。</p></li>
<li><p><strong>坐站交替</strong>：每 30–50 分钟起身 2–5
分钟；站立桌配防疲劳垫。</p></li>
</ul></li>
<li><p><strong>红旗</strong>：外伤后疼痛、持续放射至肢端/麻木无力、尿便异常、夜间痛醒→骨科/神经科。</p></li>
</ul>
<h3 id="上肢颈丛臂丛神经肩肘腕腱鞘正中尺桡神经">2.3
上肢（颈丛/臂丛神经、肩肘腕、腱鞘、正中/尺/桡神经）</h3>
<ul>
<li><strong>风险</strong>：腕管综合征、腱鞘炎、肘管综合征、鼠标肘、触发指。</li>
<li><strong>维护动作</strong>：
<ul>
<li><p><strong>人体工学</strong>：腕中立（避免上翘/下垂）、键鼠同高、<strong>轻触键</strong>、降低鼠标
DPI 依赖。</p></li>
<li><p><strong>设备</strong>：分体/分列键盘、掌托、垂直鼠标、轨迹球、热键替代重复鼠标动作。</p></li>
<li><p><strong>训练</strong>：</p>
<ul>
<li>前臂离心训练（腕伸/屈、旋前/旋后）每周 2–3 次；</li>
<li>神经滑动（正中/尺/桡）每日 1–2 组；</li>
<li>任务轮换（打字 40 分钟→会议/走动/白板 10 分钟）。</li>
</ul></li>
</ul></li>
<li><strong>红旗</strong>：夜间麻醒、持续力量下降、肌肉萎缩→康复/神经专科。</li>
</ul>
<h3 id="心血管与代谢心血管脂代谢胰腺胰岛">2.4
心血管与代谢（心、血管、脂代谢、胰腺胰岛）</h3>
<ul>
<li><p><strong>风险</strong>：久坐→胰岛素抵抗、血脂异常、高血压、体重增长。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li><strong>有氧</strong>：每周 <strong>150–300 分钟中等</strong>或
<strong>75–150 分钟高强度</strong>（跑步/骑行/游泳/HIIT）。</li>
<li><strong>力量</strong>：全身 2–3 次/周（大肌群 5–8 个动作，每动 2–4
组）。</li>
<li><strong>NEAT</strong>：步数 8000–12000；爬楼胜电梯；远点停车。</li>
<li><strong>饮食</strong>：高纤维、优质蛋白、少糖饮；<strong>酒精限量</strong>或尽量不饮。</li>
</ul></li>
<li><p><strong>红旗</strong>：胸痛胸闷、心悸伴眩晕、运动性呼吸困难、踝部明显水肿→急诊/心内。</p></li>
</ul>
<h3 id="呼吸系统鼻腔咽喉肺">2.5 呼吸系统（鼻腔、咽喉、肺）</h3>
<ul>
<li><p><strong>风险</strong>：空调干燥/PM2.5→咽干咳；呼吸浅表→压力感↑；打鼾/睡眠呼吸暂停。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li>办公室<strong>加湿与通风</strong>；必要时空气净化。</li>
<li><strong>横膈呼吸</strong>练习（坐/站 5 分钟，鼻吸口呼）。</li>
<li>打鼾/白天嗜睡→评估睡眠呼吸暂停（体重、颈围、血氧）。</li>
</ul></li>
<li><p><strong>红旗</strong>：持续咳喘、胸痛、血痰、夜间严重打鼾伴憋醒→呼吸科。</p></li>
</ul>
<h3 id="消化系统与肝胆胰">2.6 消化系统与肝胆胰</h3>
<ul>
<li><p><strong>风险</strong>：不规律饮食→胃食管反流、功能性消化不良、脂肪肝。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li><strong>定时定量</strong>，避免睡前 3
小时进食；咖啡/辛辣/酒精酌情限量。</li>
<li><strong>蛋白优先</strong>（瘦肉/鱼/蛋/豆）+
<strong>高纤维</strong>（全谷/豆类/蔬果）+
<strong>健康脂肪</strong>（坚果/橄榄/深海鱼）。</li>
<li><strong>体重管理</strong>（见
3.1）；<strong>久坐打断</strong>促进胃肠动力。</li>
</ul></li>
<li><p><strong>红旗</strong>：黑便/呕血、黄疸、体重不明原因下降、持续腹痛→消化/肝胆科。</p></li>
</ul>
<h3 id="肾脏与泌尿">2.7 肾脏与泌尿</h3>
<ul>
<li><p><strong>风险</strong>：饮水不足、久坐少动→尿路结石风险↑；高盐饮食→血压/肾负担。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li><strong>全天分次饮水</strong>（以淡黄尿为宜）；运动与炎热日适度增加。</li>
<li><strong>控盐</strong>与多蔬果；长时坐会→<strong>每小时起身</strong>。</li>
</ul></li>
<li><p><strong>红旗</strong>：血尿、浮肿、持续腰痛、排尿烧灼/频急痛→泌尿/肾内。</p></li>
</ul>
<h3 id="内分泌系统甲状腺肾上腺性腺胰岛下丘脑垂体">2.8
内分泌系统（甲状腺、肾上腺、性腺、胰岛、下丘脑‑垂体）</h3>
<ul>
<li><strong>风险</strong>：作息混乱/慢性压力→节律与激素轴紊乱；高糖饮食→胰岛负担。</li>
<li><strong>维护动作</strong>：
<ul>
<li><strong>稳定昼夜节律</strong>（固定起床、晨光、规律三餐、晚间降光）。</li>
<li><strong>碘摄入适量</strong>（碘盐/海产适度），<strong>避免随意大剂量补硒/碘</strong>；如有甲状腺症状（怕冷/心悸/体重波动/颈部肿大）→就医评估。</li>
<li><strong>力量训练</strong>与<strong>体脂管理</strong>支持睾酮/雌激素平衡与胰岛素敏感性。</li>
</ul></li>
<li><strong>红旗</strong>：突发剧烈头痛伴视力改变（垂体问题可疑）、持续乏力低钠、突发高血压伴头痛出汗心悸→急诊/内分泌。</li>
</ul>
<h3 id="神经系统中枢周围">2.9 神经系统（中枢/周围）</h3>
<ul>
<li><p><strong>风险</strong>：紧张性头痛、偏头痛诱发、周围神经卡压（见
2.3）。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li><strong>规律睡眠</strong>+咖啡因限时（中午后减少）；</li>
<li><strong>颈枕与姿势管理</strong>；</li>
<li><strong>有氧+力量</strong>对偏头痛触发阈值有帮助；</li>
<li><strong>正念/呼吸</strong>降低交感紧张。</li>
</ul></li>
<li><p><strong>红旗</strong>：单侧肢体无力/言语含糊/面瘫、突发最严重头痛→急诊排查卒中等。</p></li>
</ul>
<h3 id="免疫系统与感染">2.10 免疫系统与感染</h3>
<ul>
<li><p><strong>风险</strong>：通宵与压力→免疫力下降；空调房交叉感染。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li><strong>疫苗</strong>按当地方案（流感、加强针等）；</li>
<li><strong>睡眠与营养</strong>优先；</li>
<li>人群密集/季节性高发期佩戴口罩，手部卫生。</li>
</ul></li>
</ul>
<h3 id="口腔牙周">2.11 口腔牙周</h3>
<ul>
<li><p><strong>风险</strong>：咖啡/含糖饮、夜间磨牙、口干。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li><strong>早晚刷牙+牙线</strong>；含氟牙膏；</li>
<li><strong>定期洗牙</strong>（6–12 个月）；</li>
<li>夜磨牙考虑牙套；口干补水与加湿。</li>
</ul></li>
<li><p><strong>红旗</strong>：牙龈出血不止、牙痛发热、面部肿胀→口腔科。</p></li>
</ul>
<h3 id="皮肤含光照久坐压力相关">2.12 皮肤（含光照/久坐压力相关）</h3>
<ul>
<li><p><strong>风险</strong>：干燥湿疹、接触性皮炎、压痕与循环差、痤疮。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li><strong>SPF</strong>日间暴露；<strong>洗手后保湿</strong>；</li>
<li>久坐→<strong>每小时活动</strong>促进循环；</li>
<li>耳机/键鼠清洁，减少接触性皮炎。</li>
</ul></li>
</ul>
<h3 id="听力与前庭耳蜗听神经">2.13 听力与前庭（耳蜗、听神经）</h3>
<ul>
<li><p><strong>风险</strong>：耳机高音量、长时暴露→听力下降/耳鸣。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li><strong>60/60 原则</strong>：音量≤60%，单次≤60 分钟；</li>
<li>主动降噪耳机可在嘈杂环境下降低总体声压需求；</li>
<li>出现耳鸣/闷胀→<strong>立即降音量与休息</strong>。</li>
</ul></li>
<li><p><strong>红旗</strong>：突发听力下降、持续耳鸣伴眩晕→耳鼻喉。</p></li>
</ul>
<h3 id="生殖泌尿男女简要">2.14 生殖/泌尿（男女简要）</h3>
<ul>
<li><p><strong>风险</strong>：久坐/肥胖→激素与生育力受影响；压力→性功能/周期波动。</p></li>
<li><p><strong>维护动作</strong>：</p>
<ul>
<li><strong>体重与训练</strong>、<strong>规律作息</strong>、<strong>减少久坐压迫</strong>（站立/步行间隔）。</li>
<li>女性：维持铁/叶酸/维D充足；规律作息减少周期紊乱风险。</li>
</ul></li>
<li><p><strong>红旗</strong>：无痛血尿、睾丸持续疼痛/肿块、异常出血/经期显著改变→就医。</p></li>
</ul>
<h3 id="血液营养素铁b12维d钙镁等">2.15
血液/营养素（铁、B12、维D、钙、镁等）</h3>
<ul>
<li><strong>策略</strong>：<strong>饮食优先</strong>，补剂仅在缺乏或医嘱下使用；</li>
<li><strong>常见</strong>：素食/少红肉者关注
<strong>B12/铁/锌</strong>；室内久坐者关注
<strong>维D</strong>（与医生评估）。</li>
</ul>
<hr />
<h2 id="生活方式支柱">3. 生活方式支柱</h2>
<h3 id="饮食上班日可执行方案">3.1 饮食（上班日可执行方案）</h3>
<ul>
<li><p><strong>配比</strong>：蛋白 1.2–1.6
g/kg；碳水以全谷/豆薯/蔬果为主；脂肪来自坚果/橄榄/鱼类。</p></li>
<li><p><strong>纤维</strong>：25–38 g/日；每日 ≥5 份蔬果（1
份≈拳头大小）。</p></li>
<li><p><strong>水分</strong>：约 30–35
ml/kg/日，运动与炎热天相应增加；以淡黄尿为目标。</p></li>
<li><p><strong>外卖/食堂点单模板</strong>：</p>
<ul>
<li>组合一：烤鸡胸/鱼 + 糙米/杂粮 + 双份绿叶蔬菜 + 少油少盐。</li>
<li>组合二：豆腐/蛋类 + 全麦卷/燕麦 + 凉拌蔬菜。</li>
<li>避免：油炸、重口、高糖饮、奶茶；酱汁另放。</li>
</ul></li>
<li><p><strong>加班/通宵</strong>：</p>
<ul>
<li><strong>分餐</strong>：夜间少量多次，避免一顿高脂大餐；</li>
<li>咖啡因<strong>早段使用</strong>，<strong>结束前 6–8
小时停止</strong>；</li>
<li>补充水果/坚果/酸奶作为小食；多水少含糖饮。</li>
</ul></li>
</ul>
<h3 id="运动程序员友好版">3.2 运动（程序员友好版）</h3>
<ul>
<li><p><strong>周计划样例（60–90 分钟/日不可得时）</strong>：</p>
<ul>
<li><strong>周一/四</strong>：全身力量 30–40
分钟（深蹲/硬拉或腿推、划船/下拉、俯卧撑/卧推、推举、臀桥、平板/鸟狗式）。</li>
<li><strong>周二/五</strong>：有氧 30–40
分钟（跑步、骑行、椭圆、跳绳，含 5–10 分钟间歇）。</li>
<li><strong>周三</strong>：灵活度+核心 20–30
分钟（胸椎/髋/踝灵活+呼吸+核心）。</li>
<li><strong>周末</strong>：长距离步行/徒步/球类；家庭拉伸 15 分钟。</li>
</ul></li>
<li><p><strong>办公微运动</strong>：</p>
<ul>
<li>每小时 1–2 分钟：提踵、深蹲、弹力带外展、颈部等长收缩、腕伸离心
10–15 次。</li>
</ul></li>
</ul>
<h3 id="睡眠与节律">3.3 睡眠与节律</h3>
<ul>
<li><p><strong>配方</strong>：固定起床时刻；早光 10–30
分钟；晚间屏幕减蓝光且 <strong>睡前 60–90 分钟不工作</strong>；卧室
<strong>18–22℃</strong>、黑暗安静。</p></li>
<li><p><strong>短昼寝</strong>：午后 <strong>10–20
分钟</strong>，避免晚间睡意受损。</p></li>
<li><p><strong>通宵/on‑call</strong>：</p>
<ul>
<li>事前：前夜保证睡眠；当日减少其他消耗；准备健康零食/水。</li>
<li>期间：<strong>节律性微休息</strong>、光照管理（工作区明亮，结束前
1–2 小时逐步变暗）。</li>
<li>事后：<strong>≤90
分钟补觉</strong>，下午轻运动+日光，晚上按时就寝。</li>
</ul></li>
</ul>
<h3 id="心理与专注生理心理一体">3.4 心理与专注（生理‑心理一体）</h3>
<ul>
<li><p><strong>压力回路</strong>：工作负荷×不可控感×恢复不足。</p></li>
<li><p><strong>工具</strong>：</p>
<ul>
<li><strong>界限</strong>：日历中预留“深度工作块”和“恢复块”；</li>
<li><strong>身心调节</strong>：4‑7‑8 呼吸、冥想 5–10 分钟、正念走；</li>
<li><strong>社交与兴趣</strong>：每周最少 1 次非工作社交/爱好活动；</li>
<li><strong>成瘾管理</strong>：设定应用时间上限；以“替代行为”替换刷屏（站立走
2 分钟）。</li>
</ul></li>
<li><p><strong>红旗</strong>：持续 &gt;2
周的情绪低落/兴趣缺失、失眠/过眠、明显焦虑/惊恐→心理健康专业支持。</p></li>
</ul>
<h3 id="工位与环境人体工学">3.5 工位与环境（人体工学）</h3>
<ul>
<li><strong>显示器</strong>：上缘≈眼高，距离 50–70
cm；多屏→主屏正前方，次屏侧 30° 内。</li>
<li><strong>椅子</strong>：腰靠贴合腰椎曲线；座深使小腿前缘离座 2–3
指；足底全触地或脚踏。</li>
<li><strong>键鼠</strong>：键盘 0–5°
倾角；腕中立；需要时用<strong>分体键盘/垂直鼠标</strong>。</li>
<li><strong>灯光/空气</strong>：500–750 勒克斯工作面；<strong>湿度
40–60%</strong>；PM2.5 低；定期清洁键鼠/耳机。</li>
</ul>
<hr />
<h2 id="高频问题处置简明-sop">4. 高频问题处置（简明 SOP）</h2>
<h3 id="眼疲劳干眼">4.1 眼疲劳/干眼</h3>
<ol type="1">
<li><p>立即 20‑20‑20 + 主动眨眼；</p></li>
<li><p>降亮度/增对比、增湿；</p></li>
<li><p>人工泪液；</p></li>
<li><p>晚间减少隐形。</p>
<p><strong>复发预防</strong>：字体放大、显示器距离、日光暴露、每日热敷
5–10 分钟。</p></li>
</ol>
<h3 id="颈源性头痛颈肩痛">4.2 颈源性头痛/颈肩痛</h3>
<ol type="1">
<li><p>鸟狗式 2×10、胸椎伸展 2×10、门框拉胸 2×30 秒；</p></li>
<li><p>调整屏幕高度；</p></li>
<li><p>每小时站立 2–5 分钟。</p>
<p><strong>警示</strong>：麻木无力/跌物感→就医。</p></li>
</ol>
<h3 id="腕管综合征早期">4.3 腕管综合征早期</h3>
<ol type="1">
<li><p>减少腕背屈、改键鼠；</p></li>
<li><p>正中神经滑动每日 2×10；</p></li>
<li><p>冰敷 10 分钟（疼痛期）。</p>
<p><strong>警示</strong>：夜间麻醒或拇指鱼际萎缩→就医。</p></li>
</ol>
<h3 id="下背痛无红旗">4.4 下背痛（无红旗）</h3>
<ol type="1">
<li><p>轻度活动/步行；</p></li>
<li><p>臀桥 3×12、死虫 3×10；</p></li>
<li><p>避免久坐与负重弯腰。</p>
<p><strong>红旗</strong>同 2.2。</p></li>
</ol>
<h3 id="胃食管反流">4.5 胃食管反流</h3>
<ol type="1">
<li><p>减晚餐体积，睡前≥3 小时不进食；</p></li>
<li><p>少咖啡酒精辛辣；</p></li>
<li><p>抬高床头 10–15 cm。</p>
<p><strong>持续症状</strong>→消化科评估。</p></li>
</ol>
<h3 id="焦虑失眠短期">4.6 焦虑/失眠（短期）</h3>
<ol type="1">
<li>固定起床；</li>
<li>睡前 2 小时拉伸+热水澡/热足；</li>
<li>减蓝光、纸质阅读 10 分钟；</li>
<li>咖啡因中午后停。</li>
</ol>
<h3 id="耳鸣听力不适">4.7 耳鸣/听力不适</h3>
<ol type="1">
<li>立刻降音量/摘下耳机；</li>
<li>安静环境休息；</li>
<li>48 小时内未缓解→耳鼻喉。</li>
</ol>
<hr />
<h2 id="例行检查与自检与医生协商个性化">5.
例行检查与自检（与医生协商个性化）</h2>
<ul>
<li><strong>年度体检（基础版）</strong>：血压、BMI/腰围、血常规、空腹血糖/或
HbA1c、血脂、肝肾功能、尿常规、胸片或低剂量
CT（按风险）、眼压/裂隙灯（久屏者）、牙周检查。</li>
<li><strong>加强项（按风险/症状）</strong>：维D、铁蛋白/B12、甲状腺功能（TSH±T3/T4）、甲状腺超声、睡眠呼吸暂停筛查（STOP‑Bang）、心电图/运动试验。</li>
<li><strong>疫苗</strong>：流感年打；破伤风按周期；其他按本地指南。</li>
<li><strong>自测与记录</strong>：
<ul>
<li>每周：<strong>步数/运动分钟</strong>、<strong>平均心率/静息心率</strong>；</li>
<li>每月：<strong>体重/腰围</strong>、<strong>体脂趋势</strong>；</li>
<li>训练：<strong>心率恢复</strong>（运动后 1 分钟下降 ≥20
次/分为佳）。</li>
</ul></li>
</ul>
<hr />
<h2 id="模板与清单">6. 模板与清单</h2>
<h3 id="每日每周每季度每年清单">6.1 每日/每周/每季度/每年清单</h3>
<ul>
<li><p><strong>每日</strong>：</p>
<ul>
<li>步数≥8000｜力量/灵活 10–20 分钟｜20‑20‑20 × 每小时｜水 6–10
杯｜蔬果≥5 份｜咖啡因中午后限量｜睡前 60–90 分钟脱屏。</li>
</ul></li>
<li><p><strong>每周</strong>：</p>
<ul>
<li>有氧 ≥150 分钟｜力量 2–3 次｜行走会议 ≥2 次｜清洁键鼠/耳机 1
次｜社交/兴趣 1 次。</li>
</ul></li>
<li><p><strong>每季度</strong>：</p>
<ul>
<li>工位复核（显示器、椅子、键鼠）｜更换牙刷头｜复盘运动目标与里程。</li>
</ul></li>
<li><p><strong>每年</strong>：</p>
<ul>
<li>体检与牙科洁治｜防晒/皮肤痣自查｜听力/视力评估（久耳机/久屏者）。</li>
</ul></li>
</ul>
<h3 id="工位布置清单一步到位">6.2 工位布置清单（一步到位）</h3>
<ul>
<li>显示器上缘≈眼高｜距离 50–70
cm｜主屏正前方｜外接键鼠同高｜腕中立｜椅背支撑腰椎｜脚踏稳固｜桌面照度
500–750 lx｜湿度 40–60%。</li>
</ul>
<h3 id="运动处方样例">6.3 运动处方样例</h3>
<ul>
<li><strong>新手（每次 20–30
分钟）</strong>：徒手深蹲、俯卧撑（或斜板）、哑铃划船、臀桥、平板支撑（各
2–3 组）。</li>
<li><strong>进阶（每次 40–60
分钟）</strong>：深蹲/腿推、硬拉/罗马椅、卧推/俯卧撑、划船/下拉、过顶推举、弓步、核心循环。</li>
<li><strong>时间极少（10 分钟）</strong>：壶铃摆动 30 秒/休息 30 秒
×10；或 4 组循环：深蹲 15 + 俯卧撑 10 + 划船 12 + 臀桥 15。</li>
</ul>
<h3 id="外卖点单模板可复制">6.4 外卖点单模板（可复制）</h3>
<ul>
<li>“鸡胸 150g + 糙米半份 + 清炒时蔬双份 + 少油少盐 + 汤不加油”。</li>
<li>“铁板三文鱼/豆腐 + 藜麦/全麦卷 + 蔬菜色拉（油醋）+ 水/苏打水”。</li>
</ul>
<h3 id="oncall通宵-sop">6.5 on‑call/通宵 SOP</h3>
<ul>
<li><strong>前</strong>：补足睡眠｜准备水/坚果/水果/酸奶｜安排替班/结束后缓冲时段。</li>
<li><strong>中</strong>：整点起身 3–5
分钟｜低糖小食｜控制咖啡因节律。</li>
<li><strong>后</strong>：≤90
分钟短补觉｜上午晒光｜下午轻有氧｜晚间按时睡。</li>
</ul>
<h3 id="差旅健康包">6.6 差旅健康包</h3>
<ul>
<li>耳塞眼罩｜颈枕｜弹力带｜维持性零食（坚果/蛋白棒）｜便携加湿器/口罩｜常用药（遵医嘱）。</li>
</ul>
<h3 id="颈肩背腕手拉伸卡文字版">6.7 颈肩背/腕手拉伸卡（文字版）</h3>
<ul>
<li><strong>门框拉胸</strong>：双臂 90° 抵门框，身体前倾 30–60 秒
×2。</li>
<li><strong>颈侧屈拉伸</strong>：肩下沉，头向对侧侧屈 30 秒 ×2
双侧。</li>
<li><strong>胸椎伸展</strong>：泡沫轴仰卧背部滚动 1–2 分钟。</li>
<li><strong>腕伸离心</strong>：持轻哑铃，腕背伸缓慢下放 12–15 次
×2。</li>
<li><strong>正中神经滑动</strong>：网上搜索“median nerve
glide”动作要点，轻柔无痛感即可，每日 2×10。</li>
</ul>
<hr />
<h2 id="常见误区与辨析">7. 常见误区与辨析</h2>
<ul>
<li><strong>“坐站交替桌=万能”</strong>：关键在<strong>打断久坐</strong>与<strong>总步数/总能量消耗</strong>，而非仅站立。</li>
<li><strong>“护腕越厚越好”</strong>：目标是<strong>腕中立</strong>，而非抬高腕关节。</li>
<li><strong>“晚上补觉就行”</strong>：节律紊乱会累积，<strong>固定起床时刻</strong>更优先。</li>
<li><strong>“补剂能替代饮食”</strong>：补剂用于矫正缺乏或特定人群，<strong>饮食与作息是基石</strong>。</li>
</ul>
<hr />
<h2 id="附录应急微方案135-分钟">8. 附录：应急微方案（1/3/5 分钟）</h2>
<ul>
<li><strong>1 分钟</strong>：站起走 30 秒 + 颈部等长 30 秒。</li>
<li><strong>3 分钟</strong>：提踵 30 次 + 深蹲 15 次 + 门框拉胸 30
秒。</li>
<li><strong>5 分钟</strong>：鸟狗式 10/侧 + 臀桥 15 + 腕伸离心 12 +
眼睛远眺 60 秒。</li>
</ul>
<hr />
<h2 id="总结">9. 总结</h2>
<p>把健康当作“工程项目”：设目标（睡眠
7.5h）、指标（步数/心率）、回顾（周复盘），持续迭代。任何一个你愿意“今天就开始”的小改动，都是这个项目的最佳入口。</p>
]]></content>
  </entry>
  <entry>
    <title>面试</title>
    <url>/%E9%9D%A2%E8%AF%95.html</url>
    <content><![CDATA[<h1 id="kotlin-面试题">Kotlin 面试题</h1>
<p><a
href="https://juejin.cn/post/7213582722329952312#heading-0">谱写Kotlin面试指南三部曲-基础篇</a></p>
<p><a
href="https://juejin.cn/post/7220235452292137019">谱写Kotlin面试指南三部曲-协程篇</a></p>
<p><a
href="https://juejin.cn/post/7222982459583152188">谱写Kotlin面试指南三部曲-Flow篇</a></p>
<h1 id="andorid-面试题">Andorid 面试题</h1>
<p><a
href="https://juejin.cn/post/7267737437953720359?from=search-suggest#heading-1">【建议收藏】106道Android核心面试题及答案汇总（总结最全面的面试题）</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux 基本操作</title>
    <url>/Linux/Linux-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<h1 id="一linux-基本概念">一、Linux 基本概念</h1>
<p>Linux 是一种开源、类 Unix 的操作系统内核，由林纳斯·托瓦兹（Linus
Torvalds）于 1991 年创建。Linux 系统通常指包含 Linux
内核及各种工具和库的完整操作系统（如 Ubuntu、CentOS、Debian
等发行版）。以下是 Linux 的核心概念：</p>
<ol type="1">
<li><strong>开源与自由软件</strong>
<ul>
<li>Linux 遵循 GNU
通用公共许可证（GPL），代码公开，允许用户查看、修改和分发。</li>
<li>自由软件强调用户对软件的控制权，支持自由使用、学习、修改和分享。</li>
</ul></li>
<li><strong>内核与用户空间</strong>
<ul>
<li><strong>内核（Kernel）</strong>：管理硬件资源（如
CPU、内存、磁盘）、进程调度、设备驱动等。</li>
<li><strong>用户空间</strong>：运行用户程序和工具（如
Shell、编辑器、编译器），通过系统调用与内核交互。</li>
</ul></li>
<li><strong>发行版（Distribution）</strong>
<ul>
<li>Linux 内核结合不同软件包形成发行版，常见的有：
<ul>
<li>Ubuntu：用户友好，适合桌面和服务器。</li>
<li>CentOS/RHEL：企业级，注重稳定性。</li>
<li>Debian：通用且灵活。</li>
<li>Arch Linux：高度自定义，适合高级用户。</li>
</ul></li>
<li>每个发行版有独特的包管理器（如 apt、yum、pacman）。</li>
</ul></li>
<li><strong>文件系统</strong>
<ul>
<li>Linux 使用层次化文件系统，根目录为 <code>/</code>。</li>
<li>重要目录：
<ul>
<li><code>/home</code>：用户主目录。</li>
<li><code>/etc</code>：配置文件。</li>
<li><code>/var</code>：日志、临时文件。</li>
<li><code>/usr</code>：用户程序和库。</li>
<li><code>/bin</code>、<code>sbin</code>：基本命令和系统命令。</li>
</ul></li>
<li>文件系统类型：ext4（常见）、btrfs、xfs。</li>
<li>文件名区分大小写，无扩展名限制。</li>
</ul></li>
<li><strong>进程与多任务</strong>
<ul>
<li>Linux 支持多任务、多用户，允许多个进程并发运行。</li>
<li>每个进程有唯一进程 ID（PID），可用 <code>ps</code> 或
<code>top</code> 查看。</li>
<li>进程分为前台和后台进程。</li>
</ul></li>
<li><strong>权限管理</strong>
<ul>
<li>文件和目录有<strong>所有者（owner）、组（group）、其他（others）</strong>三种权限：读（r）、写（w）、执行（x）。</li>
<li>使用 <code>chmod</code> 修改权限，<code>chown</code>
更改所有者。</li>
</ul></li>
<li><strong>Shell 与命令行</strong>
<ul>
<li><strong>Shell</strong> 是用户与系统的交互接口，常见为
bash、zsh、fish。</li>
<li>命令行是 Linux 的核心操作方式，高效灵活。</li>
</ul></li>
<li><strong>软件包管理</strong>
<ul>
<li>使用包管理器安装、更新、卸载软件：
<ul>
<li>Debian/Ubuntu：<code>apt</code>（<code>.deb</code> 包）。</li>
<li>RHEL/CentOS：<code>yum</code>/<code>dnf</code>（<code>.rpm</code>
包）。</li>
<li>Arch Linux：<code>pacman</code>.</li>
</ul></li>
<li>源码安装：<code>./configure &amp;&amp; make &amp;&amp; make install</code>.</li>
</ul></li>
<li><strong>网络与服务</strong>
<ul>
<li>Linux 广泛用于服务器，支持 SSH、HTTP 等服务。</li>
<li>服务管理工具：<code>systemd</code>、<code>service</code>.</li>
<li>网络配置：<code>/etc/network</code> 或 NetworkManager。</li>
</ul></li>
<li><strong>开发环境</strong>
<ul>
<li>支持多种语言（C、Python、Java）。</li>
<li>开发工具：GCC、Make、Git、Vim/Emacs。</li>
<li>调试工具：GDB、Valgrind。</li>
</ul></li>
</ol>
<hr />
<h1 id="二linux-基本操作总结">二、Linux 基本操作总结</h1>
<h2 id="基础操作熟悉-linux-环境">1. 基础操作（熟悉 Linux 环境）</h2>
<p>目标：掌握命令行操作，理解文件系统和权限。</p>
<ul>
<li><p><strong>常用命令</strong></p>
<ul>
<li><p><strong>文件操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出当前目录内容（详细列表，包含隐藏文件）</span><br><span class="line">ls -la</span><br><span class="line"></span><br><span class="line"># 切换到 /home/user 目录</span><br><span class="line">cd /home/user</span><br><span class="line"></span><br><span class="line"># 显示当前工作目录</span><br><span class="line">pwd</span><br><span class="line"></span><br><span class="line"># 创建目录 test_dir</span><br><span class="line">mkdir test_dir</span><br><span class="line"></span><br><span class="line"># 创建空文件 example.txt</span><br><span class="line">touch example.txt</span><br><span class="line"></span><br><span class="line"># 复制 example.txt 到 test_dir</span><br><span class="line">cp example.txt test_dir/</span><br><span class="line"></span><br><span class="line"># 移动 example.txt 到 test_dir/renamed.txt</span><br><span class="line">mv example.txt test_dir/renamed.txt</span><br><span class="line"></span><br><span class="line"># 删除 test_dir 及其内容</span><br><span class="line">rm -rf test_dir</span><br></pre></td></tr></table></figure></li>
<li><p><strong>文件查看</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看文件内容</span><br><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line"># 分页查看文件</span><br><span class="line">less /var/log/syslog</span><br><span class="line"></span><br><span class="line"># 查看文件前 10 行</span><br><span class="line">head /etc/passwd</span><br><span class="line"></span><br><span class="line"># 实时监控日志文件</span><br><span class="line">tail -f /var/log/syslog</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>查找与搜索</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找名为 config.conf 的文件</span><br><span class="line">find /etc -name &quot;config.conf&quot;</span><br><span class="line"></span><br><span class="line"># 在当前目录递归搜索包含 &quot;error&quot; 的文件</span><br><span class="line">grep -r &quot;error&quot; .</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>权限管理</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看文件权限</span><br><span class="line">ls -l example.txt</span><br><span class="line"></span><br><span class="line"># 赋予文件所有者执行权限</span><br><span class="line">chmod u+x example.txt</span><br><span class="line"></span><br><span class="line"># 更改文件所有者为 user1，组为 group1</span><br><span class="line">chown user1:group1 example.txt</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>系统信息</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看系统信息</span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line"># 查看磁盘使用情况（人类可读格式）</span><br><span class="line">df -h</span><br><span class="line"></span><br><span class="line"># 查看内存使用情况</span><br><span class="line">free -m</span><br><span class="line"></span><br><span class="line"># 实时监控系统资源</span><br><span class="line">top</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p><strong>Shell 基础</strong></p>
<ul>
<li><p>输入/输出重定向与管道 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将 ls 输出重定向到 file.txt</span><br><span class="line">ls &gt; file.txt</span><br><span class="line"></span><br><span class="line"># 追加内容到 file.txt</span><br><span class="line">echo &quot;New line&quot; &gt;&gt; file.txt</span><br><span class="line"></span><br><span class="line"># 使用管道过滤 ls 输出</span><br><span class="line">ls | grep &quot;.txt&quot;</span><br><span class="line"></span><br><span class="line"># 从文件读取输入</span><br><span class="line">cat &lt; file.txt</span><br></pre></td></tr></table></figure></p></li>
<li><p>任务管理 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 后台运行 sleep 命令</span><br><span class="line">sleep 100 &amp;</span><br><span class="line"></span><br><span class="line"># 查看后台任务</span><br><span class="line">jobs</span><br><span class="line"></span><br><span class="line"># 终止进程（假设 PID 为 1234）</span><br><span class="line">kill -9 1234</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p><strong>练习</strong></p>
<ul>
<li>创建目录结构，复制/移动文件，修改权限。</li>
<li>使用 <code>grep</code> 搜索日志文件内容。</li>
<li>组合管道命令（如 <code>ps aux | grep python</code>）。</li>
</ul></li>
</ul>
<h2 id="中级操作系统管理与网络">2. 中级操作（系统管理与网络）</h2>
<p>目标：掌握系统配置、软件安装和网络操作。</p>
<ul>
<li><p><strong>包管理</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Ubuntu/Debian: 更新包列表并安装 nginx</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br><span class="line"></span><br><span class="line"># CentOS/RHEL: 安装 nginx</span><br><span class="line">sudo yum install nginx</span><br><span class="line"></span><br><span class="line"># 查询已安装包</span><br><span class="line">dpkg -l | grep nginx</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>用户与组管理</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建用户 newuser 并设置主目录</span><br><span class="line">sudo useradd -m newuser</span><br><span class="line"></span><br><span class="line"># 设置 newuser 密码</span><br><span class="line">sudo passwd newuser</span><br><span class="line"></span><br><span class="line"># 添加 newuser 到 sudo 组</span><br><span class="line">sudo usermod -aG sudo newuser</span><br><span class="line"></span><br><span class="line"># 创建组 developers</span><br><span class="line">sudo groupadd developers</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>服务管理</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动 nginx 服务</span><br><span class="line">sudo systemctl start nginx</span><br><span class="line"></span><br><span class="line"># 设置 nginx 开机自启</span><br><span class="line">sudo systemctl enable nginx</span><br><span class="line"></span><br><span class="line"># 查看 nginx 服务状态</span><br><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>网络操作</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看网络接口</span><br><span class="line">ip addr</span><br><span class="line"></span><br><span class="line"># 测试与 google.com 的连通性</span><br><span class="line">ping -c 4 google.com</span><br><span class="line"></span><br><span class="line"># 远程登录到服务器</span><br><span class="line">ssh user@192.168.1.100</span><br><span class="line"></span><br><span class="line"># 传输文件到远程服务器</span><br><span class="line">scp localfile.txt user@192.168.1.100:/home/user/</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>脚本编写</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 备份 /home/user 目录到 /backup</span><br><span class="line">tar -czf /backup/backup_$(date +%F).tar.gz /home/user</span><br><span class="line">echo &quot;Backup completed on $(date)&quot;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>练习</strong></p>
<ul>
<li>安装 Nginx，配置简单 Web 服务器。</li>
<li>编写备份脚本，定时运行（使用 <code>cron</code>）。</li>
<li>配置 SSH 免密登录（<code>ssh-keygen</code> 和
<code>ssh-copy-id</code>）。</li>
</ul></li>
</ul>
<h2 id="开发相关操作程序开发环境搭建">3.
开发相关操作（程序开发环境搭建）</h2>
<p>目标：搭建开发环境，编写、编译和调试程序。</p>
<ul>
<li><p><strong>安装开发工具</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Ubuntu: 安装 GCC、G++、Make</span><br><span class="line">sudo apt install build-essential</span><br><span class="line"></span><br><span class="line"># 安装 Python3 和 pip</span><br><span class="line">sudo apt install python3 python3-pip</span><br><span class="line"></span><br><span class="line"># 安装 Git</span><br><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>C/C++ 开发</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译 C 程序</span><br><span class="line">gcc hello.c -oalya</span><br><span class="line"></span><br><span class="line"># 运行程序</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Makefile</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">    gcc hello.c -o hello</span><br><span class="line">clean:</span><br><span class="line">    rm -f hello</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>调试</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 GDB 调试</span><br><span class="line">gdb ./hello</span><br><span class="line"></span><br><span class="line"># 使用 Valgrind 检查内存泄漏</span><br><span class="line">valgrind --leak-check=yes ./hello</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>版本控制</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置 Git</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;your.email@example.com&quot;</span><br><span class="line"></span><br><span class="line"># 克隆仓库</span><br><span class="line">git clone https://github.com/your/repo.git</span><br><span class="line"></span><br><span class="line"># 添加并提交代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line"></span><br><span class="line"># 推送代码</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>练习</strong></p>
<ul>
<li>编写 C 程序实现文件读写。</li>
<li>使用 Git 管理项目，推送到远程仓库。</li>
<li>使用 GDB/Valgrind 调试程序。</li>
</ul></li>
</ul>
<hr />
<h1 id="三学习路径与建议">三、学习路径与建议</h1>
<ol type="1">
<li><strong>初学者（1-2 个月）</strong>
<ul>
<li>安装 Ubuntu，熟悉命令行。</li>
<li>练习文件操作、权限管理和管道。</li>
<li>学习 Vim 或 Nano。</li>
<li>使用 <code>apt</code> 安装软件。</li>
</ul></li>
<li><strong>中级（3-6 个月）</strong>
<ul>
<li>编写 Shell 脚本，自动化任务。</li>
<li>配置 SSH、Nginx，学习网络基础。</li>
<li>管理用户、权限和服务。</li>
<li>使用 <code>find</code>、<code>grep</code> 处理复杂任务。</li>
</ul></li>
<li><strong>高级（6 个月以上）</strong>
<ul>
<li>搭建开发环境（GCC、Python、Git）。</li>
<li>编写 C/C++ 或 Python 程序，使用 Make 和 GDB。</li>
<li>参与开源项目，掌握 Git 工作流。</li>
<li>学习 Docker 或 KVM。</li>
</ul></li>
<li><strong>资源推荐</strong>
<ul>
<li><strong>文档</strong>：<code>man</code>
命令、<code>/usr/share/doc</code>。</li>
<li><strong>书籍</strong>：<em>The Linux Command Line</em>、<em>Linux
System Programming</em>。</li>
<li><strong>在线教程</strong>：<a href="https://linuxjourney.com/">Linux
Journey</a>、freeCodeCamp。</li>
<li><strong>社区</strong>：Stack Overflow、Reddit（r/linux）、X 上的
Linux 讨论。</li>
</ul></li>
</ol>
<hr />
<h1 id="四总结">四、总结</h1>
<p>熟练操作 Linux 并进行程序开发需掌握： -
<strong>命令行</strong>：文件操作、搜索、权限管理。 -
<strong>系统管理</strong>：包管理、用户管理、服务配置、网络操作。 -
<strong>开发环境</strong>：编译、调试、版本控制。 -
<strong>脚本自动化</strong>：Shell 脚本、任务自动化。</p>
<p>通过实践（如搭建服务器、编写程序、参与开源项目），6-12
个月可达到熟练水平。建议从基础命令入手，逐步深入系统管理和开发，保持动手实践。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>现代前端开发需要掌握哪些技能</title>
    <url>/%E5%89%8D%E7%AB%AF/%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E5%93%AA%E4%BA%9B%E6%8A%80%E8%83%BD.html</url>
    <content><![CDATA[<p>现代前端开发的边界已经远远超过了“写写
HTML/CSS/JS”，它是一项跨技术栈、跨平台的综合工程实践，涵盖从用户体验到工程效率的完整链路。下面是一份
<strong>现代前端开发技能体系清单</strong>，分层次系统整理：</p>
<hr />
<h2 id="一核心语言基础必会">✅ 一、核心语言基础（必会）</h2>
<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th>技能</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>HTML5</strong></td>
<td>语义化标签、表单、媒体、SVG</td>
</tr>
<tr class="even">
<td><strong>CSS3</strong></td>
<td>Flexbox、Grid、媒体查询、动画</td>
</tr>
<tr class="odd">
<td><strong>JavaScript (ES6+)</strong></td>
<td>作用域、闭包、Promise、模块、异步编程、Map/Set</td>
</tr>
<tr class="even">
<td><strong>TypeScript</strong></td>
<td>类型系统、泛型、类型推导、接口定义、联合类型</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="二前端框架与状态管理">✅ 二、前端框架与状态管理</h2>
<h3 id="框架三强">框架三强：</h3>
<table>
<thead>
<tr class="header">
<th>框架</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>React</strong></td>
<td>函数组件 + Hook + JSX（最主流）</td>
</tr>
<tr class="even">
<td><strong>Vue 3</strong></td>
<td>Composition API + 模板语法（渐进式）</td>
</tr>
<tr class="odd">
<td><strong>Svelte / SolidJS</strong></td>
<td>新兴高性能框架（了解即可）</td>
</tr>
</tbody>
</table>
<h3 id="状态管理工具">状态管理工具：</h3>
<ul>
<li>React：<code>useState</code>、<code>useReducer</code>、<code>useContext</code>、Redux、Zustand、Recoil、Jotai</li>
<li>Vue：Pinia（Vuex 替代品）</li>
<li>全局状态/局部状态/异步状态管理：React Query、SWR、Vue Query</li>
</ul>
<hr />
<h2 id="三前端工程化与构建工具">✅ 三、前端工程化与构建工具</h2>
<table>
<thead>
<tr class="header">
<th>技能</th>
<th>工具</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>包管理</td>
<td>npm、yarn、pnpm（首推）</td>
</tr>
<tr class="even">
<td>构建工具</td>
<td>Vite（主流）、Webpack、Rollup、esbuild</td>
</tr>
<tr class="odd">
<td>模块规范</td>
<td>ESModule、CommonJS</td>
</tr>
<tr class="even">
<td>代码规范</td>
<td>ESLint、Prettier、EditorConfig、Husky</td>
</tr>
<tr class="odd">
<td>组件库管理</td>
<td>Storybook、Styleguidist、Bit.dev</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="四ui-框架与组件库">✅ 四、UI 框架与组件库</h2>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>类型</th>
<th>常用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>跨端组件库</td>
<td>Ant Design、Element Plus、MUI、Arco Design</td>
</tr>
<tr class="even">
<td>移动端组件</td>
<td>Vant、NutUI、Taro UI</td>
</tr>
<tr class="odd">
<td>CSS 工具库</td>
<td>Tailwind CSS、Bootstrap、Chakra UI、UnoCSS</td>
</tr>
<tr class="even">
<td>CSS 方案</td>
<td>CSS Modules、SCSS/SASS、Styled-components、emotion、PostCSS</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="五路由与前端导航">✅ 五、路由与前端导航</h2>
<ul>
<li>React Router / Vue Router</li>
<li>嵌套路由、懒加载、重定向、动态路由</li>
<li>中间件（导航守卫）</li>
<li>路由状态传参（search/hash/params）</li>
</ul>
<hr />
<h2 id="六异步与网络请求">✅ 六、异步与网络请求</h2>
<ul>
<li>fetch / Axios / XMLHttpRequest</li>
<li>请求拦截器、响应拦截器</li>
<li>异步错误处理、重试机制</li>
<li>前端缓存、接口节流、防抖</li>
<li>React Query / SWR（数据同步工具）</li>
</ul>
<hr />
<h2 id="七测试能力">✅ 七、测试能力</h2>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>工具</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>单元测试</td>
<td>Jest、Vitest</td>
</tr>
<tr class="even">
<td>UI 测试</td>
<td>React Testing Library、Vue Testing Library</td>
</tr>
<tr class="odd">
<td>E2E 测试</td>
<td>Cypress、Playwright、Puppeteer</td>
</tr>
<tr class="even">
<td>Mock 工具</td>
<td>Mock Service Worker (MSW)、faker.js</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="八移动端开发可选">✅ 八、移动端开发（可选）</h2>
<ul>
<li>H5 适配（rem、vw/vh、媒体查询）</li>
<li>Hybrid 应用（嵌入 WebView）</li>
<li>小程序框架（Taro、Uni-app）</li>
<li>React Native / Flutter Web（了解）</li>
</ul>
<hr />
<h2 id="九前端性能优化">✅ 九、前端性能优化</h2>
<table>
<thead>
<tr class="header">
<th>方向</th>
<th>技术点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>加载速度</td>
<td>Tree Shaking、按需加载、CDN、懒加载、预加载</td>
</tr>
<tr class="even">
<td>运行性能</td>
<td>虚拟列表、合适数据结构</td>
</tr>
<tr class="odd">
<td>渲染性能</td>
<td>避免重排/回流、合成层优化、请求合并</td>
</tr>
<tr class="even">
<td>图片优化</td>
<td>WebP、SVG、Lazyload、响应式图片</td>
</tr>
<tr class="odd">
<td>样式优化</td>
<td>BEM、原子 CSS、避免嵌套过深</td>
</tr>
<tr class="even">
<td>调试工具</td>
<td>Chrome DevTools、Lighthouse、Perf tab</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="十浏览器兼容与标准">✅ 十、浏览器兼容与标准</h2>
<ul>
<li>DOM、BOM、事件机制</li>
<li>浏览器渲染流程（关键渲染路径、合成层）</li>
<li>缓存机制（Service Worker、Cache-Control）</li>
<li>跨域处理（CORS、JSONP、Proxy）</li>
</ul>
<hr />
<h2 id="十一安全与认证">✅ 十一、安全与认证</h2>
<ul>
<li><p>常见漏洞防护：</p>
<ul>
<li>XSS、CSRF、Clickjacking、DOM 注入</li>
</ul></li>
<li><p>身份认证：</p>
<ul>
<li>JWT、OAuth2、Session、Cookie</li>
</ul></li>
<li><p>接口签名、防重放、防盗链</p></li>
</ul>
<hr />
<h2 id="十二devops-与部署">✅ 十二、DevOps 与部署</h2>
<table>
<thead>
<tr class="header">
<th>技术点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>构建产物</td>
<td>SPA vs MPA，资源拆分</td>
</tr>
<tr class="even">
<td>自动化部署</td>
<td>GitHub Actions、Jenkins、Vercel、Netlify</td>
</tr>
<tr class="odd">
<td>版本管理</td>
<td>Git、语义化版本号、Changelog 自动生成</td>
</tr>
<tr class="even">
<td>预发布环境</td>
<td>Mock 环境、灰度发布</td>
</tr>
<tr class="odd">
<td>CDN 与缓存配置</td>
<td>Nginx、Cloudflare、S3 静态托管</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="十三全栈前端方向可拓展">✅ 十三、全栈前端方向（可拓展）</h2>
<ul>
<li><strong>服务端渲染（SSR）</strong>：Next.js（React）、Nuxt（Vue）</li>
<li><strong>全栈框架</strong>：Next.js / Remix / Nuxt3 /
NestJS（前后端一体）</li>
<li><strong>边缘渲染与 Serverless</strong>：Vercel Edge、Cloudflare
Workers</li>
<li><strong>数据库集成</strong>：Prisma、Supabase、Firebase</li>
<li><strong>图形学方向</strong>：Canvas / WebGL / Three.js（可选）</li>
</ul>
<hr />
<h2 id="十四常用工具和生态">✅ 十四、常用工具和生态</h2>
<table>
<thead>
<tr class="header">
<th>工具类型</th>
<th>推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>调试工具</td>
<td>Chrome DevTools、Postman、Fiddler</td>
</tr>
<tr class="even">
<td>Mock 平台</td>
<td>Mocky.io、YApi、Swagger UI</td>
</tr>
<tr class="odd">
<td>可视化工具</td>
<td>ECharts、D3.js、Chart.js</td>
</tr>
<tr class="even">
<td>文件上传/管理</td>
<td>OSS SDK、FineUploader、TUS</td>
</tr>
<tr class="odd">
<td>表格/表单库</td>
<td>Formily、React Hook Form、Naive UI 表格组件</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="十五软技能与工程意识">✅ 十五、软技能与工程意识</h2>
<ul>
<li>模块设计能力、组件抽象</li>
<li>可维护性、可测试性</li>
<li>与后端联调、接口约定（OpenAPI）</li>
<li>性能监控、前端埋点（如 Sentry）</li>
<li>团队协作（代码审查、Git 分支规范）</li>
</ul>
<hr />
<h2 id="建议学习路径">🎯 建议学习路径：</h2>
<h3 id="初级阶段">🟢 初级阶段：</h3>
<ul>
<li>HTML + CSS + JS 基础</li>
<li>React/Vue 框架基本使用</li>
<li>路由 + 状态管理 + Axios 接口通信</li>
<li>构建工具（Vite/Webpack）基础</li>
</ul>
<h3 id="中级阶段">🟡 中级阶段：</h3>
<ul>
<li>TypeScript + 更深入框架原理</li>
<li>工程化（模块化 + 自动化）</li>
<li>SSR / 前端部署</li>
<li>组件设计思想、性能优化技巧</li>
</ul>
<h3 id="高级阶段">🔴 高级阶段：</h3>
<ul>
<li>自研组件库、微前端</li>
<li>Web 安全、跨域解决方案</li>
<li>CI/CD、监控埋点、全链路日志</li>
<li>与服务端协同设计接口规范（RESTful / GraphQL）</li>
</ul>
<hr />
<p>是否需要我按“React / Vue / Flutter
Web”某个技术栈为你列一个成长路线图？或者整理成思维导图便于复习？</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>现代后端开发需要掌握哪些技能</title>
    <url>/%E5%90%8E%E7%AB%AF/%E7%8E%B0%E4%BB%A3%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E5%93%AA%E4%BA%9B%E6%8A%80%E8%83%BD.html</url>
    <content><![CDATA[<p>现代后端开发早已超出“写个接口+连数据库”这么简单，已经演化为一整套<strong>工程体系建设
+ 业务抽象能力 +
高可用架构</strong>的组合能力。以下是一份系统化的后端开发技能清单（不限语言），适合你用来梳理学习路径或查漏补缺。</p>
<hr />
<h2 id="一编程语言基础至少熟练掌握一门">✅
一、编程语言基础（至少熟练掌握一门）</h2>
<ul>
<li><strong>Java / Kotlin（Spring 系生态）</strong></li>
<li><strong>Go（云原生/高并发方向）</strong></li>
<li><strong>Node.js（全栈/中台服务）</strong></li>
<li><strong>Python（AI、脚本、Web 快速开发）</strong></li>
<li>Rust、C#（次主流）</li>
</ul>
<hr />
<h2 id="二web-框架与接口能力">✅ 二、Web 框架与接口能力</h2>
<ul>
<li><p>熟悉至少一种主流后端框架：</p>
<ul>
<li>Spring Boot / Spring Cloud（Java）</li>
<li>Gin / Echo（Go）</li>
<li>Express / NestJS（Node.js）</li>
<li>FastAPI / Flask / Django（Python）</li>
</ul></li>
<li><p>掌握：</p>
<ul>
<li>路由设计（RESTful / RPC 风格）</li>
<li>参数校验（Validation）</li>
<li>JSON 序列化/反序列化</li>
<li>API 版本控制、分页、过滤、排序</li>
</ul></li>
</ul>
<hr />
<h2 id="三数据库能力">✅ 三、数据库能力</h2>
<h3 id="关系型数据库">✅ 1. 关系型数据库</h3>
<ul>
<li>MySQL / PostgreSQL</li>
<li>ORM 工具（JPA, MyBatis, Sequelize, SQLAlchemy）</li>
<li>事务管理、索引优化、慢 SQL 分析</li>
<li>数据库设计（范式、外键、字段类型）</li>
</ul>
<h3 id="非关系型数据库">✅ 2. 非关系型数据库</h3>
<ul>
<li>Redis：缓存、分布式锁、排行榜等</li>
<li>MongoDB：文档型数据库</li>
<li>Elasticsearch：全文检索 / 日志搜索</li>
</ul>
<hr />
<h2 id="四服务开发通用能力">✅ 四、服务开发通用能力</h2>
<ul>
<li>日志（Logback、log4j、Zap 等）</li>
<li>配置中心（Nacos、Apollo、Spring Cloud Config）</li>
<li>接口文档生成（Swagger / OpenAPI / Postman）</li>
<li>参数校验（如 Hibernate Validator）</li>
<li>异常处理机制（统一异常封装）</li>
</ul>
<hr />
<h2 id="五并发与异步处理">✅ 五、并发与异步处理</h2>
<ul>
<li>多线程基础（线程池、任务调度器）</li>
<li>异步任务处理（<span class="citation"
data-cites="Async">@Async</span>、线程池、消息队列）</li>
<li>定时任务（Quartz、xxl-job、Crontab）</li>
</ul>
<hr />
<h2 id="六缓存与消息队列">✅ 六、缓存与消息队列</h2>
<ul>
<li><p><strong>缓存策略：</strong> 本地缓存（Guava/LRU）+
分布式缓存（Redis）</p></li>
<li><p><strong>缓存一致性：</strong> 失效策略、双写一致性</p></li>
<li><p><strong>消息队列：</strong></p>
<ul>
<li>Kafka（高吞吐日志流）</li>
<li>RabbitMQ、RocketMQ（事务消息、业务解耦）</li>
<li>消息重试、幂等、顺序性处理</li>
</ul></li>
</ul>
<hr />
<h2 id="七分布式与微服务">✅ 七、分布式与微服务</h2>
<ul>
<li><p><strong>微服务架构基础：</strong></p>
<ul>
<li>Spring Cloud、Dubbo、gRPC</li>
</ul></li>
<li><p><strong>注册中心</strong>（Eureka、Consul、Nacos）</p></li>
<li><p><strong>配置中心</strong>（Apollo/Nacos）</p></li>
<li><p><strong>服务网关</strong>（Spring Cloud
Gateway、Kong、Traefik）</p></li>
<li><p><strong>服务间通信</strong>（REST / RPC / gRPC）</p></li>
<li><p><strong>容错机制：</strong></p>
<ul>
<li>熔断（Hystrix、Resilience4j）</li>
<li>限流（Sentinel、Guava RateLimiter）</li>
</ul></li>
</ul>
<hr />
<h2 id="八安全与认证">✅ 八、安全与认证</h2>
<ul>
<li><p>HTTPS / TLS 基础</p></li>
<li><p>XSS、SQL 注入、CSRF 防御</p></li>
<li><p>权限认证：</p>
<ul>
<li>JWT / OAuth2 / Session</li>
<li>Spring Security / Casbin</li>
</ul></li>
<li><p>接口签名机制、API 鉴权、IP 白名单</p></li>
</ul>
<hr />
<h2 id="九测试与调试">✅ 九、测试与调试</h2>
<ul>
<li>单元测试（JUnit、Go test、pytest）</li>
<li>接口测试（Postman、Rest Assured）</li>
<li>Mock 服务（MockServer、WireMock）</li>
<li>集成测试与测试金字塔</li>
<li>性能测试（JMeter、Locust、wrk）</li>
</ul>
<hr />
<h2 id="十devops-部署">✅ 十、DevOps &amp; 部署</h2>
<ul>
<li>Git + Git Flow</li>
<li>CI/CD 流程（GitHub Actions、Jenkins、GitLab CI）</li>
<li>Docker 容器化</li>
<li>K8s（Kubernetes）部署与运维</li>
<li>配置管理（dotenv、环境变量、Kustomize）</li>
<li>灰度发布、回滚机制、健康检查</li>
</ul>
<hr />
<h2 id="十一监控与可观测性">✅ 十一、监控与可观测性</h2>
<ul>
<li><strong>日志：</strong> ELK / EFK、Loki + Grafana</li>
<li><strong>链路追踪：</strong> OpenTelemetry、Jaeger、Zipkin</li>
<li><strong>指标监控：</strong> Prometheus、Grafana</li>
<li><strong>报警系统：</strong> Prometheus AlertManager、企业微信 /
飞书通知</li>
</ul>
<hr />
<h2 id="十二高可用系统设计能力进阶">✅
十二、高可用系统设计能力（进阶）</h2>
<ul>
<li>数据一致性设计（强一致 vs 最终一致）</li>
<li>CAP 定理、BASE 理论理解</li>
<li>幂等机制设计</li>
<li>分布式锁（Redis/ZooKeeper）</li>
<li>限流熔断降级（秒杀/抢购等高并发场景）</li>
<li>多级缓存架构（本地缓存 + Redis + DB）</li>
<li>读写分离、分库分表、数据迁移方案</li>
</ul>
<hr />
<h2 id="十三算法与数据结构有业务抽象或面试需求时">✅
十三、算法与数据结构（有业务抽象或面试需求时）</h2>
<ul>
<li>常见数据结构：哈希表、堆、队列、二叉树、图等</li>
<li>算法：排序、二分、回溯、动态规划</li>
<li>分布式一致性算法：Raft、Paxos（了解）</li>
</ul>
<hr />
<h2 id="十四软技能与工程素养">✅ 十四、软技能与工程素养</h2>
<ul>
<li>良好的编码规范（Clean Code）</li>
<li>文档撰写（接口文档、架构文档）</li>
<li>需求沟通、PR Review 能力</li>
<li>代码重构意识</li>
<li>项目拆分与模块化能力</li>
</ul>
<hr />
<h2 id="新趋势可选但加分">🎯 新趋势（可选但加分）</h2>
<ul>
<li>DDD（领域驱动设计）</li>
<li>Serverless（如 AWS Lambda、Cloud Functions）</li>
<li>架构演进（单体 → 微服务 → 云原生）</li>
<li>Event Sourcing / CQRS</li>
<li>GraphQL（替代 REST）</li>
</ul>
<hr />
<h2 id="小结一句话">✅ 小结一句话：</h2>
<blockquote>
<p><strong>现代后端开发 = 编程 + 架构 + 工程能力 + 运维意识 + 性能优化 +
安全保障。</strong></p>
</blockquote>
<hr />
<p>是否需要我按“初级 → 中级 →
高级”阶段，整理一份成长路径学习表或思维导图？或者按某门语言（如 Java /
Kotlin / Go）配套推荐资料？</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>如何读懂《纯粹理性批判》</title>
    <url>/%E5%93%B2%E5%AD%A6/%E5%A6%82%E4%BD%95%E8%AF%BB%E6%87%82%E3%80%8A%E7%BA%AF%E7%B2%B9%E7%90%86%E6%80%A7%E6%89%B9%E5%88%A4%E3%80%8B.html</url>
    <content><![CDATA[<p>要看懂康德的《纯粹理性批判》（Critique of Pure
Reason），需要一定的哲学基础和对相关概念的理解。这本书是西方哲学史上最重要的著作之一，涉及复杂的形而上学、认识论和逻辑体系。</p>
<p>首先需要掌握一些哲学基础知识。</p>
<p>《纯粹理性批判》（以下简称《纯》）涉及的哲学的基本分支包括认识论（Epistemology）、形而上学（Metaphysics）、伦理学（Ethics）、逻辑学（Logic）。认识论是《纯》的核心，康德探讨知识的本质、来源和界限。康德的核心问题是如何获得可靠的知识，特别是在经验和理性之间。关于形而上学，康德探讨存在、因果性、自由意志等终极问题。康德批判传统形而上学（如关于上帝、灵魂、自由的猜测），试图为形而上学奠定新基础。虽然《纯》主要不讨论伦理，但为其后续伦理学著作（如《实践理性批判》）奠定了基础，因此，了解伦理学的基本概念有助于把握康德哲学的整体框架。了解形式逻辑（如亚里士多德的三段论）有助于理解康德的“先验逻辑”。</p>
<p>《纯》中涉及的既往哲学史的知识包括古希腊哲学中柏拉图的理念论，亚里士多德的形式与质料、因果性，近代哲学（17-18世纪）又分理性主义和经验主义。理性主义包括笛卡尔的“我思故我在”和天赋观念，斯宾诺莎的一元论，莱布尼茨的单子论和预定和谐。经验主义包括洛克的白板说和观念的来源，贝克莱的主观唯心主义，休谟的怀疑主义和因果关系的质疑。《纯》是对理性主义和经验主义的综合与批判，因此必须了解这两大流派的核心观点，尤其是休谟对因果性的怀疑，这是康德写作的直接触发点。</p>
<p>《纯》的科学背景包括牛顿物理学和欧几里得几何学。康德深受牛顿力学的影响，认为科学知识具有普遍性和必然性，他试图解释这种必然性的哲学基础。康德认为几何学是先天综合判断的典范，了解其基本假设（如空间的直观性）很有帮助。</p>
<p>然后是《纯》中频繁出现的需要掌握的关键概念。</p>
<p>先天（A Priori）与后天（A
Posteriori）。先天是不依赖经验的知识或判断（如“1+1=2”）。后天是依赖经验的知识（如“天鹅是白的”）。康德的核心问题是：是否存在“先天综合判断”？即不依赖经验但能扩展我们知识的判断。</p>
<p>分析判断与综合判断。分析判断是谓词包含于主词之中，逻辑上必然（如“所有单身汉未婚”）。综合判断是谓词为主词增加新信息（如“桌子是木头的”）。康德认为数学、物理学和形而上学依赖先天综合判断。</p>
<p>直观（Intuition）与概念（Concept）。直观是感性认识的直接形式，如空间和时间。康德认为空间和时间是先天的感性形式。概念是知性的抽象能力，用于组织直观材料。</p>
<p>感性（Sensibility）、知性（Understanding）与理性（Reason）。感性是通过感官接受外部世界的材料，依赖空间和时间。知性是通过范畴（Categories，如因果性、实体）组织感性材料，形成知识。理性是追求形而上学的终极问题（如上帝、自由、灵魂），但可能导致超验的错误。</p>
<p>先验（Transcendental）指研究知识的先决条件，即使经验成为可能的条件（如空间、时间、范畴）。康德的“先验哲学”区别于“超验”（Transcendent），后者指超出经验界限的形而上学猜测。</p>
<p>现象（Phenomenon）与物自身（Noumenon）。现象是我们通过感性和知性认识的世界，受主观条件限制。物自身是独立于我们认识的存在，永远不可知。这是康德哲学的标志性区分，解决了他对形而上学问题的态度。</p>
<p>范畴（Categories）是知性用来组织感性材料的先天概念，如因果性、实体、数量、质量等。康德从亚里士多德的范畴理论发展出自己的体系，共有12个范畴，分为四组（数量、质量、关系、模态）。</p>
<p>哥白尼式革命。康德比喻自己的哲学方法：不是我们的知识符合对象，而是对象必须符合我们的认识结构（如空间、时间、范畴）。这一思想颠覆了传统认识论，强调主观能动性。</p>
<p>先验演绎与先验唯心主义。先验演绎：康德证明范畴如何应用于经验，形成客观知识。先验唯心主义是空间和时间是主观的先天形式，现象世界依赖于我们的认识结构。</p>
<p>自由与必然性。康德区分了自然界的因果必然性和道德领域的自由意志，这一问题在《纯粹理性批判》中为后续伦理学奠定基础。</p>
<p>为了更好地理解《纯》，可以先做一些预备阅读。包括康德之前的哲学家的作品和康德的入门作品。之前的哲学家作品包括休谟《人类理解研究》（尤其是关于因果性和怀疑主义的部分），笛卡尔的《第一哲学沉思集》（了解理性主义的基本立场），洛克的《人类理解论》（经验主义的起点）。康德的入门作品包括《未来形而上学导论》（这是康德对《纯粹理性批判》的简化版，语言更通俗，适合初学者），《实践理性批判》和《道德形而上学基础》（可以帮助理解康德哲学的整体框架）。</p>
<p>最后给出一些具体的学习建议。学习顺序可以是先从康德的《未来形而上学导论》入手，掌握核心思想。再阅读《纯粹理性批判》的“序言”和“先验感性论”，这两部分相对容易理解。逐步攻克“先验分析论”（范畴和演绎）和“先验辩证论”（理性批判）。康德的术语（如先验、先天、范畴）有特定含义，建议准备一个术语表，随时对照。问题驱动，带着问题阅读，如“康德如何解决休谟的因果性问题？”“先天综合判断如何可能？”“康德如何调和理性主义与经验主义？”。《纯粹理性批判》语言晦涩，建议边读边做笔记，梳理康德的论证结构。重点记录康德对“空间和时间”“范畴”“现象与物自身”的论述。中译本推荐李秋零的译本（《纯粹理性批判》，中国人民大学出版社），注释详尽。康德的思想影响了现代科学、数学、心理学等领域，尝试联系这些领域（如空间和时间的相对论讨论）会让阅读更有趣。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
  </entry>
  <entry>
    <title>如何训练意志力</title>
    <url>/%E5%BF%83%E7%90%86%E5%AD%A6/%E5%A6%82%E4%BD%95%E8%AE%AD%E7%BB%83%E6%84%8F%E5%BF%97%E5%8A%9B.html</url>
    <content><![CDATA[<h4 id="设定清晰的目标">设定清晰的目标</h4>
<p>目标需要是具体的，可实现的，有时间限制的。比如不要说“我要锻炼”，而是改成“每周跑步3次，每次30分钟”。</p>
<h4 id="从小事开始">从小事开始</h4>
<p>起步通常都是困难的，一开始定一个很大很复杂的任务也超出了自己的能力，处于慵懒或者被情绪占据的状态时起步也是很困难的。这时候如何启动？需要从小的即使在情绪低落的状态下也可以完成的任务开始，比如看书30分钟太困难，那就改成看书1分钟，每天只看1分钟，哪怕这1分钟内有50秒都在发呆或者消沉也没问题，重要的是有行动，行动就是一切，不必关注行动之外的东西。通过完成小任务来建立意志力的基础，即使是以后意志力丧失后的重建也可以遵循这种方法，意志力的建立不是一劳永逸的，循环往复才是正常现象。从小的积累开始，逐步会不满足完成小的目标，届时再指定更高的目标。</p>
<h4 id="习惯叠加">习惯叠加</h4>
<p>一开始是每天看一分钟的书，坚持30天后感觉很轻松的时候再叠加10个俯卧撑，再坚持30天后继续叠加别的计划，从单一计划逐步叠加为组合计划，并将其作为一个整体融入生活，如果觉得吃力，就回退到上一轮计划，坚持一段时间后觉得不用花费意志力也可以很轻松完成时再加上新的计划，可以调整为更小的新计划。总体原则时有余力时再添加，添加的量要距离自己的意志力极限有一定距离，毕竟是长期乃至终身计划，而非考前冲刺式的一锤子买卖。</p>
<h4 id="生活管理">生活管理</h4>
<p>每天保证8小时睡眠，睡不着也没事，时间要够，睡不着就躺着眯着，但是不能玩手机。每天早起花半小时准备一天的饮食，且不食用计划外的任何食物或者饮品。</p>
<h4 id="不要相信自己">不要相信自己</h4>
<p>除非是刻意制定的对抗诱惑或者糟糕环境的训练，不要相信自己，不想让自己吃零食就不要买，不想把时间浪费在消极的人和事身上就远离他们，不要觉得自己的意志力可以扛得住，意志力是消耗品，没必要在这些方面浪费。人类作为生物本身存在“堕落”的原始欲望，这不以人的意志为转移，良好的环境有助于减少这些欲望的不良印象。当然，刻意训练除外，因为有时候这些环境无法避免，所以需要刻意训练让自己适应。</p>
<h4 id="记录">记录</h4>
<p>每天记录。别在格式上花时间，只在意内容，记录越省力越好，目标是长期的，而非一时的。</p>
<h4 id="建立正反馈和修正机制">建立正反馈和修正机制</h4>
<p>计划失败时要修正计划，比如每天看1分钟书都完不成就看30秒，追求绝对的目标成功，不要追求失败，建立积极的心态很重要，完成是唯一的目标，完成质量无需关注。成功后可以给予一些小的奖励。</p>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
  </entry>
  <entry>
    <title>技术书看一遍就忘怎么办</title>
    <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%B3%95%E8%AE%BA/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%9C%8B%E4%B8%80%E9%81%8D%E5%B0%B1%E5%BF%98%E6%80%8E%E4%B9%88%E5%8A%9E.html</url>
    <content><![CDATA[<p>这是很多技术学习者都会遇到的真实问题，<strong>技术书看一遍就忘，并不是你记性差，而是你“只看没练”或“看得太顺了”</strong>。这不是认知能力的问题，而是<strong>输入方式和记忆方式的问题</strong>。</p>
<hr />
<h2 id="为什么技术书籍一看就忘">✅ 为什么技术书籍一看就忘？</h2>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>原因</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>被动输入</strong></td>
<td>看书时只是“看懂了”，但没“做出来”，大脑并未形成“可用的技能链”</td>
</tr>
<tr class="even">
<td><strong>缺乏实践</strong></td>
<td>没有亲自动手写代码，缺乏肌肉记忆</td>
</tr>
<tr class="odd">
<td><strong>内容碎片化</strong></td>
<td>技术书内容很多细节，但你没有构建“框架”来挂载它们</td>
</tr>
<tr class="even">
<td><strong>没有复述和应用</strong></td>
<td>看完没说出来、没写出来，也没用出来，自然记不住</td>
</tr>
<tr class="odd">
<td><strong>信息过载</strong></td>
<td>看太快、一次性看太多，导致前面的忘光了</td>
</tr>
<tr class="even">
<td><strong>缺乏多次重复</strong></td>
<td>看一遍远远不够，人脑天然抗遗忘，必须反复强化</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="怎么解决六条实用建议">✅ 怎么解决？六条实用建议</h2>
<h3 id="边看边练不要只看不动手">1.
<strong>边看边练，不要只看不动手</strong></h3>
<blockquote>
<p>📌 原则：看完代码就写，写完就运行，运行完就改。</p>
</blockquote>
<p>✅ 示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 书上讲协程，你就自己写个 demo</span></span><br><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;Hello after 1 second&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建知识的结构图">2. <strong>构建知识的“结构图”</strong></h3>
<blockquote>
<p>把书的知识总结成“思维导图”或“卡片笔记”。</p>
</blockquote>
<p>✅ 示例结构：</p>
<ul>
<li><p>Kotlin 协程</p>
<ul>
<li>启动：<code>launch</code>, <code>async</code></li>
<li>调度器：<code>Dispatchers.IO</code>, <code>Default</code></li>
<li>挂起函数：<code>suspend fun</code></li>
<li>并发组合：<code>coroutineScope</code>,
<code>supervisorScope</code></li>
</ul></li>
</ul>
<p>你需要“组织知识”，而不是只“接收知识”。</p>
<hr />
<h3 id="刻意复述来巩固记忆">3.
<strong>“刻意复述”来巩固记忆</strong></h3>
<blockquote>
<p>每看完一小节，用自己的话说出来 / 写出来。</p>
</blockquote>
<p>✅ 示例：</p>
<blockquote>
<p>协程和线程的主要区别在于协程更轻量，能挂起恢复，线程不能；协程运行在线程上，不是替代品。</p>
</blockquote>
<p>你可以：</p>
<ul>
<li>录音自己复述</li>
<li>写成小博客</li>
<li>和人讲一遍</li>
</ul>
<hr />
<h3 id="用项目练知识做一个实际的小-app-或-demo">4.
<strong>用项目练知识，做一个实际的小 App 或 Demo</strong></h3>
<blockquote>
<p>学习协程？那就做一个“并发下载器”或者“并发 API 获取器”。</p>
</blockquote>
<p>✅ 示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> image1 = async &#123; downloadImage(url1) &#125;</span><br><span class="line"><span class="keyword">val</span> image2 = async &#123; downloadImage(url2) &#125;</span><br></pre></td></tr></table></figure>
<p>你用出来了，就记住了。</p>
<hr />
<h3 id="重复阅读间隔复习">5. <strong>重复阅读，间隔复习</strong></h3>
<blockquote>
<p>第1次看 → 2天后复习 → 1周后再复习 → 1个月再复习</p>
</blockquote>
<figure>
<img src="/images/艾宾浩斯遗忘曲线.jpeg" alt="艾宾浩斯遗忘曲线" />
<figcaption aria-hidden="true">艾宾浩斯遗忘曲线</figcaption>
</figure>
<p>用 Anki、Notion、笔记本都行，关键是：</p>
<blockquote>
<p>别想着“一次通吃”，要“反复多次”。</p>
</blockquote>
<hr />
<h3 id="输出倒逼输入教别人-or-写博客">6. <strong>输出倒逼输入（教别人 or
写博客）</strong></h3>
<blockquote>
<p>你永远无法真正理解一样东西，直到你能把它讲清楚。</p>
</blockquote>
<p>可以试试：</p>
<ul>
<li>发博客</li>
<li>写 GitHub 读书笔记</li>
<li>用 ChatGPT 讲给“它”听</li>
<li>拉朋友一起学，互相提问</li>
</ul>
<hr />
<h2 id="记忆是这样形成的">🧠 记忆是这样形成的</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">感知 -&gt; 理解 -&gt; 使用 -&gt; 重复使用 -&gt; 永久记忆</span><br></pre></td></tr></table></figure>
<p>很多人停在了“感知”和“理解”，你需要冲到“使用”和“重复使用”。</p>
<hr />
<h2 id="总结一句话">✅ 总结一句话：</h2>
<blockquote>
<p><strong>技术书不是看完的，是“练”出来的；不是“记住”，而是“用熟”。</strong></p>
</blockquote>
<hr />
<p>不只是技术书籍，其他学科也是类似。数理化需要解题来加深理解。</p>
]]></content>
      <categories>
        <category>技术方法论</category>
      </categories>
  </entry>
  <entry>
    <title>补码系统计算一致性的数学推导</title>
    <url>/%E6%95%B0%E5%AD%A6/%E8%A1%A5%E7%A0%81%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC.html</url>
    <content><![CDATA[<p>补码系统设计了一套机制，将数学上的有符号整数范围 <span
class="math inline">\([-2^{n-1}, 2^{n-1} - 1]\)</span>
映射到无符号整数范围 <span class="math inline">\([0, 2^n -
1]\)</span>。映射后，映射后，所有的算术运算（加法、减法等）在无符号二进制运算下，结果等价于有符号整数的数学运算。</p>
<p>补码的核心是设计一种“编码”，让负数、正数在二进制世界里用统一的规则运算，结果和数学一致。</p>
<p>在这种映射规则下，对于正数和零（<span class="math inline">\(x \geq
0\)</span>），直接用二进制表示，最高位为 0，即<span
class="math inline">\(B(x) = x\)</span>，范围：<span
class="math inline">\([0, 2^{n-1} - 1]\)</span>。对于负数（<span
class="math inline">\(x &lt; 0\)</span>），负数 <span
class="math inline">\(-x\)</span>（其中 <span class="math inline">\(x
&gt; 0\)</span>）映射为：<span class="math inline">\(B(-x) = 2^n -
x\)</span>，范围：<span class="math inline">\([-2^{n-1},
-1]\)</span>，整个范围正好覆盖 <span class="math inline">\([0, 2^n -
1]\)</span>，共 <span class="math inline">\(2^n\)</span>
个值，无浪费。</p>
<p>对于任意有符号整数 <span class="math inline">\(k \in [-2^{n-1},
2^{n-1} - 1]\)</span>：</p>
<p>如果 <span class="math inline">\(k \geq 0\)</span>： <span
class="math display">\[
B(k) = k
\]</span> 如果 <span class="math inline">\(k &lt; 0\)</span>： <span
class="math display">\[
B(k) = 2^n + k
\]</span> 因为 <span class="math inline">\(k = -x\)</span>（<span
class="math inline">\(x &gt; 0\)</span>），所以： <span
class="math display">\[
B(-x) = 2^n - x = 2^n + (-x)
\]</span> 这一映射确保：</p>
<ol type="1">
<li><p>每个有符号整数 <span class="math inline">\(k\)</span>
对应唯一的无符号值 <span class="math inline">\(B(k) \in [0, 2^n -
1]\)</span>。</p></li>
<li><p>反过来，每个无符号值 <span class="math inline">\(u \in [0, 2^n -
1]\)</span> 对应一个有符号整数。</p></li>
</ol>
<p>补码的映射不仅覆盖了范围，还保证了运算（特别是加法、减法）在无符号二进制下的结果与有符号整数的数学运算一致。</p>
<p>对于有符号整数加法，有<span class="math inline">\(x + (-x) =
0\)</span>，在补码系统中，正数被设计为<span class="math inline">\(B(x) =
x\)</span>，负数被设计为<span class="math inline">\(B(-x) = 2^n -
x\)</span>，相加： <span class="math display">\[
B(x) + B(-x) = x + (2^n - x) = 2^n
\]</span> 在 <span class="math inline">\(n\)</span> 位硬件中，<span
class="math inline">\(2^n = 1 0000 ... 0000\)</span>（第 <span
class="math inline">\(n+1\)</span> 位为 1），寄存器只保留低 <span
class="math inline">\(n\)</span> 位：<span class="math inline">\(0000
... 0000 = 0\)</span>。从模 <span class="math inline">\(2^n\)</span>
视角看： <span class="math display">\[
2^n \equiv 0 \pmod{2^n}
\]</span> 所以： <span class="math display">\[
x + (2^n - x) \equiv 0 \pmod{2^n}
\]</span> 对于任意任意 <span class="math inline">\(a, b \in [-2^{n-1},
2^{n-1} - 1]\)</span>，计算 <span class="math inline">\(a +
b\)</span>，结果 <span class="math inline">\(s\)</span>，补码映射：
<span class="math display">\[
B(a) + B(b) \mod 2^n = B(s)
\]</span> 如果 <span class="math inline">\(s\)</span>
在范围内，结果正确；如果溢出，模 <span
class="math inline">\(2^n\)</span> 保证循环性。</p>
<p>对于减法，可以转为加法，<span class="math inline">\(a - b = a +
(-b)\)</span>，<span class="math inline">\(B(-b) = 2^n -
b\)</span>。</p>
<p>硬件用加法器： <span class="math display">\[
B(a) + B(-b) = a + (2^n - b)
\]</span> 模 <span class="math inline">\(2^n\)</span>
后得到正确结果。</p>
<p>要保证循环性（溢出处理），补码形成模 <span
class="math inline">\(2^n\)</span> 的圆环，最大正数：<span
class="math inline">\(2^{n-1} - 1 = 0111 ... 1111\)</span>，加 1： <span
class="math display">\[
2^{n-1} - 1 + 1 = 2^{n-1} = 2^n - 2^{n-1} = B(-2^{n-1})
\]</span> 最小负数：<span class="math inline">\(-2^{n-1} = 1000 ...
0000\)</span>，减 1： <span class="math display">\[
2^n - 2^{n-1} - 1 = 2^{n-1} - 1
\]</span> 溢出时，数值在 <span class="math inline">\([-2^{n-1}, 2^{n-1}
- 1]\)</span> 内循环，硬件无需额外处理。</p>
<p>推导 <span class="math inline">\(B(a) + B(b) \mod 2^n\)</span>
如何映射到 <span class="math inline">\(B(a + b)\)</span>：</p>
<p>对于任意 <span class="math inline">\(a\)</span>： <span
class="math display">\[
B(a) =
\begin{cases}
a &amp; \text{if } a \geq 0 \\
2^n + a &amp; \text{if } a &lt; 0
\end{cases}
\]</span> 同理，<span class="math inline">\(B(b)\)</span> 类似。</p>
<p>计算 <span class="math inline">\(B(a) + B(b)\)</span>，结果模 <span
class="math inline">\(2^n\)</span>： <span class="math display">\[
S = (B(a) + B(b)) \mod 2^n
\]</span> <span class="math inline">\(S\)</span> 是 <span
class="math inline">\(n\)</span> 位寄存器的输出，范围 <span
class="math inline">\([0, 2^n - 1]\)</span>。</p>
<p>需要证明：</p>
<ol type="1">
<li><p>如果 <span class="math inline">\(a + b \in [-2^{n-1}, 2^{n-1} -
1]\)</span>（无溢出），则：<span class="math inline">\(S = B(a +
b)\)</span></p></li>
<li><p>如果 <span class="math inline">\(a + b\)</span>
溢出（超出范围），则 <span class="math inline">\(S\)</span> 是模 <span
class="math inline">\(2^n\)</span> 下的正确映射。</p></li>
</ol>
<p>假设 <span class="math inline">\(a + b = s\)</span>（数学和）。</p>
<h5 id="情况-1a-geq-0-b-geq-0正数-正数">情况 1：<span
class="math inline">\(a \geq 0, b \geq 0\)</span>（正数 + 正数）</h5>
<p>补码： <span class="math display">\[
B(a) = a, \quad B(b) = b
\]</span> 硬件加法： <span class="math display">\[
B(a) + B(b) = a + b
\]</span> 结果： <span class="math display">\[
S = (a + b) \mod 2^n
\]</span> 无溢出。如果 <span class="math inline">\(a + b \leq 2^{n-1} -
1\)</span>（在范围内）：<span class="math inline">\(S = a + b = B(a +
b)\)</span></p>
<p>正溢出。如果 <span class="math inline">\(a + b &gt; 2^{n-1} -
1\)</span>（超出正数范围）：<span class="math inline">\(S = (a + b) \mod
2^n\)</span>。在补码中，这对应负数（圆环循环）。</p>
<h5 id="情况-2a-0-b-0负数-负数">情况 2：<span class="math inline">\(a
&lt; 0, b &lt; 0\)</span>（负数 + 负数）</h5>
<p>补码： <span class="math display">\[
B(a) = 2^n + a, \quad B(b) = 2^n + b
\]</span> 硬件加法： <span class="math display">\[
B(a) + B(b) = (2^n + a) + (2^n + b) = 2^{n+1} + (a + b)
\]</span> 结果： <span class="math display">\[
S = (2^{n+1} + (a + b)) \mod 2^n
\]</span> 因为 <span class="math inline">\(2^{n+1} = 2 \cdot 2^n \equiv
0 \pmod{2^n}\)</span>（因为 <span class="math inline">\(2^n \mod 2^n =
0\)</span>），所以，<span class="math inline">\(S = (a + b) \mod
2^n\)</span>。</p>
<p>无溢出。如果 <span class="math inline">\(-2^{n-1} \leq a + b &lt;
0\)</span>：<span class="math inline">\(S = 2^n + (a + b) = B(a +
b)\)</span></p>
<p>负溢出。如果 <span class="math inline">\(a + b &lt;
-2^{n-1}\)</span>：<span class="math inline">\(a + b\)</span> 是负数，模
<span class="math inline">\(2^n\)</span> 后：<span
class="math inline">\(S = 2^n + (a +
b)\)</span>，可能映射到正数（圆环循环）。</p>
<h5 id="情况-3a-geq-0-b-0正数-负数">情况 3：<span
class="math inline">\(a \geq 0, b &lt; 0\)</span>（正数 + 负数）</h5>
<p>补码： <span class="math display">\[
B(a) = a, \quad B(b) = 2^n + b
\]</span> 硬件加法： <span class="math display">\[
B(a) + B(b) = a + (2^n + b) = 2^n + (a + b)
\]</span> 结果： <span class="math display">\[
S = (2^n + (a + b)) \mod 2^n = (a + b) \mod 2^n
\]</span> 无溢出。如果 <span class="math inline">\(-2^{n-1} \leq a + b
\leq 2^{n-1} - 1\)</span>：</p>
<ul>
<li><p>如果 <span class="math inline">\(a + b \geq 0\)</span>： <span
class="math display">\[
S = a + b = B(a + b)
\]</span></p></li>
<li><p>如果 <span class="math inline">\(a + b &lt; 0\)</span>： <span
class="math display">\[
S = 2^n + (a + b) = B(a + b)
\]</span></p></li>
</ul>
<p>溢出。正溢出（<span class="math inline">\(a + b &gt; 2^{n-1} -
1\)</span>）或负溢出（<span class="math inline">\(a + b &lt;
-2^{n-1}\)</span>），同前述。</p>
<h5 id="情况-4a-0-b-geq-0负数-正数">情况 4：<span
class="math inline">\(a &lt; 0, b \geq 0\)</span>（负数 + 正数）</h5>
<p>对称于情况 3： <span class="math display">\[
B(a) = 2^n + a, \quad B(b) = b
\]</span></p>
<p><span class="math display">\[
S = (2^n + a + b) \mod 2^n = (a + b) \mod 2^n
\]</span></p>
<p>同上，验证无溢出和溢出情况。</p>
<p>根据补码公式的设计，可以得出硬件上“取反加一”的操作。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>补码系统设计的数学表达</title>
    <url>/%E6%95%B0%E5%AD%A6/%E8%A1%A5%E7%A0%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE.html</url>
    <content><![CDATA[<p>补码（Two’s
Complement）是计算机中表示有符号整数的标准方式，其设计目标是：</p>
<ol type="1">
<li><p>统一加减法运算：让正数和负数的加法直接用硬件加法器处理，无需额外的减法逻辑。</p></li>
<li><p>避免零的歧义：确保零只有一种表示（而不是正零和负零）。</p></li>
<li><p>最大化表示范围：在固定位数下尽可能多地表示不同数值。</p></li>
</ol>
<p>基于这种设计，能简化硬件电路地实现，只需寄存器、NOT
门（取反）、加法器（加 1）、ALU（算术逻辑单元）即可实现计算。</p>
<p>基于补码系统的设计目标，可以得到补码系统的数学目标：</p>
<ol type="1">
<li>无缝加法：正数和负数的加法应直接用二进制加法，不需要额外处理符号或绝对值。</li>
<li>单一 0 表示：0 只有一个二进制表示，避免 +0 和 -0 的歧义。</li>
<li>最大范围：在 n 位中表示尽可能多的数值（共 <span
class="math inline">\(2^n\)</span> 个）。</li>
<li>循环性：数值形成一个“模运算”循环，溢出时自然绕回。</li>
</ol>
<p>因为设计出了“负数的补码等于其对应的正数取反加一后的值”这一定义，“取反加
1”正是为了实现上面的数学目标的数学操作。</p>
<p>补码系统中，正数和零的表示直接就是其二进制值，负数的表示是将其对应的正数的二进制值全部位取反后加
1。数学上，“取反加一”可以用公式表达，假设 <span class="math inline">\(x
&gt; 0\)</span>，令 x 的二进制表示为 <span
class="math inline">\(B(x)\)</span> ，长度为 n 位，取反得到 <span
class="math inline">\(\overline{B(x)}\)</span>，即每一位翻转。负数 -x
的补码表示为：</p>
<p><span class="math display">\[
B(-x) = \overline{B(x)} + 1
\]</span></p>
<p>更精确地，<span class="math inline">\(\overline{B(x)}\)</span> 的值是
<span class="math inline">\((2^n - 1 - x)\)</span>（因为取反后，1 变
0，0 变 1，相当于用最大值减去 x ）。所以： <span class="math display">\[
B(-x) = (2^n - 1 - x) + 1 = 2^n - x
\]</span></p>
<p>从数学上看，“取反加
1”确保了负数和正数在加法运算中行为正确，并且满足补码的循环性质。下面对其进行数学分析：</p>
<ol type="1">
<li>实现加法的一致性</li>
</ol>
<p>补码的目标是让 <span class="math inline">\(x + (-x) =
0\)</span>，即在补码上的计算行为要和原码相同。正数 <span
class="math inline">\(x\)</span> 的二进制是 <span
class="math inline">\(B(x) = x\)</span>，负数 <span
class="math inline">\(-x\)</span> 的补码是 <span
class="math inline">\(B(-x) = 2^n - x\)</span>。相加： <span
class="math display">\[
B(x) + B(-x) = x + (2^n - x) = 2^n
\]</span> 在 <span class="math inline">\(n\)</span> 位二进制中，<span
class="math inline">\(2^n\)</span> 是一个溢出，<span
class="math inline">\(2^n = 1 0000 ... 0000\)</span>（第 <span
class="math inline">\(n+1\)</span> 位是 1，后面 <span
class="math inline">\(n\)</span> 位是 0），<span
class="math inline">\(n\)</span> 位寄存器只保留低 <span
class="math inline">\(n\)</span> 位，结果是 <span
class="math inline">\(0000 ... 0000 = 0\)</span>。所以<span
class="math inline">\(x + (-x) = 0\)</span> 成立，这是“取反加
1”的直接结果。</p>
<ol start="2" type="1">
<li>实现循环性质（模运算）</li>
</ol>
<p>补码系统本质上是对 <span class="math inline">\(2^n\)</span>
取模的运算，任何加法结果超过 <span
class="math inline">\(2^n\)</span>，会减去 <span
class="math inline">\(2^n\)</span>（溢出丢弃），负数 <span
class="math inline">\(-x\)</span> 表示为 <span class="math inline">\(2^n
- x\)</span>，正好是模 <span class="math inline">\(2^n\)</span>
下的等价值： <span class="math display">\[
-x \equiv 2^n - x \pmod{2^n}
\]</span> 这种循环靠 <span class="math inline">\(2^n - x\)</span>
实现，而“取反加 1”正好计算出 <span class="math inline">\(2^n -
x\)</span>。</p>
<ol start="3" type="1">
<li>单一零表示</li>
</ol>
<p><span class="math inline">\(x = 0\)</span>，取反：<span
class="math inline">\(1111 ... 1111 = 2^n - 1\)</span>，加 1：<span
class="math inline">\(2^n - 1 + 1 = 2^n\)</span>，模 <span
class="math inline">\(2^n\)</span> 后是 0。所以，<span
class="math inline">\(B(-0) = B(0)\)</span>，零只有一种表示。</p>
<p>“取反”计算 <span class="math inline">\(2^n - 1 - x\)</span>，加 1
变成 <span class="math inline">\(2^n -
x\)</span>，这些都是简单的位操作，所以在硬件上只需实现反转器和加法器。</p>
<p><span class="math inline">\(n\)</span> 位补码表示 <span
class="math inline">\([-2^{n-1}, 2^{n-1} - 1]\)</span>，正好 <span
class="math inline">\(2^n\)</span> 个值，无浪费。如果使用原码，+0 和 -0
都表示 0 ，将浪费一个位置。</p>
<p>补码系统 就像一个圆环，数值在 <span class="math inline">\([0, 2^n -
1]\)</span>​ 内循环。当计算 <span class="math inline">\(x + (2^n - x) =
2^n\)</span>，<span class="math inline">\(2^n\)</span> 超出 <span
class="math inline">\(n\)</span> 位寄存器的范围（最大值是 <span
class="math inline">\(2^n - 1\)</span>）。硬件自动丢弃溢出位：<span
class="math inline">\(2^n = 1 0000 ... 0000\)</span>（第 <span
class="math inline">\(n+1\)</span> 位为 1），低 <span
class="math inline">\(n\)</span> 位是 <span class="math inline">\(0000
... 0000 =
0\)</span>。硬件不需要特殊逻辑，加法溢出自动归零。如果是原码计算，x 和
-x 的原码相加需要特殊的硬件处理逻辑。</p>
<p><span class="math inline">\(2^n - x\)</span>
让数值形成圆环，溢出自动绕回： <span class="math display">\[
2^{n-1} - 1 + 1 = 2^{n-1} = 2^{n} - 2^{n-1} = -2^{n-1}
\]</span> <span class="math display">\[
-2^{n-1} - 1 = 2^{n} - 2^{n-1} - 1 = 2^{n-1} - 1
\]</span></p>
<p>硬件进行补码计算之后，如果计算的结果是负数，只要对计算结果再次进行“取反加一”的操作，就可以得到其绝对值，再加上符号判断，即可得出正确实际结果。其数学原理在于：负数
<span class="math inline">\(-x\)</span> 的补码是 <span
class="math inline">\(2^n - x\)</span>，对 <span
class="math inline">\(2^n - x\)</span> 取反加 1：</p>
<p><span class="math display">\[
\overline{2^n - x} + 1 = (x - 1) + 1 = x
\]</span> 逆转了生成补码的过程（<span class="math inline">\(B(-x) =
\overline{B(x)} + 1\)</span>）。</p>
<p>补码系统的核心思想是设计一套机制，将数学上的有符号整数范围 <span
class="math inline">\([-2^{n-1}, 2^{n-1} - 1]\)</span>
映射到无符号整数范围 <span class="math inline">\([0, 2^n -
1]\)</span>。补码的核心是设计一种“编码”，让负数、正数在二进制世界里用统一的规则运算，结果和数学一致。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>大理和丽江</title>
    <url>/%E6%97%85%E8%A1%8C%E7%AC%94%E8%AE%B0/%E5%A4%A7%E7%90%86%E5%92%8C%E4%B8%BD%E6%B1%9F.html</url>
    <content><![CDATA[<h4 id="大理">大理</h4>
<p>昆明的火车站乱糟糟的，人流拥挤，维持秩序的工作人员拿着大喇叭喊着正在检票的车号，检票口会变动，显示的检票口并不准确，因而必须人工提醒。刚刚在火车站门口吃的一碗二十块的米线并不能让我果腹，米线的量少得可怜，昆明火车站的外景让我想起十几年的那些充斥着宰客的摩托和劣质饮食的汽车站。火车站内的墙壁上都是云南旅游的宣传画，十分精美，APP、二维码、公众号，墙壁的每一寸空间都在不遗余力地提醒我如何可以租车、买门票，以及我应该去哪些地方。</p>
<p>我坐在火车站超市内大口嚼着用来充饥的面包，回想我刚刚看过的《美丽云南》《不一样的云南》《云南通史》，努力将眼前的乱糟糟的场景和历史上的“彩云之南”联系起来。</p>
<p>唐朝开元二十六年（738年），洱海地区的蒙舍诏部落首领、哀牢夷人皮罗阁兼并其他五诏，建立南诏国。</p>
<p>后晋天福二年（937年），段思平联络三十七部灭大义宁国，建立大理国政权。</p>
<p>大理王向宋朝称臣纳贡，其首领先后被宋朝封为云南八国郡王、大理王等，并成为南宋王朝抵御蒙古贵族西部战线的助手。</p>
<p>元朝，1253年，忽必烈率大军乘革囊渡金沙入云南，灭大理国。1276年忽必烈选派赛典赤·赡思丁为“云南行中书省平章政事”，省会中庆路（昆明），自此昆明取代大理成为云南的政治中心，云南完全纳入了元朝的统一治理范围。</p>
<p>历史上的云南和中央政权的关系一直不错，极少“犯上作乱”，大理国的几任皇帝都信奉佛教，皇帝退位后去当和尚也是中国历史上的一大特色。北宋的一百多年间，北宋朝廷对云南实行“宋挥玉斧”的政策，封闭边疆，完全不来往。宋朝皇帝认为云南地区都是蛮夷，尽是不可教化之人，故而采取不再往来的态度，连发动战争征服都不屑于。</p>
<p>云南是中国民族种类最多的地区，56个民族中占了52个，不同民族通婚很常见。大理地区以白族为主，环行洱海的过程中，正好同时遇到了白族人的喜事和丧事，和汉族也未见有什么大的不同。</p>
<p>从昆明坐动车一路向西北出发，入境大理，大理的构造十分简单，苍山一圈环绕，中间是洱海，围绕洱海散落一圈大大小小的村庄，大理市就在其中。我住在才村，旁边就是一个码头，一天中的任何时间去看洱海，风景都不一样。凌晨、日出、日暮、阴雨，各不相同。云南的天气变化极快，阴晴不定，日照强烈，仅仅是在洱海周边，已经能约略体会到“一山有四季，十里不同天”的气候环境。</p>
<p>云南是低纬度地区，靠近热带，然而因为海拔较高，气候环境多变，动植物种类丰富，大理的天气就是如此，刚刚还阳光明媚，晴空万里，雨说下就下，早晚温差有十度之差。</p>
<p>从下关一路向洱海行进，向才村出发。一路上风声滚滚，下关位于苍山和洱海之间，由于位置特殊，导致这个地方常年刮风，“下关风”也是大理四大名景之一。大理的基础设施落后，连公交站台也没有，跟着导航虽然找到了位置，然而路旁却赫然竖着一根“禁止停车”的牌子，过了一会，一辆公交车姗姗来迟停在路旁，司机是个黑脸的汉子，语气不甚耐烦，相当得不客气。</p>
<p>大理地区日照紫外线强烈，这里的居民大多皮肤黝黑。才村是洱海边一个普通的村落，村子靠洱海一边建了一溜客栈，千篇一律的落地窗，透明挂椅，仿佛定制的一般。村子里的电线杆上贴着“一针包治梅毒”的广告，当地人大多穿着民族服装，在村委会设立的公告栏中，估计当地人穿着民族服装。到处都贴着“洱海是大理的生存根基”的标语。环行洱海的时候，去了“喜洲古镇”和“双廊古镇”，除了名字不一样，看不出这两个镇的区别，和我去过的大多数“古”镇一样，除了满大街的奶茶店和烧烤摊，已经难觅能够清晰标识出这个镇子的历史的一砖一瓦，或许有，也被淹没在说不尽的灯红酒绿之中，街上来自远方都市的男男女女，比着手势拍照，一年之中，洱海、苍山和这些古镇，会成为无数人的背景板，作为曾经见证过无数历史的自然地理，大理或许已经对着一切习以为常。它让我想起普吉岛，一个简单、直白地对红灯区和酒吧舞女大肆宣传的旅游胜地，它们需要的都是无穷无尽的人流，而非历史。</p>
<p>整个大理贴着大量的标语，将可以写成六卷书的《云南通史》简化为“风花雪月”，简化为一张旅游图，简化为一个个背后的意义已经无可寻觅的名字，正如奥威尔所说，语词和意义分了家。我试图在这种纷扰复杂中寻找到云南曾经的历史，但是被门票和标语掩盖下的历史遗迹似乎已经了无踪迹。和敦煌不同，如果说直面壁画给我带来的是无法阻隔的历史震撼，那大理就只是一张简单映着苍山洱海的明信片，它想让我消费，我却只想听它讲故事。</p>
<h4 id="丽江">丽江</h4>
<p>和大理不同，丽江不缺故事，相反，故事多得听不过来。</p>
<p>窗外响起了生日歌，房东带着房客们给一个客人过生日，如果在上海，我应该出门大吼一声:大半夜闹啥？睡觉呢！然而这里是丽江，一切都变得不一样了。就在几十分钟前，房东刚刚给我讲了一个故事:前几天是中秋节，房东把房客们聚集起来过中秋，半夜的院子热闹非凡，只有一户房客表达了不同意见，出来向众人表示抗议需要安静，然后被众人无视了，第二天一早房东在那户房门口放了一盒月饼，月饼被收了，不过房客走得并不开心。房东笑道:有时候你得适应环境，而不是让环境适应你。我没有说话，此刻听着院子里的动静，便有了这样的开头。</p>
<p>在丽江，有时候你分不清，他们是在表演，还是在表达真实的自我。我抽着客栈老板的二手烟，思考着这些问题，听他说起从前。说实话，不是为了这顿“丽江”式的聊天，我大概早就跑了，我最是无法忍受这种让人抽二手烟的行为，然而此刻，为了让老板“敞开心扉”，我不得不忍受那糟糕的烟味，和老板开启一段“迎合”意味浓重又不甘于配合对方表演的聊天。</p>
<p>院子里的客人们“敞开心扉”自报家门，四川话、东北话、广东话、平舌翘舌不分的普通话，伴随着那只大金毛时不时的犬吠声。一个来自东北的女人不停地在报复式的点外卖:烧烤、火锅、串串、麻辣烫，一边得意地说着自己在丽江吃和睡的生活，旁边的男伴不时地劝阻一下，只引来一阵嗔骂，女人继续点着自己根本吃不完的外卖，桌子上的食物越堆越高。</p>
<p>老板当过兵，出过家，干过外贸，移过民，转过经，徒步进过藏，苦行过，曾经和一个法国教授房客辩论十五天并“成功说服”（老板原话）对方接受中国传统文化优于西方哲学，对方甚至邀请老板去巴黎演讲（老板原话）。老板背诵了几段《道德经》《诗经》中的篇章，并且和我讨论孔孟之道，这不是我所擅长的领域，于是我试图把讨论引向西方哲学，不过老板似乎对这个领域兴趣不大，我们就这样“鸡同鸭讲”各自论述了半天，谁也没能“说服”谁，我在虚与委蛇地迎合了一些老板的见解之后直接针对东西方哲学思想差异等一些关键问题发起了提问，不过老板顾左右而言他，始终用发散式的聊天“化解”了我提出的问题。</p>
<p>玉龙雪山是纳西族的圣山，纳西族这个民族很有意思，不拜神，不拜佛，只拜自然，而且女尊男卑，女主外男主内，母系社会。纳西族拜神山所追求的东西也十分简单，就是世俗的幸福，没有佛教道教那些虚头巴脑的境界。一个崇尚自然教的民族应该不会被条条框框所束缚。这似乎暗合了“丽江人”的特性——不虚伪，然而这种不虚伪是真的天性释放还是只是一种及时行乐般的狂欢，就不得而知了，正如平时拘谨如处子进了舞池却狂放不已的人一样，很难知道哪个是真正的他。</p>
<p>丽江，正如云雾弥漫的玉龙雪山，难以辨其真面目。</p>
]]></content>
      <categories>
        <category>旅行笔记</category>
      </categories>
  </entry>
  <entry>
    <title>婺源</title>
    <url>/%E6%97%85%E8%A1%8C%E7%AC%94%E8%AE%B0/%E5%A9%BA%E6%BA%90.html</url>
    <content><![CDATA[<p>2021年的中秋，去了婺源。</p>
<p>婺源县城并不大，除了破落一点，和别处的县城并没有什么不同。横穿县城，不过五公里的距离。这座从旧石器时代便开始有人类活动的古城初见时并没有什么特别的地方，半夜的街边的大排档和烧烤摊，以及吆五喝六的人群，在别处也是一样的常见。</p>
<p>在地图上找了一条古街，零零散散地逛了片刻，从斑驳的屋墙和年久失修的各式破房子中寻找历史的痕迹。倒坍的房子和院落门上贴着政府的公告和改造计划，但显然大概是处于资金的窘迫，那些宏大的旅游开发计划并没有得以施行。唯一恢弘的建筑倒是一座寺庙，佛像宏伟，香火旺盛，庙宇轩昂，和庙门外的破落对比鲜明。古街的尽头是一条新造的步行街，各种服饰和化妆品专卖店，行人并不多。</p>
<p>早期生活在婺源地域上的土著先民，属于越族。唐代，中原发生过两次大规模的战乱，即天宝年间的“安史之乱”和唐末的黄巢起义。婺源山川险阻，兵革难至，正是人们逃避战乱的理想之地。因避中原战乱而移民婺源的北方士族，不断传播儒家文化，他们坚持不懈的教化，使当地山越土著逐步接受中原文化，终于在唐末完成了汉、越的融合。五代以后，再也不见有关山越族的文字记载。</p>
<p>中国历史上朝代更迭，战乱频繁，婺源因其地势成了很多文人和前朝官员的避世逃难之所，这些人给农耕文明时代的婺源带来了大量的文化资源。两宋时期，婺源社会重文兴教的风气开始形成。自宋庆历四年（1044），除官府在蚺城始建县学外，另有地方热心兴学人士先后创办龙川书院、万山书院、山屋书院、屏山书屋等讲学会文之所。此外还有众多的学馆、义塾、书斋在境内纷纷出现。在辈出的文人中，出了一个在历史上排得上号的人物——朱熹。朱熹继承发展了儒家文化，成为程朱理学扛鼎之人。咸淳五年（1269），宋度宗赵禥诏赐婺源为“文公阙里”。这四个大字就刻在前文提到的步行街入口处的牌坊上。</p>
<p>纵观中国的文化历史，以儒家文化为主导的“官方文化”在钳制异端，规范民众行为上居功至伟，而朱熹在历史上正是如孔子再世一般的存在，他开创的程朱理学为后世各代统治者推崇，极力宣扬教化，奠定了中国人“温良恭俭让”的理论基础。程朱理学对孔孟之道一脉相承，成为明清时期的封建统治者稳固文化思想的有力工具。清王朝倒台之后，以鲁迅为首的新文化倡导者对中国传统文化中的流毒和弊病进行了口诛笔伐，从今天发展的世俗理论上来看，发轫于程朱理学就像伊斯兰原教旨主义控制阿拉伯世界一样支配了中国人的精神思想几百年，除了一些朴素的正义和善恶理论之外，其中还充斥了大量泯灭人性的“教义”，利于通俗故事化后的“二十四孝”，“存天理，灭人欲”，以至于进入近代以来，中国人的思想非但没有得到解放，反而进一步被禁锢，女人裹小脚，男人也是只读圣贤书，进一步消灭了人性和自我，这一切只有一个好处，就是稳定。这也是中国虽然屡次经历历史周期律而封建制度却稳固不倒的原因。而对于当代的政治家和一些学者试图恢复这种泯灭人性的“传统文化”的主张，应该引起人们的警惕，历史不是不会重演，独立与自由的争取从来都是要付出代价的。最直观的，“劝忠”和“劝孝”在今天被异化成了泛滥的“民粹主义”和“愚孝”，而今天的地铁上张贴的大幅的二十四孝的宣传画也仍然让人远离历史的罪恶以为进入了思想解放的新世纪之后依然被吓得毛骨悚然，直冒冷汗。</p>
<p>朱熹在婺源的另一大创举是推进了“乡约”制度。封建统治者一直没有解决的一个政治难题是乡村一级的统治和管理问题，这时候同乡的有识之士就联合制定了乡约来规范和约束乡民的行为，作为封建统治制度的补充，并且得到朝廷和官府的支持。我在汪口村的乡约所看到一个刻满乡约的石碑，不外乎是一些赏善罚恶的约定，乡民自觉遵守。乡约制度传承到今天便成了类似于村民公约的东西，比如被改造成旅游景点的村子会约定一些规矩，比如善待游人，不允许宰客，不允许过度商业化，不许养狗之类的。同姓一族通常聚族而居，其中有名望的人回乡得了朝廷的封赏便可以建造宗祠，这些宗祠里头除了供奉先祖外，也大多供着朱熹。</p>
<p>去婺源的路上，翻看的是《婺源史话》，回来的路上，已经看起了鲁迅的文集，心情有些许沉重，那些宗祠和乡约所中的碑文旧物如鬼魅一般萦绕脑际，二十四孝，婚丧嫁娶，中国人几千年来，朝代更迭，看似变了，又好像没变，即使没有这些实物的载体，很多的旧思想、旧习惯也像千年的椽柱一样压得中国人喘不过气来，今天拿出来又来展览，是歌颂、批判还是“接受一切，欣欣然地蹩进卧室，大吸剩下的鸦片”？中国人何时能砸碎这宿命的枷锁，锤烂历史的孽债，透出口气来，大咧咧做个彻彻底底的新人，有新思想，立新文化，不复那些前朝的覆辙。</p>
<p>王师北定中原日，家祭无忘告乃翁。</p>
]]></content>
      <categories>
        <category>旅行笔记</category>
      </categories>
  </entry>
  <entry>
    <title>寻访弘一法师</title>
    <url>/%E6%97%85%E8%A1%8C%E7%AC%94%E8%AE%B0/%E5%AF%BB%E8%AE%BF%E5%BC%98%E4%B8%80%E6%B3%95%E5%B8%88.html</url>
    <content><![CDATA[<h4 id="一">一</h4>
<p>此行杭州，只为李叔同。不然我绝对不会在骄阳似火的八月跑来杭州看西湖。</p>
<p>1918年，39岁的李叔同在杭州虎跑寺剃度出家，法号弘一。此时，距离他生命终结还有24年，在这24年里，李叔同作为弘一法师长伴青灯佛影，两袖清风，一肩梵典，着百衲衣，苦修律宗。佛教八万四千法门，数律宗最难修持，因为要求修行者持戒甚严，一般勘破红尘的世俗文人会选择禅宗，讲究顿悟，修行起来要轻松不少。律宗因为修持极难，自宋朝后便已经废弛，弘一法师重新振兴了律宗，被尊称为重兴南山律宗第11代祖师。</p>
<p>李叔同生长于天津，成名于上海，他那首《金缕曲》我时常挂在嘴边念叨:</p>
<p>披发佯狂走。莽天涯，暮鸦啼彻，几株衰柳。破碎河山谁收拾?零落西风依旧。便惹得、离人消瘦。行矣临流重太息，说相思、刻骨双红豆。愁黯黯，浓于酒。</p>
<p>漾情不断淞波溜。恨年年、絮飘萍泊，遮难回首。二十文章惊海内，毕竟空谈何有?听匣底、苍龙狂吼。长夜凄风眠不得，度群生、哪惜心肝剖!
是祖国，忍辜负!</p>
<p>其中何等的少年英雄和家国情怀！年轻时，李叔同也是红尘中风流倜傥的才子，旧学功底深厚，后入南洋公学学习新学，西方的音乐绘画样样精通，到后来留学东瀛，研学西画，又有大成就。39岁舍弃相伴十年的发妻，毅然出家，彼时正值新旧交替内忧外患之际，年轻时慷慨激昂的李叔同没有选择从戎报国，也没有选择用新文艺继续开启民智，着实令人费解。其实如果了解佛教，这个也未必难理解。在不了解佛教的人看来，佛门是消极避世的去处，其实不然，佛教八万四千法门，无一门教人消极避世。佛法，修的是戒定慧，戒的是贪嗔痴，这些都是人欲。譬如年轻人失恋了要寻死觅活，这就是犯了痴戒，痴情对人而言可不是什么好事。又譬如现在的一些吃播胡吃海塞，食欲也是欲，欲壑难填，这就是贪。正常人并不会去克制这些欲望，虽然大家每天说要保持身体和心理健康，但大多也只是说说而已，并不真的去做，即使去做，也只是靠意志力去压制，并非真的用正法消除了业障。譬如看到美女帅哥只是强行忍住不看不想，时间长了稍有松懈就会被反噬。佛法就是研究如何通过修持达到对欲念控制从容不迫的境地。</p>
<p>为国为民者有之，李叔同选择了另一条路，提升修为。这种影响是缓慢而不可预知的，比如他绝对想不到在这个欲念横流、娱乐至死的2022年会有我这样一位普通人因为想探究佛法冒着酷暑和疫情跑来杭州拜访他的出家之地。</p>
<p>释迦牟尼涅槃之际，坐下比丘问:“佛入涅槃，以谁为师？”释迦牟尼答:“以戒为师”。戒是无上菩提本。</p>
<p>李叔同纪念堂入门处抬头的匾额上便是四个大字:以戒为师。来到这里颇费周折，我本住得不远，奈何导航乱指路，走了反方向，及到我匆匆赶到纪念堂时，只剩下三分钟游览时间，只能匆匆瞥过，待明日再来。迷路的时候向一个清洁工问路，问虎跑寺在哪里，不知，问李叔同和弘一法师，亦不知，失望不已。虎跑寺如今已成了虎跑公园，不见僧侣，只留一眼虎跑泉，很多人拿着桶排队打水，据说是回去煮水泡茶。进门时和门卫攀谈了几句，据说西湖边上这一片原先全是寺庙，现在全都改成公园景点了。</p>
<p>晚上呼吸着滚烫的空气环骑西湖，望着苏堤上摩肩接踵的游人，忽然冒出一句诗:</p>
<p>南朝四百八十寺，多少楼台烟雨中。</p>
<h4 id="二">二</h4>
<p>悲欣交集，是弘一法师的遗墨，也是他一生的写照。据李叔同自述，二十多岁的那几年是他一生中最快乐的时光，此后便是半生愁苦。他愁什么呢？纵使家道中落，以他的才学，在那个年代也属于高收入群体。按照中国的传统观念，他家庭、事业都有了，虽值山河破碎之际，但他既不变法（虽然支持），也不革命，只要明哲保身，并无性命之虞，即使在乱世中，也能活得自在惬意，只不过史书上少了这么一号人物而已。对普通人来说，生活富足，心情愉快足矣，君不见日寇侵华之际，十里洋场上海滩，多的是“商女不知亡国恨，隔江犹唱后庭花”。只是如此，他便不是李叔同了。</p>
<p>第二天五点便醒来，杭州的天气依然十分闷热，一出门，人便仿佛置身于烤热的玻璃瓶中，虎跑路两侧都是枝繁叶茂的大树，骑车下行，满眼都是绿意。李叔同纪念馆八点半开门，时间还没到，于是在虎跑公园内先行徘徊。上山的路上有很多拉着小车带着水桶的民众，他们是去虎跑泉打水，看他们打到的泉水冷沁，瓶身上凝着一层水珠。</p>
<p>我先看了纪念馆旁边的侧室，里面有弘一法师的起居用具和书桌笔砚，确实是不能再简单，我自认为一直是极简生活的践行者，看到如此简单的生活用具也自叹不如。</p>
<p>卧具只是一个床板，生活用具都极尽俭朴，戒是无上菩提本，持戒精严，才能摒弃对世俗欲念的渴望，专注于提升个人修为，用丰子恺的话来说，这是一种灵魂追求，又在对艺术的精神追求之上，这种灵魂追求表面上通过信仰宗教来实现，现实中要通过约束自己的言行，约束自己的欲念来实现，这并非毫无意义的自我折磨式地苦行，而是确实地能将人的灵魂提升到另一层次，贪嗔痴这样的普通人具有的精神上的弱点正是通过这样的艰苦修行一点点克服，须知人的每次愤怒、贪婪或痴想皆因欲念而起，如果摒弃这种欲念，自然这些弱点就不复存在，这种修行对于日常生活中暴躁易怒的普通人而言亦具有十分积极的意义。</p>
<p>如果弘一法师只是偏居一隅，念经求佛，还配不上他一代高僧的名声，他偏偏还是个行脚僧，云游四方，推行佛法。他是以“出世的精神”行“入世的事业”，身体力行地践行佛法，并为了普及佛法做了大量的努力。由此看出，李叔同完全不是为了消极避世而出家，如果是这样，那他大可以下半生做个寂寂无名的扫地僧，远离尘嚣，更何谈振兴“南山律宗”，做和尚，也要做一等一的和尚（这里是我的杜撰，弘一法师断没有这样的机心，他只是认真对待自己做的事）。实际上，弘一法师在出家前就是个做事非常认真的人，这和他出家后并无二致，他做人，是一以贯之，从一而终的。</p>
<p>浏览李叔同纪念馆的时候，看到潘天寿曾说：“吾师弘一法师云：’应使文艺以人传，不可人以文艺传。’可与唐书‘人能宏道，非道宏人’一语相印证。”这话今天听来真是振聋发聩，君不见今天有的人只是做出一点所谓的成就就自视甚高，人品低劣不堪。而普通民众也以成就视人，全然不顾这人人品如何低下，这种结果导向和极端现实可能是受了西方市场经济的影响，因为在物欲横流的时代，人只是规则下的零件，人的善与恶已经失去意义，只要不违法，万事皆可为。我曾经也是这种规则先行，人品无论的信仰者，因为人的行为太不可控，但是近来发生的一些事却让我反思这种忽略个人修为的所谓规则第一的制度真的是完美的么？现代人已经不知道修身为何物了，全都比着躺平摆烂，对志趣高雅洁身自好的人反而群起而讥笑之，这不能不说是一种倒退。</p>
<p>长期的神经衰弱和久久的奔波劳累也终于拖垮了弘一法师的身体。弘一法师预感自己大限将至，将后事一一安排，从容赴死。佛说：“一切有为法，如梦幻泡影，如露亦如电，应作如是观。”人生终要唱响离歌，繁华过处皆是幻灭，弘一法师圆寂前手书“悲欣交集”四个字，正是于修行中参透的大道佛法。</p>
<p>一轮明月耀天心。</p>
]]></content>
      <categories>
        <category>旅行笔记</category>
      </categories>
  </entry>
  <entry>
    <title>浙东唐诗之路</title>
    <url>/%E6%97%85%E8%A1%8C%E7%AC%94%E8%AE%B0/%E6%B5%99%E4%B8%9C%E5%94%90%E8%AF%97%E4%B9%8B%E8%B7%AF.html</url>
    <content><![CDATA[<p>2023年的五一节，驾车从上海一路向南，经过绍兴，嵊州，新昌，天台，最终到达温州，一路见闻思考颇多，兹记录如下。</p>
<p>一般而言，我会在去一个新的地方前做一些知识储备，包括历史，地理，人文等等，这次出发的比较仓促，没有看太多资料，所以也只能走马观花，囫囵吞枣地看一看。</p>
<p>不过，另一方面说，不预设什么目标，放松身心，随遇而安，也是一种不错的体验。</p>
<p>浙东唐诗之路，以萧山—柯桥—越城—上虞—嵊州—新昌—天台—仙居（临海）为主体，历史遗存和人文典故众多，留下1500多首唐诗，是一条自钱塘江经绍兴，而后经浙东运河、曹娥江至剡溪再达新昌，直至台州天台及温州的诗意之路。（百度百科）</p>
<figure>
<img src="/images/浙东唐诗之路.jpg" alt="浙东唐诗之路" />
<figcaption aria-hidden="true">浙东唐诗之路</figcaption>
</figure>
<p>无意中的得知了这条路，更没有想到大名鼎鼎的天姥山居然就在浙江嵊州，为了一睹李白奇诡诗文中的神山的现实面貌，遂决定前往。（事实上，李白写这首诗的时候并不在浙江，他完全是根据自己的梦境写成的。）</p>
<p>人总喜欢把美好寄托在别处，然而别处可能并不会有什么不同，甚至更糟。比如夜晚在台州山里开车迎面而来的全是闪瞎眼的远光灯。而所谓的当地美食也未必好吃，云南的酸辣，浙江不时就能吃到沙子的梅干菜，还有把油炸面粉换个命名的本地小吃。文学家、媒体还有心怀“诗和远方”的年轻人喜欢美化远方，但是世间的每一种事物都没法脱离自然规律的本质而运行，于我而言，旅行的目的大概就在于在了解了这些本质后观察它们在不同环境和条件下的具体实现和发展。</p>
<p>旅行结束后，朋友问我此番有什么心得，我答：“观上海而小天下，观天下而小上海。”人在一个地方待久了，思维模式和认知习惯上难免会受到环境的影响，这在其思考，语言和行为上都能分析出来，这种情况下人很容易陷入偏执和狭隘，对事物失去客观认知的能力，而总是以为自己的认知是正确且唯一的解。解决这个问题的一个方法是阅读和学习，但是停留于抽象思考认知的学习的效果往往随着时间推移而减弱至消失，人会再回到固有的模式，而“不变”，正是我对人性的基本认知，要突破“不变”，非常困难，它意味着自我革命，人类历史上能做到的人都是寥寥。</p>
<p>浙江山多，经济作物只有竹子和茶叶，很多菜都和竹笋有关，再加上山区潮湿，所以才会诞生以梅干菜为代表的一系列霉制食物(个人猜测)，而真因为这地方不适合大面积种粮食，使得浙江人通行全国做生意，温州，义乌的商人都很有名（这也是我的猜想，在和一位金华的出租车司机聊天中被认同）。仅从自然环境上而言，这地方并没有成为富庶之地的条件，至少浙东是这样，沿海可能海运和渔业发达，但不管是人文历史还是经济发达程度，这地方都是全国的翘楚，浙商之名古已有之。按理说，这地方在古代只适合躲避战乱，偏偏文人墨客都喜欢扎堆往山里跑，而古刹名寺遍布浙江，有“南朝四百八十寺”之名，而且我发现那些寺庙都喜欢往山里建，依山傍水，按说要吸引信众和生活方便的话建在山脚不是更合理？也是令我费解，可能修行之人都喜欢崇山峻岭处。佛教自印度传入后，在中国几经演化，有八万四千法门之多，清规戒律繁多，如“过午不食”，“不食非食”等等，但是到了现代似乎变成了普通民众的精神寄托，求财求子求升学，新昌大佛寺，天台国清寺，都是游人如织，香火旺盛，热闹归热闹，但总觉得少了一点佛教的清净肃杀，罗汉堂上满登登的钱币也和佛教徒不碰钱的戒律有违。寺庙成了旅游景点，而非修行道场，和尚们开着豪车，也不知道修的哪门子行。</p>
]]></content>
      <categories>
        <category>旅行笔记</category>
      </categories>
  </entry>
  <entry>
    <title>洛阳</title>
    <url>/%E6%97%85%E8%A1%8C%E7%AC%94%E8%AE%B0/%E6%B4%9B%E9%98%B3.html</url>
    <content><![CDATA[<p>洛阳南面洛水，北负邙山，地势平坦，城市主干道笔直宽阔，纵横交错有序，一派中原王气。</p>
<p>之前来过一次河南，对河南的印象就是空气中弥漫着土气，很能让人联想黄河流域粗犷的文化气息。三天时间短暂，也没有太多时间接触当地风土人情，只能走马观花，读书看景。来的路上读了两本书，一本
Lonely Planet
的《洛阳》，一本倪锡英的《洛阳游记》，倪是民国人，他旅游的时间也是民国，一路上跟着他的书边学习边想象。</p>
<p>住在古城区。洛阳的古城区并未翻修，因此和洛阳的新建筑形成鲜明对比，然而街道两侧商铺林立，尤其在晚上，热闹非凡。常见的景区小吃和洛阳本地的水席等交错排列。水席，顾名思义，菜都带着汤。</p>
<p>住的地方离洛河不远，沿着洛河修建了很长的滨河步道，亭台楼阁镶嵌其间。洛河河面宽阔，水流徐缓，临水而望，想象千年前的古人在此生息，悠然怀古。</p>
<p>唯有王城最堪隐。今天的洛阳已经不再是华夏的政治中心，然而底蕴不消，市内博物馆众多，遗迹古物俯拾皆是。我只逛了两个博物馆：洛阳博物馆和二里头博物馆，展览内容浩如烟海，朝代更迭，文化各异，各朝文物琳琅满目，应接不暇，随便一个方向就能让人驻足良久。洛阳是十三朝古都，但是作为整个华夏文明的起点，中国历史发展的每一个节点不可能和洛阳脱开联系，乃至整个世界的文明史，都需要研究洛阳。在一个博物馆里我看到一句话，大意是：未来洛阳考古的研究方向是要和经济学、社会学、物理学等结合起来，如果是以前看到可能忽略，然而随着知识储备的提升，我对这句话深表认同，历史的研究不是孤立的，它和其他学科的联动构成了整个人类文明史，而不单单是看到几个唐三彩或者青铜器那么简单。</p>
<p>当我站在二里头博物馆的文物面前时，我开始思考一个问题：国家是如何诞生的？为什么人类不一直延续原始的生存状态，而要发展出文化、国家和阶级？当我在二里头博物馆看到这样一幅图的时候，我有了答案，这个答案就是：分工。</p>
<figure>
<img src="/images/厥土生民.JPG" alt="厥土生民" />
<figcaption aria-hidden="true">厥土生民</figcaption>
</figure>
<p>分工产生了拥有资源和权力的不平等，负责管理的成为了比负责打猎的更高的阶级，而为了固化这种阶级，使之成为代代相传的明文规定（相当于公司章程协议），就产生了国家。所以说，国家一定会带有阶级属性。那么，下一个问题：为什么会产生分工？我的思考是长期从事某一种工作使得从事者更熟练，效率更高，于是本来十个人干的活八个人就能干，多出来的两个人成为管理层，而多个不同分工群体之间需要协调分配，比如打渔组和打猎组之间的协调。人类为了互助和提升效率选择了聚集而居，聚集带来了分工，分工带了阶级，阶级产生了国家。</p>
<p>龙门石窟名大于实，除了武则天修建的那几座，大多数佛像的头部都被盗毁，石窟题材单薄肤浅，多为祈福祝寿。</p>
<figure>
<img src="/images/龙门石窟.jpg" alt="龙门石窟" />
<figcaption aria-hidden="true">龙门石窟</figcaption>
</figure>
<p>白居易，仕途顺利，名利双收，善终于洛阳。</p>
<p>在白马寺，看到了“晨钟暮鼓”，河洛文化并不闭塞，几千年前已经出现了和其他文化交融的迹象，远至海上、中东，白马寺一脉相承，本是印度佛教传入华夏第一站，现建有缅甸、泰国、印度庙宇，供奉异国佛像。白马寺内设立众多功德箱，僧人在道上笑嘻嘻地手捉游客赠予的金钱，和我去过的大多数寺庙一样，香火旺盛，戒律松弛，纵然顶着华夏第一古刹的名头，也不过是多个捞钱的牌坊，徒留虚名。</p>
]]></content>
      <categories>
        <category>旅行笔记</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode hot 100</title>
    <url>/%E7%AE%97%E6%B3%95/leetcode-hot-100.html</url>
    <content><![CDATA[<h1 id="哈希">哈希</h1>
<h2 id="两数之和">两数之和</h2>
<p>题意： 在数组中找到两个数，使它们的和等于
<code>target</code>，并返回它们的索引。</p>
<p>解题思路：</p>
<ul>
<li>创建一个 <code>HashMap</code> 存储已遍历过的数字及其下标；</li>
<li>对于当前数字 <code>nums[i]</code>，计算
<code>target - nums[i]</code>；</li>
<li>如果这个差值在哈希表中存在，说明之前的某个数与当前数之和等于
<code>target</code>；</li>
<li>立即返回两个下标。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(complement), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong>：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="字母异位词分组">字母异位词分组</h2>
<h3 id="题意">题意：</h3>
<p>给你一个字符串数组 <code>strs</code>，请你将
<strong>字母异位词</strong> 组合在一起。 <strong>字母异位词</strong>
是指两个字符串中的字母相同，但排列顺序不同。
返回所有字母异位词的分组（顺序不限）。</p>
<h3 id="示例">示例：</h3>
<p>输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[[&quot;bat&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure>
<h3 id="解题思路">解题思路：</h3>
<p>核心思想：</p>
<ul>
<li><strong>异位词排序后是相同的字符串</strong>。</li>
<li>因此，可以用一个哈希表（<code>HashMap</code>）来将“排序后的字符串”作为
key，把相同 key 的字符串加入同一个列表中。</li>
</ul>
<p>步骤：</p>
<ol type="1">
<li>创建一个
<code>HashMap&lt;String, List&lt;String&gt;&gt;</code>。</li>
<li>遍历 <code>strs</code> 中的每个字符串：
<ul>
<li>将其字符排序，得到 <code>key</code>；</li>
<li>将原字符串放入该 <code>key</code> 对应的列表中。</li>
</ul></li>
<li>最后返回哈希表中所有的 value 列表。</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">            map.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析：</h3>
<ul>
<li><strong>时间复杂度</strong>：O(n * k log k) 其中 <code>n</code>
是字符串个数，<code>k</code> 是每个字符串的最大长度（排序复杂度为
<code>k log k</code>）。</li>
<li><strong>空间复杂度</strong>：O(n * k)
存储所有字符串以及中间哈希表结构。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法和数据结构</title>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
    <content><![CDATA[<h1 id="知识树">知识树</h1>
<pre><code class="highlight mermaid">graph LR
    A[算法与数据结构]
    
    A --&gt; B[数据结构]
    B --&gt; B1[线性结构]
    B1 --&gt; B1a[数组 Array]
    B1 --&gt; B1b[链表 Linked List]
    B1 --&gt; B1c[栈 Stack]
    B1 --&gt; B1d[队列 Queue]
    
    B --&gt; B2[树结构]
    B2 --&gt; B2a[二叉树 Binary Tree]
    B2 --&gt; B2b[二叉搜索树 BST]
    B2 --&gt; B2c[AVL 树]
    B2 --&gt; B2d[红黑树 Red-Black Tree]
    B2 --&gt; B2e[B 树 B-Tree]
    B2 --&gt; B2f[堆 Heap]
    B2 --&gt; B2g[Trie 前缀树]
    
    B --&gt; B3[图结构]
    B3 --&gt; B3a[有向图 Directed Graph]
    B3 --&gt; B3b[无向图 Undirected Graph]
    B3 --&gt; B3c[加权图 Weighted Graph]
    
    B --&gt; B4[集合结构]
    B4 --&gt; B4a[哈希表 Hash Table]
    B4 --&gt; B4b[集合 Set]
    B4 --&gt; B4c[位图 Bitmap]
    
    B --&gt; B5[其他结构]
    B5 --&gt; B5a[跳表 Skip List]
    B5 --&gt; B5b[并查集 Union-Find]
    B5 --&gt; B5c[线段树 Segment Tree]
    B5 --&gt; B5d[树状数组 Fenwick Tree]
    
    A --&gt; C[算法]
    C --&gt; C1[排序算法]
    C1 --&gt; C1a[冒泡排序 Bubble Sort]
    C1 --&gt; C1b[选择排序 Selection Sort]
    C1 --&gt; C1c[插入排序 Insertion Sort]
    C1 --&gt; C1d[快速排序 Quick Sort]
    C1 --&gt; C1e[归并排序 Merge Sort]
    C1 --&gt; C1f[堆排序 Heap Sort]
    C1 --&gt; C1g[计数排序 Counting Sort]
    
    C --&gt; C2[搜索算法]
    C2 --&gt; C2a[线性搜索 Linear Search]
    C2 --&gt; C2b[二分搜索 Binary Search]
    C2 --&gt; C2c[深度优先搜索 DFS]
    C2 --&gt; C2d[广度优先搜索 BFS]
    
    C --&gt; C3[图算法]
    C3 --&gt; C3a[最短路径 Dijkstra/Bellman-Ford]
    C3 --&gt; C3b[最小生成树 Prim/Kruskal]
    C3 --&gt; C3c[拓扑排序 Topological Sort]
    
    C --&gt; C4[动态规划 DP]
    C4 --&gt; C4a[背包问题 Knapsack]
    C4 --&gt; C4b[最长公共子序列 LCS]
    C4 --&gt; C4c[最长递增子序列 LIS]
    
    C --&gt; C5[贪心算法]
    C5 --&gt; C5a[活动选择 Activity Selection]
    C5 --&gt; C5b[哈夫曼编码 Huffman Coding]
    
    C --&gt; C6[分治算法]
    C6 --&gt; C6a[归并排序 Merge Sort]
    C6 --&gt; C6b[快速排序 Quick Sort]
    
    C --&gt; C7[数学与计算几何]
    C7 --&gt; C7a[最大公约数 GCD]
    C7 --&gt; C7b[快速幂 Fast Power]
    C7 --&gt; C7c[凸包 Convex Hull]
    
    C --&gt; C8[字符串算法]
    C8 --&gt; C8a[KMP 算法]
    C8 --&gt; C8b[Rabin-Karp]
    C8 --&gt; C8c[Manacher]
    
    C --&gt; C9[其他算法]
    C9 --&gt; C9a[随机化算法 Randomized]
    C9 --&gt; C9b[回溯算法 Backtracking]</code></pre>
<h1 id="数据结构">数据结构</h1>
<h2 id="基础数据结构">基础数据结构</h2>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 38%" />
<col style="width: 24%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>数据结构</th>
<th>特点</th>
<th>操作</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>数组 (Array)</strong></td>
<td>连续内存存储，固定大小，元素类型相同</td>
<td>随机访问：O(1)<br>插入/删除：O(n)</td>
<td>快速查找<br>静态数据存储</td>
</tr>
<tr class="even">
<td><strong>链表 (Linked List)</strong></td>
<td>非连续内存，动态大小，节点包含数据和指针<br>类型：单向链表、双向链表、循环链表</td>
<td>插入/删除：O(1)<br>查找：O(n)</td>
<td>频繁增删的场景（如LRU缓存）</td>
</tr>
<tr class="odd">
<td><strong>栈 (Stack)</strong></td>
<td>后进先出（LIFO），仅允许一端操作</td>
<td>入栈（push）：O(1)<br>出栈（pop）：O(1)</td>
<td>函数调用栈<br>括号匹配<br>表达式求值</td>
</tr>
<tr class="even">
<td><strong>队列 (Queue)</strong></td>
<td>先进先出（FIFO），允许两端操作<br>变种：双端队列（Deque）、优先队列（Priority
Queue）</td>
<td>入队/出队：O(1)（普通队列）</td>
<td>任务调度<br>广度优先搜索（BFS）</td>
</tr>
</tbody>
</table>
<h3 id="数组">数组</h3>
<h4 id="线性查找-linear-search">1. 线性查找 (Linear Search)</h4>
<ul>
<li><strong>功能描述</strong>：在数组中逐个检查元素，找到目标值并返回其索引，若不存在返回
-1。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">linearSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="二分查找-binary-search">2. 二分查找 (Binary Search)</h4>
<ul>
<li><strong>功能描述</strong>：在有序数组中通过不断折半查找目标值，返回其索引，若不存在返回
-1。</li>
<li><strong>时间复杂度</strong>：O(log n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="冒泡排序-bubble-sort">3. 冒泡排序 (Bubble Sort)</h4>
<ul>
<li><strong>功能描述</strong>：通过相邻元素两两比较并交换，将较大元素逐步“冒泡”到数组末尾，实现排序。</li>
<li><strong>时间复杂度</strong>：O(n²)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="快速排序-quick-sort">4. 快速排序 (Quick Sort)</h4>
<ul>
<li><strong>功能描述</strong>：选择一个基准值（pivot），将数组分区并递归排序，适用于大多数情况的高效排序算法。</li>
<li><strong>时间复杂度</strong>：O(n log n) 平均，O(n²) 最坏</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pi</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];</span><br><span class="line">    arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">    arr[high] = temp;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数组反转-reverse-array">5. 数组反转 (Reverse Array)</h4>
<ul>
<li><strong>功能描述</strong>：使用双指针从两端向中间交换元素，将数组顺序反转。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="查找最大值-find-maximum">6. 查找最大值 (Find Maximum)</h4>
<ul>
<li><strong>功能描述</strong>：遍历数组，比较每个元素，找出最大值。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Array is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="删除重复元素-remove-duplicates-from-sorted-array">7.
删除重复元素 (Remove Duplicates from Sorted Array)</h4>
<ul>
<li><strong>功能描述</strong>：在有序数组中删除重复元素，返回新长度，原地修改数组。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">writeIndex</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            arr[writeIndex] = arr[i];</span><br><span class="line">            writeIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> writeIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="旋转数组-rotate-array">8. 旋转数组 (Rotate Array)</h4>
<ul>
<li><strong>功能描述</strong>：将数组向右旋转 k
个位置，使用三次反转法实现。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k %= arr.length; <span class="comment">// 处理 k 大于数组长度的情况</span></span><br><span class="line">    reverse(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 反转整个数组</span></span><br><span class="line">    reverse(arr, <span class="number">0</span>, k - <span class="number">1</span>);          <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">    reverse(arr, k, arr.length - <span class="number">1</span>); <span class="comment">// 反转剩余元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="两数之和-two-sum">9. 两数之和 (Two Sum)</h4>
<ul>
<li><strong>功能描述</strong>：找到数组中两个元素的索引，其和等于目标值，使用哈希表优化。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] arr, <span class="type">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - arr[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(complement), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(arr[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;&#125;; <span class="comment">// 未找到返回空数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="归并排序-merge-sort">10. 归并排序 (Merge Sort)</h4>
<ul>
<li><strong>功能描述</strong>：使用分治法将数组分成小块，分别排序后合并，稳定且适用于大数据。</li>
<li><strong>时间复杂度</strong>：O(n log n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> right - mid;</span><br><span class="line">    <span class="type">int</span>[] leftArr = <span class="keyword">new</span> <span class="title class_">int</span>[n1];</span><br><span class="line">    <span class="type">int</span>[] rightArr = <span class="keyword">new</span> <span class="title class_">int</span>[n2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充临时数组</span></span><br><span class="line">    <span class="comment">// 将原数组的左子数组（arr[left..mid]）复制到 leftArr。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">        leftArr[i] = arr[left + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将原数组的右子数组（arr[mid+1..right]）复制到 rightArr。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n2; j++) &#123;</span><br><span class="line">        rightArr[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;</span><br><span class="line">            arr[k++] = leftArr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k++] = rightArr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k++] = leftArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k++] = rightArr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="前缀和-prefix-sum">11. 前缀和 (Prefix Sum)</h4>
<ul>
<li><strong>功能描述</strong>：计算数组的前缀和，用于快速求解子数组和的问题。</li>
<li><strong>时间复杂度</strong>：O(n) 预处理，O(1) 查询</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] prefixSum(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    prefix[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询子数组和 [left, right]</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSum</span><span class="params">(<span class="type">int</span>[] prefix, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix[right];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix[right] - prefix[left - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="滑动窗口最大值-sliding-window-maximum">12. 滑动窗口最大值
(Sliding Window Maximum)</h4>
<ul>
<li><strong>功能描述</strong>：使用双端队列在固定窗口大小 k
内找到每个窗口的最大值。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length - k + <span class="number">1</span>];</span><br><span class="line">    ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); <span class="comment">// 存储索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 移除超出窗口的元素</span></span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt;= i - k) &#123;</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除小于当前元素的值</span></span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; arr[deque.peekLast()] &lt; arr[i]) &#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offerLast(i);</span><br><span class="line">        <span class="comment">// 窗口形成后记录最大值</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            result[i - k + <span class="number">1</span>] = arr[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="合并两个有序数组-merge-two-sorted-arrays">13. 合并两个有序数组
(Merge Two Sorted Arrays)</h4>
<ul>
<li><strong>功能描述</strong>：将两个有序数组合并为一个有序数组，原地修改第一个数组。</li>
<li><strong>时间复杂度</strong>：O(m + n)，其中 m 和 n
是两个数组的长度</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> m - <span class="number">1</span>; <span class="comment">// nums1 的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> n - <span class="number">1</span>; <span class="comment">// nums2 的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> m + n - <span class="number">1</span>; <span class="comment">// 合并后数组的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p2 &gt;= <span class="number">0</span> &amp;&amp; p1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">            nums1[p--] = nums1[p1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[p--] = nums2[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 nums2 还有剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[p--] = nums2[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数组中第-k-大元素-kth-largest-element">14. 数组中第 k 大元素
(Kth Largest Element)</h4>
<ul>
<li><strong>功能描述</strong>：使用快速选择算法（QuickSelect）找到数组中第
k 大的元素。</li>
<li><strong>时间复杂度</strong>：O(n) 平均，O(n²) 最坏</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, arr.length - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">    <span class="keyword">if</span> (k == pivotIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[k];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; pivotIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(arr, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(arr, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数组元素移动零-move-zeroes">15. 数组元素移动零 (Move
Zeroes)</h4>
<ul>
<li><strong>功能描述</strong>：将数组中的所有零移动到末尾，保持非零元素相对顺序。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nonZeroIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将非零元素移到前面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            arr[nonZeroIndex++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充剩余位置为零</span></span><br><span class="line">    <span class="keyword">while</span> (nonZeroIndex &lt; arr.length) &#123;</span><br><span class="line">        arr[nonZeroIndex++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="链表">链表</h3>
<h4 id="单链表">单链表</h4>
<h5 id="定义单链表">1. 定义单链表</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;         <span class="comment">// 数据域</span></span><br><span class="line">    ListNode next;   <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历链表">2. 遍历链表</h5>
<p>原理</p>
<ul>
<li>从头节点开始，沿 <code>next</code> 指针依次访问每个节点，直到遇到
<code>null</code>。</li>
<li>用于统计长度、查找节点或打印链表。</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(curr.val + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        ListNode.printList(head); <span class="comment">// 输出: 1 -&gt; 2 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)，n 是链表长度。</li>
<li><strong>空间复杂度</strong>: O(1)，只用一个指针。</li>
</ul>
<hr />
<h5 id="反转链表">3. 反转链表</h5>
<p>原理</p>
<ul>
<li>使用三个指针（<code>prev</code>、<code>curr</code>、<code>next</code>）迭代反转每个节点的
<code>next</code> 指针。</li>
<li>核心思想：逐步调整指针方向，原地完成反转。</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;  <span class="comment">// 保存下一个节点</span></span><br><span class="line">            curr.next = prev;           <span class="comment">// 反转指针</span></span><br><span class="line">            prev = curr;                <span class="comment">// 前移 prev</span></span><br><span class="line">            curr = next;                <span class="comment">// 前移 curr</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;                    <span class="comment">// 新头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reversed</span> <span class="operator">=</span> reverseList(head);</span><br><span class="line">        ListNode.printList(reversed); <span class="comment">// 输出: 3 -&gt; 2 -&gt; 1 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)，一次遍历。</li>
<li><strong>空间复杂度</strong>: O(1)，原地操作。</li>
</ul>
<hr />
<h5 id="反转链表指定区间">4. 反转链表指定区间</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; left; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> start.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">        start.next = curr.next;</span><br><span class="line">        curr.next = pre.next;</span><br><span class="line">        pre.next =curr;</span><br><span class="line">        curr = start.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)，一次遍历。</li>
<li><strong>空间复杂度</strong>: O(1)，原地操作。</li>
</ul>
<hr />
<h5 id="合并两个有序链表">5. 合并两个有序链表</h5>
<p>原理</p>
<ul>
<li>类似归并排序的合并过程，比较两个链表的节点值，逐步构建新链表。</li>
<li>使用哑节点（dummy node）简化边界处理。</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 哑节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理剩余节点</span></span><br><span class="line">        curr.next = (l1 != <span class="literal">null</span>) ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        l1.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        l1.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        l2.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        l2.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> mergeTwoLists(l1, l2);</span><br><span class="line">        ListNode.printList(merged); <span class="comment">// 输出: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n + m)，n 和 m 是两个链表长度。</li>
<li><strong>空间复杂度</strong>: O(1)，仅用哑节点，不计输出空间。</li>
</ul>
<hr />
<h5 id="检测链表中的环">6. 检测链表中的环</h5>
<p>原理</p>
<ul>
<li>使用<strong>快慢指针法</strong>（Floyd 判圈算法）：
<ul>
<li>慢指针每次走 1 步，快指针每次走 2 步。</li>
<li>若有环，快慢指针会在环内相遇；若无环，快指针先到
<code>null</code>。</li>
</ul></li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;         <span class="comment">// 慢指针走 1 步</span></span><br><span class="line">            fast = fast.next.next;    <span class="comment">// 快指针走 2 步</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 相遇说明有环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = head.next; <span class="comment">// 创建环: 1 -&gt; 2 -&gt; 3 -&gt; 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hasCycle(head)); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)，快指针最多跑完环的长度。</li>
<li><strong>空间复杂度</strong>: O(1)，只用两个指针。</li>
</ul>
<hr />
<h5 id="删除链表中的节点">7. 删除链表中的节点</h5>
<p>原理</p>
<ul>
<li><strong>普通删除</strong>:
找到目标节点的前驱，调整指针跳过目标。</li>
<li><strong>特殊情况</strong>:
如果只给定要删除的节点（无前驱引用），将其值替换为下个节点的值，再删除下个节点。</li>
</ul>
<p>代码</p>
<p>删除指定值的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 哑节点处理头节点删除</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next; <span class="comment">// 跳过目标节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> deleteNode(head, <span class="number">2</span>);</span><br><span class="line">        ListNode.printList(result); <span class="comment">// 输出: 1 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只给定节点删除（无前驱）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设 node 是要删除的节点，且不是尾节点</span></span><br><span class="line">        node.val = node.next.val;    <span class="comment">// 复制下个节点的值</span></span><br><span class="line">        node.next = node.next.next;  <span class="comment">// 跳过下个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeToDelete</span> <span class="operator">=</span> head.next; <span class="comment">// 删除 2</span></span><br><span class="line"></span><br><span class="line">        deleteNode(nodeToDelete);</span><br><span class="line">        ListNode.printList(head); <span class="comment">// 输出: 1 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>普通删除</strong>: O(n) 时间，O(1) 空间。</li>
<li><strong>给定节点删除</strong>: O(1) 时间，O(1) 空间。</li>
</ul>
<hr />
<h5 id="查找中间节点">8. 查找中间节点</h5>
<p>原理</p>
<ul>
<li>使用快慢指针：快指针走 2 步，慢指针走 1
步，快指针到尾时，慢指针在中间。</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">middle</span> <span class="operator">=</span> middleNode(head);</span><br><span class="line">        System.out.println(middle.val); <span class="comment">// 输出: 3 (偶数长度取后半中间)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)。</li>
<li><strong>空间复杂度</strong>: O(1)。</li>
</ul>
<h4 id="双链表">双链表</h4>
<h5 id="双链表节点定义">1. 双链表节点定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    DoublyListNode prev;</span><br><span class="line">    DoublyListNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双链表基本类">2. 双链表基本类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DoublyListNode head;</span><br><span class="line">    <span class="keyword">private</span> DoublyListNode tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> DoublyListNode <span class="title function_">getHead</span><span class="params">()</span> &#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">    <span class="keyword">public</span> DoublyListNode <span class="title function_">getTail</span><span class="params">()</span> &#123; <span class="keyword">return</span> tail; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(DoublyListNode head)</span> &#123; <span class="built_in">this</span>.head = head; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTail</span><span class="params">(DoublyListNode tail)</span> &#123; <span class="built_in">this</span>.tail = tail; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在头部添加节点">3. 在头部添加节点</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(DoublyLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (list.getHead() == <span class="literal">null</span>) &#123;</span><br><span class="line">        list.setHead(newNode);</span><br><span class="line">        list.setTail(newNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode.next = list.getHead();</span><br><span class="line">        list.getHead().prev = newNode;</span><br><span class="line">        list.setHead(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在尾部添加节点">4. 在尾部添加节点</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(DoublyLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) &#123;</span><br><span class="line">        list.setHead(newNode);</span><br><span class="line">        list.setTail(newNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode.prev = list.getTail();</span><br><span class="line">        list.getTail().next = newNode;</span><br><span class="line">        list.setTail(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除指定值的第一个节点">5. 删除指定值的第一个节点</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(DoublyLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.val == val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current == list.getHead()) &#123;</span><br><span class="line">                list.setHead(list.getHead().next);</span><br><span class="line">                <span class="keyword">if</span> (list.getHead() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    list.getHead().prev = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.setTail(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == list.getTail()) &#123;</span><br><span class="line">                list.setTail(list.getTail().prev);</span><br><span class="line">                list.getTail().next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                current.prev.next = current.next;</span><br><span class="line">                current.next.prev = current.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="打印链表">6. 打印链表</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(DoublyLinkedList list)</span> &#123;</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.print(current.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="反转双链表">7. 反转双链表</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(DoublyLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getHead() == <span class="literal">null</span> || list.getHead().next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        temp = current.prev;</span><br><span class="line">        current.prev = current.next;</span><br><span class="line">        current.next = temp;</span><br><span class="line">        current = current.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    temp = list.getHead();</span><br><span class="line">    list.setHead(list.getTail());</span><br><span class="line">    list.setTail(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找中间节点-1">8. 查找中间节点</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> DoublyListNode <span class="title function_">findMiddle</span><span class="params">(DoublyLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getHead() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">slow</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">fast</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检测循环">9. 检测循环</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(DoublyLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getHead() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">slow</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">fast</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="合并两个有序双链表">10. 合并两个有序双链表</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n + m), 空间复杂度: O(n + m)</span></span><br><span class="line"><span class="keyword">public</span> DoublyLinkedList <span class="title function_">mergeSortedLists</span><span class="params">(DoublyLinkedList list1, DoublyLinkedList list2)</span> &#123;</span><br><span class="line">    <span class="type">DoublyLinkedList</span> <span class="variable">merged</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">p1</span> <span class="operator">=</span> list1.getHead();</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">p2</span> <span class="operator">=</span> list2.getHead();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt;= p2.val) &#123;</span><br><span class="line">            addLast(merged, p1.val);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addLast(merged, p2.val);</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        addLast(merged, p1.val);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        addLast(merged, p2.val);</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用示例">11. 使用示例</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DoublyLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line">    </span><br><span class="line">    addLast(list, <span class="number">1</span>);</span><br><span class="line">    addLast(list, <span class="number">2</span>);</span><br><span class="line">    addLast(list, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Original list:&quot;</span>);</span><br><span class="line">    printList(list);  <span class="comment">// 输出: 1 2 3</span></span><br><span class="line">    </span><br><span class="line">    reverse(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;Reversed list:&quot;</span>);</span><br><span class="line">    printList(list);  <span class="comment">// 输出: 3 2 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">middle</span> <span class="operator">=</span> findMiddle(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;Middle node value: &quot;</span> + middle.val);  <span class="comment">// 输出: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单向循环链表">单向循环链表</h4>
<ul>
<li>循环链表的特点是尾节点的 next 指向头节点，形成闭环。</li>
<li>这些算法适用于单向循环链表，操作时需要特别注意循环的维护。</li>
<li>分割算法假设链表长度为偶数时分成相等两半，奇数时第一部分少一个节点。</li>
</ul>
<h5 id="循环链表节点定义">1. 循环链表节点定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircularListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    CircularListNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircularListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="循环链表基本类">2. 循环链表基本类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircularLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CircularListNode tail;  <span class="comment">// 指向最后一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircularLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> CircularListNode <span class="title function_">getTail</span><span class="params">()</span> &#123; <span class="keyword">return</span> tail; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTail</span><span class="params">(CircularListNode tail)</span> &#123; <span class="built_in">this</span>.tail = tail; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在尾部添加节点-1">3. 在尾部添加节点</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(CircularLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) &#123;</span><br><span class="line">        list.setTail(newNode);</span><br><span class="line">        newNode.next = newNode;  <span class="comment">// 指向自己形成循环</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode.next = list.getTail().next;  <span class="comment">// 新节点指向头节点</span></span><br><span class="line">        list.getTail().next = newNode;       <span class="comment">// 原尾节点指向新节点</span></span><br><span class="line">        list.setTail(newNode);              <span class="comment">// 更新尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在头部添加节点-1">4. 在头部添加节点</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(CircularLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) &#123;</span><br><span class="line">        list.setTail(newNode);</span><br><span class="line">        newNode.next = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode.next = list.getTail().next;  <span class="comment">// 新节点指向原头节点</span></span><br><span class="line">        list.getTail().next = newNode;       <span class="comment">// 尾节点指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除指定值的第一个节点-1">5. 删除指定值的第一个节点</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(CircularLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getTail().next;  <span class="comment">// 从头开始</span></span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">prev</span> <span class="operator">=</span> list.getTail();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.val == val) &#123;</span><br><span class="line">            <span class="comment">// 只有一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (current == list.getTail() &amp;&amp; current.next == current) &#123;</span><br><span class="line">                list.setTail(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == list.getTail().next) &#123;</span><br><span class="line">                list.getTail().next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == list.getTail()) &#123;</span><br><span class="line">                prev.next = list.getTail().next;</span><br><span class="line">                list.setTail(prev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除中间节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != list.getTail().next);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="打印循环链表">6. 打印循环链表</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(CircularLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;List is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        System.out.print(current.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != list.getTail().next);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检测循环验证是否正确形成循环链表">7.
检测循环（验证是否正确形成循环链表）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCircular</span><span class="params">(CircularLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 空链表认为是循环的</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">slow</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">fast</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 快慢指针相遇说明有环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 理论上循环链表总是返回true，除非链表损坏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找链表长度">8. 查找链表长度</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(CircularLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        length++;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != list.getTail().next);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分割循环链表为两个循环链表">9. 分割循环链表为两个循环链表</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 将链表分成两半，前半部分和后半部分分别形成新的循环链表</span></span><br><span class="line"><span class="keyword">public</span> CircularLinkedList[] splitList(CircularLinkedList list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span> || list.getTail().next == list.getTail()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>[]&#123;list, <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">slow</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">fast</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">prev</span> <span class="operator">=</span> list.getTail();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到中间节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != list.getTail().next || fast.next != list.getTail().next) &#123;</span><br><span class="line">        prev = slow;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分割</span></span><br><span class="line">    <span class="type">CircularLinkedList</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>();</span><br><span class="line">    <span class="type">CircularLinkedList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>();</span><br><span class="line">    </span><br><span class="line">    list1.setTail(prev);</span><br><span class="line">    list2.setTail(list.getTail());</span><br><span class="line">    </span><br><span class="line">    prev.next = list.getTail().next;  <span class="comment">// 第一部分形成循环</span></span><br><span class="line">    list2.getTail().next = slow;      <span class="comment">// 第二部分形成循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>[]&#123;list1, list2&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用示例-1">使用示例</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CircularLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>();</span><br><span class="line">    </span><br><span class="line">    addLast(list, <span class="number">1</span>);</span><br><span class="line">    addLast(list, <span class="number">2</span>);</span><br><span class="line">    addLast(list, <span class="number">3</span>);</span><br><span class="line">    addLast(list, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Original list:&quot;</span>);</span><br><span class="line">    printList(list);  <span class="comment">// 输出: 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Length: &quot;</span> + getLength(list));  <span class="comment">// 输出: 4</span></span><br><span class="line">    </span><br><span class="line">    remove(list, <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After removing 2:&quot;</span>);</span><br><span class="line">    printList(list);  <span class="comment">// 输出: 1 3 4</span></span><br><span class="line">    </span><br><span class="line">    CircularLinkedList[] splitLists = splitList(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;First half:&quot;</span>);</span><br><span class="line">    printList(splitLists[<span class="number">0</span>]);  <span class="comment">// 输出: 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Second half:&quot;</span>);</span><br><span class="line">    printList(splitLists[<span class="number">1</span>]);  <span class="comment">// 输出: 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈">栈</h3>
<p>栈是一种后进先出（LIFO）的数据结构</p>
<ul>
<li><strong>数组实现</strong>：适合固定大小的场景，空间利用率高但不灵活。</li>
<li><strong>链表实现</strong>：动态大小，无需预定义容量，适合不确定大小的场景。</li>
</ul>
<hr />
<h4 id="基于数组的栈实现">1. 基于数组的栈实现</h4>
<h5 id="栈的基本类数组实现">栈的基本类（数组实现）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;  <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        capacity = size;</span><br><span class="line">        top = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="入栈push">1.1 入栈（push）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ArrayStack stack, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.top == stack.capacity - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.arr[++stack.top] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="出栈pop">1.2 出栈（pop）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">(ArrayStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.top == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.arr[stack.top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查看栈顶元素peek">1.3 查看栈顶元素（peek）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">(ArrayStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.top == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.arr[stack.top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断栈是否为空">1.4 判断栈是否为空</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(ArrayStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断栈是否已满">1.5 判断栈是否已满</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">(ArrayStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.top == stack.capacity - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="基于链表的栈实现">2. 基于链表的栈实现</h4>
<h5 id="栈节点定义">栈节点定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    StackNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="栈的基本类链表实现">栈的基本类（链表实现）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StackNode top;  <span class="comment">// 栈顶指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedStack</span><span class="params">()</span> &#123;</span><br><span class="line">        top = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> StackNode <span class="title function_">getTop</span><span class="params">()</span> &#123; <span class="keyword">return</span> top; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTop</span><span class="params">(StackNode top)</span> &#123; <span class="built_in">this</span>.top = top; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="入栈push-1">2.1 入栈（push）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(LinkedStack stack, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">StackNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackNode</span>(val);</span><br><span class="line">    newNode.next = stack.getTop();</span><br><span class="line">    stack.setTop(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="出栈pop-1">2.2 出栈（pop）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.getTop() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> stack.getTop().val;</span><br><span class="line">    stack.setTop(stack.getTop().next);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查看栈顶元素peek-1">2.3 查看栈顶元素（peek）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">(LinkedStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.getTop() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.getTop().val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断栈是否为空-1">2.4 判断栈是否为空</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(LinkedStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.getTop() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="栈的常用算法">3. 栈的常用算法</h4>
<h5 id="反转栈">3.1 反转栈</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(n)</span></span><br><span class="line"><span class="comment">// 使用辅助栈反转原栈</span></span><br><span class="line"><span class="keyword">public</span> LinkedStack <span class="title function_">reverseStack</span><span class="params">(LinkedStack stack)</span> &#123;</span><br><span class="line">    <span class="type">LinkedStack</span> <span class="variable">reversed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(stack)) &#123;</span><br><span class="line">        push(reversed, pop(stack));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reversed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检查括号匹配">3.2 检查括号匹配</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(n)</span></span><br><span class="line"><span class="comment">// 检查字符串中的括号是否匹配</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">LinkedStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            push(stack, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span> || c == <span class="string">&#x27;&#125;&#x27;</span> || c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(stack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> pop(stack);</span><br><span class="line">            <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>) ||</span><br><span class="line">                (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEmpty(stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计算后缀表达式逆波兰表达式">3.3
计算后缀表达式（逆波兰表达式）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(n)</span></span><br><span class="line"><span class="comment">// 计算后缀表达式的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evaluatePostfix</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    <span class="type">LinkedStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (token.matches(<span class="string">&quot;-?\\d+&quot;</span>)) &#123;  <span class="comment">// 是数字</span></span><br><span class="line">            push(stack, Integer.parseInt(token));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 是运算符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> pop(stack);</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> pop(stack);</span><br><span class="line">            <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>: push(stack, a + b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>: push(stack, a - b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>: push(stack, a * b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>: push(stack, a / b); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pop(stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最小栈获取栈中最小元素">3.4 最小栈（获取栈中最小元素）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持在 O(1) 时间获取最小元素的栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedStack mainStack;</span><br><span class="line">    <span class="keyword">private</span> LinkedStack minStack;  <span class="comment">// 辅助栈存储最小值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        mainStack = <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        push(mainStack, val);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(minStack) || val &lt;= peek(minStack)) &#123;</span><br><span class="line">            push(minStack, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> pop(mainStack);</span><br><span class="line">        <span class="keyword">if</span> (val == peek(minStack)) &#123;</span><br><span class="line">            pop(minStack);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(minStack)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> peek(minStack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="使用示例-2">使用示例</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组栈示例</span></span><br><span class="line">    <span class="type">ArrayStack</span> <span class="variable">arrayStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">5</span>);</span><br><span class="line">    push(arrayStack, <span class="number">1</span>);</span><br><span class="line">    push(arrayStack, <span class="number">2</span>);</span><br><span class="line">    push(arrayStack, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Array Stack top: &quot;</span> + peek(arrayStack));  <span class="comment">// 输出: 3</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Popped: &quot;</span> + pop(arrayStack));           <span class="comment">// 输出: 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表栈示例</span></span><br><span class="line">    <span class="type">LinkedStack</span> <span class="variable">linkedStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">    push(linkedStack, <span class="number">1</span>);</span><br><span class="line">    push(linkedStack, <span class="number">2</span>);</span><br><span class="line">    push(linkedStack, <span class="number">3</span>);</span><br><span class="line">    <span class="type">LinkedStack</span> <span class="variable">reversed</span> <span class="operator">=</span> reverseStack(linkedStack);</span><br><span class="line">    System.out.println(<span class="string">&quot;Reversed Stack top: &quot;</span> + peek(reversed));  <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 括号匹配</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;[()]&#125;&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;Parentheses valid: &quot;</span> + isValidParentheses(s));  <span class="comment">// 输出: true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后缀表达式</span></span><br><span class="line">    String[] postfix = &#123;<span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;+&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;*&quot;</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;Postfix result: &quot;</span> + evaluatePostfix(postfix));  <span class="comment">// 输出: 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最小栈</span></span><br><span class="line">    <span class="type">MinStack</span> <span class="variable">minStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinStack</span>();</span><br><span class="line">    minStack.push(<span class="number">3</span>);</span><br><span class="line">    minStack.push(<span class="number">5</span>);</span><br><span class="line">    minStack.push(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Min value: &quot;</span> + minStack.getMin());  <span class="comment">// 输出: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列">队列</h3>
<p>队列是一种先进先出（FIFO）的数据结构</p>
<ul>
<li><strong>数组队列</strong>：简单实现，但空间利用率低，出队后空间不可复用。</li>
<li><strong>链表队列</strong>：动态大小，适合不确定长度的场景。</li>
<li><strong>循环队列</strong>：优化数组队列，复用空间，适合固定大小场景。</li>
<li><strong>双端队列</strong>：支持两端操作，灵活性更高。</li>
<li><strong>优先队列</strong>：基于最小堆实现，保证每次出队的是最小元素。</li>
</ul>
<hr />
<h4 id="基于数组的队列实现">1. 基于数组的队列实现</h4>
<h5 id="队列的基本类数组实现">队列的基本类（数组实现）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;  <span class="comment">// 队首指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;   <span class="comment">// 队尾指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        capacity = size;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="入队enqueue">1.1 入队（enqueue）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(ArrayQueue queue, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.rear == queue.capacity - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    queue.arr[++queue.rear] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="出队dequeue">1.2 出队（dequeue）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(ArrayQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.front &gt; queue.rear) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.arr[queue.front++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查看队首元素peek">1.3 查看队首元素（peek）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">(ArrayQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.front &gt; queue.rear) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.arr[queue.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断队列是否为空">1.4 判断队列是否为空</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(ArrayQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.front &gt; queue.rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断队列是否已满">1.5 判断队列是否已满</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">(ArrayQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.rear == queue.capacity - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="基于链表的队列实现">2. 基于链表的队列实现</h4>
<h5 id="队列节点定义">队列节点定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QueueNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    QueueNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueueNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="队列的基本类链表实现">队列的基本类（链表实现）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> QueueNode front;  <span class="comment">// 队首指针</span></span><br><span class="line">    <span class="keyword">private</span> QueueNode rear;   <span class="comment">// 队尾指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        front = <span class="literal">null</span>;</span><br><span class="line">        rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> QueueNode <span class="title function_">getFront</span><span class="params">()</span> &#123; <span class="keyword">return</span> front; &#125;</span><br><span class="line">    <span class="keyword">public</span> QueueNode <span class="title function_">getRear</span><span class="params">()</span> &#123; <span class="keyword">return</span> rear; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFront</span><span class="params">(QueueNode front)</span> &#123; <span class="built_in">this</span>.front = front; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRear</span><span class="params">(QueueNode rear)</span> &#123; <span class="built_in">this</span>.rear = rear; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="入队enqueue-1">2.1 入队（enqueue）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(LinkedQueue queue, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">QueueNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueueNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (queue.getRear() == <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.setFront(newNode);</span><br><span class="line">        queue.setRear(newNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue.getRear().next = newNode;</span><br><span class="line">        queue.setRear(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="出队dequeue-1">2.2 出队（dequeue）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(LinkedQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.getFront() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> queue.getFront().val;</span><br><span class="line">    queue.setFront(queue.getFront().next);</span><br><span class="line">    <span class="keyword">if</span> (queue.getFront() == <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.setRear(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查看队首元素peek-1">2.3 查看队首元素（peek）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">(LinkedQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.getFront() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.getFront().val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断队列是否为空-1">2.4 判断队列是否为空</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(LinkedQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.getFront() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="队列的常用算法">3. 队列的常用算法</h4>
<h5 id="循环队列基于数组优化">3.1 循环队列（基于数组优化）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircularQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        capacity = size;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear + <span class="number">1</span>) % capacity == front) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = val;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双端队列deque">3.2 双端队列（Deque）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> QueueNode front;</span><br><span class="line">    <span class="keyword">private</span> QueueNode rear;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Deque</span><span class="params">()</span> &#123;</span><br><span class="line">        front = <span class="literal">null</span>;</span><br><span class="line">        rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFront</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">QueueNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueueNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>) &#123;</span><br><span class="line">            front = rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.next = front;</span><br><span class="line">            front = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addRear</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">QueueNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueueNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (rear == <span class="literal">null</span>) &#123;</span><br><span class="line">            front = rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rear.next = newNode;</span><br><span class="line">            rear = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> front.val;</span><br><span class="line">        front = front.next;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>) rear = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeRear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rear == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> rear.val;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            front = rear = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">QueueNode</span> <span class="variable">current</span> <span class="operator">=</span> front;</span><br><span class="line">            <span class="keyword">while</span> (current.next != rear) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            rear = current;</span><br><span class="line">            rear.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="优先队列最小堆实现">3.3 优先队列（最小堆实现）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Priority Queue is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[size] = val;</span><br><span class="line">        heapifyUp(size);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Priority Queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[--size];</span><br><span class="line">        heapifyDown(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapifyUp</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[parent] &gt; arr[index]) &#123;</span><br><span class="line">                swap(arr, parent, index);</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapifyDown</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> index;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; size &amp;&amp; arr[left] &lt; arr[smallest]) smallest = left;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp; arr[right] &lt; arr[smallest]) smallest = right;</span><br><span class="line">            <span class="keyword">if</span> (smallest == index) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, index, smallest);</span><br><span class="line">            index = smallest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="使用示例-3">使用示例</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组队列</span></span><br><span class="line">    <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">5</span>);</span><br><span class="line">    enqueue(arrayQueue, <span class="number">1</span>);</span><br><span class="line">    enqueue(arrayQueue, <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Array Queue front: &quot;</span> + peek(arrayQueue));  <span class="comment">// 输出: 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Dequeued: &quot;</span> + dequeue(arrayQueue));       <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表队列</span></span><br><span class="line">    <span class="type">LinkedQueue</span> <span class="variable">linkedQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedQueue</span>();</span><br><span class="line">    enqueue(linkedQueue, <span class="number">1</span>);</span><br><span class="line">    enqueue(linkedQueue, <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Linked Queue front: &quot;</span> + peek(linkedQueue));  <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环队列</span></span><br><span class="line">    <span class="type">CircularQueue</span> <span class="variable">circularQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularQueue</span>(<span class="number">3</span>);</span><br><span class="line">    circularQueue.enqueue(<span class="number">1</span>);</span><br><span class="line">    circularQueue.enqueue(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Circular Queue dequeued: &quot;</span> + circularQueue.dequeue());  <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双端队列</span></span><br><span class="line">    <span class="type">Deque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Deque</span>();</span><br><span class="line">    deque.addFront(<span class="number">1</span>);</span><br><span class="line">    deque.addRear(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Deque front: &quot;</span> + deque.removeFront());  <span class="comment">// 输出: 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Deque rear: &quot;</span> + deque.removeRear());    <span class="comment">// 输出: 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优先队列</span></span><br><span class="line">    <span class="type">PriorityQueue</span> <span class="variable">pq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">5</span>);</span><br><span class="line">    pq.enqueue(<span class="number">3</span>);</span><br><span class="line">    pq.enqueue(<span class="number">1</span>);</span><br><span class="line">    pq.enqueue(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Priority Queue min: &quot;</span> + pq.dequeue());  <span class="comment">// 输出: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树形结构">树形结构</h2>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 16%" />
<col style="width: 27%" />
<col style="width: 27%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th>数据结构</th>
<th>特点</th>
<th>变种/类型</th>
<th>操作</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>二叉树 (Binary Tree)</strong></td>
<td>每个节点最多两个子节点</td>
<td>- <strong>二叉搜索树 (BST)</strong>：左子树值 &lt; 根 &lt;
右子树值<br>- <strong>平衡二叉树
(AVL树/红黑树)</strong>：自动平衡高度</td>
<td>查找/插入（BST平均O(log n)，平衡树O(log n)）</td>
<td>快速查找<br>排序</td>
</tr>
<tr class="even">
<td><strong>堆 (Heap)</strong></td>
<td>完全二叉树，父节点与子节点有大小关系</td>
<td>- <strong>最大堆</strong>：父节点≥子节点<br>-
<strong>最小堆</strong>：父节点≤子节点</td>
<td>插入：O(log n)<br>取最值：O(1)</td>
<td>优先队列<br>堆排序</td>
</tr>
<tr class="odd">
<td><strong>多叉树</strong></td>
<td>支持多个子节点的树结构</td>
<td>- <strong>B树/B+树</strong>：多路平衡树，减少磁盘I/O<br>-
<strong>字典树 (Trie)</strong>：前缀树，存储字符串集合</td>
<td>依赖具体类型（如B树查找O(log
n)，Trie前缀查询O(m)，m为字符串长度）</td>
<td>B树/B+树：数据库索引<br>Trie：自动补全</td>
</tr>
</tbody>
</table>
<h3 id="二叉树">二叉树</h3>
<h4 id="普通二叉树">普通二叉树</h4>
<h5 id="二叉树节点定义">二叉树节点定义</h5>
<p>所有算法基于以下二叉树节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="前序遍历-preorder-traversal">1. 前序遍历 (Preorder
Traversal)</h5>
<ul>
<li><strong>功能描述</strong>：按照“根-左-右”的顺序递归遍历二叉树。</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是节点数</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">    preorderTraversal(root.left);     <span class="comment">// 遍历左子树</span></span><br><span class="line">    preorderTraversal(root.right);    <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历-inorder-traversal">2. 中序遍历 (Inorder Traversal)</h5>
<ul>
<li><strong>功能描述</strong>：按照“左-根-右”的顺序递归遍历二叉树，对于二叉搜索树（BST）会输出有序序列。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderTraversal(root.left);      <span class="comment">// 遍历左子树</span></span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">    inorderTraversal(root.right);     <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历-postorder-traversal">3. 后序遍历 (Postorder
Traversal)</h5>
<ul>
<li><strong>功能描述</strong>：按照“左-右-根”的顺序递归遍历二叉树，常用于释放节点内存。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorderTraversal(root.left);    <span class="comment">// 遍历左子树</span></span><br><span class="line">    postorderTraversal(root.right);   <span class="comment">// 遍历右子树</span></span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层序遍历-level-order-traversal">4. 层序遍历 (Level Order
Traversal)</h5>
<ul>
<li><strong>功能描述</strong>：使用队列按层从上到下、从左到右遍历二叉树。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计算二叉树深度-maximum-depth">5. 计算二叉树深度 (Maximum
Depth)</h5>
<ul>
<li><strong>功能描述</strong>：递归计算二叉树的最大深度（根到最远叶节点的路径长度）。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断是否平衡二叉树-check-balanced-binary-tree">6.
判断是否平衡二叉树 (Check Balanced Binary Tree)</h5>
<ul>
<li><strong>功能描述</strong>：检查二叉树是否平衡，即任意节点的左右子树高度差不超过
1。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> height(root.left);</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 左子树不平衡</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> height(root.right);</span><br><span class="line">    <span class="keyword">if</span> (rightHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 右子树不平衡</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 当前节点不平衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树路径总和-path-sum">7. 二叉树路径总和 (Path Sum)</h5>
<ul>
<li><strong>功能描述</strong>：判断是否存在从根到叶节点的路径，其节点值之和等于目标值。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123; <span class="comment">// 叶节点</span></span><br><span class="line">        <span class="keyword">return</span> targetSum == root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || </span><br><span class="line">           hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="反转二叉树-invert-binary-tree">8. 反转二叉树 (Invert Binary
Tree)</h5>
<ul>
<li><strong>功能描述</strong>：将二叉树的左右子树交换，递归反转整棵树。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉搜索树验证-validate-binary-search-tree">9. 二叉搜索树验证
(Validate Binary Search Tree)</h5>
<ul>
<li><strong>功能描述</strong>：验证二叉树是否为二叉搜索树（BST），即左子树值
&lt; 根 &lt; 右子树值。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= min || root.val &gt;= max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root.val) &amp;&amp; </span><br><span class="line">           isValidBST(root.right, root.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最低公共祖先-lowest-common-ancestor">10. 最低公共祖先 (Lowest
Common Ancestor)</h5>
<ul>
<li><strong>功能描述</strong>：在二叉树中找到两个节点的最低公共祖先（LCA）。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// p 和 q 分居两侧，root 是 LCA</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right; <span class="comment">// p 和 q 在同一侧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="前序遍历非递归preorder-traversal---iterative">11.
前序遍历（非递归）(Preorder Traversal - Iterative)</h5>
<ul>
<li><strong>功能描述</strong>：使用栈模拟递归，按照“根-左-右”的顺序遍历二叉树。</li>
<li><strong>时间复杂度</strong>：O(n)，空间复杂度 O(h)，h 为树高</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;         <span class="comment">// 先压右子树（后访问）</span></span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;          <span class="comment">// 后压左子树（先访问）</span></span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历非递归inorder-traversal---iterative">12.
中序遍历（非递归）(Inorder Traversal - Iterative)</h5>
<ul>
<li><strong>功能描述</strong>：使用栈模拟递归，按照“左-根-右”的顺序遍历二叉树，先将左子树压栈到底。</li>
<li><strong>时间复杂度</strong>：O(n)，空间复杂度 O(h)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 压入所有左子节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        System.out.print(current.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">        current = current.right;             <span class="comment">// 处理右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历非递归postorder-traversal---iterative">13.
后序遍历（非递归）(Postorder Traversal - Iterative)</h5>
<ul>
<li><strong>功能描述</strong>：使用栈模拟递归，按照“左-右-根”的顺序遍历二叉树，需记录上一次访问的节点以区分回溯路径。</li>
<li><strong>时间复杂度</strong>：O(n)，空间复杂度 O(h)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">lastVisited</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 压入所有左子节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">peekNode</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="comment">// 如果没有右子树或右子树已访问，访问当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (peekNode.right == <span class="literal">null</span> || peekNode.right == lastVisited) &#123;</span><br><span class="line">            System.out.print(peekNode.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            lastVisited = stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = peekNode.right; <span class="comment">// 处理右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层序遍历非递归level-order-traversal---iterative">14.
层序遍历（非递归）(Level Order Traversal - Iterative)</h5>
<ul>
<li><strong>功能描述</strong>：使用队列按层从上到下、从左到右遍历二叉树（已在之前提供，这里重复列出以保持完整性）。</li>
<li><strong>时间复杂度</strong>：O(n)，空间复杂度 O(w)，w
为树的最大宽度</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树-binary-search-tree-bst">二叉搜索树 (Binary Search
Tree, BST)</h4>
<ul>
<li><strong>定义</strong>: 左子树所有节点值 &lt; 根节点值 &lt;
右子树所有节点值。</li>
<li><strong>特性</strong>:
支持高效的查找、插入和删除，但可能退化为链表。</li>
<li><strong>应用场景</strong>:
<ul>
<li>数据库索引</li>
<li>动态集合管理</li>
<li>符号表</li>
</ul></li>
</ul>
<h5 id="结构图">结构图</h5>
<pre><code class="highlight mermaid">graph TD
    A[10] --&gt; B[5]
    A --&gt; C[15]
    B --&gt; D[3]
    B --&gt; E[7]
    C --&gt; F[13]</code></pre>
<hr />
<h5 id="二叉搜索树节点定义">1. 二叉搜索树节点定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    BSTNode left;</span><br><span class="line">    BSTNode right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉搜索树基本类">2. 二叉搜索树基本类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BSTNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinarySearchTree</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> BSTNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(BSTNode root)</span> &#123; <span class="built_in">this</span>.root = root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="二叉搜索树常用算法">3. 二叉搜索树常用算法</h5>
<h6 id="插入节点">3.1 插入节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(h) 其中 h 是树高，平均 O(log n)，最坏 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(BinarySearchTree bst, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    bst.setRoot(insertRec(bst.getRoot(), val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BSTNode <span class="title function_">insertRec</span><span class="params">(BSTNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BSTNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = insertRec(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = insertRec(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除节点">3.2 删除节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(h) 其中 h 是树高，平均 O(log n)，最坏 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(BinarySearchTree bst, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    bst.setRoot(deleteRec(bst.getRoot(), val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BSTNode <span class="title function_">deleteRec</span><span class="params">(BSTNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = deleteRec(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = deleteRec(root.right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 节点找到，处理删除</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 有两个子节点，找到右子树最小值替换</span></span><br><span class="line">        root.val = findMin(root.right).val;</span><br><span class="line">        root.right = deleteRec(root.right, root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BSTNode <span class="title function_">findMin</span><span class="params">(BSTNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找节点">3.3 查找节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(h) 其中 h 是树高，平均 O(log n)，最坏 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(BinarySearchTree bst, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchRec(bst.getRoot(), val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">searchRec</span><span class="params">(BSTNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchRec(root.left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchRec(root.right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="前序遍历preorder-traversal">3.4 前序遍历（Preorder
Traversal）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n) 其中 n 是节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    preorderRec(bst.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preorderRec</span><span class="params">(BSTNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preorderRec(root.left);</span><br><span class="line">        preorderRec(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="中序遍历inorder-traversal">3.5 中序遍历（Inorder
Traversal）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n) 其中 n 是节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    inorderRec(bst.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderRec</span><span class="params">(BSTNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        inorderRec(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inorderRec(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="后序遍历postorder-traversal">3.6 后序遍历（Postorder
Traversal）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n) 其中 n 是节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    postorderRec(bst.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postorderRec</span><span class="params">(BSTNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        postorderRec(root.left);</span><br><span class="line">        postorderRec(root.right);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找最小值">3.7 查找最小值</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(h) 其中 h 是树高，平均 O(log n)，最坏 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bst.getRoot() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">current</span> <span class="operator">=</span> bst.getRoot();</span><br><span class="line">    <span class="keyword">while</span> (current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        current = current.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找最大值">3.8 查找最大值</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(h) 其中 h 是树高，平均 O(log n)，最坏 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bst.getRoot() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">current</span> <span class="operator">=</span> bst.getRoot();</span><br><span class="line">    <span class="keyword">while</span> (current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="计算树的高度">3.9 计算树的高度</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n) 其中 n 是节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> heightRec(bst.getRoot());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">heightRec</span><span class="params">(BSTNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> heightRec(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> heightRec(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="验证是否是有效的bst">3.10 验证是否是有效的BST</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n) 其中 n 是节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBSTRec(bst.getRoot(), Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidBSTRec</span><span class="params">(BSTNode root, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= min || root.val &gt;= max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBSTRec(root.left, min, root.val) &amp;&amp; </span><br><span class="line">           isValidBSTRec(root.right, root.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="使用示例-4">使用示例</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BinarySearchTree</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    insert(bst, <span class="number">5</span>);</span><br><span class="line">    insert(bst, <span class="number">3</span>);</span><br><span class="line">    insert(bst, <span class="number">7</span>);</span><br><span class="line">    insert(bst, <span class="number">1</span>);</span><br><span class="line">    insert(bst, <span class="number">9</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Inorder:&quot;</span>);</span><br><span class="line">    inorder(bst);    <span class="comment">// 输出: 1 3 5 7 9</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Preorder:&quot;</span>);</span><br><span class="line">    preorder(bst);   <span class="comment">// 输出: 5 3 1 7 9</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Postorder:&quot;</span>);</span><br><span class="line">    postorder(bst);  <span class="comment">// 输出: 1 3 9 7 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 3: &quot;</span> + search(bst, <span class="number">3</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 4: &quot;</span> + search(bst, <span class="number">4</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最小值和最大值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Min: &quot;</span> + findMin(bst));  <span class="comment">// 输出: 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Max: &quot;</span> + findMax(bst));  <span class="comment">// 输出: 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    delete(bst, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After deleting 3, Inorder:&quot;</span>);</span><br><span class="line">    inorder(bst);    <span class="comment">// 输出: 1 5 7 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 高度</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Height: &quot;</span> + height(bst));  <span class="comment">// 输出: 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证BST</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Is valid BST: &quot;</span> + isValidBST(bst));  <span class="comment">// 输出: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="说明">说明</h5>
<ul>
<li><strong>时间复杂度</strong>：大多数操作依赖树高 h，在平衡 BST 中 h ≈
log n，在退化为链表时 h = n。</li>
<li><strong>插入、删除、查找</strong>：核心操作，利用 BST
的性质快速定位。</li>
<li><strong>遍历</strong>：前序、中序、后序是基本的树遍历方式，中序遍历
BST 会得到有序序列。</li>
<li><strong>最小值和最大值</strong>：利用 BST
左子树最小、右子树最大的特性。</li>
<li><strong>高度和验证</strong>：辅助功能，用于分析树结构和正确性。</li>
</ul>
<hr />
<h4 id="平衡二叉树">平衡二叉树</h4>
<h5 id="avl树-自平衡二叉搜索树">AVL树 (自平衡二叉搜索树)</h5>
<p>AVL 树通过在插入和删除时保持平衡因子（左右子树高度差不超过
1）来确保树的高度始终接近 log n，从而保证操作的高效性。</p>
<ul>
<li><strong>定义</strong>:
BST的改进，任何节点的左右子树高度差不超过1。</li>
<li><strong>特性</strong>: 通过旋转保持平衡，保证O(log n)操作。</li>
<li><strong>应用场景</strong>:
<ul>
<li>需要频繁查找的实时系统</li>
<li>内存管理中的动态分配</li>
</ul></li>
</ul>
<hr />
<h6 id="avl-树节点定义">AVL 树节点定义</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AVLNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    AVLNode left;</span><br><span class="line">    AVLNode right;</span><br><span class="line">    <span class="type">int</span> height;  <span class="comment">// 节点高度，用于平衡计算</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AVLNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="avl-树基本类">AVL 树基本类</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AVLNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AVLTree</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> AVLNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(AVLNode root)</span> &#123; <span class="built_in">this</span>.root = root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="获取节点高度">获取节点高度</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(AVLNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">null</span> ? -<span class="number">1</span> : node.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取平衡因子">获取平衡因子</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(AVLNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">null</span> ? <span class="number">0</span> : getHeight(node.left) - getHeight(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="更新节点高度">更新节点高度</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(AVLNode node)</span> &#123;</span><br><span class="line">    node.height = Math.max(getHeight(node.left), getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="右旋转right-rotation">右旋转（Right Rotation）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> AVLNode <span class="title function_">rightRotate</span><span class="params">(AVLNode y)</span> &#123;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">x</span> <span class="operator">=</span> y.left;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">T2</span> <span class="operator">=</span> x.right;</span><br><span class="line">    </span><br><span class="line">    x.right = y;</span><br><span class="line">    y.left = T2;</span><br><span class="line">    </span><br><span class="line">    updateHeight(y);</span><br><span class="line">    updateHeight(x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="左旋转left-rotation">左旋转（Left Rotation）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> AVLNode <span class="title function_">leftRotate</span><span class="params">(AVLNode x)</span> &#123;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">y</span> <span class="operator">=</span> x.right;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">T2</span> <span class="operator">=</span> y.left;</span><br><span class="line">    </span><br><span class="line">    y.left = x;</span><br><span class="line">    x.right = T2;</span><br><span class="line">    </span><br><span class="line">    updateHeight(x);</span><br><span class="line">    updateHeight(y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入节点-1">插入节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(AVLTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    tree.setRoot(insertRec(tree.getRoot(), val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">insertRec</span><span class="params">(AVLNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AVLNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = insertRec(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = insertRec(root.right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;  <span class="comment">// 不允许重复值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    updateHeight(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalanceFactor(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &lt; root.left.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; val &gt; root.right.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &gt; root.left.val) &#123;</span><br><span class="line">        root.left = leftRotate(root.left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; val &lt; root.right.val) &#123;</span><br><span class="line">        root.right = rightRotate(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除节点-1">删除节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(AVLTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    tree.setRoot(deleteRec(tree.getRoot(), val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">deleteRec</span><span class="params">(AVLNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = deleteRec(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = deleteRec(root.right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        </span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">minNode</span> <span class="operator">=</span> findMin(root.right);</span><br><span class="line">        root.val = minNode.val;</span><br><span class="line">        root.right = deleteRec(root.right, minNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    updateHeight(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalanceFactor(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(root.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(root.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        root.left = leftRotate(root.left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(root.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(root.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root.right = rightRotate(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">findMin</span><span class="params">(AVLNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找节点-1">查找节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(AVLTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchRec(tree.getRoot(), val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">searchRec</span><span class="params">(AVLNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchRec(root.left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchRec(root.right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="中序遍历inorder-traversal-1">中序遍历（Inorder Traversal）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(AVLTree tree)</span> &#123;</span><br><span class="line">    inorderRec(tree.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderRec</span><span class="params">(AVLNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        inorderRec(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inorderRec(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="验证-avl-树性质">验证 AVL 树性质</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAVLTree</span><span class="params">(AVLTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isAVLRec(tree.getRoot());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAVLRec</span><span class="params">(AVLNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalanceFactor(root);</span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> || balance &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isAVLRec(root.left) &amp;&amp; isAVLRec(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="使用示例-5">使用示例</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AVLTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    insert(tree, <span class="number">10</span>);</span><br><span class="line">    insert(tree, <span class="number">20</span>);</span><br><span class="line">    insert(tree, <span class="number">30</span>);</span><br><span class="line">    insert(tree, <span class="number">40</span>);</span><br><span class="line">    insert(tree, <span class="number">50</span>);</span><br><span class="line">    insert(tree, <span class="number">25</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Inorder traversal:&quot;</span>);</span><br><span class="line">    inorder(tree);  <span class="comment">// 输出: 10 20 25 30 40 50</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    delete(tree, <span class="number">30</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After deleting 30:&quot;</span>);</span><br><span class="line">    inorder(tree);  <span class="comment">// 输出: 10 20 25 40 50</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 20: &quot;</span> + search(tree, <span class="number">20</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 30: &quot;</span> + search(tree, <span class="number">30</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证 AVL 性质</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Is AVL Tree: &quot;</span> + isAVLTree(tree));  <span class="comment">// 输出: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="说明-1">说明</h6>
<ul>
<li><strong>平衡因子</strong>：AVL 树通过平衡因子（左子树高度 -
右子树高度）保持平衡，范围在 [-1, 1]。</li>
<li><strong>旋转操作</strong>：
<ul>
<li><strong>右旋转</strong>：处理左子树过高的情况（左左或左右）。</li>
<li><strong>左旋转</strong>：处理右子树过高的情况（右右或右左）。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>插入、删除、查找为 O(log n)，因为 AVL 树始终保持平衡。</li>
<li>遍历和验证为 O(n)，需要访问所有节点。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>递归操作依赖树高 h，由于 AVL 树平衡，h ≈ log n。</li>
</ul></li>
<li><strong>特点</strong>：
<ul>
<li>相比普通 BST，AVL
树通过旋转操作保证了高效性，但增加了维护成本。</li>
</ul></li>
</ul>
<hr />
<h5 id="红黑树-red-black-tree">红黑树 (Red-Black Tree)</h5>
<p>红黑树是一种自平衡二叉搜索树，通过颜色（红/黑）和五条性质保持平衡，确保操作时间复杂度为
O(log n)。</p>
<ul>
<li><strong>定义</strong>:
自平衡BST，具有颜色属性（红/黑），遵循特定规则：
<ol type="1">
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>红色节点的子节点必须是黑色</li>
<li>从根到叶的每条路径黑色节点数相同</li>
</ol></li>
<li><strong>红黑树性质</strong>：
<ol type="1">
<li>每个节点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>所有叶子（NIL）是黑色。</li>
<li>红色节点的子节点必须是黑色（不能有连续红色节点）。</li>
<li>从根到任一叶子的路径上黑色节点数量相同。</li>
</ol></li>
<li><strong>特性</strong>: 保证O(log n)操作，广泛用于系统实现。</li>
<li><strong>应用场景</strong>:
<ul>
<li>Java的TreeMap/TreeSet</li>
<li>Linux内核调度</li>
<li>数据库B+树基础</li>
</ul></li>
</ul>
<hr />
<h6 id="红黑树节点定义">红黑树节点定义</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RBNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    RBNode left;</span><br><span class="line">    RBNode right;</span><br><span class="line">    RBNode parent;</span><br><span class="line">    <span class="type">boolean</span> isRed;  <span class="comment">// true 表示红色，false 表示黑色</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RBNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.isRed = <span class="literal">true</span>;  <span class="comment">// 新节点默认为红色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="红黑树基本类">红黑树基本类</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedBlackTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RBNode root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RBNode</span> <span class="variable">NIL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RBNode</span>(<span class="number">0</span>);  <span class="comment">// 哨兵节点，代表空节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedBlackTree</span><span class="params">()</span> &#123;</span><br><span class="line">        NIL.isRed = <span class="literal">false</span>;  <span class="comment">// NIL 节点始终为黑色</span></span><br><span class="line">        NIL.left = NIL.right = NIL.parent = NIL;</span><br><span class="line">        root = NIL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> RBNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(RBNode root)</span> &#123; <span class="built_in">this</span>.root = root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="左旋转left-rotation-1">左旋转（Left Rotation）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(RedBlackTree tree, RBNode x)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">y</span> <span class="operator">=</span> x.right;</span><br><span class="line">    x.right = y.left;</span><br><span class="line">    <span class="keyword">if</span> (y.left != RedBlackTree.NIL) &#123;</span><br><span class="line">        y.left.parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y.parent = x.parent;</span><br><span class="line">    <span class="keyword">if</span> (x.parent == RedBlackTree.NIL) &#123;</span><br><span class="line">        tree.setRoot(y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line">        x.parent.left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x.parent.right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y.left = x;</span><br><span class="line">    x.parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="右旋转right-rotation-1">右旋转（Right Rotation）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(RedBlackTree tree, RBNode y)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">x</span> <span class="operator">=</span> y.left;</span><br><span class="line">    y.left = x.right;</span><br><span class="line">    <span class="keyword">if</span> (x.right != RedBlackTree.NIL) &#123;</span><br><span class="line">        x.right.parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    x.parent = y.parent;</span><br><span class="line">    <span class="keyword">if</span> (y.parent == RedBlackTree.NIL) &#123;</span><br><span class="line">        tree.setRoot(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y.parent.left) &#123;</span><br><span class="line">        y.parent.left = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y.parent.right = x;</span><br><span class="line">    &#125;</span><br><span class="line">    x.right = y;</span><br><span class="line">    y.parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入节点-2">插入节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(RedBlackTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RBNode</span>(val);</span><br><span class="line">    node.left = node.right = node.parent = RedBlackTree.NIL;</span><br><span class="line">    </span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">y</span> <span class="operator">=</span> RedBlackTree.NIL;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">x</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BST 插入</span></span><br><span class="line">    <span class="keyword">while</span> (x != RedBlackTree.NIL) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node.val &lt; x.val) &#123;</span><br><span class="line">            x = x.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = x.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node.parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y == RedBlackTree.NIL) &#123;</span><br><span class="line">        tree.setRoot(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &lt; y.val) &#123;</span><br><span class="line">        y.left = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y.right = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修复红黑树性质</span></span><br><span class="line">    insertFixup(tree, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertFixup</span><span class="params">(RedBlackTree tree, RBNode z)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (z.parent.isRed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z.parent == z.parent.parent.left) &#123;</span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">y</span> <span class="operator">=</span> z.parent.parent.right;  <span class="comment">// 叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (y.isRed) &#123;  <span class="comment">// 情况 1：叔叔是红色</span></span><br><span class="line">                z.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                y.isRed = <span class="literal">false</span>;</span><br><span class="line">                z.parent.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                z = z.parent.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z.parent.right) &#123;  <span class="comment">// 情况 2：叔叔是黑色，z 是右孩子</span></span><br><span class="line">                    z = z.parent;</span><br><span class="line">                    leftRotate(tree, z);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况 3：叔叔是黑色，z 是左孩子</span></span><br><span class="line">                z.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                z.parent.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                rightRotate(tree, z.parent.parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 对称情况</span></span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">y</span> <span class="operator">=</span> z.parent.parent.left;</span><br><span class="line">            <span class="keyword">if</span> (y.isRed) &#123;</span><br><span class="line">                z.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                y.isRed = <span class="literal">false</span>;</span><br><span class="line">                z.parent.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                z = z.parent.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z.parent.left) &#123;</span><br><span class="line">                    z = z.parent;</span><br><span class="line">                    rightRotate(tree, z);</span><br><span class="line">                &#125;</span><br><span class="line">                z.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                z.parent.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                leftRotate(tree, z.parent.parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tree.getRoot().isRed = <span class="literal">false</span>;  <span class="comment">// 根节点始终为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除节点-2">删除节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(RedBlackTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">z</span> <span class="operator">=</span> searchNode(tree.getRoot(), val);</span><br><span class="line">    <span class="keyword">if</span> (z == RedBlackTree.NIL) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">y</span> <span class="operator">=</span> z;</span><br><span class="line">    RBNode x;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">yOriginalColor</span> <span class="operator">=</span> y.isRed;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (z.left == RedBlackTree.NIL) &#123;</span><br><span class="line">        x = z.right;</span><br><span class="line">        transplant(tree, z, z.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z.right == RedBlackTree.NIL) &#123;</span><br><span class="line">        x = z.left;</span><br><span class="line">        transplant(tree, z, z.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = findMin(z.right);</span><br><span class="line">        yOriginalColor = y.isRed;</span><br><span class="line">        x = y.right;</span><br><span class="line">        <span class="keyword">if</span> (y.parent == z) &#123;</span><br><span class="line">            x.parent = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transplant(tree, y, y.right);</span><br><span class="line">            y.right = z.right;</span><br><span class="line">            y.right.parent = y;</span><br><span class="line">        &#125;</span><br><span class="line">        transplant(tree, z, y);</span><br><span class="line">        y.left = z.left;</span><br><span class="line">        y.left.parent = y;</span><br><span class="line">        y.isRed = z.isRed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!yOriginalColor) &#123;</span><br><span class="line">        deleteFixup(tree, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transplant</span><span class="params">(RedBlackTree tree, RBNode u, RBNode v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (u.parent == RedBlackTree.NIL) &#123;</span><br><span class="line">        tree.setRoot(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u.parent.left) &#123;</span><br><span class="line">        u.parent.left = v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u.parent.right = v;</span><br><span class="line">    &#125;</span><br><span class="line">    v.parent = u.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteFixup</span><span class="params">(RedBlackTree tree, RBNode x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (x != tree.getRoot() &amp;&amp; !x.isRed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">w</span> <span class="operator">=</span> x.parent.right;  <span class="comment">// 兄弟节点</span></span><br><span class="line">            <span class="keyword">if</span> (w.isRed) &#123;  <span class="comment">// 情况 1</span></span><br><span class="line">                w.isRed = <span class="literal">false</span>;</span><br><span class="line">                x.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                leftRotate(tree, x.parent);</span><br><span class="line">                w = x.parent.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!w.left.isRed &amp;&amp; !w.right.isRed) &#123;  <span class="comment">// 情况 2</span></span><br><span class="line">                w.isRed = <span class="literal">true</span>;</span><br><span class="line">                x = x.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!w.right.isRed) &#123;  <span class="comment">// 情况 3</span></span><br><span class="line">                    w.left.isRed = <span class="literal">false</span>;</span><br><span class="line">                    w.isRed = <span class="literal">true</span>;</span><br><span class="line">                    rightRotate(tree, w);</span><br><span class="line">                    w = x.parent.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况 4</span></span><br><span class="line">                w.isRed = x.parent.isRed;</span><br><span class="line">                x.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                w.right.isRed = <span class="literal">false</span>;</span><br><span class="line">                leftRotate(tree, x.parent);</span><br><span class="line">                x = tree.getRoot();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 对称情况</span></span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">w</span> <span class="operator">=</span> x.parent.left;</span><br><span class="line">            <span class="keyword">if</span> (w.isRed) &#123;</span><br><span class="line">                w.isRed = <span class="literal">false</span>;</span><br><span class="line">                x.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                rightRotate(tree, x.parent);</span><br><span class="line">                w = x.parent.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!w.right.isRed &amp;&amp; !w.left.isRed) &#123;</span><br><span class="line">                w.isRed = <span class="literal">true</span>;</span><br><span class="line">                x = x.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!w.left.isRed) &#123;</span><br><span class="line">                    w.right.isRed = <span class="literal">false</span>;</span><br><span class="line">                    w.isRed = <span class="literal">true</span>;</span><br><span class="line">                    leftRotate(tree, w);</span><br><span class="line">                    w = x.parent.left;</span><br><span class="line">                &#125;</span><br><span class="line">                w.isRed = x.parent.isRed;</span><br><span class="line">                x.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                w.left.isRed = <span class="literal">false</span>;</span><br><span class="line">                rightRotate(tree, x.parent);</span><br><span class="line">                x = tree.getRoot();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x.isRed = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找节点-2">查找节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(RedBlackTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchNode(tree.getRoot(), val) != RedBlackTree.NIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RBNode <span class="title function_">searchNode</span><span class="params">(RBNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (current != RedBlackTree.NIL &amp;&amp; current.val != val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; current.val) &#123;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="中序遍历inorder-traversal-2">中序遍历（Inorder Traversal）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(RedBlackTree tree)</span> &#123;</span><br><span class="line">    inorderRec(tree.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderRec</span><span class="params">(RBNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != RedBlackTree.NIL) &#123;</span><br><span class="line">        inorderRec(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inorderRec(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找最小值-1">查找最小值</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(RedBlackTree tree)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">minNode</span> <span class="operator">=</span> findMin(tree.getRoot());</span><br><span class="line">    <span class="keyword">if</span> (minNode == RedBlackTree.NIL) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNode.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RBNode <span class="title function_">findMin</span><span class="params">(RBNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != RedBlackTree.NIL) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="使用示例-6">使用示例</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RedBlackTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedBlackTree</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    insert(tree, <span class="number">10</span>);</span><br><span class="line">    insert(tree, <span class="number">20</span>);</span><br><span class="line">    insert(tree, <span class="number">30</span>);</span><br><span class="line">    insert(tree, <span class="number">15</span>);</span><br><span class="line">    insert(tree, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Inorder traversal:&quot;</span>);</span><br><span class="line">    inorder(tree);  <span class="comment">// 输出: 5 10 15 20 30</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    delete(tree, <span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After deleting 20:&quot;</span>);</span><br><span class="line">    inorder(tree);  <span class="comment">// 输出: 5 10 15 30</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 15: &quot;</span> + search(tree, <span class="number">15</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 20: &quot;</span> + search(tree, <span class="number">20</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最小值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Min value: &quot;</span> + findMin(tree));  <span class="comment">// 输出: 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="说明-2">说明</h6>
<ul>
<li><strong>旋转操作</strong>：
<ul>
<li><strong>左旋转</strong>和<strong>右旋转</strong>用于调整树结构，保持平衡。</li>
</ul></li>
<li><strong>插入和删除</strong>：
<ul>
<li>插入后通过调整颜色和旋转修复红黑性质。</li>
<li>删除后通过四种情况修复，确保黑色高度一致。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>插入、删除、查找为 O(log n)，因为红黑树高度始终保持在 2log(n+1)
以内。</li>
<li>遍历为 O(n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>大多数操作只需常数额外空间，递归调用栈为 O(log n)。</li>
</ul></li>
</ul>
<hr />
<h4 id="完全二叉树">完全二叉树</h4>
<p>完全二叉树是一种特殊的二叉树，所有层（除可能的最底层）都被填满，最底层的节点尽量靠左排列。完全二叉树常用于实现堆。</p>
<hr />
<h5 id="完全二叉树节点定义">1. 完全二叉树节点定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CBTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    CBTNode left;</span><br><span class="line">    CBTNode right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CBTNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="完全二叉树基本类基于数组实现">2.
完全二叉树基本类（基于数组实现）</h5>
<p>由于完全二叉树可以用数组高效存储（无需显式指针），以下实现主要基于数组形式，适用于堆等场景。如果需要基于链表的实现，可以另行说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompleteBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;    <span class="comment">// 数组存储完全二叉树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;     <span class="comment">// 当前节点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity; <span class="comment">// 最大容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CompleteBinaryTree</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getArr() &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> size)</span> &#123; <span class="built_in">this</span>.size = size; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="完全二叉树常用算法">3. 完全二叉树常用算法</h5>
<h6 id="插入节点尾部插入">3.1 插入节点（尾部插入）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 在完全二叉树末尾插入节点（不调整堆序性）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(CompleteBinaryTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() &gt;= tree.capacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tree.getArr()[tree.getSize()] = val;</span><br><span class="line">    tree.setSize(tree.getSize() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除最后一个节点">3.2 删除最后一个节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeLast</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> tree.getArr()[tree.getSize() - <span class="number">1</span>];</span><br><span class="line">    tree.setSize(tree.getSize() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取父节点索引">3.3 获取父节点索引</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 根节点无父节点</span></span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取左子节点索引">3.4 获取左子节点索引</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index, CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left &lt; tree.getSize() ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取右子节点索引">3.5 获取右子节点索引</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index, CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> right &lt; tree.getSize() ? right : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="检查是否为完全二叉树基于链表实现">3.6
检查是否为完全二叉树（基于链表实现）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(w), w 是树的最大宽度（队列空间）</span></span><br><span class="line"><span class="comment">// 使用层序遍历检查是否满足完全二叉树性质</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteBinaryTree</span><span class="params">(CBTNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;CBTNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">mustBeLeaf</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">// 标记后续节点必须是叶子</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">CBTNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果之前遇到过空节点，后续节点必须是叶子</span></span><br><span class="line">        <span class="keyword">if</span> (mustBeLeaf &amp;&amp; (node.left != <span class="literal">null</span> || node.right != <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;  <span class="comment">// 有右无左，不是完全二叉树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mustBeLeaf = <span class="literal">true</span>;  <span class="comment">// 后续节点必须没有子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="计算树的高度-1">3.7 计算树的高度</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 对于完全二叉树，高度可以通过节点数直接计算</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) Math.floor(Math.log(tree.getSize()) / Math.log(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="层序遍历level-order-traversal">3.8 层序遍历（Level Order
Traversal）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(w), w 是树的最大宽度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tree.getSize(); i++) &#123;</span><br><span class="line">        System.out.print(tree.getArr()[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="堆化heapify--最小堆调整">3.9 堆化（Heapify）- 最小堆调整</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 从指定节点向下调整为最小堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">minHeapify</span><span class="params">(CompleteBinaryTree tree, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> index;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getLeftChildIndex(index, tree);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getRightChildIndex(index, tree);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left != -<span class="number">1</span> &amp;&amp; tree.getArr()[left] &lt; tree.getArr()[smallest]) &#123;</span><br><span class="line">        smallest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right != -<span class="number">1</span> &amp;&amp; tree.getArr()[right] &lt; tree.getArr()[smallest]) &#123;</span><br><span class="line">        smallest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">        swap(tree.getArr(), index, smallest);</span><br><span class="line">        minHeapify(tree, smallest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="构建最小堆">3.10 构建最小堆</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 将整个数组调整为最小堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMinHeap</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> tree.getSize() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        minHeapify(tree, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="最大堆化max-heapify">3.11 最大堆化（Max Heapify）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 从指定节点向下调整为最大堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(CompleteBinaryTree tree, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> index;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getLeftChildIndex(index, tree);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getRightChildIndex(index, tree);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left != -<span class="number">1</span> &amp;&amp; tree.getArr()[left] &gt; tree.getArr()[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right != -<span class="number">1</span> &amp;&amp; tree.getArr()[right] &gt; tree.getArr()[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (largest != index) &#123;</span><br><span class="line">        swap(tree.getArr(), index, largest);</span><br><span class="line">        maxHeapify(tree, largest);  <span class="comment">// 递归调整子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="构建最大堆">3.12 构建最大堆</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 将整个数组调整为最大堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> tree.getSize() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxHeapify(tree, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入并调整为最大堆">3.13 插入并调整为最大堆</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 插入新元素并上浮调整为最大堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertMaxHeap</span><span class="params">(CompleteBinaryTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() &gt;= tree.capacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tree.getArr()[tree.getSize()] = val;</span><br><span class="line">    tree.setSize(tree.getSize() + <span class="number">1</span>);</span><br><span class="line">    siftUpMax(tree, tree.getSize() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpMax</span><span class="params">(CompleteBinaryTree tree, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> getParentIndex(index);</span><br><span class="line">        <span class="keyword">if</span> (tree.getArr()[parent] &lt; tree.getArr()[index]) &#123;</span><br><span class="line">            swap(tree.getArr(), parent, index);</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除最大值根节点">3.14 删除最大值（根节点）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 删除并返回最大值，然后调整为最大堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">extractMax</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> tree.getArr()[<span class="number">0</span>];</span><br><span class="line">    tree.getArr()[<span class="number">0</span>] = tree.getArr()[tree.getSize() - <span class="number">1</span>];</span><br><span class="line">    tree.setSize(tree.getSize() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxHeapify(tree, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="使用示例-7">使用示例</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 基于数组的完全二叉树</span></span><br><span class="line">        <span class="type">CompleteBinaryTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompleteBinaryTree</span>(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入节点</span></span><br><span class="line">        insert(tree, <span class="number">5</span>);</span><br><span class="line">        insert(tree, <span class="number">3</span>);</span><br><span class="line">        insert(tree, <span class="number">7</span>);</span><br><span class="line">        insert(tree, <span class="number">1</span>);</span><br><span class="line">        insert(tree, <span class="number">9</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Level order before heapify:&quot;</span>);</span><br><span class="line">        levelOrder(tree);  <span class="comment">// 输出: 5 3 7 1 9</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建最小堆</span></span><br><span class="line">        buildMinHeap(tree);</span><br><span class="line">        System.out.println(<span class="string">&quot;Level order after min heapify:&quot;</span>);</span><br><span class="line">        levelOrder(tree);  <span class="comment">// 输出: 1 3 7 5 9</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Height: &quot;</span> + getHeight(tree));  <span class="comment">// 输出: 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除最后一个节点</span></span><br><span class="line">        removeLast(tree);</span><br><span class="line">        System.out.println(<span class="string">&quot;After removing last node:&quot;</span>);</span><br><span class="line">        levelOrder(tree);  <span class="comment">// 输出: 1 3 7 5</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 基于链表的完全二叉树检查</span></span><br><span class="line">        <span class="type">CBTNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CBTNode</span>(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> <span class="title class_">CBTNode</span>(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> <span class="title class_">CBTNode</span>(<span class="number">3</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> <span class="title class_">CBTNode</span>(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Is complete binary tree: &quot;</span> + isCompleteBinaryTree(root));  <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="说明-3">说明</h5>
<ul>
<li><strong>实现方式</strong>：
<ul>
<li>主要基于数组实现，因为完全二叉树可以用数组连续存储，适合堆等应用。</li>
<li>提供了基于链表的 <code>isCompleteBinaryTree</code>
检查算法，展示树结构的验证。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>插入和删除最后一个节点为 O(1)，因为只操作数组末尾。</li>
<li>堆化操作（如 <code>minHeapify</code>）为 O(log n)，构建堆为
O(n)。</li>
<li>遍历和检查为 O(n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>数组实现大多为 O(1) 额外空间。</li>
<li>层序遍历和检查使用队列，空间为 O(w)，w 是树的最大宽度。</li>
</ul></li>
<li><strong>与堆的关系</strong>：
<ul>
<li>完全二叉树常用于实现堆（如最小堆、最大堆），因此包含了堆化相关算法。</li>
<li>如果不考虑堆序性，完全二叉树仅关注结构完整性。</li>
</ul></li>
<li><strong>扩展</strong>：
<ul>
<li>如果需要最大堆调整、前序/中序遍历等其他算法，可以告诉我，我会补充。</li>
</ul></li>
</ul>
<p>完全二叉树的算法相对简单，主要优势在于其结构特性便于数组存储和高效操作，尤其在堆的实现中应用广泛。</p>
<h3 id="多叉树">多叉树</h3>
<h4 id="多路平衡树">多路平衡树</h4>
<h5 id="b树">B树</h5>
<p>B
树是一种自平衡的多路搜索树，广泛用于数据库和文件系统，能够高效处理大量数据。B
树的每个节点可以有多个键和子节点，保持树的平衡以确保操作时间为 O(log
n)。</p>
<p><strong>B 树性质</strong>：</p>
<ol type="1">
<li>每个节点最多有 2t-1 个键，最多 2t 个子节点。</li>
<li>每个非根节点至少有 t-1 个键，至少 t 个子节点。</li>
<li>根节点至少有 1 个键（除非树为空）。</li>
<li>所有叶子节点在同一层。</li>
</ol>
<hr />
<h6 id="b-树节点定义">B 树节点定义</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BTreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] keys;           <span class="comment">// 键数组</span></span><br><span class="line">    BTreeNode[] children; <span class="comment">// 子节点数组</span></span><br><span class="line">    <span class="type">int</span> keyCount;         <span class="comment">// 当前键数量</span></span><br><span class="line">    <span class="type">boolean</span> isLeaf;       <span class="comment">// 是否为叶子节点</span></span><br><span class="line">    <span class="type">int</span> t;                <span class="comment">// 最小度数（定义 B 树的阶）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTreeNode</span><span class="params">(<span class="type">int</span> t, <span class="type">boolean</span> isLeaf)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.isLeaf = isLeaf;</span><br><span class="line">        <span class="built_in">this</span>.keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * t - <span class="number">1</span>];      <span class="comment">// 最多 2t-1 个键</span></span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">BTreeNode</span>[<span class="number">2</span> * t]; <span class="comment">// 最多 2t 个子节点</span></span><br><span class="line">        <span class="built_in">this</span>.keyCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="b-树基本类">B 树基本类</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BTreeNode root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> t;  <span class="comment">// 最小度数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">BTreeNode</span>(t, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BTreeNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(BTreeNode root)</span> &#123; <span class="built_in">this</span>.root = root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="搜索键">搜索键</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 其中 t 是度数，n 是键总数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> BTreeNode <span class="title function_">search</span><span class="params">(BTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchRec(tree.getRoot(), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BTreeNode <span class="title function_">searchRec</span><span class="params">(BTreeNode node, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; node.keyCount &amp;&amp; key == node.keys[i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;  <span class="comment">// 找到键</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 未找到且是叶子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchRec(node.children[i], key);  <span class="comment">// 递归搜索子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入键">插入键</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 空间复杂度: O(t) 递归栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(BTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    <span class="keyword">if</span> (root.keyCount == <span class="number">2</span> * tree.t - <span class="number">1</span>) &#123;  <span class="comment">// 根节点已满</span></span><br><span class="line">        <span class="type">BTreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeNode</span>(tree.t, <span class="literal">false</span>);</span><br><span class="line">        newRoot.children[<span class="number">0</span>] = root;</span><br><span class="line">        splitChild(newRoot, <span class="number">0</span>, root, tree.t);</span><br><span class="line">        insertNonFull(newRoot, key, tree.t);</span><br><span class="line">        tree.setRoot(newRoot);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertNonFull(root, key, tree.t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertNonFull</span><span class="params">(BTreeNode node, <span class="type">int</span> key, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> node.keyCount - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; key &lt; node.keys[i]) &#123;</span><br><span class="line">            node.keys[i + <span class="number">1</span>] = node.keys[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        node.keys[i + <span class="number">1</span>] = key;</span><br><span class="line">        node.keyCount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; key &lt; node.keys[i]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (node.children[i].keyCount == <span class="number">2</span> * t - <span class="number">1</span>) &#123;</span><br><span class="line">            splitChild(node, i, node.children[i], t);</span><br><span class="line">            <span class="keyword">if</span> (key &gt; node.keys[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNonFull(node.children[i], key, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">splitChild</span><span class="params">(BTreeNode parent, <span class="type">int</span> i, BTreeNode fullChild, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeNode</span>(t, fullChild.isLeaf);</span><br><span class="line">    newNode.keyCount = t - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制后半部分键到新节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; t - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        newNode.keys[j] = fullChild.keys[j + t];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是叶子节点，复制子节点</span></span><br><span class="line">    <span class="keyword">if</span> (!fullChild.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">            newNode.children[j] = fullChild.children[j + t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fullChild.keyCount = t - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整父节点的子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> parent.keyCount; j &gt; i; j--) &#123;</span><br><span class="line">        parent.children[j + <span class="number">1</span>] = parent.children[j];</span><br><span class="line">    &#125;</span><br><span class="line">    parent.children[i + <span class="number">1</span>] = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提升中间键到父节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> parent.keyCount - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">        parent.keys[j + <span class="number">1</span>] = parent.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    parent.keys[i] = fullChild.keys[t - <span class="number">1</span>];</span><br><span class="line">    parent.keyCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除键">删除键</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 空间复杂度: O(t) 递归栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(BTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    deleteRec(tree.getRoot(), key, tree.t);</span><br><span class="line">    <span class="keyword">if</span> (tree.getRoot().keyCount == <span class="number">0</span> &amp;&amp; !tree.getRoot().isLeaf) &#123;</span><br><span class="line">        tree.setRoot(tree.getRoot().children[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteRec</span><span class="params">(BTreeNode node, <span class="type">int</span> key, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &lt; node.keyCount &amp;&amp; key == node.keys[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.isLeaf) &#123;</span><br><span class="line">            removeFromLeaf(node, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeFromNonLeaf(node, i, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node.isLeaf) &#123;</span><br><span class="line">        deleteFromSubtree(node, i, key, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeFromLeaf</span><span class="params">(BTreeNode node, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; node.keyCount; j++) &#123;</span><br><span class="line">        node.keys[j - <span class="number">1</span>] = node.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    node.keyCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeFromNonLeaf</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> node.keys[i];</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">pred</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">succ</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pred.keyCount &gt;= t) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">predKey</span> <span class="operator">=</span> getPredecessor(pred);</span><br><span class="line">        node.keys[i] = predKey;</span><br><span class="line">        deleteRec(pred, predKey, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (succ.keyCount &gt;= t) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">succKey</span> <span class="operator">=</span> getSuccessor(succ);</span><br><span class="line">        node.keys[i] = succKey;</span><br><span class="line">        deleteRec(succ, succKey, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mergeNodes(node, i, t);</span><br><span class="line">        deleteRec(node.children[i], key, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteFromSubtree</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> key, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="keyword">if</span> (child.keyCount &lt; t) &#123;</span><br><span class="line">        fillChild(node, i, t);</span><br><span class="line">    &#125;</span><br><span class="line">    deleteRec(child, key, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPredecessor</span><span class="params">(BTreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!node.isLeaf) &#123;</span><br><span class="line">        node = node.children[node.keyCount];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.keys[node.keyCount - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSuccessor</span><span class="params">(BTreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!node.isLeaf) &#123;</span><br><span class="line">        node = node.children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.keys[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeNodes</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">left</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">right</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    left.keys[left.keyCount] = node.keys[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; right.keyCount; j++) &#123;</span><br><span class="line">        left.keys[left.keyCount + <span class="number">1</span> + j] = right.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!left.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= right.keyCount; j++) &#123;</span><br><span class="line">            left.children[left.keyCount + <span class="number">1</span> + j] = right.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left.keyCount += right.keyCount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; node.keyCount; j++) &#123;</span><br><span class="line">        node.keys[j - <span class="number">1</span>] = node.keys[j];</span><br><span class="line">        node.children[j] = node.children[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.keyCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fillChild</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; node.children[i - <span class="number">1</span>].keyCount &gt;= t) &#123;</span><br><span class="line">        borrowFromPrev(node, i, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != node.keyCount &amp;&amp; node.children[i + <span class="number">1</span>].keyCount &gt;= t) &#123;</span><br><span class="line">        borrowFromNext(node, i, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != node.keyCount) &#123;</span><br><span class="line">            mergeNodes(node, i, t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeNodes(node, i - <span class="number">1</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowFromPrev</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">sibling</span> <span class="operator">=</span> node.children[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> child.keyCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        child.keys[j + <span class="number">1</span>] = child.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!child.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> child.keyCount; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            child.children[j + <span class="number">1</span>] = child.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    child.keys[<span class="number">0</span>] = node.keys[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!child.isLeaf) &#123;</span><br><span class="line">        child.children[<span class="number">0</span>] = sibling.children[sibling.keyCount];</span><br><span class="line">    &#125;</span><br><span class="line">    node.keys[i - <span class="number">1</span>] = sibling.keys[sibling.keyCount - <span class="number">1</span>];</span><br><span class="line">    child.keyCount++;</span><br><span class="line">    sibling.keyCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowFromNext</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">sibling</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    child.keys[child.keyCount] = node.keys[i];</span><br><span class="line">    <span class="keyword">if</span> (!child.isLeaf) &#123;</span><br><span class="line">        child.children[child.keyCount + <span class="number">1</span>] = sibling.children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.keys[i] = sibling.keys[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; sibling.keyCount; j++) &#123;</span><br><span class="line">        sibling.keys[j - <span class="number">1</span>] = sibling.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!sibling.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= sibling.keyCount; j++) &#123;</span><br><span class="line">            sibling.children[j - <span class="number">1</span>] = sibling.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    child.keyCount++;</span><br><span class="line">    sibling.keyCount--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="遍历中序遍历">遍历（中序遍历）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(t) 递归栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">    inorderRec(tree.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderRec</span><span class="params">(BTreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; node.keyCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.isLeaf) &#123;</span><br><span class="line">                inorderRec(node.children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(node.keys[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!node.isLeaf) &#123;</span><br><span class="line">            inorderRec(node.children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="使用示例-8">使用示例</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTree</span>(<span class="number">3</span>);  <span class="comment">// 最小度数 t=3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入键</span></span><br><span class="line">        insert(tree, <span class="number">10</span>);</span><br><span class="line">        insert(tree, <span class="number">20</span>);</span><br><span class="line">        insert(tree, <span class="number">5</span>);</span><br><span class="line">        insert(tree, <span class="number">6</span>);</span><br><span class="line">        insert(tree, <span class="number">12</span>);</span><br><span class="line">        insert(tree, <span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Inorder traversal:&quot;</span>);</span><br><span class="line">        inorder(tree);  <span class="comment">// 输出: 5 6 10 12 20 30</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 搜索</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search 6: &quot;</span> + (search(tree, <span class="number">6</span>) != <span class="literal">null</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search 15: &quot;</span> + (search(tree, <span class="number">15</span>) != <span class="literal">null</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        delete(tree, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After deleting 6:&quot;</span>);</span><br><span class="line">        inorder(tree);  <span class="comment">// 输出: 5 10 12 20 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="说明-4">说明</h6>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>搜索、插入、删除为 O(t log_t n)，其中 t 是度数，n 是键总数。</li>
<li>遍历为 O(n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>每个节点占用 O(t) 空间，递归栈为 O(t)。</li>
</ul></li>
<li><strong>算法特点</strong>：
<ul>
<li><strong>插入</strong>：通过分裂满节点保持平衡。</li>
<li><strong>删除</strong>：通过借用或合并子节点保持最小键数。</li>
<li><strong>搜索</strong>：利用有序键快速定位。</li>
</ul></li>
<li><strong>应用</strong>：
<ul>
<li>B 树适用于磁盘存储系统，因其多路结构减少了 I/O 操作。</li>
</ul></li>
<li><strong>扩展</strong>：
<ul>
<li>如果需要范围查询、最小/最大值等其他算法，可以告诉我，我会补充。</li>
</ul></li>
</ul>
<p>这个实现假设键为整数，t 为固定值。如果需要动态调整 t
或支持其他数据类型，可以进一步修改。有什么具体需求，请告诉我！</p>
<h5 id="b-树">B+ 树</h5>
<p>B+ 树是 B
树的变种，广泛用于数据库和文件系统，特点是所有键值存储在叶子节点，非叶子节点仅用于索引，且叶子节点通过链表连接，便于范围查询。</p>
<p><strong>B+ 树性质</strong>：</p>
<ol type="1">
<li>所有键值存储在叶子节点，非叶子节点仅存储索引。</li>
<li>每个节点最多有 2t-1 个键，最多 2t 个子节点。</li>
<li>每个非根节点至少有 t-1 个键，至少 t 个子节点。</li>
<li>叶子节点通过链表连接。</li>
</ol>
<hr />
<h6 id="b-树节点定义-1">B+ 树节点定义</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusNode</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] keys;           <span class="comment">// 键数组</span></span><br><span class="line">    BPlusNode[] children; <span class="comment">// 子节点数组（仅非叶子节点使用）</span></span><br><span class="line">    <span class="type">int</span> keyCount;         <span class="comment">// 当前键数量</span></span><br><span class="line">    <span class="type">boolean</span> isLeaf;       <span class="comment">// 是否为叶子节点</span></span><br><span class="line">    BPlusNode next;       <span class="comment">// 叶子节点的下一个指针</span></span><br><span class="line">    <span class="type">int</span> t;                <span class="comment">// 最小度数（定义 B+ 树的阶）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BPlusNode</span><span class="params">(<span class="type">int</span> t, <span class="type">boolean</span> isLeaf)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.isLeaf = isLeaf;</span><br><span class="line">        <span class="built_in">this</span>.keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * t - <span class="number">1</span>];      <span class="comment">// 最多 2t-1 个键</span></span><br><span class="line">        <span class="built_in">this</span>.children = isLeaf ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">BPlusNode</span>[<span class="number">2</span> * t]; <span class="comment">// 最多 2t 个子节点</span></span><br><span class="line">        <span class="built_in">this</span>.keyCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="b-树基本类-1">B+ 树基本类</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BPlusNode root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> t;  <span class="comment">// 最小度数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BPlusTree</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">BPlusNode</span>(t, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BPlusNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(BPlusNode root)</span> &#123; <span class="built_in">this</span>.root = root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="搜索键-1">搜索键</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 其中 t 是度数，n 是键总数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> BPlusNode <span class="title function_">search</span><span class="params">(BPlusTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">node</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    <span class="keyword">while</span> (!node.isLeaf) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (i &lt; node.keyCount &amp;&amp; node.keys[i] == key) ? node : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入键-1">插入键</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 空间复杂度: O(t) 递归栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(BPlusTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">root</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    <span class="keyword">if</span> (root.keyCount == <span class="number">2</span> * tree.t - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">BPlusNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BPlusNode</span>(tree.t, <span class="literal">false</span>);</span><br><span class="line">        newRoot.children[<span class="number">0</span>] = root;</span><br><span class="line">        splitChild(newRoot, <span class="number">0</span>, root, tree.t);</span><br><span class="line">        tree.setRoot(newRoot);</span><br><span class="line">        insertNonFull(tree.getRoot(), key, tree.t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertNonFull(root, key, tree.t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertNonFull</span><span class="params">(BPlusNode node, <span class="type">int</span> key, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.isLeaf) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> node.keyCount - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; key &lt; node.keys[i]) &#123;</span><br><span class="line">            node.keys[i + <span class="number">1</span>] = node.keys[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        node.keys[i + <span class="number">1</span>] = key;</span><br><span class="line">        node.keyCount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BPlusNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">        <span class="keyword">if</span> (child.keyCount == <span class="number">2</span> * t - <span class="number">1</span>) &#123;</span><br><span class="line">            splitChild(node, i, child, t);</span><br><span class="line">            <span class="keyword">if</span> (key &gt; node.keys[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNonFull(node.children[i], key, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">splitChild</span><span class="params">(BPlusNode parent, <span class="type">int</span> i, BPlusNode fullChild, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BPlusNode</span>(t, fullChild.isLeaf);</span><br><span class="line">    newNode.keyCount = t - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制后半部分键到新节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; t - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        newNode.keys[j] = fullChild.keys[j + t];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是叶子节点，设置链表指针</span></span><br><span class="line">    <span class="keyword">if</span> (fullChild.isLeaf) &#123;</span><br><span class="line">        newNode.next = fullChild.next;</span><br><span class="line">        fullChild.next = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是叶子节点，复制子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">            newNode.children[j] = fullChild.children[j + t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fullChild.keyCount = t - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整父节点的子节点和键</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> parent.keyCount; j &gt; i; j--) &#123;</span><br><span class="line">        parent.children[j + <span class="number">1</span>] = parent.children[j];</span><br><span class="line">    &#125;</span><br><span class="line">    parent.children[i + <span class="number">1</span>] = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> parent.keyCount - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">        parent.keys[j + <span class="number">1</span>] = parent.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    parent.keys[i] = fullChild.keys[t - <span class="number">1</span>];  <span class="comment">// 中间键提升到父节点</span></span><br><span class="line">    parent.keyCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除键-1">删除键</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 空间复杂度: O(t) 递归栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(BPlusTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    deleteRec(tree.getRoot(), key, tree.t);</span><br><span class="line">    <span class="keyword">if</span> (tree.getRoot().keyCount == <span class="number">0</span> &amp;&amp; !tree.getRoot().isLeaf) &#123;</span><br><span class="line">        tree.setRoot(tree.getRoot().children[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteRec</span><span class="params">(BPlusNode node, <span class="type">int</span> key, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; node.keyCount &amp;&amp; node.keys[i] == key) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; node.keyCount; j++) &#123;</span><br><span class="line">                node.keys[j - <span class="number">1</span>] = node.keys[j];</span><br><span class="line">            &#125;</span><br><span class="line">            node.keyCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">BPlusNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">        <span class="keyword">if</span> (child.keyCount &lt; t) &#123;</span><br><span class="line">            fillChild(node, i, t);</span><br><span class="line">            <span class="keyword">if</span> (i &gt; node.keyCount) i--;  <span class="comment">// 合并可能导致索引调整</span></span><br><span class="line">        &#125;</span><br><span class="line">        deleteRec(node.children[i], key, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fillChild</span><span class="params">(BPlusNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; node.children[i - <span class="number">1</span>].keyCount &gt;= t) &#123;</span><br><span class="line">        borrowFromPrev(node, i, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != node.keyCount &amp;&amp; node.children[i + <span class="number">1</span>].keyCount &gt;= t) &#123;</span><br><span class="line">        borrowFromNext(node, i, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != node.keyCount) &#123;</span><br><span class="line">            mergeNodes(node, i, t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeNodes(node, i - <span class="number">1</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowFromPrev</span><span class="params">(BPlusNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">sibling</span> <span class="operator">=</span> node.children[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> child.keyCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            child.keys[j + <span class="number">1</span>] = child.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">        child.keys[<span class="number">0</span>] = sibling.keys[sibling.keyCount - <span class="number">1</span>];</span><br><span class="line">        node.keys[i - <span class="number">1</span>] = sibling.keys[sibling.keyCount - <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> child.keyCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            child.keys[j + <span class="number">1</span>] = child.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">        child.keys[<span class="number">0</span>] = node.keys[i - <span class="number">1</span>];</span><br><span class="line">        node.keys[i - <span class="number">1</span>] = sibling.keys[sibling.keyCount - <span class="number">1</span>];</span><br><span class="line">        child.children[child.keyCount + <span class="number">1</span>] = child.children[child.keyCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> child.keyCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            child.children[j + <span class="number">1</span>] = child.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">        child.children[<span class="number">0</span>] = sibling.children[sibling.keyCount];</span><br><span class="line">    &#125;</span><br><span class="line">    child.keyCount++;</span><br><span class="line">    sibling.keyCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowFromNext</span><span class="params">(BPlusNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">sibling</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child.isLeaf) &#123;</span><br><span class="line">        child.keys[child.keyCount] = sibling.keys[<span class="number">0</span>];</span><br><span class="line">        node.keys[i] = sibling.keys[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; sibling.keyCount; j++) &#123;</span><br><span class="line">            sibling.keys[j - <span class="number">1</span>] = sibling.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.keys[child.keyCount] = node.keys[i];</span><br><span class="line">        node.keys[i] = sibling.keys[<span class="number">0</span>];</span><br><span class="line">        child.children[child.keyCount + <span class="number">1</span>] = sibling.children[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; sibling.keyCount; j++) &#123;</span><br><span class="line">            sibling.keys[j - <span class="number">1</span>] = sibling.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= sibling.keyCount; j++) &#123;</span><br><span class="line">            sibling.children[j - <span class="number">1</span>] = sibling.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    child.keyCount++;</span><br><span class="line">    sibling.keyCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeNodes</span><span class="params">(BPlusNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">left</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">right</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; right.keyCount; j++) &#123;</span><br><span class="line">            left.keys[left.keyCount + j] = right.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = right.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left.keys[left.keyCount] = node.keys[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; right.keyCount; j++) &#123;</span><br><span class="line">            left.keys[left.keyCount + <span class="number">1</span> + j] = right.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= right.keyCount; j++) &#123;</span><br><span class="line">            left.children[left.keyCount + <span class="number">1</span> + j] = right.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left.keyCount += right.keyCount + (left.isLeaf ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; node.keyCount; j++) &#123;</span><br><span class="line">        node.keys[j - <span class="number">1</span>] = node.keys[j];</span><br><span class="line">        node.children[j] = node.children[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.keyCount--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="范围查询">范围查询</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n + k), 其中 k 是范围内的键数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(k) 用于存储结果</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rangeSearch</span><span class="params">(BPlusTree tree, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">node</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到第一个大于等于 low 的叶子节点</span></span><br><span class="line">    <span class="keyword">while</span> (!node.isLeaf) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; low &gt; node.keys[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历叶子节点链表</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; node.keyCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.keys[i] &gt;= low &amp;&amp; node.keys[i] &lt;= high) &#123;</span><br><span class="line">                result.add(node.keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.keys[i] &gt; high) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="遍历叶子节点顺序遍历">遍历（叶子节点顺序遍历）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(BPlusTree tree)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">node</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    <span class="keyword">while</span> (!node.isLeaf) &#123;</span><br><span class="line">        node = node.children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; node.keyCount; i++) &#123;</span><br><span class="line">            System.out.print(node.keys[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="使用示例-9">使用示例</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BPlusTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BPlusTree</span>(<span class="number">3</span>);  <span class="comment">// 最小度数 t=3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入键</span></span><br><span class="line">        insert(tree, <span class="number">10</span>);</span><br><span class="line">        insert(tree, <span class="number">20</span>);</span><br><span class="line">        insert(tree, <span class="number">5</span>);</span><br><span class="line">        insert(tree, <span class="number">6</span>);</span><br><span class="line">        insert(tree, <span class="number">12</span>);</span><br><span class="line">        insert(tree, <span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Traversal:&quot;</span>);</span><br><span class="line">        traverse(tree);  <span class="comment">// 输出: 5 6 10 12 20 30</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 搜索</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search 6: &quot;</span> + (search(tree, <span class="number">6</span>) != <span class="literal">null</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search 15: &quot;</span> + (search(tree, <span class="number">15</span>) != <span class="literal">null</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        delete(tree, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After deleting 6:&quot;</span>);</span><br><span class="line">        traverse(tree);  <span class="comment">// 输出: 5 10 12 20 30</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 范围查询</span></span><br><span class="line">        List&lt;Integer&gt; range = rangeSearch(tree, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Range [10, 20]: &quot;</span> + range);  <span class="comment">// 输出: [10, 12, 20]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="说明-5">说明</h6>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>搜索、插入、删除为 O(t log_t n)，t 是度数，n 是键总数。</li>
<li>范围查询为 O(t log_t n + k)，k 是范围内的键数。</li>
<li>遍历为 O(n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>每个节点占用 O(t) 空间，递归栈为 O(t)。</li>
<li>范围查询结果占用 O(k) 空间。</li>
</ul></li>
<li><strong>算法特点</strong>：
<ul>
<li><strong>插入</strong>：分裂时将中间键提升到父节点，叶子节点保持链表。</li>
<li><strong>删除</strong>：仅从叶子节点删除，通过借用或合并保持平衡。</li>
<li><strong>范围查询</strong>：利用叶子节点链表高效实现。</li>
</ul></li>
<li><strong>与 B 树的区别</strong>：
<ul>
<li>B+ 树叶子节点存储所有数据，非叶子节点仅用于导航。</li>
<li>叶子节点链表支持顺序访问和范围查询。</li>
</ul></li>
<li><strong>应用</strong>：
<ul>
<li>数据库索引（如 MySQL InnoDB），因其支持高效范围查询和顺序访问。</li>
</ul></li>
</ul>
<p>这个实现假设键为整数，t 为固定值。如果需要支持其他数据类型或动态
t，可以进一步修改。有什么具体需求，请告诉我！</p>
<h4 id="trie-前缀树">Trie (前缀树)</h4>
<p>Trie 是一种树形数据结构，特别适合处理字符串的前缀查询和搜索问题。</p>
<ul>
<li><strong>定义</strong>:
多叉树，用于存储字符串集合，每个节点代表一个字符。</li>
<li><strong>特性</strong>: 高效前缀查询，空间换时间。</li>
<li><strong>应用场景</strong>:
<ul>
<li>自动补全（如搜索引擎）</li>
<li>拼写检查</li>
<li>IP路由表</li>
</ul></li>
</ul>
<hr />
<h5 id="trie-节点定义">1. Trie 节点定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    TrieNode[] children;  <span class="comment">// 子节点数组，通常大小为字符集大小</span></span><br><span class="line">    <span class="type">boolean</span> isEnd;        <span class="comment">// 标记是否为单词结尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];  <span class="comment">// 假设只处理小写字母 a-z</span></span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="trie-基本类">2. Trie 基本类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TrieNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="trie-常用算法">3. Trie 常用算法</h5>
<h6 id="插入字符串">3.1 插入字符串</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(m), 其中 m 是字符串长度</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(m), 最坏情况下为每个字符创建一个新节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Trie trie, String word)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> trie.getRoot();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 假设小写字母</span></span><br><span class="line">        <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.children[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="literal">true</span>;  <span class="comment">// 标记单词结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="搜索完整单词">3.2 搜索完整单词</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(m), 其中 m 是单词长度</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(Trie trie, String word)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> trie.getRoot();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.isEnd;  <span class="comment">// 必须是单词结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="检查前缀">3.3 检查前缀</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(m), 其中 m 是前缀长度</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(Trie trie, String prefix)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> trie.getRoot();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 只要前缀存在即可，不要求是单词结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除字符串">3.4 删除字符串</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(m), 其中 m 是字符串长度</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1) 不考虑递归栈，递归栈为 O(m)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Trie trie, String word)</span> &#123;</span><br><span class="line">    deleteRec(trie.getRoot(), word, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">deleteRec</span><span class="params">(TrieNode node, String word, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == word.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node.isEnd) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不是单词结尾，无需删除</span></span><br><span class="line">        node.isEnd = <span class="literal">false</span>;  <span class="comment">// 取消单词结尾标记</span></span><br><span class="line">        <span class="keyword">return</span> isEmpty(node);  <span class="comment">// 检查是否可以删除该节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(depth) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">shouldDeleteCurrent</span> <span class="operator">=</span> deleteRec(node.children[index], word, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (shouldDeleteCurrent) &#123;</span><br><span class="line">        node.children[index] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> isEmpty(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(TrieNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (TrieNode child : node.children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !node.isEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找所有以某前缀开头的单词">3.5 查找所有以某前缀开头的单词</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(p + n), 其中 p 是前缀长度，n 是以该前缀开头的单词总数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(n), 用于存储结果</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWordsWithPrefix</span><span class="params">(Trie trie, String prefix)</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> trie.getRoot();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定位到前缀节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;  <span class="comment">// 前缀不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从该节点开始 DFS 收集所有单词</span></span><br><span class="line">    findWordsRec(node, prefix, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findWordsRec</span><span class="params">(TrieNode node, String prefix, List&lt;String&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.isEnd) &#123;</span><br><span class="line">        result.add(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.children[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            findWordsRec(node.children[i], prefix + (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + i), result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="计算-trie-中单词总数">3.6 计算 Trie 中单词总数</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 其中 n 是 Trie 中所有节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h), 其中 h 是 Trie 高度（递归栈）</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWords</span><span class="params">(Trie trie)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> countWordsRec(trie.getRoot());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countWordsRec</span><span class="params">(TrieNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> node.isEnd ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TrieNode child : node.children) &#123;</span><br><span class="line">        count += countWordsRec(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="使用示例-10">使用示例</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入单词</span></span><br><span class="line">        insert(trie, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        insert(trie, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        insert(trie, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 搜索单词</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search &#x27;apple&#x27;: &quot;</span> + search(trie, <span class="string">&quot;apple&quot;</span>));    <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search &#x27;app&#x27;: &quot;</span> + search(trie, <span class="string">&quot;app&quot;</span>));        <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search &#x27;appl&#x27;: &quot;</span> + search(trie, <span class="string">&quot;appl&quot;</span>));      <span class="comment">// 输出: false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查前缀</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Starts with &#x27;app&#x27;: &quot;</span> + startsWith(trie, <span class="string">&quot;app&quot;</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Starts with &#x27;ban&#x27;: &quot;</span> + startsWith(trie, <span class="string">&quot;ban&quot;</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除单词</span></span><br><span class="line">        delete(trie, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After deleting &#x27;app&#x27;, search &#x27;app&#x27;: &quot;</span> + search(trie, <span class="string">&quot;app&quot;</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找前缀单词</span></span><br><span class="line">        List&lt;String&gt; words = findWordsWithPrefix(trie, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Words with prefix &#x27;a&#x27;: &quot;</span> + words);  <span class="comment">// 输出: [apple]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计单词数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Total words: &quot;</span> + countWords(trie));  <span class="comment">// 输出: 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="说明-6">说明</h5>
<ul>
<li><strong>Trie 特点</strong>：
<ul>
<li>每个节点表示一个字符，路径表示字符串。</li>
<li>适合前缀查询、自动补全等场景。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>插入、搜索、检查前缀为 O(m)，m 是字符串长度。</li>
<li>删除为 O(m)，但涉及递归清理。</li>
<li>查找前缀单词为 O(p + n)，p 是前缀长度，n 是匹配单词数。</li>
<li>统计单词为 O(n)，n 是所有节点数。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>插入可能需要 O(m) 空间来存储新节点。</li>
<li>其他操作通常为 O(1) 或 O(h)，h 是 Trie 高度。</li>
</ul></li>
<li><strong>假设</strong>：
<ul>
<li>这里假设只处理小写字母（26 个字符）。如果需要支持更多字符（如 ASCII
或 Unicode），可以调整 <code>children</code> 数组大小。</li>
</ul></li>
<li><strong>扩展</strong>：
<ul>
<li>如果需要支持大小写、数字等，可以将 <code>children</code> 改为
<code>Map&lt;Character, TrieNode&gt;</code>。</li>
<li>如果需要其他算法（如最长公共前缀、模糊匹配等），可以告诉我，我会补充。</li>
</ul></li>
</ul>
<h2 id="哈希结构">哈希结构</h2>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 16%" />
<col style="width: 30%" />
<col style="width: 26%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th>数据结构</th>
<th>特点</th>
<th>冲突解决方法</th>
<th>操作</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>哈希表 (Hash Table)</strong></td>
<td>键值对存储，通过哈希函数快速定位</td>
<td>- <strong>链地址法</strong>：链表存储冲突元素<br>-
<strong>开放寻址法</strong>：探测下一个空位<br>包括线性探测、二次探测和双重哈希</td>
<td>插入：O(1)<br>删除：O(1)<br>查找：O(1)（理想情况下）</td>
<td>缓存（如Redis）<br>快速去重</td>
</tr>
</tbody>
</table>
<p>哈希表是一种基于键值对（Key-Value
Pair）的高效数据结构，通过哈希函数将键映射到存储位置，支持快速的插入、查找和删除操作。实现一个简单的哈希表，处理冲突使用<strong>链地址法</strong>（Separate
Chaining）。</p>
<hr />
<h3 id="哈希表节点定义链地址法">哈希表节点定义（链地址法）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    HashNode next;  <span class="comment">// 链表指针，处理冲突</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈希表基本类">哈希表基本类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashNode[] table;  <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;      <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;          <span class="comment">// 当前键值对数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTable</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">HashNode</span>[capacity];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简单哈希函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(key) % capacity;  <span class="comment">// 取模运算</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入键值对">插入键值对</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: 平均 O(1), 最坏 O(n)（冲突严重时）</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)（不计链表节点）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(HashTable ht, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ht.hash(key);</span><br><span class="line">    <span class="keyword">if</span> (ht.table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">        ht.table[index] = <span class="keyword">new</span> <span class="title class_">HashNode</span>(key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">HashNode</span> <span class="variable">current</span> <span class="operator">=</span> ht.table[index];</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.key == key) &#123;  <span class="comment">// 键已存在，更新值</span></span><br><span class="line">                current.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = <span class="keyword">new</span> <span class="title class_">HashNode</span>(key, value);  <span class="comment">// 插入到链表末尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    ht.size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找键值对">查找键值对</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: 平均 O(1), 最坏 O(n)（冲突严重时）</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(HashTable ht, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ht.hash(key);</span><br><span class="line">    <span class="type">HashNode</span> <span class="variable">current</span> <span class="operator">=</span> ht.table[index];</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> current.value;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除键值对">删除键值对</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: 平均 O(1), 最坏 O(n)（冲突严重时）</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(HashTable ht, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ht.hash(key);</span><br><span class="line">    <span class="type">HashNode</span> <span class="variable">current</span> <span class="operator">=</span> ht.table[index];</span><br><span class="line">    <span class="type">HashNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.key == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">                ht.table[index] = current.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ht.size--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检查键是否存在">检查键是否存在</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: 平均 O(1), 最坏 O(n)（冲突严重时）</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(HashTable ht, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ht.hash(key);</span><br><span class="line">    <span class="type">HashNode</span> <span class="variable">current</span> <span class="operator">=</span> ht.table[index];</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取所有键">获取所有键</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n + m), 其中 n 是键值对数，m 是数组容量</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(n)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getAllKeys</span><span class="params">(HashTable ht)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ht.capacity; i++) &#123;</span><br><span class="line">        <span class="type">HashNode</span> <span class="variable">current</span> <span class="operator">=</span> ht.table[i];</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            keys.add(current.key);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整容量动态扩容">调整容量（动态扩容）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(HashTable ht, <span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    HashNode[] oldTable = ht.table;</span><br><span class="line">    ht.table = <span class="keyword">new</span> <span class="title class_">HashNode</span>[newCapacity];</span><br><span class="line">    ht.capacity = newCapacity;</span><br><span class="line">    ht.size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (HashNode node : oldTable) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            put(ht, node.key, node.value);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="使用示例-11">使用示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashTable</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTable</span>(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入键值对</span></span><br><span class="line">        put(ht, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        put(ht, <span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">        put(ht, <span class="number">6</span>, <span class="number">600</span>);  <span class="comment">// 可能与 1 冲突（6 % 5 = 1）</span></span><br><span class="line">        put(ht, <span class="number">3</span>, <span class="number">300</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Get 2: &quot;</span> + get(ht, <span class="number">2</span>));    <span class="comment">// 输出: 200</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Get 6: &quot;</span> + get(ht, <span class="number">6</span>));    <span class="comment">// 输出: 600</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Get 5: &quot;</span> + get(ht, <span class="number">5</span>));    <span class="comment">// 输出: null</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Contains 1: &quot;</span> + containsKey(ht, <span class="number">1</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        remove(ht, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After removing 2, get 2: &quot;</span> + get(ht, <span class="number">2</span>));  <span class="comment">// 输出: null</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取所有键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;All keys: &quot;</span> + getAllKeys(ht));  <span class="comment">// 输出: [1, 6, 3]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        resize(ht, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After resize, get 6: &quot;</span> + get(ht, <span class="number">6</span>));  <span class="comment">// 输出: 600</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="说明-7">说明</h3>
<ul>
<li><strong>链地址法特点</strong>：
<ul>
<li>使用链表处理冲突，适合动态负载。</li>
<li>平均时间复杂度为 O(1)，但冲突严重时退化为 O(n)。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>插入、查找、删除：平均 O(1)，最坏 O(n)。</li>
<li>获取所有键和扩容：O(n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>基本操作 O(1)，存储所有键值对为 O(n)。</li>
<li>扩容时临时需要 O(n) 额外空间。</li>
</ul></li>
<li><strong>哈希函数</strong>：
<ul>
<li>这里使用简单的模运算，可根据需求优化（如乘法散列）。</li>
</ul></li>
<li><strong>负载因子</strong>：
<ul>
<li>当 size/capacity 超过某个阈值（如 0.7），应调用 <code>resize</code>
扩容以保持性能。</li>
</ul></li>
<li><strong>应用</strong>：
<ul>
<li>哈希表用于键值存储（如 HashMap）、缓存、数据库索引等。</li>
</ul></li>
</ul>
<h3 id="开放寻址法处理冲突">开放寻址法处理冲突</h3>
<hr />
<h4 id="哈希表基本类开放寻址法通用">哈希表基本类（开放寻址法通用）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAddressingHashTable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">boolean</span> isDeleted;  <span class="comment">// 懒删除标记</span></span><br><span class="line"></span><br><span class="line">        Entry(<span class="type">int</span> key, <span class="type">int</span> value) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.isDeleted = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">LOAD_FACTOR_THRESHOLD</span> <span class="operator">=</span> <span class="number">0.75</span>;  <span class="comment">// 负载因子阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAddressingHashTable</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始哈希函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(key) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个哈希函数（用于双重哈希）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash2</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> - (key % <span class="number">7</span>);  <span class="comment">// 确保步长不为 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCapacity</span><span class="params">()</span> &#123; <span class="keyword">return</span> capacity; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容 - 时间复杂度: O(n)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">        capacity = newCapacity;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : oldTable) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; !entry.isDeleted) &#123;</span><br><span class="line">                putLinear(entry.key, entry.value);  <span class="comment">// 选择一种方法重新插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查负载因子并扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkLoadFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">double</span>) size / capacity &gt;= LOAD_FACTOR_THRESHOLD) &#123;</span><br><span class="line">            resize(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="线性探测linear-probing实现">线性探测（Linear Probing）实现</h4>
<p>发生冲突时，线性向后查找下一个空位。时间复杂度：平均
O(1)，但随着负载因子增加，可能退化为 O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性探测函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">probeLinear</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (hash(key) + i) % capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putLinear</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    checkLoadFactor();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeLinear(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span> || table[index].isDeleted) &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (table[index].key == key) &#123;</span><br><span class="line">            table[index].value = value;  <span class="comment">// 更新值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Hash table is full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getLinear</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeLinear(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> table[index].value;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeLinear</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeLinear(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">            table[index].isDeleted = <span class="literal">true</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="二次探测quadratic-probing实现">二次探测（Quadratic
Probing）实现</h4>
<p>冲突时按二次函数（i²）偏移查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二次探测函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">probeQuadratic</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (hash(key) + i * i) % capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putQuadratic</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    checkLoadFactor();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeQuadratic(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span> || table[index].isDeleted) &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (table[index].key == key) &#123;</span><br><span class="line">            table[index].value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Hash table is full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getQuadratic</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeQuadratic(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> table[index].value;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeQuadratic</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeQuadratic(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">            table[index].isDeleted = <span class="literal">true</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="双重哈希double-hashing实现">双重哈希（Double Hashing）实现</h4>
<p>使用第二个哈希函数确定探测步长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 双重哈希探测函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">probeDouble</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (hash(key) + i * hash2(key)) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putDouble</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        checkLoadFactor();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            index = probeDouble(key, i);</span><br><span class="line">            <span class="keyword">if</span> (table[index] == <span class="literal">null</span> || table[index].isDeleted) &#123;</span><br><span class="line">                table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (table[index].key == key) &#123;</span><br><span class="line">                table[index].value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; capacity);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Hash table is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getDouble</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            index = probeDouble(key, i);</span><br><span class="line">            <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> table[index].value;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeDouble</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            index = probeDouble(key, i);</span><br><span class="line">            <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">                table[index].isDeleted = <span class="literal">true</span>;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="使用示例-12">使用示例</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="type">OpenAddressingHashTable</span> <span class="variable">htLinear</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenAddressingHashTable</span>(<span class="number">5</span>);</span><br><span class="line">        htLinear.putLinear(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        htLinear.putLinear(<span class="number">6</span>, <span class="number">600</span>);  <span class="comment">// 冲突：6 % 5 = 1</span></span><br><span class="line">        htLinear.putLinear(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Linear Probing - Get 6: &quot;</span> + htLinear.getLinear(<span class="number">6</span>));  <span class="comment">// 输出: 600</span></span><br><span class="line">        htLinear.removeLinear(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Linear Probing - After remove 6: &quot;</span> + htLinear.getLinear(<span class="number">6</span>));  <span class="comment">// 输出: null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二次探测</span></span><br><span class="line">        <span class="type">OpenAddressingHashTable</span> <span class="variable">htQuadratic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenAddressingHashTable</span>(<span class="number">5</span>);</span><br><span class="line">        htQuadratic.putQuadratic(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        htQuadratic.putQuadratic(<span class="number">6</span>, <span class="number">600</span>);</span><br><span class="line">        htQuadratic.putQuadratic(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Quadratic Probing - Get 6: &quot;</span> + htQuadratic.getQuadratic(<span class="number">6</span>));  <span class="comment">// 输出: 600</span></span><br><span class="line">        htQuadratic.removeQuadratic(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Quadratic Probing - After remove 6: &quot;</span> + htQuadratic.getQuadratic(<span class="number">6</span>));  <span class="comment">// 输出: null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双重哈希</span></span><br><span class="line">        <span class="type">OpenAddressingHashTable</span> <span class="variable">htDouble</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenAddressingHashTable</span>(<span class="number">5</span>);</span><br><span class="line">        htDouble.putDouble(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        htDouble.putDouble(<span class="number">6</span>, <span class="number">600</span>);</span><br><span class="line">        htDouble.putDouble(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Double Hashing - Get 6: &quot;</span> + htDouble.getDouble(<span class="number">6</span>));  <span class="comment">// 输出: 600</span></span><br><span class="line">        htDouble.removeDouble(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Double Hashing - After remove 6: &quot;</span> + htDouble.getDouble(<span class="number">6</span>));  <span class="comment">// 输出: null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="说明-8">说明</h4>
<ul>
<li><strong>负载因子控制</strong>：
<ul>
<li>设置 <code>LOAD_FACTOR_THRESHOLD = 0.75</code>，当 size/capacity ≥
0.75 时，自动扩容为两倍容量。</li>
<li>扩容通过 <code>resize</code> 方法实现，时间复杂度 O(n)。</li>
</ul></li>
<li><strong>冲突处理方法</strong>：
<ul>
<li><strong>线性探测</strong>：简单，但容易主聚集。</li>
<li><strong>二次探测</strong>：减少主聚集，但可能次聚集，需确保容量为素数以覆盖所有位置。</li>
<li><strong>双重哈希</strong>：最优，避免聚集，但需设计合适的第二个哈希函数。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>平均 O(1)（负载因子低时），最坏 O(n)（表满或聚集严重）。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>O(1) 额外空间（不计数组本身），扩容时临时需要 O(n)。</li>
</ul></li>
<li><strong>优化点</strong>：
<ul>
<li>这里使用懒删除（标记删除），避免破坏探测序列。</li>
<li>哈希函数简单，可根据实际需求优化（如乘法散列）。</li>
<li>二次探测和双重哈希未强制容量为素数，实际应用中建议调整。</li>
</ul></li>
</ul>
<h2 id="图结构">图结构</h2>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 24%" />
<col style="width: 43%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>类别</th>
<th>内容</th>
<th>描述</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>表示方式</strong></td>
<td><strong>邻接矩阵</strong></td>
<td>二维数组表示顶点关系，<code>matrix[i][j]</code>表示边权重或是否存在边</td>
<td>适合稠密图（边较多）</td>
</tr>
<tr class="even">
<td></td>
<td><strong>邻接表</strong></td>
<td>链表数组表示顶点关系，每个顶点关联一个邻接顶点链表</td>
<td>适合稀疏图（边较少）</td>
</tr>
<tr class="odd">
<td><strong>算法场景</strong></td>
<td><strong>最短路径 (Dijkstra算法)</strong></td>
<td>从单一源点计算到所有顶点的最短路径，基于贪心策略</td>
<td>网络路由、路径规划</td>
</tr>
<tr class="even">
<td></td>
<td><strong>最小生成树 (Prim/Kruskal算法)</strong></td>
<td>- <strong>Prim</strong>：从某顶点扩展生成树<br>-
<strong>Kruskal</strong>：按边权重排序合并</td>
<td>网络设计（如电缆布线）</td>
</tr>
<tr class="odd">
<td></td>
<td><strong>拓扑排序</strong></td>
<td>对有向无环图（DAG）排序，输出顶点线性序列</td>
<td>任务调度、依赖解析（如编译顺序）</td>
</tr>
</tbody>
</table>
<h3 id="定义">定义</h3>
<p>图（Graph）是由 <strong>顶点 (Vertex)</strong> 和 <strong>边
(Edge)</strong> 构成的数据结构，可以用来表示对象之间的关系。</p>
<ul>
<li><strong>有向图 (Directed Graph)</strong>：边有方向。</li>
<li><strong>无向图 (Undirected Graph)</strong>：边无方向。</li>
<li><strong>加权图 (Weighted Graph)</strong>：边带有权值。</li>
<li><strong>邻接矩阵</strong>：适合稠密图，存储空间 O(V²)。</li>
<li><strong>邻接表</strong>：适合稀疏图，存储空间 O(V + E)。</li>
</ul>
<h3 id="图的表示">图的表示</h3>
<p>在实际工程中，图算法几乎都用 <strong>邻接表</strong>
而不是邻接矩阵，因为邻接表只占 <strong>O(V+E)</strong>
空间，适合现实中的稀疏图；遍历效率高（O(V+E) vs
O(V²)）；实现更贴近实际场景如社交网络、路网、依赖图，而邻接矩阵仅在小规模稠密图或需要
O(1) 判断边存在时才会用。</p>
<h4 id="邻接矩阵表示">邻接矩阵表示</h4>
<h5 id="定义-1">定义</h5>
<p>邻接矩阵 (Adjacency Matrix) 用一个二维数组 <code>matrix[V][V]</code>
表示图：</p>
<ul>
<li><strong>无向图</strong>：如果存在边 (u, v)，则
<code>matrix[u][v] = matrix[v][u] = 1</code>。</li>
<li><strong>有向图</strong>：如果存在边 u → v，则
<code>matrix[u][v] = 1</code>。</li>
<li><strong>加权图</strong>：边权值存储在 <code>matrix[u][v]</code>
中，没有边则用 <code>0</code> 或 <code>∞</code> 表示。</li>
<li><strong>空间复杂度</strong>：O(V²)，适合稠密图。</li>
<li><strong>时间复杂度</strong>：判断是否存在一条边为 O(1)。</li>
</ul>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;  <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;           <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphMatrix</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        matrix = <span class="keyword">new</span> <span class="title class_">int</span>[V][V];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边 (无向图)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        matrix[u][v] = <span class="number">1</span>;</span><br><span class="line">        matrix[v][u] = <span class="number">1</span>; <span class="comment">// 如果是有向图，这行去掉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加加权边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWeightedEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        matrix[u][v] = weight;</span><br><span class="line">        matrix[v][u] = weight; <span class="comment">// 无向图对称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[u][v] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印邻接矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">                System.out.print(matrix[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历算法">遍历算法</h5>
<h6 id="深度优先搜索-dfs">1. 深度优先搜索 (DFS)</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    System.out.print(start + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[start][v] != <span class="number">0</span> &amp;&amp; !visited[v]) &#123;</span><br><span class="line">            dfs(v, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(V²)</li>
<li><strong>空间复杂度</strong>：O(V)</li>
</ul>
<hr />
<h6 id="广度优先搜索-bfs">2. 广度优先搜索 (BFS)</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    queue.offer(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(u + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[u][v] != <span class="number">0</span> &amp;&amp; !visited[v]) &#123;</span><br><span class="line">                visited[v] = <span class="literal">true</span>;</span><br><span class="line">                queue.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(V²)</li>
<li><strong>空间复杂度</strong>：O(V)</li>
</ul>
<hr />
<h5 id="使用示例-13">使用示例</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GraphMatrix</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphMatrix</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;邻接矩阵:&quot;</span>);</span><br><span class="line">    g.printGraph();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;DFS 遍历:&quot;</span>);</span><br><span class="line">    g.dfs(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">4</span>]);  <span class="comment">// 输出: 0 1 2 3</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\nBFS 遍历:&quot;</span>);</span><br><span class="line">    g.bfs(<span class="number">0</span>);  <span class="comment">// 输出: 0 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结">总结</h5>
<ul>
<li>邻接矩阵适合 <strong>稠密图</strong>，判断边是否存在很快 O(1)。</li>
<li>但空间开销大 (O(V²))，不适合稀疏图。</li>
<li>遍历复杂度 O(V²)，在稠密图和顶点不太多的情况下效果很好。</li>
</ul>
<h4 id="邻接表表示">邻接表表示</h4>
<h5 id="定义-2">定义</h5>
<p>邻接表 (Adjacency List) 是用 <strong>链表 / 动态数组</strong>
存储每个顶点的相邻顶点集合。</p>
<ul>
<li><strong>空间复杂度</strong>：O(V + E)，适合
<strong>稀疏图</strong>。</li>
<li><strong>时间复杂度</strong>：判断是否存在边需要
O(度(v))，不如邻接矩阵快。</li>
<li><strong>常见实现</strong>：
<ul>
<li>数组 + 链表（C/C++ 常见）</li>
<li><code>ArrayList&lt;List&lt;Integer&gt;&gt;</code>（Java 常用）</li>
</ul></li>
</ul>
<h5 id="代码-1">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;  <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; adj;  <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphList</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); <span class="comment">// 每个顶点有一个邻接链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边 (无向图)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        adj.get(u).add(v);</span><br><span class="line">        adj.get(v).add(u); <span class="comment">// 如果是有向图，这行去掉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取邻居</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNeighbors</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adj.get(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(i)) &#123;</span><br><span class="line">                System.out.print(neighbor + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历">遍历</h5>
<h6 id="深度优先搜索-dfs-1">深度优先搜索 (DFS)</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    System.out.print(u + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(u)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            dfs(neighbor, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(V + E)</li>
<li><strong>空间复杂度</strong>：O(V)</li>
</ul>
<h6 id="广度优先搜索-bfs-1">广度优先搜索 (BFS)</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    queue.offer(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(u + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                queue.offer(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(V + E)</li>
<li><strong>空间复杂度</strong>：O(V)</li>
</ul>
<h5 id="使用示例-14">使用示例</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GraphList</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphList</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.addEdge(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;邻接表表示:&quot;</span>);</span><br><span class="line">    g.printGraph();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;DFS 遍历:&quot;</span>);</span><br><span class="line">    g.dfs(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">5</span>]);  <span class="comment">// 输出: 0 1 3 2 4</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\nBFS 遍历:&quot;</span>);</span><br><span class="line">    g.bfs(<span class="number">0</span>);  <span class="comment">// 输出: 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="总结对比">总结对比</h4>
<ul>
<li><strong>邻接矩阵</strong>：O(1) 判断边是否存在，空间
O(V²)，适合稠密图。</li>
<li><strong>邻接表</strong>：空间 O(V + E)，遍历高效，适合稀疏图。</li>
</ul>
<hr />
<h3 id="图的常见算法">图的常见算法</h3>
<h4 id="最短路径">最短路径</h4>
<h5 id="dijkstra非负权图oe-log-v">Dijkstra（非负权图，O(E log V)）</h5>
<ul>
<li><strong>邻接矩阵版</strong>（适合稠密图，复杂度 O(V²)）</li>
<li><strong>邻接表 + 最小堆版</strong>（适合稀疏图，复杂度 O(E log
V)）</li>
</ul>
<h6 id="邻接矩阵实现ov²">1. 邻接矩阵实现（O(V²)）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DijkstraMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DijkstraMatrix</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        graph = <span class="keyword">new</span> <span class="title class_">int</span>[V][V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            Arrays.fill(graph[i], Integer.MAX_VALUE); <span class="comment">// 无边记为无穷大</span></span><br><span class="line">            graph[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        graph[u][v] = w;</span><br><span class="line">        graph[v][u] = w; <span class="comment">// 如果是有向图就去掉这行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> src)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> minDistance(dist, visited);</span><br><span class="line">            visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; graph[u][v] != Integer.MAX_VALUE </span><br><span class="line">                    &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                    dist[v] = dist[u] + graph[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printSolution(dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(<span class="type">int</span>[] dist, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE, minIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class="line">                min = dist[v];</span><br><span class="line">                minIndex = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printSolution</span><span class="params">(<span class="type">int</span>[] dist)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vertex Distance from Source:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; \t &quot;</span> + dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DijkstraMatrix</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DijkstraMatrix</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        g.dijkstra(<span class="number">0</span>); <span class="comment">// 从 0 号点开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="邻接表-最小堆实现oe-log-v">2. 邻接表 + 最小堆实现（O(E log
V)）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DijkstraList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Node&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> vertex, weight;</span><br><span class="line">        Node(<span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">            vertex = v;</span><br><span class="line">            weight = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DijkstraList</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        adj.get(u).add(<span class="keyword">new</span> <span class="title class_">Node</span>(v, w));</span><br><span class="line">        adj.get(v).add(<span class="keyword">new</span> <span class="title class_">Node</span>(u, w)); <span class="comment">// 如果是有向图就去掉这行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> src)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(n -&gt; n.weight));</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(src, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> node.vertex;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node neighbor : adj.get(u)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> neighbor.vertex;</span><br><span class="line">                <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> neighbor.weight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dist[u] + weight &lt; dist[v]) &#123;</span><br><span class="line">                    dist[v] = dist[u] + weight;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(v, dist[v]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printSolution(dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printSolution</span><span class="params">(<span class="type">int</span>[] dist)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vertex Distance from Source:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; \t &quot;</span> + dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DijkstraList</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DijkstraList</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        g.dijkstra(<span class="number">0</span>); <span class="comment">// 从 0 号点开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="对比总结">对比总结</h6>
<table>
<thead>
<tr class="header">
<th>实现方式</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>适合场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>邻接矩阵</td>
<td>O(V²)</td>
<td>O(V²)</td>
<td>稠密图（边接近 V²）</td>
</tr>
<tr class="even">
<td>邻接表 + 堆</td>
<td>O(E log V)</td>
<td>O(V+E)</td>
<td>稀疏图（边远小于 V²）</td>
</tr>
</tbody>
</table>
<h5 id="bellman-ford支持负权ove">Bellman-Ford（支持负权，O(VE)）</h5>
<h6 id="邻接矩阵实现ov³">1. 邻接矩阵实现（O(V³)）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BellmanFordMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BellmanFordMatrix</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        graph = <span class="keyword">new</span> <span class="title class_">int</span>[V][V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            Arrays.fill(graph[i], Integer.MAX_VALUE);</span><br><span class="line">            graph[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        graph[u][v] = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bellmanFord</span><span class="params">(<span class="type">int</span> src)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行 V-1 轮松弛</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; V - <span class="number">1</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (graph[u][v] != Integer.MAX_VALUE &amp;&amp; dist[u] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                            dist[v] = dist[u] + graph[u][v];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测负权回路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[u][v] != Integer.MAX_VALUE &amp;&amp; dist[u] != Integer.MAX_VALUE</span><br><span class="line">                    &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;图中包含负权回路！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printSolution(dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printSolution</span><span class="params">(<span class="type">int</span>[] dist)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vertex Distance from Source:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; \t &quot;</span> + dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BellmanFordMatrix</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BellmanFordMatrix</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">3</span>, -<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        g.bellmanFord(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="邻接表实现ove">2. 邻接表实现（O(VE)）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BellmanFordList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> src, dest, weight;</span><br><span class="line">        Edge(<span class="type">int</span> s, <span class="type">int</span> d, <span class="type">int</span> w) &#123;</span><br><span class="line">            src = s;</span><br><span class="line">            dest = d;</span><br><span class="line">            weight = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BellmanFordList</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">Edge</span>(u, v, w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bellmanFord</span><span class="params">(<span class="type">int</span> src)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// V-1 轮松弛</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[edge.src] != Integer.MAX_VALUE </span><br><span class="line">                    &amp;&amp; dist[edge.src] + edge.weight &lt; dist[edge.dest]) &#123;</span><br><span class="line">                    dist[edge.dest] = dist[edge.src] + edge.weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测负权回路</span></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[edge.src] != Integer.MAX_VALUE </span><br><span class="line">                &amp;&amp; dist[edge.src] + edge.weight &lt; dist[edge.dest]) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;图中包含负权回路！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printSolution(dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printSolution</span><span class="params">(<span class="type">int</span>[] dist)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vertex Distance from Source:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; \t &quot;</span> + dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BellmanFordList</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BellmanFordList</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">3</span>, -<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        g.bellmanFord(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="总结-1">总结</h6>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th>实现方式</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>邻接矩阵版</td>
<td>O(V³)</td>
<td>O(V²)</td>
<td>三重循环，适合稠密图，但性能差</td>
</tr>
<tr class="even">
<td>邻接表版</td>
<td>O(VE)</td>
<td>O(V+E)</td>
<td>实际常用，性能更好，便于处理边集</td>
</tr>
</tbody>
</table>
<h4 id="最小生成树-mst">最小生成树 (MST)</h4>
<h5 id="prim适合稠密图">Prim（适合稠密图）</h5>
<h6 id="邻接矩阵实现ov²-1">1. 邻接矩阵实现（O(V²)）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrimMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrimMatrix</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        graph = <span class="keyword">new</span> <span class="title class_">int</span>[V][V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            Arrays.fill(graph[i], Integer.MAX_VALUE);</span><br><span class="line">            graph[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        graph[u][v] = w;</span><br><span class="line">        graph[v][u] = w; <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primMST</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] key = <span class="keyword">new</span> <span class="title class_">int</span>[V];        <span class="comment">// 最小边权</span></span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[V];     <span class="comment">// 记录生成树结构</span></span><br><span class="line">        <span class="type">boolean</span>[] inMST = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(key, Integer.MAX_VALUE);</span><br><span class="line">        key[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 从顶点0开始</span></span><br><span class="line">        parent[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; count &lt; V - <span class="number">1</span>; count++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> minKey(key, inMST);</span><br><span class="line">            inMST[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[u][v] != Integer.MAX_VALUE &amp;&amp; !inMST[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class="line">                    parent[v] = u;</span><br><span class="line">                    key[v] = graph[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printMST(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">minKey</span><span class="params">(<span class="type">int</span>[] key, <span class="type">boolean</span>[] inMST)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE, minIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inMST[v] &amp;&amp; key[v] &lt; min) &#123;</span><br><span class="line">                min = key[v];</span><br><span class="line">                minIndex = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMST</span><span class="params">(<span class="type">int</span>[] parent)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Edge \tWeight&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(parent[i] + <span class="string">&quot; - &quot;</span> + i + <span class="string">&quot;\t&quot;</span> + graph[i][parent[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrimMatrix</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimMatrix</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        g.primMST();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="邻接表-最小堆实现oe-log-v-1">2. 邻接表 + 最小堆实现（O(E log
V)）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrimList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Node&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> vertex, weight;</span><br><span class="line">        Node(<span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">            vertex = v;</span><br><span class="line">            weight = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrimList</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        adj.get(u).add(<span class="keyword">new</span> <span class="title class_">Node</span>(v, w));</span><br><span class="line">        adj.get(v).add(<span class="keyword">new</span> <span class="title class_">Node</span>(u, w)); <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primMST</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] inMST = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        <span class="type">int</span>[] key = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        Arrays.fill(key, Integer.MAX_VALUE);</span><br><span class="line">        key[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        parent[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(n -&gt; n.weight));</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> node.vertex;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inMST[u]) <span class="keyword">continue</span>;</span><br><span class="line">            inMST[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node neighbor : adj.get(u)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> neighbor.vertex;</span><br><span class="line">                <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> neighbor.weight;</span><br><span class="line">                <span class="keyword">if</span> (!inMST[v] &amp;&amp; w &lt; key[v]) &#123;</span><br><span class="line">                    key[v] = w;</span><br><span class="line">                    parent[v] = u;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(v, w));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printMST(parent, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMST</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span>[] key)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Edge \tWeight&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(parent[i] + <span class="string">&quot; - &quot;</span> + i + <span class="string">&quot;\t&quot;</span> + key[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrimList</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimList</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        g.primMST();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="总结对比-1">总结对比</h6>
<table>
<thead>
<tr class="header">
<th>实现方式</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>适合场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>邻接矩阵版</td>
<td>O(V²)</td>
<td>O(V²)</td>
<td>稠密图</td>
</tr>
<tr class="even">
<td>邻接表 + 堆版</td>
<td>O(E log V)</td>
<td>O(V+E)</td>
<td>稀疏图</td>
</tr>
</tbody>
</table>
<h5
id="kruskal适合稀疏图结合并查集">Kruskal（适合稀疏图，结合并查集）</h5>
<p>和 Prim 不同，Kruskal 不依赖邻接矩阵/邻接表，而是依赖 <strong>边集
(Edge List)</strong>，再结合 <strong>并查集 (Union-Find)</strong>
来避免成环</p>
<h6 id="核心思路">核心思路</h6>
<ol type="1">
<li>将所有边按照 <strong>权值从小到大排序</strong>。</li>
<li>从小到大遍历边 <code>(u, v)</code>：
<ul>
<li>如果 <code>u</code> 和 <code>v</code> 不在同一个连通分量（即
<code>find(u) != find(v)</code>），则选中这条边，并合并集合。</li>
<li>否则跳过（避免成环）。</li>
</ul></li>
<li>直到选中 <code>V-1</code> 条边。</li>
</ol>
<ul>
<li><strong>时间复杂度</strong>：O(E log E)，主要来自边排序。</li>
<li><strong>空间复杂度</strong>：O(V + E)。</li>
<li><strong>适合场景</strong>：稀疏图 / 需要直接操作边集。</li>
</ul>
<hr />
<h6 id="java-实现">Java 实现</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KruskalMST</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> u, v, weight;</span><br><span class="line">        Edge(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">            <span class="built_in">this</span>.u = u;</span><br><span class="line">            <span class="built_in">this</span>.v = v;</span><br><span class="line">            <span class="built_in">this</span>.weight = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] parent, rank;</span><br><span class="line">        UnionFind(<span class="type">int</span> n) &#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x), rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) parent[rootX] = rootY;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) parent[rootY] = rootX;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">                rank[rootX]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KruskalMST</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">Edge</span>(u, v, w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kruskalMST</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 按照权值升序排序</span></span><br><span class="line">        edges.sort(Comparator.comparingInt(e -&gt; e.weight));</span><br><span class="line"></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(V);</span><br><span class="line">        List&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf.find(edge.u) != uf.find(edge.v)) &#123;</span><br><span class="line">                result.add(edge);</span><br><span class="line">                uf.union(edge.u, edge.v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Edge \tWeight&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Edge e : result) &#123;</span><br><span class="line">            System.out.println(e.u + <span class="string">&quot; - &quot;</span> + e.v + <span class="string">&quot;\t&quot;</span> + e.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">KruskalMST</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KruskalMST</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        g.kruskalMST();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="示例输出">📌 示例输出</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Edge    Weight</span><br><span class="line">2 - 3   4</span><br><span class="line">0 - 3   5</span><br><span class="line">0 - 1   10</span><br></pre></td></tr></table></figure>
<p>说明选中的边构成最小生成树，总权值最小。</p>
<hr />
<h5 id="对比-mst-三大算法">对比 MST 三大算法</h5>
<table>
<thead>
<tr class="header">
<th>算法</th>
<th>时间复杂度</th>
<th>适合场景</th>
<th>依赖结构</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Prim(矩阵)</td>
<td>O(V²)</td>
<td>稠密图</td>
<td>邻接矩阵</td>
</tr>
<tr class="even">
<td>Prim(堆+表)</td>
<td>O(E log V)</td>
<td>稀疏图</td>
<td>邻接表</td>
</tr>
<tr class="odd">
<td>Kruskal</td>
<td>O(E log E)</td>
<td>稀疏图</td>
<td>边集+并查集</td>
</tr>
</tbody>
</table>
<h4 id="拓扑排序">拓扑排序</h4>
<p>适用范围：<strong>有向无环图 (DAG)</strong></p>
<p>作用：线性排序，使得每条有向边 <code>(u → v)</code>
中，<code>u</code> 在排序结果中出现在 <code>v</code> 之前。</p>
<p>常见应用：任务调度、编译依赖顺序、课程安排等。</p>
<h5 id="kahn-算法bfs-入度法">Kahn 算法（BFS 入度法）</h5>
<ul>
<li>思路：
<ol type="1">
<li>统计所有顶点的入度。</li>
<li>将入度为 0 的节点入队。</li>
<li>每次出队一个节点，把它加入结果，同时减少其邻居的入度。</li>
<li>若邻居入度降为 0，则入队。</li>
</ol></li>
<li>时间复杂度：O(V + E)</li>
<li>空间复杂度：O(V + E)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopoSortKahn</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TopoSortKahn</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        adj.get(u).add(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topoSort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) &#123;</span><br><span class="line">                inDegree[v]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            result.add(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) queue.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.size() != V) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;图中存在环，无法进行拓扑排序！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;拓扑排序结果: &quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TopoSortKahn</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopoSortKahn</span>(<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        g.topoSort(); <span class="comment">// 可能输出: [4, 5, 0, 2, 3, 1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dfs-逆后序">DFS 逆后序</h5>
<ul>
<li>思路：
<ol type="1">
<li>用 DFS 遍历每个顶点。</li>
<li>当某个顶点的所有邻居都访问完成后，把该顶点压栈。</li>
<li>最终输出栈中的元素（即逆后序遍历）。</li>
</ol></li>
<li>时间复杂度：O(V + E)</li>
<li>空间复杂度：O(V + E)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopoSortDFS</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TopoSortDFS</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        adj.get(u).add(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topoSort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                dfs(i, visited, stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;拓扑排序结果: &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">boolean</span>[] visited, Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                dfs(v, visited, stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(u); <span class="comment">// 后序压栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TopoSortDFS</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopoSortDFS</span>(<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        g.topoSort(); <span class="comment">// 可能输出: 5 4 2 3 1 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对比总结-1">对比总结</h5>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Kahn(BFS)</td>
<td>O(V+E)</td>
<td>O(V+E)</td>
<td>直观、可检测环（若结果顶点数 &lt; V，则有环）</td>
</tr>
<tr class="even">
<td>DFS逆后序</td>
<td>O(V+E)</td>
<td>O(V+E)</td>
<td>实现简洁，天然给出拓扑序</td>
</tr>
</tbody>
</table>
<h2 id="高级数据结构">高级数据结构</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 17%" />
<col style="width: 28%" />
<col style="width: 35%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th>数据结构</th>
<th>特点</th>
<th>操作</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>并查集 (Union-Find)</strong></td>
<td>管理元素分组，支持合并集合和查询所属集合</td>
<td>合并（Union）：近似O(1)<br>查找（Find）：近似O(1)（路径压缩优化后）</td>
<td>连通性问题（如社交网络好友关系）</td>
</tr>
<tr class="even">
<td><strong>跳表 (Skip List)</strong></td>
<td>多层链表结构，利用概率平衡，提升查询效率</td>
<td>插入：O(log n)<br>删除：O(log n)<br>查找：O(log n)</td>
<td>Redis有序集合实现</td>
</tr>
<tr class="odd">
<td><strong>布隆过滤器 (Bloom Filter)</strong></td>
<td>概率型数据结构，判断元素“可能存在”或“一定不存在”</td>
<td>添加：O(1)<br>查询：O(1)</td>
<td>缓存穿透防护<br>垃圾邮件过滤</td>
</tr>
</tbody>
</table>
<h3 id="跳表-skip-list">1. 跳表 (Skip List)</h3>
<ul>
<li><strong>特点</strong>：基于多层链表的概率型数据结构，支持 O(log n)
查找。</li>
<li><strong>操作</strong>：插入、删除、查找。</li>
<li><strong>场景</strong>：替代平衡树（如 Redis 的有序集合）。</li>
</ul>
<p>下面给出一个<strong>可运行的 Java 跳表 (Skip List)</strong>
实现，包含：查找、插入（可更新）、删除三大操作，均期望 <strong>O(log
n)</strong>。为避免泛型数组带来的繁琐，这里用
<code>int key / int val</code> 版本，逻辑清晰好改造。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_LEVEL</span> <span class="operator">=</span> <span class="number">32</span>;   <span class="comment">// 允许的最大层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">P</span> <span class="operator">=</span> <span class="number">0.5</span>;       <span class="comment">// 提升层数的概率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳表节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key, val;</span><br><span class="line">        Node[] next; <span class="comment">// 各层前进指针</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> level, <span class="type">int</span> key, <span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="keyword">new</span> <span class="title class_">Node</span>[level];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(MAX_LEVEL, Integer.MIN_VALUE, <span class="number">0</span>); <span class="comment">// 头哨兵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 当前实际层数（至少为 1）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机决定新节点的层数（几何分布）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lv</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lv &lt; MAX_LEVEL &amp;&amp; rnd.nextDouble() &lt; P) lv++;</span><br><span class="line">        <span class="keyword">return</span> lv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找：存在返回对应值，不存在返回 null</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p.next[i] != <span class="literal">null</span> &amp;&amp; p.next[i].key &lt; key) &#123;</span><br><span class="line">                p = p.next[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> (p != <span class="literal">null</span> &amp;&amp; p.key == key) ? p.val : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或更新：若 key 已存在则更新 val；否则按随机层数插入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        Node[] update = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX_LEVEL];</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p.next[i] != <span class="literal">null</span> &amp;&amp; p.next[i].key &lt; key) &#123;</span><br><span class="line">                p = p.next[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> p.next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; x.key == key) &#123;</span><br><span class="line">            <span class="comment">// 已存在 → 更新</span></span><br><span class="line">            x.val = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lv</span> <span class="operator">=</span> randomLevel();</span><br><span class="line">        <span class="keyword">if</span> (lv &gt; level) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level; i &lt; lv; i++) &#123;</span><br><span class="line">                update[i] = head;</span><br><span class="line">            &#125;</span><br><span class="line">            level = lv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(lv, key, val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">            newNode.next[i] = update[i].next[i];</span><br><span class="line">            update[i].next[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除：存在返回 true，不存在返回 false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        Node[] update = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX_LEVEL];</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p.next[i] != <span class="literal">null</span> &amp;&amp; p.next[i].key &lt; key) &#123;</span><br><span class="line">                p = p.next[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> p.next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || x.key != key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i].next[i] != x) <span class="keyword">break</span>;</span><br><span class="line">            update[i].next[i] = x.next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缩减当前层数（若最高层已空）</span></span><br><span class="line">        <span class="keyword">while</span> (level &gt; <span class="number">1</span> &amp;&amp; head.next[level - <span class="number">1</span>] == <span class="literal">null</span>) level--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试打印（从底层打印）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.next[i];</span><br><span class="line">            System.out.print(<span class="string">&quot;L&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span> + p.key + <span class="string">&quot;,&quot;</span> + p.val + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">                p = p.next[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SkipList</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkipList</span>();</span><br><span class="line">        sl.put(<span class="number">3</span>, <span class="number">30</span>);</span><br><span class="line">        sl.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        sl.put(<span class="number">7</span>, <span class="number">70</span>);</span><br><span class="line">        sl.put(<span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line">        sl.put(<span class="number">9</span>, <span class="number">90</span>);</span><br><span class="line">        sl.print();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;search(7) = &quot;</span> + sl.search(<span class="number">7</span>)); <span class="comment">// 70</span></span><br><span class="line">        System.out.println(<span class="string">&quot;search(2) = &quot;</span> + sl.search(<span class="number">2</span>)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        sl.put(<span class="number">5</span>, <span class="number">500</span>); <span class="comment">// 更新</span></span><br><span class="line">        System.out.println(<span class="string">&quot;search(5) = &quot;</span> + sl.search(<span class="number">5</span>)); <span class="comment">// 500</span></span><br><span class="line"></span><br><span class="line">        sl.remove(<span class="number">3</span>);</span><br><span class="line">        sl.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong>（期望）：</p>
<ul>
<li>查找 / 插入 / 删除：<strong>O(log n)</strong></li>
<li>空间：<strong>O(n)</strong>（每个节点期望有常数条“提升”指针）</li>
</ul>
<hr />
<h3 id="并查集-union-find">2. 并查集 (Union-Find)</h3>
<ul>
<li><strong>特点</strong>：用于集合划分，支持快速合并与查找。</li>
<li><strong>操作</strong>：<code>find</code>（查找根节点）、<code>union</code>（合并集合）。</li>
<li><strong>优化</strong>：路径压缩 + 按秩合并。</li>
<li><strong>场景</strong>：连通分量、最小生成树 Kruskal 算法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x), rootY = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX == rootY) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) parent[rootX] = rootY;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) parent[rootY] = rootX;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">            rank[rootX]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>无优化</th>
<th>路径压缩 + 按秩合并</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>初始化</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr class="even">
<td><code>find</code></td>
<td>O(n)</td>
<td>O(α(n)) ≈ O(1)</td>
</tr>
<tr class="odd">
<td><code>union</code></td>
<td>O(n)</td>
<td>O(α(n)) ≈ O(1)</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="线段树-segment-tree">3. 线段树 (Segment Tree)</h3>
<ul>
<li><strong>特点</strong>：树形结构，通常用数组存储（堆式存储，根在索引
1），区间查询与修改高效。</li>
<li><strong>操作复杂度</strong>：O(log n)。</li>
<li><strong>场景</strong>：区间最值 / 区间和 / 区间更新。</li>
</ul>
<p>Java 实现：区间和 &amp; 单点更新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] tree;   <span class="comment">// 线段树数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;        <span class="comment">// 原始数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        n = arr.length;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n]; <span class="comment">// 安全空间</span></span><br><span class="line">        build(arr, <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建线段树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tree[node] = arr[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            build(arr, node * <span class="number">2</span>, l, mid);</span><br><span class="line">            build(arr, node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">            tree[node] = tree[node * <span class="number">2</span>] + tree[node * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间查询 [ql, qr]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (qr &lt; l || ql &gt; r) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不相交</span></span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> tree[node]; <span class="comment">// 完全覆盖</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> query(node * <span class="number">2</span>, l, mid, ql, qr) + query(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单点更新：arr[idx] = val</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, idx, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tree[node] = val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= mid) update(node * <span class="number">2</span>, l, mid, idx, val);</span><br><span class="line">            <span class="keyword">else</span> update(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, idx, val);</span><br><span class="line">            tree[node] = tree[node * <span class="number">2</span>] + tree[node * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印树（调试用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[i] != <span class="number">0</span>) System.out.println(<span class="string">&quot;node &quot;</span> + i + <span class="string">&quot;: &quot;</span> + tree[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="type">SegmentTree</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SegmentTree</span>(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;query(1,3) = &quot;</span> + st.query(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// 3+5+7 = 15</span></span><br><span class="line">        st.update(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// arr[1] = 10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;query(1,3) = &quot;</span> + st.query(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// 10+5+7 = 22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>构建</strong>：O(n)</li>
<li><strong>查询 (区间和/最值/最小值)</strong>：O(log n)</li>
<li><strong>单点更新</strong>：O(log n)</li>
</ul>
<hr />
<h3 id="树状数组-fenwick-tree-binary-indexed-tree">4. 树状数组 (Fenwick
Tree / Binary Indexed Tree)</h3>
<ul>
<li><strong>特点</strong>：数组实现，维护前缀和。</li>
<li><strong>操作复杂度</strong>：O(log n)。</li>
<li><strong>场景</strong>：动态数组求前缀和，区间和。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FenwickTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FenwickTree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">            tree[i] += delta;</span><br><span class="line">            i += i &amp; -i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[i];</span><br><span class="line">            i -= i &amp; -i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法">算法</h1>
<h2 id="排序算法sorting">1. 排序算法（Sorting）</h2>
<ul>
<li><strong>基础排序</strong>：冒泡排序、选择排序、插入排序</li>
<li><strong>高效排序</strong>：快速排序、归并排序、堆排序</li>
<li><strong>线性排序</strong>：计数排序、桶排序、基数排序</li>
<li><strong>要点</strong>：时间复杂度、空间复杂度、稳定性、适用场景</li>
</ul>
<hr />
<h2 id="查找与搜索searching">2. 查找与搜索（Searching）</h2>
<ul>
<li><strong>二分查找</strong>：标准二分、变种二分（左边界/右边界）</li>
<li><strong>DFS / BFS</strong>：树和图的遍历，最短路径搜索</li>
<li><strong>回溯算法</strong>：全排列、组合、子集、N 皇后、数独</li>
<li><strong>剪枝优化</strong>：约束满足、状态缓存</li>
</ul>
<hr />
<h2 id="分治与递归divide-and-conquer">3. 分治与递归（Divide and
Conquer）</h2>
<ul>
<li><strong>分治思想</strong>：快速排序、归并排序</li>
<li><strong>矩阵乘法</strong>：Strassen 算法</li>
<li><strong>递归与递推</strong>：递归树分析、递归优化</li>
</ul>
<hr />
<h2 id="动态规划dynamic-programming-dp">4. 动态规划（Dynamic
Programming, DP）</h2>
<ul>
<li><strong>一维 DP</strong>：斐波那契数列、爬楼梯</li>
<li><strong>背包问题</strong>：01 背包、完全背包、多重背包</li>
<li><strong>序列
DP</strong>：最长上升子序列、最长公共子序列、编辑距离</li>
<li><strong>区间 DP</strong>：石子合并、矩阵链乘</li>
<li><strong>状态压缩 DP</strong>：旅行商问题、集合覆盖问题</li>
<li><strong>树形 DP</strong>：树的直径、树形背包</li>
</ul>
<hr />
<h2 id="贪心算法greedy">5. 贪心算法（Greedy）</h2>
<ul>
<li><strong>区间调度问题</strong></li>
<li><strong>最优装载问题</strong></li>
<li><strong>哈夫曼编码</strong></li>
<li><strong>最小生成树 (Kruskal / Prim)</strong></li>
</ul>
<hr />
<h2 id="图论算法graph-algorithms">6. 图论算法（Graph Algorithms）</h2>
<ul>
<li><strong>最短路径</strong>：Dijkstra、Bellman-Ford、Floyd-Warshall、SPFA</li>
<li><strong>最小生成树</strong>：Prim、Kruskal</li>
<li><strong>拓扑排序</strong>：Kahn 算法、DFS 逆后序</li>
<li><strong>强连通分量</strong>：Kosaraju、Tarjan</li>
<li><strong>二分图</strong>：最大匹配、染色判定</li>
<li><strong>最大流最小割</strong>：Edmonds-Karp、Dinic</li>
</ul>
<hr />
<h2 id="字符串算法string-algorithms">7. 字符串算法（String
Algorithms）</h2>
<ul>
<li><strong>模式匹配</strong>：KMP、Rabin-Karp</li>
<li><strong>字典树 (Trie)</strong></li>
<li><strong>AC 自动机</strong>（多模式匹配）</li>
<li><strong>Manacher 算法</strong>（最长回文子串）</li>
<li><strong>后缀数组 / 后缀自动机</strong></li>
</ul>
<hr />
<h2 id="数学与数论math-number-theory">8. 数学与数论（Math &amp; Number
Theory）</h2>
<ul>
<li><strong>最大公约数 /
最小公倍数</strong>：欧几里得、扩展欧几里得</li>
<li><strong>快速幂</strong>：快速模幂</li>
<li><strong>素数</strong>：埃氏筛、线性筛</li>
<li><strong>同余与逆元</strong>：费马小定理、中国剩余定理</li>
<li><strong>组合数学</strong>：排列组合、卡特兰数</li>
<li><strong>矩阵快速幂</strong>：递推数列优化</li>
</ul>
<hr />
<h2 id="高级算法思想advanced-paradigms">9. 高级算法思想（Advanced
Paradigms）</h2>
<ul>
<li><strong>分治</strong></li>
<li><strong>动态规划</strong></li>
<li><strong>贪心</strong></li>
<li><strong>搜索 + 剪枝</strong></li>
<li><strong>随机化算法</strong>（跳表、随机快排）</li>
<li><strong>启发式搜索</strong>（A*）</li>
</ul>
<hr />
<h2 id="经典综合问题">10. 经典综合问题</h2>
<ul>
<li><strong>排序 + 二分</strong>：区间问题、查找问题</li>
<li><strong>DP + 贪心</strong>：背包类优化</li>
<li><strong>图 + 并查集</strong>：连通分量、MST</li>
<li><strong>搜索 + 剪枝</strong>：数独、八皇后</li>
<li><strong>字符串 + DP</strong>：最长回文子串、编辑距离</li>
</ul>
<hr />
<h2 id="算法技巧algorithmic-techniques">11. 算法技巧（Algorithmic
Techniques）</h2>
<ul>
<li><strong>双指针 (Two Pointers)</strong>
<ul>
<li>快慢指针（链表环检测、找中点）</li>
<li>左右指针（两数之和、盛最多水的容器）</li>
</ul></li>
<li><strong>滑动窗口 (Sliding Window)</strong>
<ul>
<li>固定窗口（区间和、最大平均数）</li>
<li>可变窗口（最小覆盖子串、最长无重复子串）</li>
<li>单调队列优化（滑动窗口最大值）</li>
</ul></li>
<li><strong>前缀和 / 差分数组</strong>
<ul>
<li>区间和快速计算</li>
<li>区间更新优化</li>
</ul></li>
<li><strong>位运算技巧</strong>
<ul>
<li>子集枚举</li>
<li>lowbit 运算（树状数组）</li>
</ul></li>
<li><strong>双端队列优化</strong>
<ul>
<li>单调队列（维护区间最值）</li>
</ul></li>
<li><strong>哈希 + 枚举</strong>
<ul>
<li>两数之和、四数之和</li>
</ul></li>
<li><strong>排序 + 双指针 / 二分结合</strong>
<ul>
<li>区间查找、两数之和、三数之和</li>
</ul></li>
</ul>
<h2 id="总结-2">总结</h2>
<p><strong>算法范式</strong>：分治、动态规划、贪心、搜索</p>
<p><strong>算法领域</strong>：排序、图论、字符串、数论</p>
<p><strong>算法技巧</strong>：双指针、滑动窗口、前缀和、位运算</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>中国哲学简史</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6%E7%AE%80%E5%8F%B2.html</url>
    <content><![CDATA[<p>“我们在衡山只住了大约四个月，1938年春迁往昆明——最西南的边陲。在衡山只有短短的几月，精神上却深受激励。其时，正处于我们历史上最大的民族灾难时期；其地，则是怀让磨砖做镜、朱熹会友论学之处。我们正遭受着与晋人南渡、宋人南渡相似的命运。可是我们生活在一个神奇的环境：这么多的哲学家、著作家和学者都住在一栋楼里。遭逢世变，投止名山，荟萃斯文：如此天地人三合，使这一段生活格外的激动人心，令人神往。”</p>
<p>“在这短短的几个月，我自己和我的同事汤用彤教授、金岳霖教授，把在此以前开始写的著作写完了。汤先生的书是《中国佛教史》第一部分、金先生的书是《论道》、我的书是《新理学》。”</p>
<p>看到上面这段文字的时候，上海封城已经结束。这本书的大部分都是在上海封城期间看完的，从三月初的物资匮乏的焦躁到冷静下来重新开始阅读这本书，经过了很长的停歇期和复杂的内心活动。在中华民族经历内忧外患，山河破碎的抗日战争期间，作者在漫山遍野的炮火重击中偏居一隅，研究学问，著书立说，为中国哲学立传续脉，和我看这本书的心境何其相似。这似乎是一种命运的巧合。</p>
<p>中国哲学是什么？很难用一句话解释这个问题。从春秋时代的儒家、法家、墨家、名家、道家，到汉代董仲舒的儒学官方化，今文派和古文派的对立，到后来吸收了宗教文化的禅宗，为了对抗印度佛教文化而形成的道教，再到后来魏晋时期的玄学和清谈文化，然后是兴起于宋朝的理学，再然后是明代理学和心学之争，再然后是西方哲学的传入，让清朝的汉学家开始考据汉代的典籍，“白发死章句”，除儒学外的其他流派开始得到整理和重视，为了对抗西方逻辑学的“名家”被重新注意到，再到康有为尝试把儒家宗教化，建立“孔教”，整个中国哲学的发展史，就是中国的思想家们认识世界和宇宙的波澜壮阔的历史。和西方哲学不同，“在中国哲学史中，正的方法从未得到充分发展；事实上，对它太忽视了。因此，中国哲学历来缺乏清晰的思想，这也是中国哲学以单纯为特色的原因之一。由于缺乏清晰的思想，其单纯性也就是非常素朴的。单纯性本身是值得发扬的，但是它的素朴性必须通过清晰的思想的作用加以克服。清晰的思想不是哲学的目的，但是它是每个哲学家需要的不可缺少的训练。它确实是中国哲学家所需要的。另一方面，在西方哲学史中从未见到充分发展的负的方法。只有两者相结合才能产生未来的哲学。”中国哲学中宇宙的概念也包括了观测者本身，所以宇宙是“不可见”的，也是“不可说”的，一旦“可见”了，就只能以宇宙外的观测者的角度，但是这是不可能的，所以中国哲学的最终境界就是“不可说”，这就是“负的方法”。而中国的哲学家们过于追求这种对终极境界的探索，忽视了正向观测的逻辑体系的建立，实际上，“正的方法”是到达终极境界的必由之路。中国的国门被西方的坚船利炮打开后，中国的哲学体系同样承受着西方哲学体系的冲击，一方面中国的思想家们发现自己之外也有一个完整的思想体系的存在，另一方面又迫切地在自己思想体系中寻找能和西方哲学体系对等的存在以弥补这种国力悬殊造成的心理落差。他们找到了“名家”来对标西方的“逻辑学”，但是在更多更大的方面，两种思想体系却看似截然不同，一方面是因为东西方哲学分别侧重于正负两种不同的研究方法，中国哲学偏重于觉悟和经验，西方哲学偏重于逻辑和分析，这两种方法在目标上有时候会殊途同归，但是中国的思想家们当时并不能意识到这种更深层次的相似，另一方面在于中国当时缺乏真正了解西方哲学的人。</p>
<p>很多人认为西方国力强于中国，就认为西方的思想就比中国的更优越，实际上这种思想领域的高低比较没有意义，每一种思想体系都有其适用的范围和局限。那么中国的哲学能对未来的哲学造成什么样的影响呢？“所以中国的圣人是既入世而又出世的，中国的哲学也是既入世而又出世的。随着未来科学的进步，我相信，宗教及其教条和迷信，必将让位于科学；可是人的对于超越人世的渴望，必将由未来的哲学来满足。未来的哲学很可能是既入世而又出世的。在这方面，中国哲学可能有所贡献。”技术的高速发展带来了一系列问题，而技术问题是无法用技术来解决的，人类中的哲学家们在追求着超越自然和功利的境界，作者称之为“道德境界”和“天地境界”，道家哲学中的“道”，理学中的“理”和“性”，心学中“心”，禅宗的“悟”，都在追求这种“天人合一”的境界，这是人类哲学的终极理想，而对这一终极理想的追求也蕴藏着人类社会众多问题的解决方案。</p>
<p>这本书可说的地方太多，这里只能浅尝辄止，有兴趣的读者可以多读中国哲学的原著，那会是一趟非常奇妙的旅程。</p>
<p>“大学之道，在明明德，在亲民，在止于至善。”—《大学》</p>
<p>“格物、致知、诚意、正心、修身、齐家、治国、平天下。”—《大学》八条目</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>什么是教育</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%99%E8%82%B2.html</url>
    <content><![CDATA[<p>学习的痛苦之处在于，要在接受内容的同时，理解、怀疑、思考和联结内容。看这本书的过程就是如此。但真正有价值的学习，不在于知识的记忆和重复，而在于经历这种痛苦的过程，产生对事物本质的个体化思考，即“本己化”。</p>
<p>卡尔·雅斯贝尔斯，最初研究精神病学，后研究哲学。少年时期，雅斯贝尔斯就对哲学问题产生了兴趣，并试图和他的父亲讨论哲学问题，但并没有从他的父亲那里得到回应。他从他的父母那里接受了良好的教育，关于宗教、原则、经济等。这些教育让他对一些问题能进行严肃的思考。</p>
<p>什么是教育？教育不是知识的传授，那是培训；不是灌输教条和道理，那是规训；不是让被教育者重复自己的行为，那是模仿；不是树立榜样，那是个人崇拜；不是排名淘汰，那是筛选。教育是对话。这种对话在两个完全平等的灵魂之间进行。教育者或者被教育者抛出问题，双方就此进行讨论沟通，并表达阐述自己理解和思考，目的是为了激发出对问题的更深层次的理解。这个过程首先必须经历学习和思考，并充分引导自己的好奇心和冒险精神（面对痛苦和未知的勇气）。耳提面命式的知识传授，会养成被教育者的懒惰习性和对权威的崇拜，在被教育者眼里，教育者成为了权威，被教育者则对权威产生依赖，这种权威在整个教育体系的加持下会愈加强化。教育的目的，是产生本己化的灵魂。</p>
<p>被教育者应当具备怎样的素质？对于被传授的知识，被教育者应当具备怀疑一切的意识，包括道德条例、政治术语、公式法则等。在进行怀疑之前，被教育者应当被给予逻辑学的训练，以更加高效地进行怀疑。教育者和被教育者的身份不是固定的，教育者同时也是被教育者。对每个个体而言，教育和被教育都在持续不断地发生，这是“对话”所带来的必然过程。被教育者应该对自身好奇心的丧失和对权威的服从保持警惕，并警惕自身成为权威和用固化的知识泯灭他人的好奇心。对权威的服从根植于人性，并经过后天的规训而被固化，这在东亚文化中尤其明显。这是一种懒惰和胆怯，用现成的伦理和知识来逃避真实世界的复杂性和对其的思考，他们生活在知识构筑的“虚拟空间”中，言论皆有引用，行为皆有章程，理性在这个过程中逐步丧失了。</p>
<p>教育的目的是什么？教育的目的是自我教育。雅斯贝尔斯认为，自我教育是形成民主政治的必要条件。伦理道德、理性以及思考的意愿都是不可灌输的。在中国的学校，墙上都会悬挂张贴规训标语，然而每一所学校所发生的事实似乎离这些标语很遥远。在整个教育过程中，师生关系的等级明确，学生必须无条件尊师，但是老师却可以无视学生的作为独立人的权利。这种情况并没有随着技术进步和经济发展改善。韩愈在《师说》中“闻道有先后，术业有专攻”的阐述涉及了这一问题，但并没有从本质上进一步探究（中国先贤们的论述普遍停留于表观的“术”而缺乏“道”理）。完成教育的条件包括：好奇心、冒险精神、怀疑批判一切的意识、承受痛苦的毅力（反抗懒惰）。真正的个人意识产生于深刻的思考之后，初期的模仿只是暂时的（若停留于模仿可持续一生）。孔子说：“学而不思则罔。”学习是记忆和理解的过程，这个过程有可能是快乐的，而运用则更加快乐（比如解题或者工程实践），但是思考往往带来痛苦，因为思考面对的是深究、重构、怀疑、反叛，需要在对事物的认知极限处（边缘）向外探索，那种获得和理解的快乐将被打破，重新进入迷惑的状态，这个过程有时候通过运用经验会轻松一点，但在缺乏经验支撑甚至主动放弃经验的时候就会让人倍感痛苦。在经历深刻而痛苦的思考之后，人会形成自我意识，并具备自我教育的能力。陆九渊有言：“学苟知本，六经皆我注脚。”教育，是以自我为中心的。</p>
<p>应试的问题是什么？应试是对教育的极大的简化和片面抽象。学生学得并非太多，而是太少，同样，学生花在学习和思考上的时间也太少。在这样的教育下，一个固定的教学模式是：讲授知识点
— 讲解基于知识点的例题 — 学生解题 —
纠错，并不断重复这个过程，直到学生可以熟练地应付考试。一个普遍情况是，在经历了高考或者研究生考试后，学生就忘记了自己所学的东西，甚至完全没有印象。他们对知识只是暂时性地学习和应用。“用不到就忘了”的真正原因是没有对本质问题进行深入思考，知识之间也并未真正联结成体系，只是散在的孤岛。</p>
<p>如何解决？把学校教育作为家庭教育的补充。中国目前的学校教育模式在可以预见的未来都不会有质的改变：一方面是制度和传统的惯性巨大；另一方面是学生和教师的身份转变过程中，作为教育行为构成主体的人无所改变。家长需要觉醒并先行自我教育为可以承担这一职责的人。</p>
<p>为了应对应试的片面性，曾经有一个“素质教育”的概念被提出（如今已销声匿迹），却因为试验者在应试培训上的投入不足而导致应试结果差。“素质教育”被理解为“快乐教育”，这是对教育的极大误解，如前所述，思考必然伴随痛苦，快乐无从谈起。对知识的深刻理解可以覆盖应试（应试作为其微不足道的一个结果），教育本身的投入比纯粹应试要大得多，被教育者只会更累，而非更轻松。须知，对人的塑造绝非易事。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>任何一种能够作为科学出现的未来形而上学导论</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BB%BB%E4%BD%95%E4%B8%80%E7%A7%8D%E8%83%BD%E5%A4%9F%E4%BD%9C%E4%B8%BA%E7%A7%91%E5%AD%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%AA%E6%9D%A5%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6%E5%AF%BC%E8%AE%BA.html</url>
    <content><![CDATA[<h3 id="分析判断">分析判断</h3>
<p>分析判断是指那些通过分析概念本身就能确定其真实性的判断。它们的真实性不依赖于经验，而是基于逻辑和定义。例如，“所有单身汉都是未婚的”就是一个分析判断，因为“单身汉”的定义本身就包含了“未婚”的属性。分析判断通常被认为是先验的，因为它们不需要通过经验来验证。</p>
<h3 id="综合判断">综合判断</h3>
<p>综合判断是指那些通过经验和观察来确定其真实性的判断。它们的真实性依赖于对现实世界的观察和经验积累。例如，“这个苹果是红色的”就是一个综合判断，因为它需要通过观察苹果的颜色来验证。综合判断通常被认为是后验的，因为它们需要通过经验来验证。</p>
<h3 id="先验哲学">先验哲学</h3>
<p>先验哲学是指那些关注于先天知识和概念的哲学思潮。它们认为某些知识是与生俱来的，不依赖于经验。例如，康德的先验哲学就强调了时间和空间是人类认知的先天框架。先验哲学通常关注于知识的来源和结构，而不是具体的经验内容。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>金瓶梅</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%91%E7%93%B6%E6%A2%85.html</url>
    <content><![CDATA[<p>没读《金瓶梅》之前，道听途说，《金瓶梅》是一本淫书。读完以后，才发现《金瓶梅》确实是一本淫书，不仅如此，金瓶梅更是一本奇书。</p>
<p>以现代眼光看，《金瓶梅》算得上《水浒传》的同人作品，但是这个同人作品的艺术价值和现实意义却远远超越了《水浒传》。毫不夸张地说，在我读过的所有中国古代小说里，《金瓶梅》是绝对的神作，甚至高于《红楼梦》。</p>
<p>我激赏《金瓶梅》的原因很简单：这是一本描写极恶极欲的书。《金瓶梅》用夸张而且略带荒谬的方式表现了宋代社会中黑暗腐朽的人性，它对人性中的黑暗、沉沦和欲望的刻画即使在现代社会仍然有着强烈的警示意义。小说将人能在社会中接触到的大多数反道德的形象通过包括西门庆、潘金莲在内的一众人物集中起来，让人在掩卷之余，喟叹人心之恶和现实的冷酷。</p>
<p>《金瓶梅》写的是现实中活生生的人，真切无比的事，入木三分的欲望，淋漓尽致的恶。如果你细心观察现代社会中的人的种种行为，你会发现西门庆和潘金莲在今天远远没有消失，你甚至觉得他们本来就应该存在，因为人有色欲，爱美食，喜欢钱，好面子，渴望权力，同时又自私、虚伪，人会落井下石，卖友求荣，恩将仇报，这些劣根性根植在人的欲望基因中，导致小说里那些戏剧化的情节总是在现实中以不同的形式上演着。《金瓶梅》着力描写的就是这种人性的恶，毫无希望的恶。虽然最后西门庆死了，但是永远会有像西门庆那样的人活着，死亡不是罪恶的终结，而是罪恶的轮回，我想这就是《金瓶梅》存在的意义。</p>
<p>《金瓶梅》作为一本淫书，大概不会出现在年轻人的必读书目上。我个人认为对于尚未接受过正规的性教育的青少年，还是不要阅读，一方面书中的性爱描写确实露骨，另一方面由于缺乏阅历，也确实领会不到这本书的价值，没有阅读必要。但是对于更年长一些的渴望加深对社会和人性的了解的青年人，我还是建议他们去读一读。诚然，《金瓶梅》是一本描写纯粹的黑暗而让人毫无希望的书，但是这层黑暗的下面潜伏着巨大的艺术价值和现实意义，他对于青年人的启发性要大于着力于描写爱情的《红楼梦》。</p>
<p>我们可以将潘金莲和林黛玉做一个对比。潘金莲是现实版本的林黛玉，两个人都是小肚鸡肠，喜欢勾心斗角，争风吃醋。因为李瓶儿生了儿子，西门庆对她宠爱有加，潘金莲嫉妒，就在大姐吴月娘那里搬弄是非，说李瓶儿的坏话，离间吴月娘和李瓶儿，还训练猫吓死李瓶儿的儿子。林黛玉是一直对贾宝玉和薛宝钗的“金玉良缘”耿耿于怀，平时对贾宝玉冷嘲热讽，稍有不如意就大发脾气，哭成泪人。不过林黛玉的出身比潘金莲好太多了，在旧社会中，两个人的阶级地位不可同日而语。林黛玉不会为了目的不择手段，除了说两句酸话，不会像潘金莲那样杀人诛心。潘金莲为了得到西门庆的恩宠手段尽施，对西门庆，她甘愿受辱，对其他的西门庆宠爱的女人，她心狠手辣，恨不能除之而后快。林黛玉是大家闺秀，诗书礼仪，无所不精。潘金莲出身低微，用现代眼光看，她就是个没有受过什么高等教育的只会唱两首流行歌曲的粗人。林黛玉最后病死，爱情虽不美满，却仍然算得上善终。潘金莲最后因为和陈敬济通奸被吴月娘扫地出门，被王婆卖给了武松，而后被武松杀死，死得十分凄惨。相较于林黛玉，潘金莲更像一个彻头彻尾的悲剧人物。</p>
<p>《金瓶梅》第八十七回“王婆子贪财忘祸，武都头杀嫂祭兄”中这样描写潘金莲的死亡：“武松恐怕他挣扎，先用油靴只顾踢他肋肢，后用两只手去摊开他胸脯，说时迟，那时快，把刀子去妇人白馥馥心窝内只一剜，剜了个血窟窿，那鲜血就冒出来。那妇人就星眸半闪，两只脚只顾登踏。武松口噙着刀子，双手去斡开他胸脯，扎乞的一声，把心肝五脏生扯下来，血沥沥供养在灵前。后方一刀割下头来，血流满地。”这一段让人读得真是让人倒抽一口凉气，即使是对于潘金莲这样的奸邪淫恶之人，这样的结局也未免太过悲惨。乍看之下好像恶有恶报，让人痛快淋漓，然而转念一想，武松以恶制恶的残忍手段一方面让人慨叹小人物在司法黑暗的时期对于公平正义的诉求无力，另一方面，也让人对潘金莲隐隐地有一丝同情。作者在所有的人都唾弃潘金莲的时候安排了一个人物——春梅，即“金瓶梅”中的“梅”字。春梅原本是潘金莲在西门庆家的侍女，潘金莲和春梅的关系很好，两人虽是主仆，却情似姐妹。潘金莲和陈敬济通奸被春梅撞见，潘金莲为了封住春梅的口让春梅和陈敬济交媾，春梅从此便和潘金莲一起和陈敬济通奸，而她和陈敬济的这段情缘也为后来二人的死亡埋下了伏笔。作为一名男性，有时候我无法理解女人之间的友情，即使那些品行不端的女人，也会有几个死心塌地的知心朋友，还对她处处维护，而我一直以为女人之间的友情很脆弱。潘金莲毒杀武大郎，逼死李瓶儿，通奸陈敬济，气走自己的亲生母亲，按我认为的这样的人在生活中应该没朋友，但是潘金莲被武松杀死后，尸首无人认领，春梅得知后领回安葬，待之如亲姐姐，这就着实令我费解了。人和人之间的关系在这种时候往往显现出其复杂性，就像我曾经问过一个女生为何和另一个品行不端的女生如此要好的时候，她回答我：“她待我又不差，我还不想失去这个朋友。”</p>
<p>关于潘金莲和春梅关系的思考引出了我的另一个认识，那就是《金瓶梅》中一个很重要的概念：积善行恶。《金瓶梅》第五十七回“开缘簿千金喜舍，戏雕栏一笑回嗔
”中西门庆有这样一段言论：“咱只消尽这家私广为善事，就使强奸了姮娥，和奸了织女，拐了许飞琼，盗了西王母的女儿，也不减我泼天的富贵。”</p>
<p>西门庆虽然假公济私，淫人妻女，贿上欺下，贪财好色，但是对他那几个酒肉朋友确是格外大方，给钱给物，没事就喊过来喝酒吃饭听妓女唱歌，而这些损友一方面帮着西门庆出一些阴招坑害别人，另一方面也从西门庆那里获利颇丰。对于僧人道士，西门庆从不吝啬，他出资五百两银子帮和尚修庙，家中也时常有各种宗教人士走动，西门庆对他们也格外优待。对于自己“收用”的女子，西门庆出手也十分大方。这就是西门庆所谓的“善”，只不过他的善并非为人，而是为了自己。吊诡的是，西门庆从胡僧那里获得了“虎狼之药”，却最终也因为被潘金莲多喂了两颗虎狼之药而一命呜呼。</p>
<p>李瓶儿虽然在西门庆家中为人宽厚，善待下人，但是却也曾经为了一己之利气死自己的原配丈夫花子虚。在儿子死后，李瓶儿重疾缠身，弥留之际，经常做噩梦，梦到花子虚来找自己报仇。</p>
<p>春梅先于潘金莲被吴月娘扫地出门，卖到西门庆家十六两银子，卖出去还是原价，嫁给守备之后春梅时来运转，深得守备喜爱，后来为守备生了儿子，在守备家中的地位就更高了。春梅不计前嫌帮助吴月娘领回被盗的财物，又与吴月娘交好来往，后来被陈敬济劝阻才和月娘断了往来。孙雪娥被卖到守备府当下人的时候，春梅借机整治她，将孙雪娥卖出去当了娼妓。春梅得势后不忘潘金莲，想让守备娶潘金莲为妾，不成。潘金莲死后春梅为其收尸，在陈敬济落魄时和他假扮姐弟帮助陈敬济在守备府站稳脚跟，又为陈敬济娶了媳妇。春梅和陈敬济通奸时谋害张胜，不想被张胜窃听，陈敬济被张胜砍死。春梅携家小伴随统制（此时守备已经升职为统制）屯边抗金，战事紧急，统制无心房事，春梅不甘寂寞和家仆之子通奸。统制战死，春梅返家守节持贞，却也即将走向生命的尽头。在《金瓶梅》第一百回“韩爱姐路遇二捣鬼，普静师幻度孝哥儿
”中作者这样叙述春梅的死亡：“这春梅在内颐养之余，淫情愈盛。常留周义在香阁中，镇日不出。朝来暮往，淫欲无度，生出骨蒸痨病症。逐日吃药，减了饮食，消了精神，体瘦如柴，而贪淫不已。一日，过了他生辰，到六月伏暑天气，早辰晏起，不料他搂着周义在床上，一泄之后，鼻口皆出凉气，淫津流下一洼口，就鸣呼哀哉，死在周义身上。亡年二十九岁。”至此，“金瓶梅”三人（潘金莲、李瓶儿、春梅）全部死亡，没有一个是善终。</p>
<p>《金瓶梅》全书中，始终充斥着这样的宿命论。全书的最后作者写了一首诗：“阀阅遗书思惘然，谁知天道有循环。西门豪横难存嗣，敬济颠狂定被歼。楼月善良终有寿，瓶梅淫佚早归泉。可怪金莲遭恶报，遗臭千年作话传。”这首诗阐明了善恶有报，天道轮回，似乎又回到了宗教迷信一般的旧窠中去，但我更愿意把这种刻意“拔高”的立意理解为作者的一次“此地无银”，不然这本书的遭遇可能会更惨。如果《金瓶梅》讲述的只是一个“善有善报，恶有恶报”的故事，它不会有如此高的价值。作者虽然安排“恶人”惨死，“好人”善终，但是在全书中的人物描写却都是有血有肉。即使是“被树为正面典型”的吴月娘，也有耳根子软的毛病，三番五次被潘金莲挑拨离间，而且总是迷信刘婆子的偏方，不喜欢请太医，还找尼姑讨能怀上孩子的药。吴月娘在书中扮演了一个传统“正派妇女”的角色，但是这样的角色也没有让人觉得呆板和脸谱化。</p>
<p>在全书的最后还出现了一个人物：韩爱姐。韩爱姐遇到陈敬济之后眼里便再也没有别人，陈敬济死后，她自愿去周府给陈敬济做妾，为陈敬济守孝。书中这样叙述韩爱姐的死亡：“韩二再三教他嫁人，爱姐割发毁目，出家为尼，誓不再配他人。后来至三十一岁，无疾而终。”在看似“男子皆有淫心，女子皆可淫辱”的《金瓶梅》中，从一而终的韩爱姐，竟然让我有一丝感动。虽然她爱上的陈敬济，用现代的眼光来看，实在是个不怎么样的男人。</p>
<p>读罢《金瓶梅》，从古人的爱恨情仇中走出来，看看眼前，想想现在，不由得生出“太阳底下无新事”的感叹，书中的故事，在现实中也还在一幕幕上演。</p>
<p>《金瓶梅》中，潘金莲为了掩盖事实说了无数“理直气壮”的谎，即使到最后，也没有人知道西门庆惨死的真相是因为潘金莲多喂了他两颗药丸。我们知道真相是因为我们是读者，然而“现实”这本大书是根本不存在读者的，如果有一天我们遇到了潘金莲，又有谁能知道真相呢？</p>
<p>人间处处金瓶梅。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="分类">分类</h1>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 26%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>分类</strong></th>
<th style="text-align: left;"><strong>设计模式</strong></th>
<th style="text-align: left;"><strong>简单说明</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>创建型模式<br>Creational
Patterns</strong></td>
<td style="text-align: left;">单例模式（Singleton）</td>
<td
style="text-align: left;">确保类只有一个实例，并提供全局访问点。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">工厂方法（Factory Method）</td>
<td
style="text-align: left;">定义创建对象的接口，由子类决定实例化。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">抽象工厂（Abstract Factory）</td>
<td style="text-align: left;">创建一系列相关对象的工厂。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">建造者（Builder）</td>
<td style="text-align: left;">分步构造复杂对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">原型模式（Prototype）</td>
<td style="text-align: left;">通过克隆创建新对象。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>结构型模式<br>Structural
Patterns</strong></td>
<td style="text-align: left;">适配器（Adapter）</td>
<td style="text-align: left;">将不兼容的接口转换为兼容接口。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">桥接（Bridge）</td>
<td style="text-align: left;">将抽象与实现分离。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">组合（Composite）</td>
<td style="text-align: left;">将对象组织成树形结构。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">装饰者（Decorator）</td>
<td style="text-align: left;">动态扩展对象功能。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">外观（Facade）</td>
<td style="text-align: left;">为复杂子系统提供简单接口。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">享元（Flyweight）</td>
<td style="text-align: left;">共享细粒度对象以节省资源。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">代理（Proxy）</td>
<td style="text-align: left;">控制对对象的访问。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>行为型模式<br>Behavioral
Patterns</strong></td>
<td style="text-align: left;">责任链（Chain of Responsibility）</td>
<td style="text-align: left;">将请求沿处理链传递。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">命令（Command）</td>
<td style="text-align: left;">将请求封装为对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">解释器（Interpreter）</td>
<td style="text-align: left;">定义语言的解释规则。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">迭代器（Iterator）</td>
<td style="text-align: left;">顺序访问集合元素。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">中介者（Mediator）</td>
<td style="text-align: left;">通过中介协调对象交互。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">备忘录（Memento）</td>
<td style="text-align: left;">保存和恢复对象状态。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">观察者（Observer）</td>
<td style="text-align: left;">对象状态变化时通知依赖者。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">状态（State）</td>
<td style="text-align: left;">根据状态改变对象行为。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">策略（Strategy）</td>
<td style="text-align: left;">定义可互换的算法家族。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">模板方法（Template Method）</td>
<td style="text-align: left;">定义算法骨架，子类实现细节。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">访问者（Visitor）</td>
<td style="text-align: left;">在不修改类的情况下增加新操作。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>扩展模式<br>Extended
Patterns</strong></td>
<td style="text-align: left;">依赖注入（Dependency Injection）</td>
<td style="text-align: left;">通过外部注入依赖，解耦组件。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">发布-订阅（Publish-Subscribe）</td>
<td style="text-align: left;">事件驱动的观察者变种。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">模块模式（Module Pattern）</td>
<td style="text-align: left;">封装代码，管理私有/公有成员。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">MVC（Model-View-Controller）</td>
<td
style="text-align: left;">分离数据（Model）、界面（View）和逻辑（Controller）。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">MVP（Model-View-Presenter）</td>
<td style="text-align: left;">View 和 Presenter 交互，Model
隔离数据。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">MVVM（Model-View-ViewModel）</td>
<td style="text-align: left;">通过 ViewModel 绑定 Model 和 View。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">仓储模式（Repository Pattern）</td>
<td style="text-align: left;">封装数据访问逻辑。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">服务定位器（Service Locator）</td>
<td style="text-align: left;">集中管理服务实例的获取。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">事件溯源（Event Sourcing）</td>
<td style="text-align: left;">通过事件记录对象状态。</td>
</tr>
</tbody>
</table>
<h1 id="图示">图示</h1>
<pre><code class="highlight mermaid">graph LR
    A[设计模式&lt;br&gt;Design Patterns]
    
    A --&gt; B[创建型模式&lt;br&gt;Creational Patterns]
    B --&gt; B1[单例模式&lt;br&gt;Singleton]
    B --&gt; B2[工厂方法&lt;br&gt;Factory Method]
    B --&gt; B3[抽象工厂&lt;br&gt;Abstract Factory]
    B --&gt; B4[建造者&lt;br&gt;Builder]
    B --&gt; B5[原型模式&lt;br&gt;Prototype]
    
    A --&gt; C[结构型模式&lt;br&gt;Structural Patterns]
    C --&gt; C1[适配器&lt;br&gt;Adapter]
    C --&gt; C2[桥接&lt;br&gt;Bridge]
    C --&gt; C3[组合&lt;br&gt;Composite]
    C --&gt; C4[装饰者&lt;br&gt;Decorator]
    C --&gt; C5[外观&lt;br&gt;Facade]
    C --&gt; C6[享元&lt;br&gt;Flyweight]
    C --&gt; C7[代理&lt;br&gt;Proxy]
    
    A --&gt; D[行为型模式&lt;br&gt;Behavioral Patterns]
    D --&gt; D1[责任链&lt;br&gt;Chain of Responsibility]
    D --&gt; D2[命令&lt;br&gt;Command]
    D --&gt; D3[解释器&lt;br&gt;Interpreter]
    D --&gt; D4[迭代器&lt;br&gt;Iterator]
    D --&gt; D5[中介者&lt;br&gt;Mediator]
    D --&gt; D6[备忘录&lt;br&gt;Memento]
    D --&gt; D7[观察者&lt;br&gt;Observer]
    D --&gt; D8[状态&lt;br&gt;State]
    D --&gt; D9[策略&lt;br&gt;Strategy]
    D --&gt; D10[模板方法&lt;br&gt;Template Method]
    D --&gt; D11[访问者&lt;br&gt;Visitor]
    
    A --&gt; E[扩展模式&lt;br&gt;Extended Patterns]
    E --&gt; E1[依赖注入&lt;br&gt;Dependency Injection]
    E --&gt; E2[发布-订阅&lt;br&gt;Publish-Subscribe]
    E --&gt; E3[模块模式&lt;br&gt;Module Pattern]
    E --&gt; E4[MVC&lt;br&gt;Model-View-Controller]
    E --&gt; E5[MVP&lt;br&gt;Model-View-Presenter]
    E --&gt; E6[MVVM&lt;br&gt;Model-View-ViewModel]
    E --&gt; E7[仓储模式&lt;br&gt;Repository Pattern]
    E --&gt; E8[服务定位器&lt;br&gt;Service Locator]
    E --&gt; E9[事件溯源&lt;br&gt;Event Sourcing]</code></pre>
<h1 id="详解">详解</h1>
<h2 id="创建型模式creational-patterns">创建型模式（Creational
Patterns）</h2>
<h3 id="单例模式singleton"><strong>单例模式（Singleton）</strong></h3>
<p>单例模式（Singleton
Pattern）是一种创建型设计模式，确保一个类只有一个实例，并提供全局访问点。以下是单例模式的各种实现方式，包括线程安全的版本，用
Java 编写。每种实现都会标注其特点、优缺点及适用场景。</p>
<hr />
<h4 id="饿汉式eager-initialization">1. 饿汉式（Eager
Initialization）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="comment">// 类加载时就创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonEager</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonEager</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造方法，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonEager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射创建实例</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Singleton instance already exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonEager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：类加载时即创建实例，线程安全。</li>
<li><strong>优点</strong>：简单，无需同步，天然线程安全。</li>
<li><strong>缺点</strong>：无论是否使用，都会创建实例，可能浪费资源。</li>
<li><strong>适用场景</strong>：实例开销小，且肯定会被使用。</li>
</ul>
<hr />
<h4 id="懒汉式lazy-initialization非线程安全">2. 懒汉式（Lazy
Initialization，非线程安全）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射创建实例，这并不能真正防止反射，用饿汉式、枚举或者使用标志位</span></span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Singleton instance already exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：延迟加载，第一次调用时创建实例。</li>
<li><strong>优点</strong>：节省资源，懒加载。</li>
<li><strong>缺点</strong>：非线程安全，多线程下可能创建多个实例。</li>
<li><strong>适用场景</strong>：单线程环境，或不在意线程安全。</li>
</ul>
<p>添加标志位：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazyWithFlag</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazyWithFlag instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">// 标志位</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazyWithFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SingletonLazyWithFlag.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Singleton instance already exists&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            initialized = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonLazyWithFlag <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonLazyWithFlag.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingletonLazyWithFlag</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="线程安全的懒汉式synchronized-方法">3.
线程安全的懒汉式（Synchronized 方法）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonSyncMethod</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonSyncMethod instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonSyncMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Singleton instance already exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 synchronized 同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonSyncMethod <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonSyncMethod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：通过同步方法实现线程安全。</li>
<li><strong>优点</strong>：简单，保证线程安全。</li>
<li><strong>缺点</strong>：每次调用 <code>getInstance</code>
都要加锁，性能开销大。</li>
<li><strong>适用场景</strong>：多线程环境，但调用频率不高。</li>
</ul>
<hr />
<h4 id="双重检查锁double-checked-locking-dcl">4.
双重检查锁（Double-Checked Locking, DCL）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDCL</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDCL instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDCL</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Singleton instance already exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDCL <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 第一次检查（无锁）</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDCL.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 第二次检查（加锁）</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingletonDCL</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：结合懒加载和线程安全，双重检查减少同步开销。</li>
<li><strong>优点</strong>：高效，只有在实例未创建时加锁。</li>
<li><strong>缺点</strong>：实现复杂，需使用 <code>volatile</code>（Java
5+）防止指令重排。</li>
<li><strong>适用场景</strong>：多线程环境，追求性能优化。</li>
</ul>
<hr />
<h4 id="静态内部类static-inner-class">5. 静态内部类（Static Inner
Class）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonStaticInner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonStaticInner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SingletonHolder.INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Singleton instance already exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类持有实例, 静态内部类只有在第一次被使用的时候才会加载，所以是懒加载。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonStaticInner</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonStaticInner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonStaticInner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：利用类加载机制实现懒加载和线程安全。</li>
<li><strong>优点</strong>：简单、高效，JVM
保证线程安全，无需显式同步。</li>
<li><strong>缺点</strong>：无法传递构造参数。</li>
<li><strong>适用场景</strong>：多线程环境，推荐的懒加载方式。</li>
</ul>
<hr />
<h4 id="枚举单例enum-singleton">6. 枚举单例（Enum Singleton）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span> &#123;</span><br><span class="line">    INSTANCE;  <span class="comment">// 唯一实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以添加方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SingletonEnum is working&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>用法</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SingletonEnum</span> <span class="variable">singleton</span> <span class="operator">=</span> SingletonEnum.INSTANCE;</span><br><span class="line">singleton.doSomething();</span><br></pre></td></tr></table></figure></li>
<li><strong>特点</strong>：使用枚举实现单例，JVM 保证唯一性。</li>
<li><strong>优点</strong>：最简单，天然线程安全，防止反射和序列化破坏。</li>
<li><strong>缺点</strong>：无法懒加载，枚举类加载时即创建。</li>
<li><strong>适用场景</strong>：需要绝对安全（如防止反射攻击）的场景。</li>
</ul>
<hr />
<h4 id="threadlocal-单例线程局部单例">7. ThreadLocal
单例（线程局部单例）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonThreadLocal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SingletonThreadLocal&gt; THREAD_LOCAL = </span><br><span class="line">        ThreadLocal.withInitial(SingletonThreadLocal::<span class="keyword">new</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonThreadLocal <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> THREAD_LOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理 ThreadLocal，防止内存泄漏</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        THREAD_LOCAL.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：每个线程拥有独立的单例实例。</li>
<li><strong>优点</strong>：线程隔离，适合线程特定的单例需求。</li>
<li><strong>缺点</strong>：不是全局单例，需注意 ThreadLocal
的内存管理。</li>
<li><strong>适用场景</strong>：线程私有单例，如线程上下文管理。</li>
</ul>
<hr />
<h4 id="测试代码">测试代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试饿汉式</span></span><br><span class="line">        <span class="type">SingletonEager</span> <span class="variable">s1</span> <span class="operator">=</span> SingletonEager.getInstance();</span><br><span class="line">        <span class="type">SingletonEager</span> <span class="variable">s2</span> <span class="operator">=</span> SingletonEager.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;Eager: &quot;</span> + (s1 == s2));  <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 测试双重检查锁（多线程）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;DCL: &quot;</span> + SingletonDCL.getInstance());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 测试枚举</span></span><br><span class="line">        <span class="type">SingletonEnum</span> <span class="variable">e1</span> <span class="operator">=</span> SingletonEnum.INSTANCE;</span><br><span class="line">        <span class="type">SingletonEnum</span> <span class="variable">e2</span> <span class="operator">=</span> SingletonEnum.INSTANCE;</span><br><span class="line">        System.out.println(<span class="string">&quot;Enum: &quot;</span> + (e1 == e2));  <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 测试 ThreadLocal</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">SingletonThreadLocal</span> <span class="variable">stl1</span> <span class="operator">=</span> SingletonThreadLocal.getInstance();</span><br><span class="line">            System.out.println(<span class="string">&quot;ThreadLocal Thread1: &quot;</span> + stl1);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">SingletonThreadLocal</span> <span class="variable">stl2</span> <span class="operator">=</span> SingletonThreadLocal.getInstance();</span><br><span class="line">            System.out.println(<span class="string">&quot;ThreadLocal Thread2: &quot;</span> + stl2);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="说明">说明</h4>
<ul>
<li><strong>线程安全</strong>：
<ul>
<li>饿汉式、静态内部类、枚举天然线程安全。</li>
<li>懒汉式需加锁（同步方法或 DCL）实现线程安全。</li>
<li>ThreadLocal 为每个线程提供独立实例。</li>
</ul></li>
<li><strong>反射和序列化防护</strong>：
<ul>
<li>枚举单例天然防止反射和序列化破坏。</li>
<li>其他实现通过检查实例是否存在（构造方法抛异常）防御反射。</li>
<li>序列化需实现 <code>readResolve</code> 方法： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>性能</strong>：
<ul>
<li>饿汉式和枚举无延迟，静态内部类和 DCL 高效懒加载。</li>
<li>同步方法性能较低。</li>
</ul></li>
<li><strong>复杂度</strong>：
<ul>
<li>枚举最简单，DCL 最复杂。</li>
</ul></li>
</ul>
<hr />
<h4 id="总结表">总结表</h4>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 8%" />
<col style="width: 11%" />
<col style="width: 8%" />
<col style="width: 11%" />
<col style="width: 14%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="header">
<th>实现方式</th>
<th>懒加载</th>
<th>线程安全</th>
<th>复杂度</th>
<th>防止反射</th>
<th>防止序列化</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>饿汉式</td>
<td>否</td>
<td>是</td>
<td>低</td>
<td>是</td>
<td>需额外实现</td>
<td>简单实例</td>
</tr>
<tr class="even">
<td>懒汉式</td>
<td>是</td>
<td>否</td>
<td>低</td>
<td>是</td>
<td>需额外实现</td>
<td>单线程</td>
</tr>
<tr class="odd">
<td>同步方法</td>
<td>是</td>
<td>是</td>
<td>中</td>
<td>是</td>
<td>需额外实现</td>
<td>调用不频繁</td>
</tr>
<tr class="even">
<td>双重检查锁</td>
<td>是</td>
<td>是</td>
<td>高</td>
<td>是</td>
<td>需额外实现</td>
<td>高性能多线程</td>
</tr>
<tr class="odd">
<td>静态内部类</td>
<td>是</td>
<td>是</td>
<td>中</td>
<td>是</td>
<td>需额外实现</td>
<td>推荐的多线程懒加载</td>
</tr>
<tr class="even">
<td>枚举</td>
<td>否</td>
<td>是</td>
<td>低</td>
<td>是</td>
<td>是</td>
<td>最高安全性</td>
</tr>
<tr class="odd">
<td>ThreadLocal</td>
<td>是</td>
<td>线程内</td>
<td>中</td>
<td>是</td>
<td>需额外实现</td>
<td>线程私有单例</td>
</tr>
</tbody>
</table>
<h4 id="如何防止序列化破坏">如何防止序列化破坏</h4>
<p>为什么会发生序列化破坏：如果一个单例类实现了 Serializable
接口，反序列化时会通过反射创建一个新实例，而不是返回现有的单例实例。这会导致系统中存在多个实例，破坏单例的唯一性。</p>
<p>在单例类中添加 readResolve 方法，反序列化时 JVM
会调用此方法，返回指定的对象，而不是新建的实例。或者使用枚举。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加 readResolve 方法</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;  <span class="comment">// 返回单例实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;singleton.ser&quot;</span>));</span><br><span class="line">        oos.writeObject(s1);</span><br><span class="line">        oos.close();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;singleton.ser&quot;</span>));</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;s1 == s2: &quot;</span> + (s1 == s2));  <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工厂方法factory-method"><strong>工厂方法（Factory
Method）</strong></h3>
<p>工厂方法模式（Factory Method
Pattern）是一种创建型设计模式，它定义了一个用于创建对象的接口，但将具体的对象实例化推迟到子类中实现。相比简单工厂模式，工厂方法模式通过将对象的创建交给具体的工厂类，提升了灵活性和扩展性，遵循了“开闭原则”（对扩展开放，对修改关闭）。</p>
<p>以下是用 Java
实现工厂方法模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="工厂方法模式的定义">1. 工厂方法模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：定义一个创建对象的接口（工厂方法），由子类决定具体实例化哪种产品。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦客户端与具体产品类。</li>
<li>让子类决定创建哪种对象，增加系统的可扩展性。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>需要生成的产品种类较多，且可能新增类型。</li>
<li>客户端不关心对象的具体创建过程，只关心接口。</li>
</ul></li>
</ul>
<hr />
<h4 id="工厂方法模式的结构">2. 工厂方法模式的结构</h4>
<ul>
<li><strong>抽象产品（Product）</strong>：定义产品的接口，所有具体产品实现此接口。</li>
<li><strong>具体产品（Concrete
Product）</strong>：实现抽象产品接口的具体类。</li>
<li><strong>抽象工厂（Creator）</strong>：声明工厂方法，返回抽象产品类型。</li>
<li><strong>具体工厂（Concrete
Creator）</strong>：实现工厂方法，创建具体产品实例。</li>
</ul>
<h5 id="uml-图">UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Product &#123;
        &lt;&lt;interface&gt;&gt;
        +operation() void
    &#125;
    
    class ConcreteProduct &#123;
        +operation() void
    &#125;
    
    class Creator &#123;
        &lt;&lt;abstract&gt;&gt;
        +factoryMethod() Product
    &#125;
    
    class ConcreteCreator &#123;
        +factoryMethod() Product
    &#125;
    
    ConcreteProduct ..|&gt; Product : implements
    ConcreteCreator --|&gt; Creator : extends
    ConcreteCreator o--&gt; &quot;1&quot; ConcreteProduct : creates</code></pre>
<hr />
<h4 id="java-实现示例">3. Java 实现示例</h4>
<p>以下是一个生产不同类型车辆的工厂方法模式示例：</p>
<h5 id="抽象产品接口">3.1 抽象产品接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品：车辆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;  <span class="comment">// 定义车辆的通用行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体产品类">3.2 具体产品类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体产品：汽车</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Driving a car&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：摩托车</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Motorcycle</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Riding a motorcycle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象工厂类">3.3 抽象工厂类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂：车辆工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">VehicleFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 工厂方法，子类实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Vehicle <span class="title function_">createVehicle</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可选：提供默认行为</span></span><br><span class="line">    <span class="keyword">public</span> Vehicle <span class="title function_">getVehicle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> createVehicle();</span><br><span class="line">        vehicle.drive();</span><br><span class="line">        <span class="keyword">return</span> vehicle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体工厂类">3.4 具体工厂类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体工厂：汽车工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> <span class="keyword">extends</span> <span class="title class_">VehicleFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Vehicle <span class="title function_">createVehicle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：摩托车工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MotorcycleFactory</span> <span class="keyword">extends</span> <span class="title class_">VehicleFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Vehicle <span class="title function_">createVehicle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Motorcycle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用汽车工厂</span></span><br><span class="line">        <span class="type">VehicleFactory</span> <span class="variable">carFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarFactory</span>();</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">car</span> <span class="operator">=</span> carFactory.getVehicle();  <span class="comment">// 输出: Driving a car</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用摩托车工厂</span></span><br><span class="line">        <span class="type">VehicleFactory</span> <span class="variable">motorcycleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MotorcycleFactory</span>();</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">motorcycle</span> <span class="operator">=</span> motorcycleFactory.getVehicle();  <span class="comment">// 输出: Riding a motorcycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>选择具体的工厂类（<code>CarFactory</code> 或
<code>MotorcycleFactory</code>）。</li>
<li>调用工厂的 <code>createVehicle()</code>
方法，创建具体产品（<code>Car</code> 或 <code>Motorcycle</code>）。</li>
<li>返回的 <code>Vehicle</code>
对象由客户端使用，客户端无需知道具体产品类。</li>
</ol>
<hr />
<h4 id="优点">5. 优点</h4>
<ul>
<li><strong>灵活性</strong>：新增产品只需添加新产品类和对应的工厂类，无需修改现有代码。</li>
<li><strong>解耦</strong>：客户端只依赖抽象接口（<code>Vehicle</code> 和
<code>VehicleFactory</code>），不关心具体实现。</li>
<li><strong>单一职责</strong>：每个工厂负责创建一种产品，职责清晰。</li>
</ul>
<hr />
<h4 id="缺点">6. 缺点</h4>
<ul>
<li><strong>类数量增加</strong>：每增加一种产品，就需要新增一个具体产品类和一个具体工厂类，导致类数量增多。</li>
<li><strong>复杂度提升</strong>：相比简单工厂模式，代码结构更复杂。</li>
</ul>
<hr />
<h4 id="与简单工厂的对比">7. 与简单工厂的对比</h4>
<h5 id="简单工厂非工厂方法模式">简单工厂（非工厂方法模式）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleVehicleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vehicle <span class="title function_">createVehicle</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;car&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;motorcycle&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Motorcycle</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">car</span> <span class="operator">=</span> SimpleVehicleFactory.createVehicle(<span class="string">&quot;car&quot;</span>);</span><br><span class="line">        car.drive();  <span class="comment">// 输出: Driving a car</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>区别</strong>：
<ul>
<li>简单工厂将创建逻辑集中在一个类中，违反“开闭原则”（新增类型需修改工厂类）。</li>
<li>工厂方法将创建逻辑分散到子类中，符合“开闭原则”。</li>
</ul></li>
</ul>
<hr />
<h4 id="扩展示例带参数的工厂方法">8. 扩展示例：带参数的工厂方法</h4>
<p>如果需要根据参数创建不同配置的产品，可以这样扩展：</p>
<h5 id="修改抽象工厂">修改抽象工厂</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">VehicleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Vehicle <span class="title function_">createVehicle</span><span class="params">(String color)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修改具体工厂">修改具体工厂</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> <span class="keyword">extends</span> <span class="title class_">VehicleFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Vehicle <span class="title function_">createVehicle</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Driving a &quot;</span> + color + <span class="string">&quot; car&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端">客户端</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VehicleFactory</span> <span class="variable">carFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarFactory</span>();</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">redCar</span> <span class="operator">=</span> carFactory.createVehicle(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">        redCar.drive();  <span class="comment">// 输出: Driving a red car</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="实际应用场景">9. 实际应用场景</h4>
<ul>
<li><strong>日志框架</strong>：如 SLF4J 的
<code>LoggerFactory</code>，根据配置创建不同类型的日志记录器。</li>
<li><strong>数据库连接</strong>：根据驱动类型创建不同的
<code>Connection</code> 对象。</li>
<li><strong>UI 组件</strong>：根据主题创建不同样式的按钮或窗口。</li>
</ul>
<hr />
<h4 id="源码中的例子">10. 源码中的例子</h4>
<p>Java 中的 <code>java.util.Calendar</code> 使用了类似工厂方法模式：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();  <span class="comment">// getInstance 是工厂方法</span></span><br></pre></td></tr></table></figure> - <code>Calendar</code>
是抽象类，<code>getInstance()</code> 根据区域和时区返回具体子类（如
<code>GregorianCalendar</code>）。</p>
<hr />
<h4 id="总结">总结</h4>
<ul>
<li><strong>工厂方法模式</strong>通过抽象工厂接口和具体工厂类实现对象的创建，提供了扩展性和解耦性。</li>
<li><strong>Java
实现</strong>的关键是定义抽象产品和工厂接口，然后由具体子类实现。</li>
<li><strong>核心优势</strong>是支持新增产品而无需修改现有代码。</li>
</ul>
<h3 id="抽象工厂abstract-factory"><strong>抽象工厂（Abstract
Factory）</strong></h3>
<p>抽象工厂模式（Abstract Factory
Pattern）是一种创建型设计模式，它提供了一个接口，用于创建一系列相关或相互依赖的对象，而无需指定具体类。与工厂方法模式不同，抽象工厂模式关注于创建一组相关的产品（产品族），适用于需要统一风格或兼容性对象的场景。</p>
<p>以下是用 Java
实现抽象工厂模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="抽象工厂模式的定义">1. 抽象工厂模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：定义一个抽象工厂接口，创建一组相关产品的对象，具体工厂类实现该接口，生成具体产品。</li>
<li><strong>目的</strong>：
<ul>
<li>将一组相关产品的创建封装起来，确保产品之间的兼容性。</li>
<li>解耦客户端与具体产品类，客户端只依赖抽象接口。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>需要创建多个相关对象（如 UI 组件、数据库访问对象）。</li>
<li>系统需要支持多种产品族（如不同风格的主题或配置）。</li>
</ul></li>
</ul>
<hr />
<h4 id="抽象工厂模式的结构">2. 抽象工厂模式的结构</h4>
<ul>
<li><strong>抽象产品接口（Abstract
Product）</strong>：定义每个产品类型的接口。</li>
<li><strong>具体产品（Concrete
Product）</strong>：实现抽象产品接口的具体类。</li>
<li><strong>抽象工厂（Abstract
Factory）</strong>：声明一组创建产品的方法。</li>
<li><strong>具体工厂（Concrete
Factory）</strong>：实现抽象工厂接口，创建一组具体产品。</li>
</ul>
<h5 id="uml-图-1">UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class AbstractProductA &#123;
        +operationA()
    &#125;
    class ConcreteProductA &#123;
        +operationA()
    &#125;
    class AbstractProductB &#123;
        +operationB()
    &#125;
    class ConcreteProductB &#123;
        +operationB()
    &#125;
    class AbstractFactory &#123;
        +createProductA() AbstractProductA
        +createProductB() AbstractProductB
    &#125;
    class ConcreteFactory &#123;
        +createProductA() AbstractProductA
        +createProductB() AbstractProductB
    &#125;
    
    ConcreteProductA --|&gt; AbstractProductA
    ConcreteProductB --|&gt; AbstractProductB
    ConcreteFactory --|&gt; AbstractFactory
    ConcreteFactory --&gt; ConcreteProductA
    ConcreteFactory --&gt; ConcreteProductB</code></pre>
<hr />
<h4 id="java-实现示例-1">3. Java 实现示例</h4>
<p>以下是一个生产 UI
组件（按钮和文本框）的抽象工厂模式示例，支持不同风格（如 Windows 和
Mac）。</p>
<h5 id="抽象产品接口-1">3.1 抽象产品接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品：按钮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品：文本框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体产品类-1">3.2 具体产品类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体产品：Windows 按钮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rendering a Windows button&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Windows 文本框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Input in a Windows text field&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Mac 按钮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rendering a Mac button&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Mac 文本框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Input in a Mac text field&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象工厂接口">3.3 抽象工厂接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂：UI 工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UIFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体工厂类-1">3.4 具体工厂类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体工厂：Windows UI 工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsUIFactory</span> <span class="keyword">implements</span> <span class="title class_">UIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：Mac UI 工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacUIFactory</span> <span class="keyword">implements</span> <span class="title class_">UIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-1">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Windows UI 工厂</span></span><br><span class="line">        <span class="type">UIFactory</span> <span class="variable">windowsFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsUIFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">windowsButton</span> <span class="operator">=</span> windowsFactory.createButton();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">windowsText</span> <span class="operator">=</span> windowsFactory.createTextField();</span><br><span class="line">        windowsButton.render();  <span class="comment">// 输出: Rendering a Windows button</span></span><br><span class="line">        windowsText.input();     <span class="comment">// 输出: Input in a Windows text field</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Mac UI 工厂</span></span><br><span class="line">        <span class="type">UIFactory</span> <span class="variable">macFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacUIFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">macButton</span> <span class="operator">=</span> macFactory.createButton();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">macText</span> <span class="operator">=</span> macFactory.createTextField();</span><br><span class="line">        macButton.render();  <span class="comment">// 输出: Rendering a Mac button</span></span><br><span class="line">        macText.input();     <span class="comment">// 输出: Input in a Mac text field</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-1">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>选择一个具体工厂（如
<code>WindowsUIFactory</code> 或 <code>MacUIFactory</code>）。</li>
<li>调用工厂的创建方法（<code>createButton()</code> 和
<code>createTextField()</code>），生成一组相关产品。</li>
<li>客户端使用这些产品，保持风格一致性（如 Windows
风格的按钮和文本框）。</li>
</ol>
<hr />
<h4 id="优点-1">5. 优点</h4>
<ul>
<li><strong>一致性</strong>：保证创建的产品属于同一产品族，兼容性强。</li>
<li><strong>扩展性</strong>：新增产品族只需增加新的具体工厂和产品类，符合“开闭原则”。</li>
<li><strong>解耦</strong>：客户端只依赖抽象工厂和产品接口，不关心具体实现。</li>
</ul>
<hr />
<h4 id="缺点-1">6. 缺点</h4>
<ul>
<li><strong>复杂度高</strong>：需要定义多个抽象产品和具体工厂，类数量较多。</li>
<li><strong>不易扩展产品</strong>：如果产品族中的产品种类增加（如新增
Checkbox），需要修改抽象工厂接口及其所有实现类，违反“开闭原则”。</li>
</ul>
<hr />
<h4 id="与工厂方法的对比">7. 与工厂方法的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>工厂方法模式</th>
<th>抽象工厂模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>创建对象</strong></td>
<td>单个产品</td>
<td>一组相关产品（产品族）</td>
</tr>
<tr class="even">
<td><strong>扩展性</strong></td>
<td>易扩展新产品种类</td>
<td>易扩展新产品族</td>
</tr>
<tr class="odd">
<td><strong>复杂度</strong></td>
<td>较低</td>
<td>较高</td>
</tr>
<tr class="even">
<td><strong>抽象层级</strong></td>
<td>一个工厂方法</td>
<td>多个创建方法</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>工厂方法</strong>：关注单一产品的创建（如只创建按钮）。</li>
<li><strong>抽象工厂</strong>：关注一组相关产品的创建（如按钮和文本框的组合）。</li>
</ul>
<hr />
<h4 id="扩展示例带参数">8. 扩展示例：带参数</h4>
<p>如果需要根据参数创建产品，可以这样扩展：</p>
<h5 id="修改抽象工厂-1">修改抽象工厂</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UIFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">(String style)</span>;</span><br><span class="line">    TextField <span class="title function_">createTextField</span><span class="params">(String style)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修改具体工厂-1">修改具体工厂</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsUIFactory</span> <span class="keyword">implements</span> <span class="title class_">UIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">(String style)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>(style);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">(String style)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsTextField</span>(style);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String style;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WindowsButton</span><span class="params">(String style)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.style = style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rendering a Windows button with style: &quot;</span> + style);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端-1">客户端</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UIFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsUIFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> factory.createButton(<span class="string">&quot;modern&quot;</span>);</span><br><span class="line">        button.render();  <span class="comment">// 输出: Rendering a Windows button with style: modern</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="实际应用场景-1">9. 实际应用场景</h4>
<ul>
<li><strong>GUI 框架</strong>：如 Swing 或
JavaFX，创建不同平台的组件（如 Windows 和 Mac 风格的按钮、窗口）。</li>
<li><strong>数据库访问</strong>：创建一组数据库操作对象（如连接、语句、结果集），支持
MySQL、Oracle 等。</li>
<li><strong>游戏开发</strong>：创建不同主题的资源（如森林主题的树木和动物）。</li>
</ul>
<hr />
<h4 id="源码中的例子-1">10. 源码中的例子</h4>
<p>Java 中的 <code>java.sql.DriverManager</code> 和 JDBC
驱动有一些抽象工厂的影子： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url);  <span class="comment">// 工厂方法创建连接</span></span><br></pre></td></tr></table></figure> - 根据驱动类型，创建对应的
<code>Connection</code>、<code>Statement</code> 等对象。</p>
<hr />
<h4 id="总结-1">总结</h4>
<ul>
<li><strong>抽象工厂模式</strong>通过抽象工厂接口创建一组相关产品，适用于产品族场景。</li>
<li><strong>Java
实现</strong>的关键是定义抽象产品和工厂接口，由具体工厂实现产品创建。</li>
<li><strong>核心优势</strong>是保证产品一致性和支持产品族的扩展。</li>
</ul>
<p>如果你需要更复杂的例子（如多产品族）或 UML 图，请告诉我！</p>
<h3 id="建造者builder"><strong>建造者（Builder）</strong></h3>
<p>建造者模式（Builder
Pattern）是一种创建型设计模式，用于分步构建复杂对象。它将对象的构造过程与其表示分离，使得同样的构建过程可以创建不同的表示。建造者模式特别适合需要多个步骤配置的对象，例如对象有多个可选属性或复杂的初始化逻辑。</p>
<p>以下是用 Java 实现建造者模式的详细讲解，并附上用 Mermaid 绘制的 UML
类图。</p>
<hr />
<h4 id="建造者模式的定义">1. 建造者模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过一个建造者（Builder）逐步构造复杂对象，最终由指挥者（Director）或直接调用建造者生成产品。</li>
<li><strong>目的</strong>：
<ul>
<li>分离对象的构造和表示，便于灵活配置。</li>
<li>避免构造函数参数过多（“望远镜构造函数”问题）。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>对象有多个可选属性或复杂初始化步骤。</li>
<li>需要创建不可变对象。</li>
<li>构造过程需要复用。</li>
</ul></li>
</ul>
<hr />
<h4 id="建造者模式的结构">2. 建造者模式的结构</h4>
<ul>
<li><strong>产品（Product）</strong>：最终要构建的复杂对象。</li>
<li><strong>抽象建造者（Builder）</strong>：定义构建产品各部分的抽象方法。</li>
<li><strong>具体建造者（Concrete
Builder）</strong>：实现抽象建造者，逐步构造产品并提供获取结果的方法。</li>
<li><strong>指挥者（Director）</strong>：可选，负责控制建造过程，调用建造者的方法。</li>
</ul>
<h5 id="uml-图-2">UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Product &#123;
        -field1
        -field2
    &#125;
    class Builder &#123;
        +buildPart1()
        +buildPart2()
        +getResult() Product
    &#125;
    class ConcreteBuilder &#123;
        -product: Product
        +buildPart1()
        +buildPart2()
        +getResult() Product
    &#125;
    class Director &#123;
        -builder: Builder
        +construct()
    &#125;
    
    ConcreteBuilder --&gt; Product : builds
    ConcreteBuilder ..|&gt; Builder : implements
    Director --&gt; Builder : uses</code></pre>
<hr />
<h4 id="java-实现示例-2">3. Java 实现示例</h4>
<p>以下是一个构建房屋（House）的建造者模式示例。</p>
<h5 id="产品类">3.1 产品类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品：房屋</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String foundation;  <span class="comment">// 地基</span></span><br><span class="line">    <span class="keyword">private</span> String structure;   <span class="comment">// 结构</span></span><br><span class="line">    <span class="keyword">private</span> String roof;        <span class="comment">// 屋顶</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoundation</span><span class="params">(String foundation)</span> &#123; <span class="built_in">this</span>.foundation = foundation; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStructure</span><span class="params">(String structure)</span> &#123; <span class="built_in">this</span>.structure = structure; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoof</span><span class="params">(String roof)</span> &#123; <span class="built_in">this</span>.roof = roof; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;House [foundation=&quot;</span> + foundation + <span class="string">&quot;, structure=&quot;</span> + structure + <span class="string">&quot;, roof=&quot;</span> + roof + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象建造者接口">3.2 抽象建造者接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildFoundation</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildStructure</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildRoof</span><span class="params">()</span>;</span><br><span class="line">    House <span class="title function_">getResult</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体建造者类">3.3 具体建造者类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体建造者：木屋建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WoodenHouseBuilder</span> <span class="keyword">implements</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> House house;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WoodenHouseBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFoundation</span><span class="params">()</span> &#123;</span><br><span class="line">        house.setFoundation(<span class="string">&quot;Wooden foundation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildStructure</span><span class="params">()</span> &#123;</span><br><span class="line">        house.setStructure(<span class="string">&quot;Wooden walls&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildRoof</span><span class="params">()</span> &#123;</span><br><span class="line">        house.setRoof(<span class="string">&quot;Wooden roof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="指挥者类可选">3.4 指挥者类（可选）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指挥者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseDirector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HouseBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseDirector</span><span class="params">(HouseBuilder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        builder.buildFoundation();</span><br><span class="line">        builder.buildStructure();</span><br><span class="line">        builder.buildRoof();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-2">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用指挥者</span></span><br><span class="line">        <span class="type">HouseBuilder</span> <span class="variable">woodenBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WoodenHouseBuilder</span>();</span><br><span class="line">        <span class="type">HouseDirector</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseDirector</span>(woodenBuilder);</span><br><span class="line">        <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        System.out.println(house);  <span class="comment">// 输出: House [foundation=Wooden foundation, structure=Wooden walls, roof=Wooden roof]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接使用建造者</span></span><br><span class="line">        <span class="type">HouseBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WoodenHouseBuilder</span>();</span><br><span class="line">        builder.buildFoundation();</span><br><span class="line">        builder.buildStructure();</span><br><span class="line">        builder.buildRoof();</span><br><span class="line">        <span class="type">House</span> <span class="variable">house2</span> <span class="operator">=</span> builder.getResult();</span><br><span class="line">        System.out.println(house2);  <span class="comment">// 同上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-2">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>选择一个具体建造者（如
<code>WoodenHouseBuilder</code>）。</li>
<li>通过指挥者（可选）或直接调用建造者的方法，逐步构建产品（设置地基、结构、屋顶）。</li>
<li>调用 <code>getResult()</code> 获取最终产品。</li>
</ol>
<hr />
<h4 id="优点-2">5. 优点</h4>
<ul>
<li><strong>分步构造</strong>：将复杂对象的创建分解为多个步骤，清晰可控。</li>
<li><strong>灵活性</strong>：支持不同的构造过程和产品表示。</li>
<li><strong>封装性</strong>：隐藏产品的内部构造细节。</li>
</ul>
<hr />
<h4 id="缺点-2">6. 缺点</h4>
<ul>
<li><strong>类数量增加</strong>：需要为每种产品定义建造者，增加代码量。</li>
<li><strong>适用范围有限</strong>：适合复杂对象，不适合简单对象。</li>
</ul>
<hr />
<h4 id="与工厂模式的对比">7. 与工厂模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>工厂模式</th>
<th>建造者模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>关注点</strong></td>
<td>创建单一对象</td>
<td>分步构建复杂对象</td>
</tr>
<tr class="even">
<td><strong>过程</strong></td>
<td>一步完成</td>
<td>多步配置</td>
</tr>
<tr class="odd">
<td><strong>结果</strong></td>
<td>直接返回产品</td>
<td>构建完成后返回产品</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-2">9. 实际应用场景</h4>
<ul>
<li><strong>字符串构建</strong>：<code>StringBuilder</code>
是建造者模式的典型例子。</li>
<li><strong>对象配置</strong>：如 <code>OkHttpClient.Builder</code> 或
<code>AlertDialog.Builder</code>。</li>
<li><strong>文档生成</strong>：如生成复杂的 PDF 或 HTML 文档。</li>
</ul>
<hr />
<h4 id="源码中的例子-2">10. 源码中的例子</h4>
<p>Java 中的 <code>StringBuilder</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">builder.append(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot; &quot;</span>).append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> builder.toString();  <span class="comment">// 输出: Hello World</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-2">总结</h4>
<ul>
<li><strong>建造者模式</strong>通过分步构建复杂对象，提供灵活性和封装性。</li>
<li><strong>Java
实现</strong>的关键是定义建造者接口和产品类，指挥者可选。</li>
<li><strong>Mermaid UML</strong>展示了核心结构，清晰表达模式关系。</li>
</ul>
<p>如果需要更复杂的例子（如多个建造者）或调整 UML 图，请告诉我！</p>
<h3 id="原型模式prototype"><strong>原型模式（Prototype）</strong></h3>
<p>原型模式（Prototype
Pattern）是一种创建型设计模式，通过复制现有对象（原型）来创建新对象，而不是通过构造函数从头构建。它适用于创建对象成本较高（如需要大量计算或资源）或需要基于现有对象快速生成类似对象的场景。</p>
<p>以下是用 Java 实现原型模式的详细讲解，并附上用 Mermaid 绘制的 UML
类图。</p>
<hr />
<h4 id="原型模式的定义">1. 原型模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过克隆已有对象（原型）创建新对象，而不是通过
<code>new</code> 实例化。</li>
<li><strong>目的</strong>：
<ul>
<li>提高创建效率，避免重复的初始化工作。</li>
<li>支持动态生成对象副本。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>对象创建复杂或耗时。</li>
<li>需要创建大量相似对象。</li>
<li>需要对象深拷贝或浅拷贝。</li>
</ul></li>
</ul>
<hr />
<h4 id="原型模式的结构">2. 原型模式的结构</h4>
<ul>
<li><strong>抽象原型（Prototype）</strong>：定义克隆方法的接口。</li>
<li><strong>具体原型（Concrete
Prototype）</strong>：实现克隆方法，复制自身。</li>
<li><strong>客户端（Client）</strong>：使用原型创建新对象。</li>
</ul>
<h5 id="uml-图-3">UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Prototype &#123;
        +clone() Prototype
    &#125;
    class ConcretePrototype &#123;
        -field1
        -field2
        +clone() Prototype
    &#125;
    class Client &#123;
        -prototype: Prototype
    &#125;
    
    ConcretePrototype ..|&gt; Prototype : implements
	Client --&gt; Prototype : uses
	ConcretePrototype --&gt; ConcretePrototype : clones</code></pre>
<hr />
<h4 id="java-实现示例-3">3. Java 实现示例</h4>
<p>以下是一个形状（Shape）的原型模式示例，支持克隆圆形对象。</p>
<h5 id="抽象原型接口">3.1 抽象原型接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象原型：实现 Cloneable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> <span class="keyword">extends</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Shape <span class="title function_">clone</span><span class="params">()</span>;  <span class="comment">// 克隆方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;    <span class="comment">// 示例方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体原型类">3.2 具体原型类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体原型：圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> radius, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">int</span> radius)</span> &#123; <span class="built_in">this</span>.radius = radius; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123; <span class="built_in">this</span>.color = color; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Shape) <span class="built_in">super</span>.clone();  <span class="comment">// 浅拷贝</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a &quot;</span> + color + <span class="string">&quot; circle with radius &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-3">3.3 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原型</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        original.draw();  <span class="comment">// 输出: Drawing a red circle with radius 10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆对象</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">cloned</span> <span class="operator">=</span> (Circle) original.clone();</span><br><span class="line">        cloned.setColor(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        cloned.draw();  <span class="comment">// 输出: Drawing a blue circle with radius 10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原对象保持不变</span></span><br><span class="line">        original.draw();  <span class="comment">// 输出: Drawing a red circle with radius 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-3">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建初始原型对象（如
<code>Circle</code>）。</li>
<li>调用 <code>clone()</code> 方法生成副本。</li>
<li>修改副本的属性，保持原对象不变。</li>
</ol>
<hr />
<h4 id="深拷贝-vs-浅拷贝">5. 深拷贝 vs 浅拷贝</h4>
<ul>
<li><strong>浅拷贝</strong>（如上例）：
<ul>
<li>使用
<code>Object.clone()</code>，只复制对象本身，引用类型字段仍指向原对象。</li>
<li>如果原型包含复杂对象（如列表），副本修改会影响原对象。</li>
</ul></li>
<li><strong>深拷贝</strong>：
<ul>
<li>手动实现 <code>clone()</code>，递归复制所有引用字段。</li>
</ul></li>
</ul>
<h5 id="深拷贝示例">深拷贝示例</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; tags;  <span class="comment">// 复杂字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> radius, String color, List&lt;String&gt; tags)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.tags = tags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Circle</span> <span class="variable">cloned</span> <span class="operator">=</span> (Circle) <span class="built_in">super</span>.clone();</span><br><span class="line">            cloned.tags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.tags);  <span class="comment">// 深拷贝列表</span></span><br><span class="line">            <span class="keyword">return</span> cloned;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a &quot;</span> + color + <span class="string">&quot; circle with radius &quot;</span> + radius + <span class="string">&quot;, tags: &quot;</span> + tags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTags</span><span class="params">(List&lt;String&gt; tags)</span> &#123; <span class="built_in">this</span>.tags = tags; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="优点-3">6. 优点</h4>
<ul>
<li><strong>性能提升</strong>：避免重复初始化，适合复杂对象。</li>
<li><strong>灵活性</strong>：动态创建对象副本，可修改副本而不影响原型。</li>
<li><strong>简化创建</strong>：无需复杂构造函数。</li>
</ul>
<hr />
<h4 id="缺点-3">7. 缺点</h4>
<ul>
<li><strong>实现复杂性</strong>：深拷贝需要手动实现，浅拷贝可能导致意外副作用。</li>
<li><strong>依赖 <code>Cloneable</code></strong>：Java
的克隆机制不够灵活，异常处理麻烦。</li>
</ul>
<hr />
<h4 id="与工厂模式的对比-1">8. 与工厂模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>工厂模式</th>
<th>原型模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>创建方式</strong></td>
<td>通过类实例化</td>
<td>通过复制现有对象</td>
</tr>
<tr class="even">
<td><strong>初始化</strong></td>
<td>从头构建</td>
<td>基于原型克隆</td>
</tr>
<tr class="odd">
<td><strong>适用性</strong></td>
<td>创建新对象</td>
<td>复制已有对象</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-3">10. 实际应用场景</h4>
<ul>
<li><strong>对象缓存</strong>：缓存复杂对象，通过克隆提供副本。</li>
<li><strong>图形编辑器</strong>：复制图形元素（如矩形、圆形）。</li>
<li><strong>游戏开发</strong>：克隆敌人或道具对象。</li>
</ul>
<hr />
<h4 id="源码中的例子-3">11. 源码中的例子</h4>
<p>Java 中的 <code>Object.clone()</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">ArrayList&lt;String&gt; cloned = (ArrayList&lt;String&gt;) list.clone();</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-3">总结</h4>
<ul>
<li><strong>原型模式</strong>通过克隆原型创建对象，提高效率和灵活性。</li>
<li><strong>Java 实现</strong>依赖 <code>Cloneable</code> 和
<code>clone()</code>，可实现浅拷贝或深拷贝。</li>
<li><strong>Mermaid UML</strong>展示了原型模式的核心结构。</li>
</ul>
<h2 id="结构型模式structural-patterns">结构型模式（Structural
Patterns）</h2>
<h3 id="适配器adapter"><strong>适配器（Adapter）</strong></h3>
<p>适配器模式（Adapter
Pattern）是一种结构型设计模式，用于将一个类的接口转换为客户端期望的另一个接口。它解决接口不兼容的问题，使原本不匹配的类能够协同工作。适配器模式有两种形式：<strong>类适配器</strong>（通过继承）和<strong>对象适配器</strong>（通过组合）。</p>
<p>以下是用 Java 实现适配器模式的讲解，并直接用 Mermaid 绘制 UML
类图。</p>
<hr />
<h4 id="适配器模式的定义">1. 适配器模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过一个适配器，将不兼容的接口转换为目标接口。</li>
<li><strong>目的</strong>：
<ul>
<li>让现有类适配新接口，无需修改原有代码。</li>
<li>提高代码复用性。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>集成遗留系统或第三方库。</li>
<li>接口不匹配但功能类似的情况。</li>
</ul></li>
</ul>
<hr />
<h4 id="适配器模式的结构">2. 适配器模式的结构</h4>
<ul>
<li><strong>目标接口（Target）</strong>：客户端期望的接口。</li>
<li><strong>适配者（Adaptee）</strong>：需要适配的现有类，接口不兼容。</li>
<li><strong>适配器（Adapter）</strong>：实现目标接口，调用适配者的方法。</li>
</ul>
<h5 id="uml-图-4">UML 图</h5>
<p>对象适配器版本：</p>
<pre><code class="highlight mermaid">classDiagram
    class Target &#123;
        +request()
    &#125;
    class Adaptee &#123;
        +specificRequest()
    &#125;
    class Adapter &#123;
        -adaptee: Adaptee
        +request()
    &#125;
    
    Adapter ..|&gt; Target : implements
    Adapter --&gt; Adaptee : uses</code></pre>
<p>类适配器版本：</p>
<pre><code class="highlight mermaid">classDiagram
    class Target &#123;
        +request()
    &#125;
    class Adaptee &#123;
        +specificRequest()
    &#125;
    class Adapter &#123;
        +request()
    &#125;
    
    Target &lt;|.. Adapter : implements
    Adaptee &lt;|-- Adapter : extends</code></pre>
<p>说明</p>
<ul>
<li><strong><code>Target</code></strong>：目标接口，定义客户端期望的方法。</li>
<li><strong><code>Adaptee</code></strong>：适配者，提供不兼容的功能。</li>
<li><strong><code>Adapter</code></strong>：
<ul>
<li>对象适配器：通过组合（<code>--&gt;</code>）持有
<code>Adaptee</code>。</li>
<li>类适配器：通过继承（<code>&lt;|--</code>）扩展
<code>Adaptee</code>。</li>
</ul></li>
<li><strong>关系</strong>：
<ul>
<li><code>Target &lt;|.. Adapter</code>：适配器实现目标接口。</li>
<li>对象适配器：<code>Adapter --&gt; Adaptee</code>（组合）。</li>
<li>类适配器：<code>Adaptee &lt;|-- Adapter</code>（继承）。</li>
</ul></li>
</ul>
<hr />
<h4 id="java-实现示例-4">3. Java 实现示例</h4>
<p>以下是一个将旧电源接口适配为新接口的例子。</p>
<h5 id="目标接口">3.1 目标接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标接口：新电源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NewPower</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">providePower</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="适配者类">3.2 适配者类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 适配者：旧电源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldPower</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outputPower</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outputting power from old system&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对象适配器">3.3 对象适配器</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerAdapter</span> <span class="keyword">implements</span> <span class="title class_">NewPower</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OldPower oldPower;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PowerAdapter</span><span class="params">(OldPower oldPower)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oldPower = oldPower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">providePower</span><span class="params">()</span> &#123;</span><br><span class="line">        oldPower.outputPower();  <span class="comment">// 调用适配者的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类适配器替代实现">3.4 类适配器（替代实现）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类适配器（通过继承）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerAdapterClass</span> <span class="keyword">extends</span> <span class="title class_">OldPower</span> <span class="keyword">implements</span> <span class="title class_">NewPower</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">providePower</span><span class="params">()</span> &#123;</span><br><span class="line">        outputPower();  <span class="comment">// 继承并调用父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-4">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 对象适配器</span></span><br><span class="line">        <span class="type">OldPower</span> <span class="variable">oldPower</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OldPower</span>();</span><br><span class="line">        <span class="type">NewPower</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PowerAdapter</span>(oldPower);</span><br><span class="line">        adapter.providePower();  <span class="comment">// 输出: Outputting power from old system</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类适配器</span></span><br><span class="line">        <span class="type">NewPower</span> <span class="variable">adapterClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PowerAdapterClass</span>();</span><br><span class="line">        adapterClass.providePower();  <span class="comment">// 输出: Outputting power from old system</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-4">4. 工作原理</h4>
<ul>
<li><strong>对象适配器</strong>：通过组合持有适配者对象，转换调用。</li>
<li><strong>类适配器</strong>：通过继承适配者并实现目标接口，转换调用。</li>
</ul>
<hr />
<h4 id="优点-4">5. 优点</h4>
<ul>
<li><strong>复用性</strong>：无需修改现有代码即可复用适配者。</li>
<li><strong>灵活性</strong>：对象适配器通过组合更灵活，类适配器适合简单场景。</li>
<li><strong>解耦</strong>：客户端只依赖目标接口。</li>
</ul>
<hr />
<h4 id="缺点-4">6. 缺点</h4>
<ul>
<li><strong>复杂度</strong>：增加一个适配器类，可能提高系统复杂性。</li>
<li><strong>类适配器局限</strong>：Java
单继承限制了类适配器的使用。</li>
</ul>
<hr />
<h4 id="与其他模式的对比">7. 与其他模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>适配器模式</th>
<th>装饰者模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>接口转换</td>
<td>增强功能</td>
</tr>
<tr class="even">
<td><strong>结构</strong></td>
<td>适配已有类</td>
<td>包装同类对象</td>
</tr>
<tr class="odd">
<td><strong>关系</strong></td>
<td>转换调用</td>
<td>递归调用</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-4">8. 实际应用场景</h4>
<ul>
<li><strong>IO 流</strong>：<code>InputStreamReader</code> 适配
<code>InputStream</code> 到 <code>Reader</code>。</li>
<li><strong>事件监听</strong>：<code>MouseAdapter</code> 适配
<code>MouseListener</code> 接口。</li>
<li><strong>第三方库</strong>：适配旧 API 到新系统。</li>
</ul>
<hr />
<h4 id="源码中的例子-4">9. 源码中的例子</h4>
<p>Java 中的 <code>InputStreamReader</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input);  <span class="comment">// 适配器</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-4">总结</h4>
<ul>
<li><strong>适配器模式</strong>通过转换接口实现兼容性，支持对象适配器（组合）和类适配器（继承）。</li>
<li><strong>Java 实现</strong>依赖接口和组合/继承机制。</li>
<li><strong>Mermaid UML</strong>展示了两种形式的结构。</li>
</ul>
<p>如果需要深究某种适配器或调整 UML 图，请告诉我！</p>
<h3 id="桥接bridge"><strong>桥接（Bridge）</strong></h3>
<p>桥接模式（Bridge
Pattern）是一种结构型设计模式，用于将抽象部分与实现部分分离，使它们可以独立变化。它通过组合而非继承，将两个维度的变化解耦，增强系统的灵活性和扩展性。</p>
<p>以下是用 Java 实现桥接模式的详细讲解，并在“模式结构”部分提供 Mermaid
UML 图。</p>
<hr />
<h4 id="桥接模式的定义">1. 桥接模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：将抽象（Abstraction）与实现（Implementation）分离，通过组合关系连接两者。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦抽象和实现，避免多层继承导致的复杂性。</li>
<li>支持独立扩展抽象和实现。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>一个类存在两个独立变化的维度（如形状和颜色）。</li>
<li>需要在运行时动态切换实现。</li>
<li>避免继承带来的紧耦合。</li>
</ul></li>
</ul>
<hr />
<h4 id="桥接模式的结构">2. 桥接模式的结构</h4>
<ul>
<li><strong>抽象部分（Abstraction）</strong>：定义高层接口，包含对实现的引用。</li>
<li><strong>修正抽象（Refined
Abstraction）</strong>：扩展抽象部分，提供具体功能。</li>
<li><strong>实现接口（Implementor）</strong>：定义实现部分的接口。</li>
<li><strong>具体实现（Concrete
Implementor）</strong>：实现接口的具体类。</li>
</ul>
<h5 id="mermaid-uml-图">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Abstraction &#123;
        -implementor: Implementor
        +operation()
    &#125;
    class RefinedAbstraction &#123;
        +operation()
    &#125;
    class Implementor &#123;
        +operationImpl()
    &#125;
    class ConcreteImplementorA &#123;
        +operationImpl()
    &#125;
    class ConcreteImplementorB &#123;
        +operationImpl()
    &#125;
    
	RefinedAbstraction --|&gt; Abstraction : extends
	ConcreteImplementorA ..|&gt; Implementor : implements
	ConcreteImplementorB ..|&gt; Implementor : implements
	Abstraction --&gt; Implementor : uses</code></pre>
<hr />
<h4 id="java-实现示例-5">3. Java 实现示例</h4>
<p>以下是一个绘制形状（矩形）并支持不同绘制方式（颜色）的桥接模式示例。</p>
<h5 id="实现接口">3.1 实现接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现接口：绘制方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体实现类">3.2 具体实现类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体实现：红色绘制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedDraw</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a red rectangle: &quot;</span> + width + <span class="string">&quot;x&quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现：蓝色绘制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlueDraw</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a blue rectangle: &quot;</span> + width + <span class="string">&quot;x&quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象部分">3.3 抽象部分</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象部分：形状</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Shape</span><span class="params">(DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修正抽象类">3.4 修正抽象类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修正抽象：矩形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.drawRectangle(width, height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-5">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用红色绘制矩形</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">redRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">RedDraw</span>());</span><br><span class="line">        redRectangle.draw();  <span class="comment">// 输出: Drawing a red rectangle: 10x5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用蓝色绘制矩形</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">blueRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">20</span>, <span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">BlueDraw</span>());</span><br><span class="line">        blueRectangle.draw();  <span class="comment">// 输出: Drawing a blue rectangle: 20x10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-5">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建具体实现（<code>RedDraw</code> 或
<code>BlueDraw</code>）。</li>
<li>将实现注入抽象类（<code>Rectangle</code>），通过组合连接。</li>
<li>调用抽象类的操作（<code>draw()</code>），间接调用实现的方法。</li>
</ol>
<hr />
<h4 id="优点-5">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：抽象和实现独立变化，互不影响。</li>
<li><strong>扩展性</strong>：可独立增加新的抽象或实现类。</li>
<li><strong>运行时切换</strong>：通过组合动态改变实现。</li>
</ul>
<hr />
<h4 id="缺点-5">6. 缺点</h4>
<ul>
<li><strong>复杂度增加</strong>：引入额外接口和类，设计更复杂。</li>
<li><strong>适用性有限</strong>：仅适合有两个独立变化维度的场景。</li>
</ul>
<hr />
<h4 id="与适配器模式的对比">7. 与适配器模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>桥接模式</th>
<th>适配器模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>分离抽象和实现</td>
<td>接口转换</td>
</tr>
<tr class="even">
<td><strong>时机</strong></td>
<td>设计时规划</td>
<td>集成已有代码</td>
</tr>
<tr class="odd">
<td><strong>关系</strong></td>
<td>组合为主</td>
<td>组合或继承</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-5">8. 实际应用场景</h4>
<ul>
<li><strong>JDBC</strong>：<code>Driver</code> 和
<code>Connection</code> 分离，驱动实现独立变化。</li>
<li><strong>GUI 框架</strong>：组件（如按钮）与绘制方式（如 Windows/Mac
风格）分离。</li>
<li><strong>日志系统</strong>：日志级别与输出方式（如文件、控制台）解耦。</li>
</ul>
<hr />
<h4 id="源码中的例子-5">9. 源码中的例子</h4>
<p>Java 中的 <code>java.sql.DriverManager</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url);  <span class="comment">// 桥接驱动实现</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-5">10. 总结</h4>
<ul>
<li><strong>桥接模式</strong>通过组合将抽象与实现分离，支持独立扩展。</li>
<li><strong>Java 实现</strong>依赖接口和组合，灵活性高。</li>
<li><strong>UML 图</strong>清晰展示了两部分的解耦关系。</li>
</ul>
<p>如果需要更复杂示例（如多实现）或调整 UML，请告诉我！</p>
<h3 id="组合composite"><strong>组合（Composite）</strong></h3>
<p>组合模式（Composite
Pattern）是一种结构型设计模式，用于将对象组织成树形结构，以表示“部分-整体”的层次关系。它允许客户端统一对待单个对象（叶子）和对象集合（容器），简化操作。</p>
<p>以下是用 Java
实现组合模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="组合模式的定义">1. 组合模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：将对象组合成树形结构，使单个对象和组合对象具有一致的接口。</li>
<li><strong>目的</strong>：
<ul>
<li>统一处理叶子节点和容器节点。</li>
<li>隐藏内部结构差异，简化客户端代码。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>表示树形结构（如文件系统、组织架构）。</li>
<li>需要统一操作单个对象和对象集合。</li>
</ul></li>
</ul>
<hr />
<h4 id="组合模式的结构">2. 组合模式的结构</h4>
<ul>
<li><strong>抽象组件（Component）</strong>：定义叶子和容器的公共接口。</li>
<li><strong>叶子（Leaf）</strong>：实现组件接口，表示树中的单个对象。</li>
<li><strong>容器（Composite）</strong>：实现组件接口，包含子组件集合，可递归操作。</li>
</ul>
<h5 id="mermaid-uml-图-1">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Component &#123;
        +operation()
        +add(Component)
        +remove(Component)
        +getChild(int) Component
    &#125;
    class Leaf &#123;
        +operation()
    &#125;
    class Composite &#123;
        -children: List&lt;Component&gt;
        +operation()
        +add(Component)
        +remove(Component)
        +getChild(int) Component
    &#125;
    
    Leaf ..|&gt; Component : implements
	Composite ..|&gt; Component : implements
    Composite o--&gt; &quot;many&quot; Component : contains</code></pre>
<hr />
<h4 id="java-实现示例-6">3. Java 实现示例</h4>
<p>以下是一个文件系统（文件和文件夹）的组合模式示例。</p>
<h5 id="抽象组件">3.1 抽象组件</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象组件：文件系统项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileSystemItem</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;  <span class="comment">// 显示信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="叶子类">3.2 叶子类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 叶子：文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">implements</span> <span class="title class_">FileSystemItem</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;File: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="容器类">3.3 容器类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 容器：文件夹</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Folder</span> <span class="keyword">implements</span> <span class="title class_">FileSystemItem</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;FileSystemItem&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Folder</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(FileSystemItem item)</span> &#123;</span><br><span class="line">        children.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(FileSystemItem item)</span> &#123;</span><br><span class="line">        children.remove(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Folder: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (FileSystemItem item : children) &#123;</span><br><span class="line">            item.display();  <span class="comment">// 递归显示子项</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-6">3.4 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        <span class="type">FileSystemItem</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;doc1.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileSystemItem</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;doc2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件夹</span></span><br><span class="line">        <span class="type">Folder</span> <span class="variable">folder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&quot;Documents&quot;</span>);</span><br><span class="line">        folder1.add(file1);</span><br><span class="line">        folder1.add(file2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Folder</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&quot;Root&quot;</span>);</span><br><span class="line">        root.add(folder1);</span><br><span class="line">        root.add(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;readme.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示树形结构</span></span><br><span class="line">        root.display();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Folder: Root</span></span><br><span class="line"><span class="comment">        Folder: Documents</span></span><br><span class="line"><span class="comment">        File: doc1.txt</span></span><br><span class="line"><span class="comment">        File: doc2.txt</span></span><br><span class="line"><span class="comment">        File: readme.txt</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-6">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建叶子（<code>File</code>）和容器（<code>Folder</code>）。</li>
<li>将叶子和子容器添加到容器中，形成树形结构。</li>
<li>调用统一接口（<code>display()</code>），递归处理整个结构。</li>
</ol>
<hr />
<h4 id="优点-6">5. 优点</h4>
<ul>
<li><strong>统一性</strong>：客户端无需区分叶子和容器，使用一致接口。</li>
<li><strong>扩展性</strong>：易于添加新组件（叶子或容器）。</li>
<li><strong>简化操作</strong>：递归处理树形结构。</li>
</ul>
<hr />
<h4 id="缺点-6">6. 缺点</h4>
<ul>
<li><strong>限制性</strong>：叶子和容器的接口必须一致，可能导致叶子实现无意义的方法（如
<code>add</code>）。</li>
<li><strong>复杂度</strong>：管理树形结构可能增加系统复杂性。</li>
</ul>
<hr />
<h4 id="与装饰者模式的对比">7. 与装饰者模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>组合模式</th>
<th>装饰者模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>表示部分-整体关系</td>
<td>动态增强功能</td>
</tr>
<tr class="even">
<td><strong>结构</strong></td>
<td>树形层次</td>
<td>线性包装</td>
</tr>
<tr class="odd">
<td><strong>操作</strong></td>
<td>统一处理</td>
<td>递归调用</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-6">8. 实际应用场景</h4>
<ul>
<li><strong>文件系统</strong>：文件和文件夹的树形结构。</li>
<li><strong>GUI 组件</strong>：如 Swing 中的 <code>Container</code> 和
<code>Component</code>。</li>
<li><strong>组织架构</strong>：公司部门和员工的层次关系。</li>
</ul>
<hr />
<h4 id="源码中的例子-6">9. 源码中的例子</h4>
<p>Java 中的 <code>java.awt.Component</code> 和 <code>Container</code>：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Container</span> <span class="variable">panel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Click&quot;</span>));  <span class="comment">// 组合结构</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-6">10. 总结</h4>
<ul>
<li><strong>组合模式</strong>通过统一接口处理树形结构，适合部分-整体场景。</li>
<li><strong>Java 实现</strong>依赖接口和递归，容器管理子组件。</li>
<li><strong>UML 图</strong>展示了组件、叶子和容器的关系。</li>
</ul>
<h3 id="装饰者decorator"><strong>装饰者（Decorator）</strong></h3>
<p>装饰者模式是一种结构型设计模式，用于动态地为对象添加功能，而无需修改其原有代码。它通过包装对象实现功能的扩展，遵循“开闭原则”（对扩展开放，对修改关闭）。</p>
<p>以下是用 Java
实现装饰者模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="装饰者模式的定义">1. 装饰者模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过组合动态地为对象添加职责，替代继承。</li>
<li><strong>目的</strong>：
<ul>
<li>增强对象功能，同时保持接口一致。</li>
<li>提供灵活的替代继承的扩展方式。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>需要动态添加功能（如日志、权限）。</li>
<li>无法通过子类扩展现有类。</li>
<li>需要多种功能组合。</li>
</ul></li>
</ul>
<hr />
<h4 id="装饰者模式的结构">2. 装饰者模式的结构</h4>
<ul>
<li><strong>抽象组件（Component）</strong>：定义被装饰对象的接口。</li>
<li><strong>具体组件（Concrete
Component）</strong>：实现组件接口，是被装饰的核心对象。</li>
<li><strong>抽象装饰者（Decorator）</strong>：实现组件接口，持有组件引用，定义装饰框架。</li>
<li><strong>具体装饰者（Concrete
Decorator）</strong>：扩展装饰者，添加具体功能。</li>
</ul>
<h5 id="mermaid-uml-图-2">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Component &#123;
        +operation()
    &#125;
    class ConcreteComponent &#123;
        +operation()
    &#125;
    class Decorator &#123;
        -component: Component
        +operation()
    &#125;
    class ConcreteDecorator &#123;
        +operation()
        +addedBehavior()
    &#125;
    
    ConcreteComponent ..|&gt; Component : implements
	Decorator ..|&gt; Component : implements
	ConcreteDecorator --|&gt; Decorator : extends
    Decorator o--&gt; Component : contains</code></pre>
<hr />
<h4 id="java-实现示例-7">3. Java 实现示例</h4>
<p>以下是一个咖啡定价的装饰者模式示例，支持添加配料（如牛奶、糖）。</p>
<h5 id="抽象组件-1">3.1 抽象组件</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象组件：咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;  <span class="comment">// 计算价格</span></span><br><span class="line">    String <span class="title function_">description</span><span class="params">()</span>;  <span class="comment">// 获取描述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体组件">3.2 具体组件</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体组件：简单咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">description</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Simple Coffee&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象装饰者">3.3 抽象装饰者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象装饰者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Coffee coffee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeDecorator</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">description</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.description();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体装饰者">3.4 具体装饰者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体装饰者：加牛奶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkDecorator</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MilkDecorator</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.cost() + <span class="number">2.0</span>;  <span class="comment">// 牛奶加价</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">description</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.description() + <span class="string">&quot;, Milk&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰者：加糖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SugarDecorator</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SugarDecorator</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.cost() + <span class="number">1.0</span>;  <span class="comment">// 糖加价</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">description</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.description() + <span class="string">&quot;, Sugar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-7">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 基础咖啡</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCoffee</span>();</span><br><span class="line">        System.out.println(coffee.description() + <span class="string">&quot; $&quot;</span> + coffee.cost());</span><br><span class="line">        <span class="comment">// 输出: Simple Coffee $5.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加牛奶</span></span><br><span class="line">        coffee = <span class="keyword">new</span> <span class="title class_">MilkDecorator</span>(coffee);</span><br><span class="line">        System.out.println(coffee.description() + <span class="string">&quot; $&quot;</span> + coffee.cost());</span><br><span class="line">        <span class="comment">// 输出: Simple Coffee, Milk $7.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加糖</span></span><br><span class="line">        coffee = <span class="keyword">new</span> <span class="title class_">SugarDecorator</span>(coffee);</span><br><span class="line">        System.out.println(coffee.description() + <span class="string">&quot; $&quot;</span> + coffee.cost());</span><br><span class="line">        <span class="comment">// 输出: Simple Coffee, Milk, Sugar $8.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-7">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建具体组件（如
<code>SimpleCoffee</code>）。</li>
<li>使用装饰者（如
<code>MilkDecorator</code>、<code>SugarDecorator</code>）包装组件，动态添加功能。</li>
<li>调用统一接口（<code>cost()</code>、<code>description()</code>），递归执行装饰逻辑。</li>
</ol>
<hr />
<h4 id="优点-7">5. 优点</h4>
<ul>
<li><strong>灵活性</strong>：动态添加或移除功能，无需修改原有类。</li>
<li><strong>复用性</strong>：装饰者可组合使用，生成多种组合。</li>
<li><strong>符合开闭原则</strong>：扩展功能不改动源代码。</li>
</ul>
<hr />
<h4 id="缺点-7">6. 缺点</h4>
<ul>
<li><strong>复杂度增加</strong>：多层装饰导致对象层次复杂，调试困难。</li>
<li><strong>类数量增多</strong>：每个新功能需定义新装饰者。</li>
</ul>
<hr />
<h4 id="与适配器模式的对比-1">7. 与适配器模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>装饰者模式</th>
<th>适配器模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>增强功能</td>
<td>接口转换</td>
</tr>
<tr class="even">
<td><strong>结构</strong></td>
<td>包装同类对象</td>
<td>适配不同类</td>
</tr>
<tr class="odd">
<td><strong>调用</strong></td>
<td>递归调用</td>
<td>转换调用</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-7">8. 实际应用场景</h4>
<ul>
<li><strong>IO 流</strong>：<code>BufferedInputStream</code> 装饰
<code>InputStream</code>。</li>
<li><strong>GUI 组件</strong>：添加边框、滚动条等装饰。</li>
<li><strong>日志系统</strong>：为日志添加时间戳、格式化。</li>
</ul>
<hr />
<h4 id="源码中的例子-7">9. 源码中的例子</h4>
<p>Java 中的 <code>java.io</code> 包： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">buffered</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(input);  <span class="comment">// 装饰</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-7">10. 总结</h4>
<ul>
<li><strong>装饰者模式</strong>通过包装动态增强对象功能，保持接口一致。</li>
<li><strong>Java 实现</strong>依赖接口和组合，支持多层装饰。</li>
<li><strong>UML 图</strong>展示了组件和装饰者的递归关系。</li>
</ul>
<h3 id="外观facade"><strong>外观（Facade）</strong></h3>
<p>外观模式是一种结构型设计模式，它为复杂的子系统提供一个简化的统一接口，隐藏子系统的复杂性，使客户端更容易使用。</p>
<p>以下是用 Java
实现外观模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="外观模式的定义">1. 外观模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过一个外观类封装子系统的复杂操作，提供简单的高层接口。</li>
<li><strong>目的</strong>：
<ul>
<li>简化客户端与子系统的交互。</li>
<li>解耦客户端与子系统，降低依赖性。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>子系统复杂且难以直接使用。</li>
<li>需要为子系统提供统一入口。</li>
<li>分层设计中隔离层间耦合。</li>
</ul></li>
</ul>
<hr />
<h4 id="外观模式的结构">2. 外观模式的结构</h4>
<ul>
<li><strong>子系统（Subsystem）</strong>：一组独立的类，完成特定功能。</li>
<li><strong>外观（Facade）</strong>：封装子系统，提供简化的接口。</li>
<li><strong>客户端（Client）</strong>：通过外观访问子系统。</li>
</ul>
<h5 id="mermaid-uml-图-3">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Facade &#123;
        -subsystemA: SubsystemA
        -subsystemB: SubsystemB
        +operation()
    &#125;
    class SubsystemA &#123;
        +operationA()
    &#125;
    class SubsystemB &#123;
        +operationB()
    &#125;
    class Client
    
    Client --&gt; Facade : uses
    Facade --&gt; SubsystemA : delegates
    Facade --&gt; SubsystemB : delegates</code></pre>
<hr />
<h4 id="java-实现示例-8">3. Java 实现示例</h4>
<p>以下是一个家庭影院系统的外观模式示例，简化音响、投影仪和灯光的操作。</p>
<h5 id="子系统类">3.1 子系统类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子系统：音响</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AudioSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audio system is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVolume</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audio volume set to &quot;</span> + level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audio system is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统：投影仪</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Projector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Projector is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInput</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Projector input set to &quot;</span> + input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Projector is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统：灯光</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lights</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dim</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lights dimmed to &quot;</span> + level + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lights are off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="外观类">3.2 外观类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外观：家庭影院</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeTheaterFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AudioSystem audio;</span><br><span class="line">    <span class="keyword">private</span> Projector projector;</span><br><span class="line">    <span class="keyword">private</span> Lights lights;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomeTheaterFacade</span><span class="params">(AudioSystem audio, Projector projector, Lights lights)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.audio = audio;</span><br><span class="line">        <span class="built_in">this</span>.projector = projector;</span><br><span class="line">        <span class="built_in">this</span>.lights = lights;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchMovie</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Preparing to watch a movie...&quot;</span>);</span><br><span class="line">        audio.turnOn();</span><br><span class="line">        audio.setVolume(<span class="number">50</span>);</span><br><span class="line">        projector.turnOn();</span><br><span class="line">        projector.setInput(input);</span><br><span class="line">        lights.dim(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Movie is ready!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">endMovie</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shutting down the movie...&quot;</span>);</span><br><span class="line">        audio.turnOff();</span><br><span class="line">        projector.turnOff();</span><br><span class="line">        lights.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-8">3.3 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AudioSystem</span> <span class="variable">audio</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AudioSystem</span>();</span><br><span class="line">        <span class="type">Projector</span> <span class="variable">projector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Projector</span>();</span><br><span class="line">        <span class="type">Lights</span> <span class="variable">lights</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lights</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HomeTheaterFacade</span> <span class="variable">theater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HomeTheaterFacade</span>(audio, projector, lights);</span><br><span class="line"></span><br><span class="line">        theater.watchMovie(<span class="string">&quot;HDMI&quot;</span>);  <span class="comment">// 启动电影</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Preparing to watch a movie...</span></span><br><span class="line"><span class="comment">        Audio system is on</span></span><br><span class="line"><span class="comment">        Audio volume set to 50</span></span><br><span class="line"><span class="comment">        Projector is on</span></span><br><span class="line"><span class="comment">        Projector input set to HDMI</span></span><br><span class="line"><span class="comment">        Lights dimmed to 20%</span></span><br><span class="line"><span class="comment">        Movie is ready!</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        theater.endMovie();  <span class="comment">// 关闭电影</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Shutting down the movie...</span></span><br><span class="line"><span class="comment">        Audio system is off</span></span><br><span class="line"><span class="comment">        Projector is off</span></span><br><span class="line"><span class="comment">        Lights are off</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-8">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建子系统实例并注入外观类。</li>
<li>调用外观的简化方法（如
<code>watchMovie</code>），外观协调子系统完成任务。</li>
<li>子系统独立运行，客户端无需直接操作。</li>
</ol>
<hr />
<h4 id="优点-8">5. 优点</h4>
<ul>
<li><strong>简化接口</strong>：降低客户端使用子系统的复杂度。</li>
<li><strong>解耦</strong>：客户端与子系统隔离，降低耦合度。</li>
<li><strong>封装性</strong>：隐藏子系统细节。</li>
</ul>
<hr />
<h4 id="缺点-8">6. 缺点</h4>
<ul>
<li><strong>功能有限</strong>：外观可能无法满足所有需求，客户端可能仍需直接访问子系统。</li>
<li><strong>新增开销</strong>：增加一个外观类，可能提高维护成本。</li>
</ul>
<hr />
<h4 id="与适配器模式的对比-2">7. 与适配器模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>外观模式</th>
<th>适配器模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>简化接口</td>
<td>接口转换</td>
</tr>
<tr class="even">
<td><strong>作用对象</strong></td>
<td>整个子系统</td>
<td>单个类</td>
</tr>
<tr class="odd">
<td><strong>复杂度</strong></td>
<td>降低使用复杂度</td>
<td>增加适配层复杂度</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-8">8. 实际应用场景</h4>
<ul>
<li><strong>数据库访问</strong>：封装 JDBC 操作，提供简单 API。</li>
<li><strong>多媒体系统</strong>：简化设备控制（如电视、音响）。</li>
<li><strong>工具库</strong>：为复杂底层功能提供高层接口。</li>
</ul>
<hr />
<h4 id="源码中的例子-8">9. 源码中的例子</h4>
<p>Java 中的 <code>java.util.logging.Logger</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;myLogger&quot;</span>);  <span class="comment">// 外观简化日志操作</span></span><br><span class="line">logger.info(<span class="string">&quot;Message&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-8">10. 总结</h4>
<ul>
<li><strong>外观模式</strong>通过封装子系统提供简化的统一接口，降低使用难度。</li>
<li><strong>Java 实现</strong>依赖组合，协调多个子系统。</li>
<li><strong>UML 图</strong>展示了外观与子系统的委托关系。</li>
</ul>
<h3 id="享元flyweight"><strong>享元（Flyweight）</strong></h3>
<p>享元模式（Flyweight
Pattern）是一种结构型设计模式，旨在通过共享对象来减少内存使用和提高性能。它适用于系统中存在大量相似对象的情况，通过复用已有的对象而不是创建新实例来优化资源消耗。</p>
<p>以下是用 Java
实现享元模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="享元模式的定义">1. 享元模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：共享相同的对象实例，减少重复创建，降低内存开销。</li>
<li><strong>目的</strong>：
<ul>
<li>提高系统效率，特别是在对象数量庞大时。</li>
<li>分离对象的内在状态（共享）和外在状态（不共享）。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>系统有大量相似对象。</li>
<li>对象创建成本高且可共享。</li>
<li>需要缓存不可变对象。</li>
</ul></li>
</ul>
<hr />
<h4 id="享元模式的结构">2. 享元模式的结构</h4>
<ul>
<li><strong>抽象享元（Flyweight）</strong>：定义共享对象的接口。</li>
<li><strong>具体享元（Concrete
Flyweight）</strong>：实现享元接口，存储内在状态。</li>
<li><strong>享元工厂（Flyweight
Factory）</strong>：管理享元对象的创建和共享。</li>
<li><strong>客户端（Client）</strong>：使用享元对象，维护外在状态。</li>
</ul>
<h5 id="mermaid-uml-图-4">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Flyweight &#123;
        +operation(extrinsicState)
    &#125;
    class ConcreteFlyweight &#123;
        -intrinsicState
        +operation(extrinsicState)
    &#125;
    class FlyweightFactory &#123;
        -flyweights: Map
        +getFlyweight(key) Flyweight
    &#125;
    class Client
    
    ConcreteFlyweight ..|&gt; Flyweight : implements
    FlyweightFactory --&gt; Flyweight : creates
    Client --&gt; FlyweightFactory : uses
    Client --&gt; Flyweight : uses</code></pre>
<hr />
<h4 id="java-实现示例-9">3. Java 实现示例</h4>
<p>以下是一个绘制圆形的享元模式示例，共享颜色相同的圆形对象。</p>
<h5 id="抽象享元接口">3.1 抽象享元接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象享元：圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;  <span class="comment">// 外在状态由客户端传入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体享元类">3.2 具体享元类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体享元：圆形（共享颜色）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;  <span class="comment">// 内在状态（共享）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a &quot;</span> + color + <span class="string">&quot; circle at (&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="享元工厂">3.3 享元工厂</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 享元工厂：管理圆形对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Shape&gt; circleMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title function_">getCircle</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> circleMap.get(color);</span><br><span class="line">        <span class="keyword">if</span> (circle == <span class="literal">null</span>) &#123;</span><br><span class="line">            circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(color);</span><br><span class="line">            circleMap.put(color, circle);</span><br><span class="line">            System.out.println(<span class="string">&quot;Created a new &quot;</span> + color + <span class="string">&quot; circle&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-9">3.4 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] colors = &#123;<span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Blue&quot;</span>, <span class="string">&quot;Green&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> colors[(<span class="type">int</span>) (Math.random() * colors.length)];</span><br><span class="line">            <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> ShapeFactory.getCircle(color);</span><br><span class="line">            circle.draw(i, i * <span class="number">2</span>);  <span class="comment">// 外在状态：位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出示例</strong>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Created a new Red circle</span><br><span class="line">Drawing a Red circle at (0, 0)</span><br><span class="line">Created a new Blue circle</span><br><span class="line">Drawing a Blue circle at (1, 2)</span><br><span class="line">Drawing a Red circle at (2, 4)</span><br><span class="line">Created a new Green circle</span><br><span class="line">Drawing a Green circle at (3, 6)</span><br><span class="line">Drawing a Blue circle at (4, 8)</span><br><span class="line">...</span><br></pre></td></tr></table></figure> -
<strong>说明</strong>：相同颜色的圆形只创建一次，之后共享。</p>
<hr />
<h4 id="工作原理-9">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>通过工厂请求享元对象（如
<code>getCircle</code>）。</li>
<li>工厂检查是否已有对应对象，若无则创建并缓存，若有则返回共享实例。</li>
<li>客户端传入外在状态（如位置），调用享元方法。</li>
</ol>
<hr />
<h4 id="内在状态-vs-外在状态">5. 内在状态 vs 外在状态</h4>
<ul>
<li><strong>内在状态</strong>：存储在享元对象中，不可变且可共享（如
<code>color</code>）。</li>
<li><strong>外在状态</strong>：由客户端维护，不共享（如
<code>x</code>、<code>y</code> 坐标）。</li>
</ul>
<hr />
<h4 id="优点-9">6. 优点</h4>
<ul>
<li><strong>节省内存</strong>：共享对象减少实例数量。</li>
<li><strong>性能提升</strong>：避免重复创建耗时对象。</li>
<li><strong>集中管理</strong>：工厂统一管理共享对象。</li>
</ul>
<hr />
<h4 id="缺点-9">7. 缺点</h4>
<ul>
<li><strong>复杂度增加</strong>：需要分离内外状态，设计更复杂。</li>
<li><strong>线程安全</strong>：共享对象需考虑并发访问（可用同步或不可变设计）。</li>
<li><strong>适用性有限</strong>：仅适合大量相似对象的场景。</li>
</ul>
<hr />
<h4 id="与单例模式的对比">8. 与单例模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>享元模式</th>
<th>单例模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>实例数量</strong></td>
<td>多实例（按键共享）</td>
<td>单实例</td>
</tr>
<tr class="even">
<td><strong>目的</strong></td>
<td>共享减少内存</td>
<td>确保唯一性</td>
</tr>
<tr class="odd">
<td><strong>管理</strong></td>
<td>工厂管理</td>
<td>静态方法控制</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-9">9. 实际应用场景</h4>
<ul>
<li><strong>字符缓存</strong>：文本编辑器中共享字体或字符对象。</li>
<li><strong>游戏开发</strong>：复用纹理或模型实例。</li>
<li><strong>连接池</strong>：数据库连接或线程池的共享管理。</li>
</ul>
<hr />
<h4 id="源码中的例子-9">10. 源码中的例子</h4>
<p>Java 中的 <code>Integer.valueOf()</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);  <span class="comment">// 缓存 -128 到 127 的整数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">System.out.println(a == b);  <span class="comment">// true，共享同一对象</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-9">11. 总结</h4>
<ul>
<li><strong>享元模式</strong>通过共享对象优化资源使用，分离内外状态。</li>
<li><strong>Java 实现</strong>依赖工厂和缓存（如
<code>Map</code>），支持高效复用。</li>
<li><strong>UML 图</strong>展示了享元、工厂和客户端的关系。</li>
</ul>
<h3 id="代理proxy"><strong>代理（Proxy）</strong></h3>
<p>代理模式（Proxy
Pattern）是一种结构型设计模式，通过引入一个代理对象来控制对目标对象的访问。它可以在不修改目标对象的情况下，增强功能（如权限检查、延迟加载、日志记录等）。代理模式的核心是为目标对象提供一个替代者，客户端通过代理间接访问目标。</p>
<p>以下是用 Java
实现代理模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="代理模式的定义">1. 代理模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过代理对象控制对目标对象的访问，增加额外的功能或限制。</li>
<li><strong>目的</strong>：
<ul>
<li>增强目标对象功能。</li>
<li>保护或隐藏目标对象。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>延迟加载（虚拟代理）。</li>
<li>访问控制（保护代理）。</li>
<li>日志或缓存（装饰代理）。</li>
</ul></li>
</ul>
<hr />
<h4 id="代理模式的结构">2. 代理模式的结构</h4>
<ul>
<li><strong>抽象主题（Subject）</strong>：定义目标和代理的公共接口。</li>
<li><strong>真实主题（Real
Subject）</strong>：实现主题接口，是被代理的目标对象。</li>
<li><strong>代理（Proxy）</strong>：实现主题接口，持有真实主题引用，控制访问并添加功能。</li>
</ul>
<h5 id="mermaid-uml-图-5">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Subject &#123;
        +request()
    &#125;
    class RealSubject &#123;
        +request()
    &#125;
    class Proxy &#123;
        -realSubject: RealSubject
        +request()
    &#125;
    
	RealSubject ..|&gt; Subject : implements
	Proxy ..|&gt; Subject : implements
	Proxy --&gt; RealSubject : uses</code></pre>
<hr />
<h4 id="代理模式的类型">3. 代理模式的类型</h4>
<ol type="1">
<li><strong>静态代理</strong>：代理类在编译时手动创建。</li>
<li><strong>动态代理</strong>：运行时通过反射动态生成（如 Java 的
<code>Proxy</code> 类）。</li>
<li><strong>虚拟代理</strong>：延迟加载目标对象。</li>
<li><strong>保护代理</strong>：控制访问权限。</li>
</ol>
<hr />
<h4 id="java-实现示例-10">4. Java 实现示例</h4>
<p>以下是一个文件访问的代理模式示例，展示静态代理和动态代理。</p>
<h5 id="抽象主题">4.1 抽象主题</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象主题：文件操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="真实主题">4.2 真实主题</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真实主题：文件服务实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FileService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Reading file: &quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="静态代理">4.3 静态代理</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态代理：添加日志功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">FileService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileService realService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileServiceProxy</span><span class="params">(FileService realService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realService = realService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging: Attempting to read file &quot;</span> + fileName);</span><br><span class="line">        realService.readFile(fileName);</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging: File read completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="动态代理">4.4 动态代理</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态代理：通过反射实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dynamic Logging: Before &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;Dynamic Logging: After &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FileService <span class="title function_">createProxy</span><span class="params">(FileService target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (FileService) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(target)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-10">4.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代理</span></span><br><span class="line">        <span class="type">FileService</span> <span class="variable">realService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileServiceImpl</span>();</span><br><span class="line">        <span class="type">FileService</span> <span class="variable">staticProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileServiceProxy</span>(realService);</span><br><span class="line">        staticProxy.readFile(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Logging: Attempting to read file data.txt</span></span><br><span class="line"><span class="comment">        Reading file: data.txt</span></span><br><span class="line"><span class="comment">        Logging: File read completed</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态代理</span></span><br><span class="line">        <span class="type">FileService</span> <span class="variable">dynamicProxy</span> <span class="operator">=</span> DynamicProxyHandler.createProxy(realService);</span><br><span class="line">        dynamicProxy.readFile(<span class="string">&quot;config.txt&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Dynamic Logging: Before readFile</span></span><br><span class="line"><span class="comment">        Reading file: config.txt</span></span><br><span class="line"><span class="comment">        Dynamic Logging: After readFile</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-10">5. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>通过代理对象调用方法。</li>
<li>代理执行额外逻辑（如日志、权限检查），然后委托给真实主题。</li>
<li>真实主题完成核心操作，返回结果。</li>
</ol>
<hr />
<h4 id="优点-10">6. 优点</h4>
<ul>
<li><strong>功能增强</strong>：无需修改目标代码即可添加功能。</li>
<li><strong>控制访问</strong>：代理可限制或延迟对目标的访问。</li>
<li><strong>灵活性</strong>：动态代理支持运行时调整。</li>
</ul>
<hr />
<h4 id="缺点-10">7. 缺点</h4>
<ul>
<li><strong>性能开销</strong>：代理层增加调用
overhead，尤其是动态代理。</li>
<li><strong>复杂度</strong>：实现动态代理需熟悉反射。</li>
<li><strong>静态局限</strong>：静态代理需为每个目标手动编写代理类。</li>
</ul>
<hr />
<h4 id="与装饰者模式的对比-1">8. 与装饰者模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>代理模式</th>
<th>装饰者模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>控制访问</td>
<td>增强功能</td>
</tr>
<tr class="even">
<td><strong>关注点</strong></td>
<td>代理行为</td>
<td>对象功能</td>
</tr>
<tr class="odd">
<td><strong>结构</strong></td>
<td>单层代理</td>
<td>多层包装</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-10">9. 实际应用场景</h4>
<ul>
<li><strong>延迟加载</strong>：如 ORM 框架中的懒加载（Hibernate）。</li>
<li><strong>权限控制</strong>：限制对敏感资源的访问。</li>
<li><strong>AOP</strong>：Spring
中通过代理实现切面（如日志、事务）。</li>
</ul>
<hr />
<h4 id="源码中的例子-10">10. 源码中的例子</h4>
<p>Java 中的 <code>java.lang.reflect.Proxy</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">proxy</span> <span class="operator">=</span> (Runnable) Proxy.newProxyInstance(</span><br><span class="line">    Runnable.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Runnable.class&#125;,</span><br><span class="line">    (p, method, args) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before run&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">proxy.run();</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-10">11. 总结</h4>
<ul>
<li><strong>代理模式</strong>通过代理对象控制目标访问，支持静态和动态实现。</li>
<li><strong>Java 实现</strong>静态代理用组合，动态代理用反射。</li>
<li><strong>UML 图</strong>展示了代理与真实主题的关系。</li>
</ul>
<h2 id="行为型模式behavioral-patterns">行为型模式（Behavioral
Patterns）</h2>
<h3 id="责任链chain-of-responsibility"><strong>责任链（Chain of
Responsibility）</strong></h3>
<p>我假设你指的是“责任链模式”（Chain of Responsibility
Pattern），可能是“责任链”中的简写或输入问题。责任链模式是一种行为型设计模式，它将请求的处理者组织成一个链，请求沿着链传递，直到某个处理者处理它或链结束。这种模式解耦了请求的发送者和接收者，增强了灵活性。</p>
<p>以下是用 Java
实现责任链模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="责任链模式的定义">1. 责任链模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：将请求的处理者组成一个链，请求沿链传递，每个处理者决定处理或转发。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦请求发送者和处理者。</li>
<li>动态调整处理顺序或责任分配。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>请求有多个处理者，但处理者不确定。</li>
<li>需要动态指定处理流程。</li>
<li>处理逻辑分层或条件化。</li>
</ul></li>
</ul>
<hr />
<h4 id="责任链模式的结构">2. 责任链模式的结构</h4>
<ul>
<li><strong>抽象处理者（Handler）</strong>：定义处理请求的接口和链的链接方法。</li>
<li><strong>具体处理者（Concrete
Handler）</strong>：实现处理逻辑，决定处理或传递请求。</li>
<li><strong>客户端（Client）</strong>：发起请求并交给链的起点。</li>
</ul>
<h5 id="mermaid-uml-图-6">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Handler &#123;
        -next: Handler
        +setNext(Handler)
        +handleRequest(request)
    &#125;
    class ConcreteHandlerA &#123;
        +handleRequest(request)
    &#125;
    class ConcreteHandlerB &#123;
        +handleRequest(request)
    &#125;
    class Client
    
    ConcreteHandlerA ..|&gt; Handler : implements
    ConcreteHandlerB ..|&gt; Handler : implements
    Handler o--&gt; Handler : next
    Client --&gt; Handler : sends to</code></pre>
<hr />
<h4 id="java-实现示例-11">3. Java 实现示例</h4>
<p>以下是一个日志处理的责任链模式示例，根据日志级别分发处理。</p>
<h5 id="抽象处理者">3.1 抽象处理者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象处理者：日志处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Logger nextLogger;  <span class="comment">// 下一个处理者</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> level;          <span class="comment">// 处理级别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Logger nextLogger)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextLogger = nextLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logMessage</span><span class="params">(<span class="type">int</span> level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.level &lt;= level) &#123;</span><br><span class="line">            write(message);  <span class="comment">// 当前处理者处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nextLogger != <span class="literal">null</span>) &#123;</span><br><span class="line">            nextLogger.logMessage(level, message);  <span class="comment">// 传递给下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体处理者">3.2 具体处理者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体处理者：控制台日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsoleLogger</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Console Logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者：文件日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;File Logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者：错误日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ErrorLogger</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Error Logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-11">3.3 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INFO</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEBUG</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ERROR</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建处理者</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">consoleLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleLogger</span>(INFO);</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">fileLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>(DEBUG);</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">errorLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorLogger</span>(ERROR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建责任链</span></span><br><span class="line">        consoleLogger.setNext(fileLogger);</span><br><span class="line">        fileLogger.setNext(errorLogger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        consoleLogger.logMessage(INFO, <span class="string">&quot;This is an info message&quot;</span>);</span><br><span class="line">        consoleLogger.logMessage(DEBUG, <span class="string">&quot;This is a debug message&quot;</span>);</span><br><span class="line">        consoleLogger.logMessage(ERROR, <span class="string">&quot;This is an error message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Console Logger: This is an info message</span><br><span class="line">Console Logger: This is a debug message</span><br><span class="line">File Logger: This is a debug message</span><br><span class="line">Console Logger: This is an error message</span><br><span class="line">File Logger: This is an error message</span><br><span class="line">Error Logger: This is an error message</span><br></pre></td></tr></table></figure> -
<strong>说明</strong>：消息按级别沿链传递，符合条件的处理者输出日志。</p>
<hr />
<h4 id="工作原理-11">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>构建责任链，设置处理者顺序。</li>
<li>请求从链头开始传递，每个处理者检查是否处理。</li>
<li>若当前处理者不处理，则传递给下一个，直到链结束。</li>
</ol>
<hr />
<h4 id="优点-11">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：请求发送者无需知道具体处理者。</li>
<li><strong>灵活性</strong>：可动态调整链的结构和顺序。</li>
<li><strong>扩展性</strong>：易于添加新处理者。</li>
</ul>
<hr />
<h4 id="缺点-11">6. 缺点</h4>
<ul>
<li><strong>不确定性</strong>：请求可能未被处理（链尾无匹配）。</li>
<li><strong>性能开销</strong>：链过长可能影响效率。</li>
<li><strong>调试复杂</strong>：多处理者时难以跟踪流程。</li>
</ul>
<hr />
<h4 id="与装饰者模式的对比-2">7. 与装饰者模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>责任链模式</th>
<th>装饰者模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>分担责任</td>
<td>增强功能</td>
</tr>
<tr class="even">
<td><strong>传递</strong></td>
<td>条件传递</td>
<td>递归调用</td>
</tr>
<tr class="odd">
<td><strong>结果</strong></td>
<td>单处理或无处理</td>
<td>层层增强</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-11">8. 实际应用场景</h4>
<ul>
<li><strong>Servlet 过滤器</strong>：请求沿 Filter 链处理。</li>
<li><strong>日志框架</strong>：如 SLF4J 的日志级别处理。</li>
<li><strong>事件处理</strong>：GUI 事件传递。</li>
</ul>
<hr />
<h4 id="源码中的例子-11">9. 源码中的例子</h4>
<p>Java 中的 <code>javax.servlet.FilterChain</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before filter&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);  <span class="comment">// 传递给下一个</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After filter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-11">10. 总结</h4>
<ul>
<li><strong>责任链模式</strong>通过链式结构分担请求处理，解耦发送者和接收者。</li>
<li><strong>Java 实现</strong>依赖抽象类和链式引用，支持动态调整。</li>
<li><strong>UML 图</strong>展示了处理者的链接关系。</li>
</ul>
<h3 id="命令command"><strong>命令（Command）</strong></h3>
<p>命令模式（Command
Pattern）是一种行为型设计模式，它将请求封装成一个对象，从而允许参数化客户端、记录请求日志、支持撤销操作以及将请求排队或延迟执行。命令模式通过解耦请求的发送者和接收者，增强了系统的灵活性。</p>
<p>以下是用 Java
实现命令模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="命令模式的定义">1. 命令模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：将请求封装为命令对象，分离请求的发起者（Invoker）和执行者（Receiver）。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦调用者和执行逻辑。</li>
<li>支持请求的存储、撤销、重做等操作。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>需要参数化操作（如菜单、按钮）。</li>
<li>支持事务或回滚。</li>
<li>请求需要排队或延迟执行。</li>
</ul></li>
</ul>
<hr />
<h4 id="命令模式的结构">2. 命令模式的结构</h4>
<ul>
<li><strong>抽象命令（Command）</strong>：定义命令的接口，通常包含执行方法。</li>
<li><strong>具体命令（Concrete
Command）</strong>：实现命令接口，关联接收者并调用其操作。</li>
<li><strong>接收者（Receiver）</strong>：执行具体操作的类。</li>
<li><strong>调用者（Invoker）</strong>：持有命令对象并触发执行。</li>
<li><strong>客户端（Client）</strong>：创建命令并配置调用者。</li>
</ul>
<h5 id="mermaid-uml-图-7">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Command &#123;
        +execute()
    &#125;
    class ConcreteCommand &#123;
        -receiver: Receiver
        +execute()
    &#125;
    class Receiver &#123;
        +action()
    &#125;
    class Invoker &#123;
        -command: Command
        +setCommand(Command)
        +executeCommand()
    &#125;
    class Client
    
    ConcreteCommand ..|&gt; Command : implements
    ConcreteCommand --&gt; Receiver : uses
    Invoker --&gt; Command : holds
    Client --&gt; Invoker : configures
    Client --&gt; ConcreteCommand : creates</code></pre>
<hr />
<h4 id="java-实现示例-12">3. Java 实现示例</h4>
<p>以下是一个控制灯光开关的命令模式示例。</p>
<h5 id="接收者">3.1 接收者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收者：灯</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is ON&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is OFF&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象命令">3.2 抽象命令</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体命令">3.3 具体命令</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体命令：开灯</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOnCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令：关灯</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOffCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOffCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用者">3.4 调用者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用者：遥控器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressButton</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-12">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建接收者</span></span><br><span class="line">        <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建命令</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">lightOn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOnCommand</span>(light);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">lightOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOffCommand</span>(light);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建调用者</span></span><br><span class="line">        <span class="type">RemoteControl</span> <span class="variable">remote</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteControl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行开灯</span></span><br><span class="line">        remote.setCommand(lightOn);</span><br><span class="line">        remote.pressButton();  <span class="comment">// 输出: Light is ON</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行关灯</span></span><br><span class="line">        remote.setCommand(lightOff);</span><br><span class="line">        remote.pressButton();  <span class="comment">// 输出: Light is OFF</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-12">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建接收者和命令，将命令与接收者关联。</li>
<li>将命令注入调用者（<code>RemoteControl</code>）。</li>
<li>调用者触发命令执行，命令调用接收者的方法。</li>
</ol>
<hr />
<h4 id="优点-12">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：请求发起者和执行者分离。</li>
<li><strong>扩展性</strong>：易于添加新命令。</li>
<li><strong>支持撤销</strong>：可通过添加 <code>undo()</code>
方法实现回滚。</li>
<li><strong>可记录</strong>：命令对象可存储用于日志或重做。</li>
</ul>
<hr />
<h4 id="缺点-12">6. 缺点</h4>
<ul>
<li><strong>类数量增加</strong>：每个操作需定义新命令类。</li>
<li><strong>复杂度</strong>：简单场景可能显得过于繁琐。</li>
</ul>
<hr />
<h4 id="支持撤销的扩展">7. 支持撤销的扩展</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOnCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123;</span><br><span class="line">        light.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        <span class="type">Command</span> <span class="variable">lightOn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOnCommand</span>(light);</span><br><span class="line">        <span class="type">RemoteControl</span> <span class="variable">remote</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteControl</span>();</span><br><span class="line"></span><br><span class="line">        remote.setCommand(lightOn);</span><br><span class="line">        remote.pressButton();  <span class="comment">// 输出: Light is ON</span></span><br><span class="line">        ((LightOnCommand) lightOn).undo();  <span class="comment">// 输出: Light is OFF</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="与策略模式的对比">8. 与策略模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>命令模式</th>
<th>策略模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>封装请求</td>
<td>封装算法</td>
</tr>
<tr class="even">
<td><strong>关注点</strong></td>
<td>操作执行</td>
<td>行为选择</td>
</tr>
<tr class="odd">
<td><strong>结构</strong></td>
<td>命令+接收者</td>
<td>上下文+策略</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-12">9. 实际应用场景</h4>
<ul>
<li><strong>GUI 按钮</strong>：按钮点击触发命令。</li>
<li><strong>事务管理</strong>：支持回滚的操作队列。</li>
<li><strong>宏命令</strong>：组合多个命令执行。</li>
</ul>
<hr />
<h4 id="源码中的例子-12">10. 源码中的例子</h4>
<p>Java 中的 <code>Runnable</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Running&quot;</span>));</span><br><span class="line">thread.start();  <span class="comment">// 封装并执行命令</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-12">11. 总结</h4>
<ul>
<li><strong>命令模式</strong>将请求封装为对象，解耦发起者和执行者。</li>
<li><strong>Java 实现</strong>依赖接口和组合，支持扩展功能如撤销。</li>
<li><strong>UML 图</strong>展示了命令、接收者和调用者的关系。</li>
</ul>
<p>如果需要宏命令示例（组合多个命令）或调整 UML，请告诉我！</p>
<h3 id="解释器interpreter"><strong>解释器（Interpreter）</strong></h3>
<p>解释器模式（Interpreter
Pattern）是一种行为型设计模式，用于定义一种语言的语法，并通过解释器对象来解析和执行这种语言的语句。它特别适合处理简单的语法规则或领域特定语言（DSL），将复杂的表达式分解为可递归解释的对象。</p>
<p>以下是对解释器模式的详细讲解，包括定义、结构、Java
实现示例及其优缺点。</p>
<hr />
<h4 id="解释器模式的定义">1. 解释器模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：为特定语言定义语法表示，并通过递归解释器解析语句。</li>
<li><strong>目的</strong>：
<ul>
<li>将语法规则封装为对象，便于处理复杂的表达式。</li>
<li>支持动态解释和执行语言规则。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>解析简单的脚本或表达式（如数学表达式、查询语言）。</li>
<li>处理规则引擎或自定义语言。</li>
</ul></li>
</ul>
<hr />
<h4 id="解释器模式的结构">2. 解释器模式的结构</h4>
<ul>
<li><strong>抽象表达式（Abstract
Expression）</strong>：定义解释方法的接口。</li>
<li><strong>终结符表达式（Terminal
Expression）</strong>：表示语法中的基本元素，直接实现解释逻辑。</li>
<li><strong>非终结符表达式（Non-Terminal
Expression）</strong>：表示复合规则，递归调用子表达式解释。</li>
<li><strong>上下文（Context）</strong>：存储解释过程中需要的全局信息（如变量值）。</li>
<li><strong>客户端（Client）</strong>：构建表达式树并调用解释器。</li>
</ul>
<h5 id="mermaid-uml-图-8">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class AbstractExpression &#123;
        +interpret(context) int
    &#125;
    class TerminalExpression &#123;
        -value: int
        +interpret(context) int
    &#125;
    class NonTerminalExpression &#123;
        -left: AbstractExpression
        -right: AbstractExpression
        +interpret(context) int
    &#125;
    class Context &#123;
        -data: Map
        +getValue(key) int
        +setValue(key, value)
    &#125;
    class Client
    
    TerminalExpression ..|&gt; AbstractExpression : implements
	NonTerminalExpression ..|&gt; AbstractExpression : implements
    NonTerminalExpression o--&gt; &quot;2&quot; AbstractExpression : contains
    Client --&gt; AbstractExpression : uses
    Client --&gt; Context : uses</code></pre>
<hr />
<h4 id="java-实现示例-13">3. Java 实现示例</h4>
<p>以下是一个解析简单加减法的解释器模式示例。</p>
<h5 id="上下文类">3.1 上下文类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上下文：存储变量值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVariable</span><span class="params">(String name, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        variables.put(name, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVariable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> variables.getOrDefault(name, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象表达式">3.2 抽象表达式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="终结符表达式">3.3 终结符表达式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终结符表达式：数字或变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String value;  <span class="comment">// 可以是数字或变量名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumberExpression</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(value);  <span class="comment">// 直接数字</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> context.getVariable(value);  <span class="comment">// 变量名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非终结符表达式">3.4 非终结符表达式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非终结符表达式：加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression left;</span><br><span class="line">    <span class="keyword">private</span> Expression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddExpression</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) + right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式：减法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubtractExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression left;</span><br><span class="line">    <span class="keyword">private</span> Expression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubtractExpression</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) - right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-13">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建上下文并设置变量</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        context.setVariable(<span class="string">&quot;x&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        context.setVariable(<span class="string">&quot;y&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建表达式：x + y - 3</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubtractExpression</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AddExpression</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="string">&quot;x&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解释执行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> expression.interpret(context);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);  <span class="comment">// 输出: Result: 12 (10 + 5 - 3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-13">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>构建表达式树（如
<code>x + y - 3</code>）。</li>
<li>将上下文（变量值）传递给表达式。</li>
<li>表达式递归调用 <code>interpret()</code> 方法，计算结果：
<ul>
<li>终结符直接返回值。</li>
<li>非终结符组合子表达式的结果。</li>
</ul></li>
</ol>
<hr />
<h4 id="优点-13">5. 优点</h4>
<ul>
<li><strong>灵活性</strong>：易于扩展新语法规则（新增表达式类）。</li>
<li><strong>模块化</strong>：语法规则封装为独立对象。</li>
<li><strong>可解释性</strong>：支持动态解析语言。</li>
</ul>
<hr />
<h4 id="缺点-13">6. 缺点</h4>
<ul>
<li><strong>复杂度高</strong>：大量表达式类增加系统复杂性。</li>
<li><strong>性能开销</strong>：递归解析复杂表达式可能效率低。</li>
<li><strong>适用性有限</strong>：仅适合简单语言，复杂语法（如完整编程语言）不实用。</li>
</ul>
<hr />
<h4 id="与其他模式的对比-1">7. 与其他模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>解释器模式</th>
<th>命令模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>解析语法</td>
<td>封装请求</td>
</tr>
<tr class="even">
<td><strong>结构</strong></td>
<td>表达式树</td>
<td>命令对象</td>
</tr>
<tr class="odd">
<td><strong>执行</strong></td>
<td>递归解释</td>
<td>单次调用</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-13">8. 实际应用场景</h4>
<ul>
<li><strong>数学表达式</strong>：计算器程序解析公式。</li>
<li><strong>规则引擎</strong>：解释业务规则。</li>
<li><strong>脚本语言</strong>：简单 DSL 的解析。</li>
</ul>
<hr />
<h4 id="源码中的例子-13">9. 源码中的例子</h4>
<p>Java 中的正则表达式（<code>java.util.regex</code>）：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\d+&quot;</span>);  <span class="comment">// 定义语法</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Valid number&quot;</span>);  <span class="comment">// 解释执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-13">10. 总结</h4>
<ul>
<li><strong>解释器模式</strong>通过对象表示语法规则，递归解析表达式。</li>
<li><strong>Java 实现</strong>依赖接口和表达式树，支持动态解释。</li>
<li><strong>UML 图</strong>展示了表达式和上下文的关系。</li>
</ul>
<h3 id="迭代器iterator"><strong>迭代器（Iterator）</strong></h3>
<p>迭代器模式（Iterator
Pattern）是一种行为型设计模式，它提供了一种方法来顺序访问聚合对象（如集合、列表或数组）的元素，而无需暴露其内部结构。迭代器模式将遍历逻辑从集合中分离出来，增强了封装性和灵活性。</p>
<p>以下是用 Java
实现迭代器模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="迭代器模式的定义">1. 迭代器模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过迭代器对象提供对集合元素的顺序访问，隐藏集合的实现细节。</li>
<li><strong>目的</strong>：
<ul>
<li>统一访问不同类型的集合。</li>
<li>分离集合的遍历逻辑和数据存储。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>需要遍历复杂数据结构（如树、图）。</li>
<li>集合类型多样但需一致访问。</li>
<li>增强集合的封装性。</li>
</ul></li>
</ul>
<hr />
<h4 id="迭代器模式的结构">2. 迭代器模式的结构</h4>
<ul>
<li><strong>抽象迭代器（Iterator）</strong>：定义遍历接口，如
<code>hasNext()</code> 和 <code>next()</code>。</li>
<li><strong>具体迭代器（Concrete
Iterator）</strong>：实现迭代器接口，跟踪遍历位置。</li>
<li><strong>抽象聚合（Aggregate）</strong>：定义创建迭代器的方法。</li>
<li><strong>具体聚合（Concrete
Aggregate）</strong>：实现聚合接口，存储数据并返回迭代器。</li>
<li><strong>客户端（Client）</strong>：使用迭代器遍历集合。</li>
</ul>
<h5 id="mermaid-uml-图-9">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Iterator &#123;
        +hasNext() boolean
        +next() Object
    &#125;
    class ConcreteIterator &#123;
        -aggregate: ConcreteAggregate
        -index: int
        +hasNext() boolean
        +next() Object
    &#125;
    class Aggregate &#123;
        +createIterator() Iterator
    &#125;
    class ConcreteAggregate &#123;
        -items: List
        +createIterator() Iterator
    &#125;
    class Client
    
	ConcreteIterator ..|&gt; Iterator : implements
	ConcreteAggregate ..|&gt; Aggregate : implements
	ConcreteAggregate --&gt; ConcreteIterator : creates
	ConcreteIterator --&gt; ConcreteAggregate : references
	Client --&gt; Iterator : uses
	Client --&gt; Aggregate : uses</code></pre>
<hr />
<h4 id="java-实现示例-14">3. Java 实现示例</h4>
<p>以下是一个简单列表的迭代器模式示例。</p>
<h5 id="抽象迭代器">3.1 抽象迭代器</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Object <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象聚合">3.2 抽象聚合</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象聚合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">    Iterator <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体聚合">3.3 具体聚合</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体聚合：自定义列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span> <span class="keyword">implements</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyList</span><span class="params">(String[] items)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体迭代器">3.4 具体迭代器</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyList list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListIterator</span><span class="params">(MyList list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">        <span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(index++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-14">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] data = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line">        <span class="type">MyList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyList</span>(data);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.createIterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Apple</span></span><br><span class="line"><span class="comment">        Banana</span></span><br><span class="line"><span class="comment">        Cherry</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-14">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建具体聚合（如
<code>MyList</code>）并获取迭代器。</li>
<li>使用迭代器的 <code>hasNext()</code> 和 <code>next()</code>
方法顺序访问元素。</li>
<li>迭代器内部维护遍历状态，隐藏聚合的实现细节。</li>
</ol>
<hr />
<h4 id="优点-14">5. 优点</h4>
<ul>
<li><strong>封装性</strong>：隐藏集合内部结构，保护数据。</li>
<li><strong>统一性</strong>：为不同集合提供一致的遍历接口。</li>
<li><strong>解耦</strong>：分离遍历逻辑和集合实现。</li>
</ul>
<hr />
<h4 id="缺点-14">6. 缺点</h4>
<ul>
<li><strong>复杂度增加</strong>：为简单集合引入迭代器可能显得多余。</li>
<li><strong>功能有限</strong>：标准迭代器不支持修改集合或双向遍历。</li>
<li><strong>性能开销</strong>：动态创建迭代器可能增加少量开销。</li>
</ul>
<hr />
<h4 id="与其他模式的对比-2">7. 与其他模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>迭代器模式</th>
<th>访问者模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>顺序访问</td>
<td>操作复杂结构</td>
</tr>
<tr class="even">
<td><strong>关注点</strong></td>
<td>遍历集合</td>
<td>扩展功能</td>
</tr>
<tr class="odd">
<td><strong>控制权</strong></td>
<td>客户端控制遍历</td>
<td>访问者控制操作</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-14">8. 实际应用场景</h4>
<ul>
<li><strong>集合遍历</strong>：Java 集合框架中的
<code>Iterator</code>。</li>
<li><strong>树结构</strong>：遍历树节点。</li>
<li><strong>数据库查询</strong>：结果集迭代。</li>
</ul>
<hr />
<h4 id="源码中的例子-14">9. 源码中的例子</h4>
<p>Java 中的 <code>java.util.Iterator</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-14">10. 总结</h4>
<ul>
<li><strong>迭代器模式</strong>通过分离遍历逻辑提供集合的顺序访问。</li>
<li><strong>Java 实现</strong>依赖接口和具体迭代器，支持灵活遍历。</li>
<li><strong>UML 图</strong>展示了迭代器与聚合的关系。</li>
</ul>
<p>如果需要增强版（如支持 <code>remove()</code> 或双向迭代器）或调整
UML，请告诉我！</p>
<h3 id="中介者mediator"><strong>中介者（Mediator）</strong></h3>
<p>中介者模式（Mediator
Pattern）是一种行为型设计模式，它通过引入一个中介者对象来封装一组对象之间的交互，从而减少对象间的直接耦合。中介者模式将多对多的通信转换为一对多的通信，提升系统的灵活性和可维护性。</p>
<p>以下是用 Java
实现中介者模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="中介者模式的定义">1. 中介者模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过中介者协调对象间的通信，降低耦合。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦复杂对象间的直接依赖。</li>
<li>集中管理交互逻辑。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>对象间存在复杂的多对多关系。</li>
<li>需要协调多个组件的行为。</li>
<li>简化对象间的通信。</li>
</ul></li>
</ul>
<hr />
<h4 id="中介者模式的结构">2. 中介者模式的结构</h4>
<ul>
<li><strong>抽象中介者（Mediator）</strong>：定义中介者接口，声明通信方法。</li>
<li><strong>具体中介者（Concrete
Mediator）</strong>：实现中介逻辑，协调同事对象。</li>
<li><strong>抽象同事（Colleague）</strong>：定义同事类的接口，与中介者交互。</li>
<li><strong>具体同事（Concrete
Colleague）</strong>：实现同事接口，通过中介者通信。</li>
<li><strong>客户端（Client）</strong>：创建同事和中介者，发起交互。</li>
</ul>
<h5 id="mermaid-uml-图-10">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Mediator &#123;
        +notify(sender: Colleague, event)
    &#125;
    class ConcreteMediator &#123;
        -colleagueA: ColleagueA
        -colleagueB: ColleagueB
        +notify(sender: Colleague, event)
    &#125;
    class Colleague &#123;
        +send(event)
        +receive(event)
    &#125;
    class ColleagueA &#123;
        -mediator: Mediator
        +send(event)
        +receive(event)
    &#125;
    class ColleagueB &#123;
        -mediator: Mediator
        +send(event)
        +receive(event)
    &#125;
    
    ConcreteMediator ..|&gt; Mediator : implements
    ColleagueA ..|&gt; Colleague : implements
    ColleagueB ..|&gt; Colleague : implements
    ConcreteMediator --&gt; ColleagueA : coordinates
    ConcreteMediator --&gt; ColleagueB : coordinates
    ColleagueA --&gt; Mediator : uses
    ColleagueB --&gt; Mediator : uses</code></pre>
<hr />
<h4 id="java-实现示例-15">3. Java 实现示例</h4>
<p>以下是一个聊天室的中介者模式示例，用户通过中介者发送和接收消息。</p>
<h5 id="抽象中介者">3.1 抽象中介者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatMediator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, User sender)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体中介者">3.2 具体中介者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体中介者：聊天室</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatRoom</span> <span class="keyword">implements</span> <span class="title class_">ChatMediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, User sender)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user != sender) &#123;  <span class="comment">// 不发给自己</span></span><br><span class="line">                user.receive(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象同事">3.3 抽象同事</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象同事：用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> ChatMediator mediator;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(ChatMediator mediator, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体同事">3.4 具体同事</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体同事：普通用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatUser</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatUser</span><span class="params">(ChatMediator mediator, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; sends: &quot;</span> + message);</span><br><span class="line">        mediator.sendMessage(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; receives: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-15">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChatRoom</span> <span class="variable">chatRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatRoom</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">alice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatUser</span>(chatRoom, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">bob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatUser</span>(chatRoom, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">charlie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatUser</span>(chatRoom, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"></span><br><span class="line">        chatRoom.addUser(alice);</span><br><span class="line">        chatRoom.addUser(bob);</span><br><span class="line">        chatRoom.addUser(charlie);</span><br><span class="line"></span><br><span class="line">        alice.send(<span class="string">&quot;Hello everyone!&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Alice sends: Hello everyone!</span></span><br><span class="line"><span class="comment">        Bob receives: Hello everyone!</span></span><br><span class="line"><span class="comment">        Charlie receives: Hello everyone!</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        bob.send(<span class="string">&quot;Hi Alice!&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Bob sends: Hi Alice!</span></span><br><span class="line"><span class="comment">        Alice receives: Hi Alice!</span></span><br><span class="line"><span class="comment">        Charlie receives: Hi Alice!</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-15">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建中介者和同事对象，注册同事到中介者。</li>
<li>同事通过中介者发送消息（<code>send</code>），中介者协调分发（<code>notify</code>）。</li>
<li>其他同事接收消息（<code>receive</code>），完成通信。</li>
</ol>
<hr />
<h4 id="优点-15">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：减少同事间的直接依赖，降低耦合。</li>
<li><strong>集中控制</strong>：交互逻辑集中在中介者，便于管理。</li>
<li><strong>灵活性</strong>：易于修改通信规则。</li>
</ul>
<hr />
<h4 id="缺点-15">6. 缺点</h4>
<ul>
<li><strong>中介者复杂性</strong>：中介者可能变得臃肿，难以维护。</li>
<li><strong>性能开销</strong>：大量对象交互时，中介者可能成为瓶颈。</li>
<li><strong>单点故障</strong>：中介者失败影响整个系统。</li>
</ul>
<hr />
<h4 id="与观察者模式的对比">7. 与观察者模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>中介者模式</th>
<th>观察者模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>通信方式</strong></td>
<td>通过中介者协调</td>
<td>发布-订阅</td>
</tr>
<tr class="even">
<td><strong>耦合</strong></td>
<td>同事依赖中介者</td>
<td>观察者依赖主题</td>
</tr>
<tr class="odd">
<td><strong>控制权</strong></td>
<td>中介者集中控制</td>
<td>主题广播</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-15">8. 实际应用场景</h4>
<ul>
<li><strong>GUI 框架</strong>：控件间通过对话框协调。</li>
<li><strong>聊天系统</strong>：用户通过服务器通信。</li>
<li><strong>航空管制</strong>：飞机通过塔台协调。</li>
</ul>
<hr />
<h4 id="源码中的例子-15">9. 源码中的例子</h4>
<p>Java 中的 <code>java.util.Timer</code>（简化中介者）：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Task&quot;</span>); &#125; &#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-15">10. 总结</h4>
<ul>
<li><strong>中介者模式</strong>通过中介者封装对象交互，降低耦合。</li>
<li><strong>Java 实现</strong>依赖接口和组合，支持集中管理通信。</li>
<li><strong>UML 图</strong>展示了中介者与同事的关系。</li>
</ul>
<p>如果需要更复杂示例（如支持事件类型）或调整 UML，请告诉我！</p>
<h3 id="备忘录memento"><strong>备忘录（Memento）</strong></h3>
<p>备忘录模式（Memento
Pattern）是一种行为型设计模式，用于捕获并保存对象的内部状态，以便在需要时恢复到该状态，而不破坏对象的封装性。它常用于实现撤销（Undo）功能或状态快照。</p>
<p>以下是用 Java
实现备忘录模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="备忘录模式的定义">1. 备忘录模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过备忘录对象保存对象状态，并在需要时恢复。</li>
<li><strong>目的</strong>：
<ul>
<li>保存和恢复对象的状态。</li>
<li>保持封装性，避免暴露内部细节。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>需要撤销或回滚操作。</li>
<li>保存历史状态（如游戏存档）。</li>
<li>状态快照管理。</li>
</ul></li>
</ul>
<hr />
<h4 id="备忘录模式的结构">2. 备忘录模式的结构</h4>
<ul>
<li><strong>原发器（Originator）</strong>：需要保存和恢复状态的对象，创建和使用备忘录。</li>
<li><strong>备忘录（Memento）</strong>：存储原发器状态的对象，通常只提供有限访问。</li>
<li><strong>管理者（Caretaker）</strong>：负责保存备忘录，但不修改其内容。</li>
<li><strong>客户端（Client）</strong>：触发状态保存和恢复。</li>
</ul>
<h5 id="mermaid-uml-图-11">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Originator &#123;
        -state: State
        +createMemento() Memento
        +setMemento(Memento)
        +setState(state)
        +getState() State
    &#125;
    class Memento &#123;
        -state: State
        +getState() State
    &#125;
    class Caretaker &#123;
        -memento: Memento
        +setMemento(Memento)
        +getMemento() Memento
    &#125;
    class Client
    
    Originator --&gt; Memento : creates/uses
    Caretaker --&gt; Memento : holds
    Client --&gt; Originator : uses
    Client --&gt; Caretaker : uses</code></pre>
<hr />
<h4 id="java-实现示例-16">3. Java 实现示例</h4>
<p>以下是一个文本编辑器的备忘录模式示例，支持保存和恢复文本状态。</p>
<h5 id="备忘录类">3.1 备忘录类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备忘录：保存状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="原发器类">3.2 原发器类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原发器：文本编辑器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        System.out.println(<span class="string">&quot;Current state: &quot;</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = memento.getState();</span><br><span class="line">        System.out.println(<span class="string">&quot;Restored state: &quot;</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="管理者类">3.3 管理者类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管理者：保存备忘录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-16">3.4 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TextEditor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line">        <span class="type">History</span> <span class="variable">history</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">History</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置初始状态</span></span><br><span class="line">        editor.setState(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 输出: Current state: Hello</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存状态</span></span><br><span class="line">        history.setMemento(editor.createMemento());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        editor.setState(<span class="string">&quot;Hello World&quot;</span>);  <span class="comment">// 输出: Current state: Hello World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复状态</span></span><br><span class="line">        editor.setMemento(history.getMemento());  <span class="comment">// 输出: Restored state: Hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-16">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>通过原发器（<code>TextEditor</code>）设置状态。</li>
<li>调用 <code>createMemento()</code>
保存状态到备忘录，交给管理者（<code>History</code>）存储。</li>
<li>修改状态后，通过 <code>setMemento()</code>
从备忘录恢复之前的状态。</li>
</ol>
<hr />
<h4 id="优点-16">5. 优点</h4>
<ul>
<li><strong>封装性</strong>：备忘录隐藏原发器的内部状态。</li>
<li><strong>支持撤销</strong>：方便实现回滚功能。</li>
<li><strong>状态隔离</strong>：管理者不修改备忘录内容。</li>
</ul>
<hr />
<h4 id="缺点-16">6. 缺点</h4>
<ul>
<li><strong>内存开销</strong>：保存大量状态可能消耗内存。</li>
<li><strong>复杂度</strong>：增加备忘录和管理类，提高系统复杂性。</li>
<li><strong>状态管理</strong>：多状态时需额外设计存储结构。</li>
</ul>
<hr />
<h4 id="与命令模式的对比">7. 与命令模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>备忘录模式</th>
<th>命令模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>保存/恢复状态</td>
<td>封装请求</td>
</tr>
<tr class="even">
<td><strong>关注点</strong></td>
<td>状态管理</td>
<td>操作执行</td>
</tr>
<tr class="odd">
<td><strong>撤销</strong></td>
<td>通过状态恢复</td>
<td>通过命令回滚</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-16">8. 实际应用场景</h4>
<ul>
<li><strong>文本编辑器</strong>：撤销和重做功能。</li>
<li><strong>游戏</strong>：保存和加载游戏进度。</li>
<li><strong>数据库</strong>：事务回滚。</li>
</ul>
<hr />
<h4 id="源码中的例子-16">9. 源码中的例子</h4>
<p>Java 中的 <code>java.util.Date</code>（简化备忘录思想）：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> date.getTime();  <span class="comment">// 保存状态</span></span><br><span class="line">date.setTime(time);  <span class="comment">// 恢复状态</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-16">10. 总结</h4>
<ul>
<li><strong>备忘录模式</strong>通过备忘录保存和恢复对象状态，支持撤销。</li>
<li><strong>Java
实现</strong>依赖原发器创建和使用备忘录，管理者存储。</li>
<li><strong>UML 图</strong>展示了原发器、备忘录和管理者的关系。</li>
</ul>
<p>如果需要多状态管理示例（如历史记录列表）或调整 UML，请告诉我！</p>
<h3 id="观察者observer"><strong>观察者（Observer）</strong></h3>
<p>观察者模式（Observer
Pattern）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象的状态发生变化时，所有依赖它的对象都会自动收到通知并更新。观察者模式也被称为“发布-订阅模式”，广泛用于事件处理和状态监控。</p>
<p>以下是用 Java
实现观察者模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="观察者模式的定义">1. 观察者模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过主题（Subject）维护观察者（Observer）列表，当主题状态变化时通知所有观察者。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦主体和依赖对象。</li>
<li>实现状态变化的自动广播。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>事件监听（如 GUI 按钮点击）。</li>
<li>数据变化通知（如股票价格）。</li>
<li>发布-订阅系统。</li>
</ul></li>
</ul>
<hr />
<h4 id="观察者模式的结构">2. 观察者模式的结构</h4>
<ul>
<li><strong>抽象主题（Subject）</strong>：维护观察者列表，提供添加、移除和通知方法。</li>
<li><strong>具体主题（Concrete
Subject）</strong>：实现主题接口，存储状态并触发通知。</li>
<li><strong>抽象观察者（Observer）</strong>：定义更新接口。</li>
<li><strong>具体观察者（Concrete
Observer）</strong>：实现更新逻辑，响应主题变化。</li>
<li><strong>客户端（Client）</strong>：创建主题和观察者，发起交互。</li>
</ul>
<h5 id="mermaid-uml-图-12">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Subject &#123;
        +attach(Observer)
        +detach(Observer)
        +notify()
    &#125;
    class ConcreteSubject &#123;
        -state: State
        -observers: List&lt;Observer&gt;
        +attach(Observer)
        +detach(Observer)
        +notify()
        +setState(state)
        +getState() State
    &#125;
    class Observer &#123;
        +update()
    &#125;
    class ConcreteObserver &#123;
        -subject: Subject
        +update()
    &#125;
    
    ConcreteSubject ..|&gt; Subject : implements
    ConcreteObserver ..|&gt; Observer : implements
    ConcreteSubject o--&gt; &quot;many&quot; Observer : notifies
    ConcreteObserver --&gt; Subject : observes</code></pre>
<hr />
<h4 id="java-实现示例-17">3. Java 实现示例</h4>
<p>以下是一个天气站的观察者模式示例，天气变化时通知显示器。</p>
<h5 id="抽象观察者">3.1 抽象观察者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象主题-1">3.2 抽象主题</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WeatherStation</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体主题">3.3 具体主题</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体主题：天气站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteWeatherStation</span> <span class="keyword">implements</span> <span class="title class_">WeatherStation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTemperature</span><span class="params">(<span class="type">float</span> temperature)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        System.out.println(<span class="string">&quot;Temperature changed to: &quot;</span> + temperature);</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体观察者">3.4 具体观察者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体观察者：温度显示器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemperatureDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TemperatureDisplay</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; displays temperature: &quot;</span> + temperature);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-17">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteWeatherStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteWeatherStation</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Observer</span> <span class="variable">display1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemperatureDisplay</span>(<span class="string">&quot;Display 1&quot;</span>);</span><br><span class="line">        <span class="type">Observer</span> <span class="variable">display2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemperatureDisplay</span>(<span class="string">&quot;Display 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        station.addObserver(display1);</span><br><span class="line">        station.addObserver(display2);</span><br><span class="line"></span><br><span class="line">        station.setTemperature(<span class="number">25.0f</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Temperature changed to: 25.0</span></span><br><span class="line"><span class="comment">        Display 1 displays temperature: 25.0</span></span><br><span class="line"><span class="comment">        Display 2 displays temperature: 25.0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        station.setTemperature(<span class="number">30.0f</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Temperature changed to: 30.0</span></span><br><span class="line"><span class="comment">        Display 1 displays temperature: 30.0</span></span><br><span class="line"><span class="comment">        Display 2 displays temperature: 30.0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-17">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建主题和观察者，将观察者注册到主题。</li>
<li>主题状态变化（<code>setTemperature</code>）时，调用
<code>notifyObservers</code>。</li>
<li>所有观察者收到通知，执行 <code>update</code> 更新状态。</li>
</ol>
<hr />
<h4 id="优点-17">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：主题和观察者松耦合，仅通过接口交互。</li>
<li><strong>动态性</strong>：支持运行时添加或移除观察者。</li>
<li><strong>广播</strong>：自动通知所有依赖对象。</li>
</ul>
<hr />
<h4 id="缺点-17">6. 缺点</h4>
<ul>
<li><strong>性能开销</strong>：大量观察者时通知可能变慢。</li>
<li><strong>内存泄漏</strong>：未移除的观察者可能导致引用残留。</li>
<li><strong>复杂性</strong>：多观察者时调试困难。</li>
</ul>
<hr />
<h4 id="与中介者模式的对比">7. 与中介者模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>观察者模式</th>
<th>中介者模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>通信方式</strong></td>
<td>广播</td>
<td>协调</td>
</tr>
<tr class="even">
<td><strong>耦合</strong></td>
<td>观察者依赖主题</td>
<td>同事依赖中介者</td>
</tr>
<tr class="odd">
<td><strong>控制权</strong></td>
<td>主题主动通知</td>
<td>中介者集中控制</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-17">8. 实际应用场景</h4>
<ul>
<li><strong>GUI 事件</strong>：按钮点击通知监听器。</li>
<li><strong>数据绑定</strong>：视图随模型变化更新。</li>
<li><strong>消息系统</strong>：发布-订阅模型。</li>
</ul>
<hr />
<h4 id="源码中的例子-17">9. 源码中的例子</h4>
<p>Java 中的 <code>java.util.Observable</code> 和
<code>Observer</code>（已废弃，但为经典示例）： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTemp</span><span class="params">(<span class="type">float</span> temp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temp = temp;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> <span class="keyword">implements</span> <span class="title class_">java</span>.util.Observer &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Temperature: &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weather</span> <span class="variable">weather</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weather</span>();</span><br><span class="line">        weather.addObserver(<span class="keyword">new</span> <span class="title class_">Display</span>());</span><br><span class="line">        weather.setTemp(<span class="number">25.0f</span>);  <span class="comment">// 输出: Temperature: 25.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现代替代：<code>java.beans.PropertyChangeSupport</code>。</p>
<hr />
<h4 id="总结-17">10. 总结</h4>
<ul>
<li><strong>观察者模式</strong>通过主题广播状态变化，解耦依赖关系。</li>
<li><strong>Java 实现</strong>依赖接口和列表管理，支持动态通知。</li>
<li><strong>UML 图</strong>展示了主题与观察者的一对多关系。</li>
</ul>
<p>如果需要推模式（推送数据）与拉模式（观察者拉取）的对比或调整
UML，请告诉我！</p>
<h3 id="状态state"><strong>状态（State）</strong></h3>
<p>状态模式（State
Pattern）是一种行为型设计模式，它允许对象在内部状态发生变化时改变其行为，使对象看起来像是改变了其类。状态模式通过将状态封装为独立的对象，简化复杂条件逻辑，提高代码的可维护性和扩展性。</p>
<p>以下是用 Java
实现状态模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="状态模式的定义">1. 状态模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：将状态抽象为对象，对象根据状态切换行为。</li>
<li><strong>目的</strong>：
<ul>
<li>消除大量条件语句（如 if-else）。</li>
<li>使状态转换逻辑清晰且可扩展。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>对象行为随状态变化。</li>
<li>状态转换规则复杂。</li>
<li>需要状态机（如订单流程）。</li>
</ul></li>
</ul>
<hr />
<h4 id="状态模式的结构">2. 状态模式的结构</h4>
<ul>
<li><strong>上下文（Context）</strong>：持有当前状态，委托行为给状态对象。</li>
<li><strong>抽象状态（State）</strong>：定义状态接口，声明行为方法。</li>
<li><strong>具体状态（Concrete
State）</strong>：实现状态接口，定义具体行为并处理状态转换。</li>
<li><strong>客户端（Client）</strong>：创建上下文并触发操作。</li>
</ul>
<h5 id="mermaid-uml-图-13">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Context &#123;
        -state: State
        +setState(State)
        +request()
    &#125;
    class State &#123;
        +handle(Context)
    &#125;
    class ConcreteStateA &#123;
        +handle(Context)
    &#125;
    class ConcreteStateB &#123;
        +handle(Context)
    &#125;
    
    ConcreteStateA ..|&gt; State : implements
    ConcreteStateB ..|&gt; State : implements
    Context --&gt; State : uses
    ConcreteStateA --&gt; Context : changes state
    ConcreteStateB --&gt; Context : changes state</code></pre>
<hr />
<h4 id="java-实现示例-18">3. Java 实现示例</h4>
<p>以下是一个订单状态机的状态模式示例，订单状态在待支付、已支付和已发货之间切换。</p>
<h5 id="抽象状态">3.1 抽象状态</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Order order)</span>;  <span class="comment">// 处理订单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体状态">3.2 具体状态</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体状态：待支付</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PendingState</span> <span class="keyword">implements</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order is pending payment&quot;</span>);</span><br><span class="line">        order.setState(<span class="keyword">new</span> <span class="title class_">PaidState</span>());  <span class="comment">// 转换为已支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态：已支付</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaidState</span> <span class="keyword">implements</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order has been paid&quot;</span>);</span><br><span class="line">        order.setState(<span class="keyword">new</span> <span class="title class_">ShippedState</span>());  <span class="comment">// 转换为已发货</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态：已发货</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShippedState</span> <span class="keyword">implements</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order has been shipped&quot;</span>);</span><br><span class="line">        <span class="comment">// 不再转换状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="上下文">3.3 上下文</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上下文：订单</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderState state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="keyword">new</span> <span class="title class_">PendingState</span>();  <span class="comment">// 初始状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(OrderState state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        state.handle(<span class="built_in">this</span>);  <span class="comment">// 委托给当前状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-18">3.4 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"></span><br><span class="line">        order.process();  <span class="comment">// 输出: Order is pending payment</span></span><br><span class="line">        order.process();  <span class="comment">// 输出: Order has been paid</span></span><br><span class="line">        order.process();  <span class="comment">// 输出: Order has been shipped</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-18">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建上下文（<code>Order</code>），初始状态为
<code>PendingState</code>。</li>
<li>调用 <code>process()</code>，上下文委托给当前状态对象执行。</li>
<li>状态对象处理请求并可切换上下文的状态（如从 <code>Pending</code> 到
<code>Paid</code>）。</li>
</ol>
<hr />
<h4 id="优点-18">5. 优点</h4>
<ul>
<li><strong>清晰性</strong>：状态逻辑封装在独立类中，减少条件分支。</li>
<li><strong>扩展性</strong>：新增状态只需添加新类。</li>
<li><strong>符合开闭原则</strong>：修改行为不需更改上下文。</li>
</ul>
<hr />
<h4 id="缺点-18">6. 缺点</h4>
<ul>
<li><strong>类数量增加</strong>：每个状态需定义新类。</li>
<li><strong>复杂度</strong>：小型系统使用状态模式可能显得繁琐。</li>
<li><strong>状态切换管理</strong>：转换逻辑分散在状态类中，可能难跟踪。</li>
</ul>
<hr />
<h4 id="与策略模式的对比-1">7. 与策略模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>状态模式</th>
<th>策略模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>状态驱动行为</td>
<td>算法选择</td>
</tr>
<tr class="even">
<td><strong>切换</strong></td>
<td>状态内部控制</td>
<td>客户端控制</td>
</tr>
<tr class="odd">
<td><strong>关注点</strong></td>
<td>状态转换</td>
<td>行为替换</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-18">8. 实际应用场景</h4>
<ul>
<li><strong>订单系统</strong>：状态流转（如待支付 → 已支付）。</li>
<li><strong>游戏角色</strong>：角色状态（如站立、行走、跳跃）。</li>
<li><strong>有限状态机</strong>：网络协议状态管理。</li>
</ul>
<hr />
<h4 id="源码中的例子-18">9. 源码中的例子</h4>
<p>Java 中的 <code>java.nio.channels.SelectionKey</code>（状态相关）：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="comment">// 根据状态执行不同操作</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-18">10. 总结</h4>
<ul>
<li><strong>状态模式</strong>通过状态对象改变行为，简化状态管理。</li>
<li><strong>Java 实现</strong>依赖接口和状态切换，支持动态行为。</li>
<li><strong>UML 图</strong>展示了上下文与状态的关系。</li>
</ul>
<p>如果需要复杂状态机（如带条件转换）或调整 UML，请告诉我！</p>
<h3 id="策略strategy"><strong>策略（Strategy）</strong></h3>
<p>策略模式（Strategy
Pattern）是一种行为型设计模式，它定义了一系列算法或策略，将每个策略封装成独立的对象，使得这些策略可以在运行时动态切换。策略模式通过解耦上下文和具体策略，增强了代码的灵活性和可扩展性。</p>
<p>以下是用 Java
实现策略模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="策略模式的定义">1. 策略模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：将算法或行为封装为策略对象，上下文根据需要选择策略。</li>
<li><strong>目的</strong>：
<ul>
<li>消除条件语句（如 if-else）。</li>
<li>支持运行时动态替换行为。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>多个类似行为需动态选择。</li>
<li>算法或策略可能频繁变化。</li>
<li>需要隔离具体实现。</li>
</ul></li>
</ul>
<hr />
<h4 id="策略模式的结构">2. 策略模式的结构</h4>
<ul>
<li><strong>抽象策略（Strategy）</strong>：定义策略接口，声明行为方法。</li>
<li><strong>具体策略（Concrete
Strategy）</strong>：实现策略接口，提供具体算法。</li>
<li><strong>上下文（Context）</strong>：持有策略引用，调用策略执行行为。</li>
<li><strong>客户端（Client）</strong>：创建上下文并配置策略。</li>
</ul>
<h4 id="mermaid-uml-图-14"># Mermaid UML 图</h4>
<pre><code class="highlight mermaid">classDiagram
    class Strategy &#123;
        +execute()
    &#125;
    class ConcreteStrategyA &#123;
        +execute()
    &#125;
    class ConcreteStrategyB &#123;
        +execute()
    &#125;
    class Context &#123;
        -strategy: Strategy
        +setStrategy(Strategy)
        +executeStrategy()
    &#125;
    class Client
    
    ConcreteStrategyA ..|&gt; Strategy : implements
    ConcreteStrategyB ..|&gt; Strategy : implements
    Context --&gt; Strategy : uses
    Client --&gt; Context : uses
    Client --&gt; Strategy : configures</code></pre>
<hr />
<h4 id="java-实现示例-19">3. Java 实现示例</h4>
<p>以下是一个支付系统的策略模式示例，支持不同支付方式。</p>
<h4 id="抽象策略"># 3.1 抽象策略</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象策略：支付方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体策略"># 3.2 具体策略</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体策略：信用卡支付</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreditCardPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CreditCardPayment</span><span class="params">(String cardNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardNumber = cardNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Paid &quot;</span> + amount + <span class="string">&quot; with credit card &quot;</span> + cardNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略：PayPal 支付</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayPalPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PayPalPayment</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Paid &quot;</span> + amount + <span class="string">&quot; with PayPal &quot;</span> + email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上下文-1"># 3.3 上下文</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上下文：购物车</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentStrategy paymentStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPaymentStrategy</span><span class="params">(PaymentStrategy paymentStrategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentStrategy = paymentStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkout</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (paymentStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">            paymentStrategy.pay(amount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No payment strategy selected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端代码-19"># 3.4 客户端代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用信用卡支付</span></span><br><span class="line">        <span class="type">PaymentStrategy</span> <span class="variable">creditCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreditCardPayment</span>(<span class="string">&quot;1234-5678-9012-3456&quot;</span>);</span><br><span class="line">        cart.setPaymentStrategy(creditCard);</span><br><span class="line">        cart.checkout(<span class="number">100.0</span>);  <span class="comment">// 输出: Paid 100.0 with credit card 1234-5678-9012-3456</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换到 PayPal 支付</span></span><br><span class="line">        <span class="type">PaymentStrategy</span> <span class="variable">payPal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayPalPayment</span>(<span class="string">&quot;user@example.com&quot;</span>);</span><br><span class="line">        cart.setPaymentStrategy(payPal);</span><br><span class="line">        cart.checkout(<span class="number">50.0</span>);  <span class="comment">// 输出: Paid 50.0 with PayPal user@example.com</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-19">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建上下文（<code>ShoppingCart</code>）和策略（如
<code>CreditCardPayment</code>）。</li>
<li>将策略注入上下文（<code>setPaymentStrategy</code>）。</li>
<li>调用上下文方法（<code>checkout</code>），执行当前策略的行为。</li>
</ol>
<hr />
<h4 id="优点-19">5. 优点</h4>
<ul>
<li><strong>灵活性</strong>：运行时动态切换策略。</li>
<li><strong>扩展性</strong>：新增策略只需添加新类。</li>
<li><strong>消除条件</strong>：避免大量 if-else 语句。</li>
</ul>
<hr />
<h4 id="缺点-19">6. 缺点</h4>
<ul>
<li><strong>类数量增加</strong>：每个策略需定义新类。</li>
<li><strong>客户端复杂性</strong>：客户端需了解并选择策略。</li>
<li><strong>适用性有限</strong>：适合行为差异明显的情况。</li>
</ul>
<hr />
<h4 id="与状态模式的对比">7. 与状态模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>策略模式</th>
<th>状态模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>算法选择</td>
<td>状态驱动行为</td>
</tr>
<tr class="even">
<td><strong>切换控制</strong></td>
<td>客户端控制</td>
<td>状态内部控制</td>
</tr>
<tr class="odd">
<td><strong>关注点</strong></td>
<td>行为替换</td>
<td>状态转换</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-19">8. 实际应用场景</h4>
<ul>
<li><strong>排序算法</strong>：选择不同排序策略（如快排、冒泡）。</li>
<li><strong>支付系统</strong>：动态选择支付方式。</li>
<li><strong>游戏 AI</strong>：切换敌人行为策略。</li>
</ul>
<hr />
<h4 id="源码中的例子-19">9. 源码中的例子</h4>
<p>Java 中的 <code>Comparator</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Collections.sort(list, Comparator.naturalOrder());  <span class="comment">// 自然顺序策略</span></span><br><span class="line">Collections.sort(list, Comparator.reverseOrder());  <span class="comment">// 逆序策略</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-19">10. 总结</h4>
<ul>
<li><strong>策略模式</strong>通过封装策略对象实现行为动态切换。</li>
<li><strong>Java 实现</strong>依赖接口和组合，支持灵活替换。</li>
<li><strong>UML 图</strong>展示了上下文与策略的关系。</li>
</ul>
<p>如果需要更复杂示例（如结合工厂模式）或调整 UML，请告诉我！</p>
<h3 id="模板方法template-method"><strong>模板方法（Template
Method）</strong></h3>
<p>模板方法模式（Template Method
Pattern）是一种行为型设计模式，它在抽象类中定义了一个操作的算法骨架，将某些步骤的具体实现推迟到子类中。模板方法模式通过固定的流程控制和灵活的实现分离，实现了代码复用和行为定制。</p>
<p>以下是用 Java
实现模板方法模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="模板方法模式的定义">1. 模板方法模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：在抽象类中定义算法框架，子类实现具体步骤。</li>
<li><strong>目的</strong>：
<ul>
<li>复用通用算法结构。</li>
<li>允许子类定制部分行为。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>多个类共享固定流程但细节不同。</li>
<li>需要控制算法执行顺序。</li>
<li>提取公共代码。</li>
</ul></li>
</ul>
<hr />
<h4 id="模板方法模式的结构">2. 模板方法模式的结构</h4>
<ul>
<li><strong>抽象类（Abstract
Class）</strong>：定义模板方法（算法骨架）和抽象步骤。</li>
<li><strong>具体类（Concrete
Class）</strong>：实现抽象步骤，完成具体逻辑。</li>
<li><strong>客户端（Client）</strong>：调用模板方法执行算法。</li>
</ul>
<h5 id="mermaid-uml-图-15">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class AbstractClass &#123;
        +templateMethod()
        #abstractStep1()
        #abstractStep2()
        +concreteStep()
    &#125;
    class ConcreteClass &#123;
        #abstractStep1()
        #abstractStep2()
    &#125;
    class Client
    
    ConcreteClass --|&gt; AbstractClass : extends
    Client --&gt; AbstractClass : uses</code></pre>
<hr />
<h4 id="java-实现示例-20">3. Java 实现示例</h4>
<p>以下是一个制作饮料的模板方法模式示例，流程固定但配方不同。</p>
<h5 id="抽象类">3.1 抽象类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类：饮料制作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法：定义制作流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareBeverage</span><span class="params">()</span> &#123;</span><br><span class="line">        boilWater();       <span class="comment">// 固定步骤</span></span><br><span class="line">        brew();            <span class="comment">// 抽象步骤，由子类实现</span></span><br><span class="line">        pourInCup();       <span class="comment">// 固定步骤</span></span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiments()) &#123;  <span class="comment">// 钩子方法</span></span><br><span class="line">            addCondiments();  <span class="comment">// 抽象步骤</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定步骤</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boiling water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pouring into cup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象步骤</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法（可选步骤）</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">customerWantsCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 默认添加调料</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体类">3.2 具体类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体类：咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Brewing coffee grounds&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adding sugar and milk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：茶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Steeping tea leaves&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adding lemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">customerWantsCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 茶默认不加调料</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-20">3.3 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Making coffee:&quot;</span>);</span><br><span class="line">        coffee.prepareBeverage();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Making coffee:</span></span><br><span class="line"><span class="comment">        Boiling water</span></span><br><span class="line"><span class="comment">        Brewing coffee grounds</span></span><br><span class="line"><span class="comment">        Pouring into cup</span></span><br><span class="line"><span class="comment">        Adding sugar and milk</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;\nMaking tea:&quot;</span>);</span><br><span class="line">        tea.prepareBeverage();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Making tea:</span></span><br><span class="line"><span class="comment">        Boiling water</span></span><br><span class="line"><span class="comment">        Steeping tea leaves</span></span><br><span class="line"><span class="comment">        Pouring into cup</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-20">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建具体类实例（如 <code>Coffee</code> 或
<code>Tea</code>）。</li>
<li>调用模板方法（<code>prepareBeverage</code>），执行固定流程。</li>
<li>子类实现抽象步骤（<code>brew</code> 和
<code>addCondiments</code>），定制行为。</li>
</ol>
<hr />
<h4 id="优点-20">5. 优点</h4>
<ul>
<li><strong>代码复用</strong>：通用流程在抽象类中定义，避免重复。</li>
<li><strong>控制性</strong>：模板方法控制算法顺序，子类只实现细节。</li>
<li><strong>扩展性</strong>：新增行为只需添加子类。</li>
</ul>
<hr />
<h4 id="缺点-20">6. 缺点</h4>
<ul>
<li><strong>类数量增加</strong>：每个新行为需定义新子类。</li>
<li><strong>继承依赖</strong>：子类必须继承抽象类，灵活性受限。</li>
<li><strong>复杂性</strong>：大型系统可能导致继承层次深。</li>
</ul>
<hr />
<h4 id="与策略模式的对比-2">7. 与策略模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>模板方法模式</th>
<th>策略模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>实现方式</strong></td>
<td>继承</td>
<td>组合</td>
</tr>
<tr class="even">
<td><strong>控制权</strong></td>
<td>抽象类控制流程</td>
<td>客户端选择策略</td>
</tr>
<tr class="odd">
<td><strong>灵活性</strong></td>
<td>固定流程</td>
<td>动态切换</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-20">8. 实际应用场景</h4>
<ul>
<li><strong>Servlet</strong>：<code>HttpServlet</code> 的
<code>service</code> 方法。</li>
<li><strong>游戏流程</strong>：固定游戏循环，子类实现细节。</li>
<li><strong>数据处理</strong>：通用处理框架，子类定制步骤。</li>
</ul>
<hr />
<h4 id="源码中的例子-20">9. 源码中的例子</h4>
<p>Java 中的 <code>AbstractList</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();  <span class="comment">// 子类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 子类如
<code>ArrayList</code> 实现具体逻辑。</p>
<hr />
<h4 id="总结-20">10. 总结</h4>
<ul>
<li><strong>模板方法模式</strong>通过抽象类定义算法框架，子类实现细节。</li>
<li><strong>Java 实现</strong>结合继承和抽象方法，支持行为定制。</li>
<li><strong>UML 图</strong>展示了抽象类与具体类的关系。</li>
</ul>
<p>如果需要更复杂示例（如带钩子方法的多步骤流程）或调整
UML，请告诉我！</p>
<h3 id="访问者visitor"><strong>访问者（Visitor）</strong></h3>
<p>访问者模式（Visitor
Pattern）是一种行为型设计模式，它允许在不修改对象结构的情况下，为对象添加新的操作。访问者模式通过将操作逻辑分离到访问者对象中，实现了数据结构与操作的解耦，特别适用于结构稳定但操作频繁变化的场景。</p>
<p>以下是用 Java
实现访问者模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="访问者模式的定义">1. 访问者模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：将操作封装到访问者对象中，对象结构接受访问者并调用其操作。</li>
<li><strong>目的</strong>：
<ul>
<li>分离数据结构与操作逻辑。</li>
<li>支持动态添加新功能。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>对象结构稳定但操作多变。</li>
<li>需要对复杂对象执行多种操作。</li>
<li>数据结构与操作独立演化。</li>
</ul></li>
</ul>
<hr />
<h4 id="访问者模式的结构">2. 访问者模式的结构</h4>
<ul>
<li><strong>抽象访问者（Visitor）</strong>：定义对每个元素类的访问方法。</li>
<li><strong>具体访问者（Concrete Visitor）</strong>：实现访问逻辑。</li>
<li><strong>抽象元素（Element）</strong>：定义接受访问者的方法。</li>
<li><strong>具体元素（Concrete
Element）</strong>：实现接受方法，调用访问者操作。</li>
<li><strong>对象结构（Object
Structure）</strong>：包含元素集合，允许访问者遍历。</li>
<li><strong>客户端（Client）</strong>：创建结构和访问者，发起访问。</li>
</ul>
<h5 id="mermaid-uml-图-16">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Visitor &#123;
        +visitElementA(ElementA)
        +visitElementB(ElementB)
    &#125;
    class ConcreteVisitor &#123;
        +visitElementA(ElementA)
        +visitElementB(ElementB)
    &#125;
    class Element &#123;
        +accept(Visitor)
    &#125;
    class ElementA &#123;
        +accept(Visitor)
    &#125;
    class ElementB &#123;
        +accept(Visitor)
    &#125;
    class ObjectStructure &#123;
        -elements: List&lt;Element&gt;
        +accept(Visitor)
    &#125;
    class Client
    
    ConcreteVisitor ..|&gt; Visitor : implements
    ElementA ..|&gt; Element : implements
    ElementB ..|&gt; Element : implements
    ObjectStructure o--&gt; &quot;many&quot; Element : contains
    Element --&gt; Visitor : accepts
    Client --&gt; ObjectStructure : uses
    Client --&gt; Visitor : uses</code></pre>
<hr />
<h4 id="java-实现示例-21">3. Java 实现示例</h4>
<p>以下是一个计算文件大小的访问者模式示例，访问文件和文件夹。</p>
<h5 id="抽象元素">3.1 抽象元素</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileSystemElement</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(FileSystemVisitor visitor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体元素">3.2 具体元素</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体元素：文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">implements</span> <span class="title class_">FileSystemElement</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String name, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(FileSystemVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素：文件夹</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Folder</span> <span class="keyword">implements</span> <span class="title class_">FileSystemElement</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;FileSystemElement&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Folder</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(FileSystemElement element)</span> &#123;</span><br><span class="line">        children.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;FileSystemElement&gt; <span class="title function_">getChildren</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(FileSystemVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象访问者">3.3 抽象访问者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileSystemVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Folder folder)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体访问者">3.4 具体访问者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体访问者：计算大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SizeCalculatorVisitor</span> <span class="keyword">implements</span> <span class="title class_">FileSystemVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        totalSize += file.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Folder folder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemElement element : folder.getChildren()) &#123;</span><br><span class="line">            element.accept(<span class="built_in">this</span>);  <span class="comment">// 递归访问子元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTotalSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对象结构可选">3.5 对象结构（可选）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;FileSystemElement&gt; elements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(FileSystemElement element)</span> &#123;</span><br><span class="line">        elements.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(FileSystemVisitor visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemElement element : elements) &#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-21">3.6 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;doc1.txt&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;doc2.txt&quot;</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="type">Folder</span> <span class="variable">folder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&quot;Documents&quot;</span>);</span><br><span class="line">        folder.add(file1);</span><br><span class="line">        folder.add(file2);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystem</span>();</span><br><span class="line">        fileSystem.addElement(folder);</span><br><span class="line"></span><br><span class="line">        <span class="type">SizeCalculatorVisitor</span> <span class="variable">sizeVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SizeCalculatorVisitor</span>();</span><br><span class="line">        fileSystem.accept(sizeVisitor);</span><br><span class="line">        System.out.println(<span class="string">&quot;Total size: &quot;</span> + sizeVisitor.getTotalSize());  <span class="comment">// 输出: Total size: 300</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-21">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建对象结构（<code>FileSystem</code>）和具体元素（<code>File</code>
和 <code>Folder</code>）。</li>
<li>创建访问者（<code>SizeCalculatorVisitor</code>）并传递给结构。</li>
<li>元素通过 <code>accept</code> 调用访问者的对应方法，执行操作。</li>
</ol>
<hr />
<h4 id="优点-21">5. 优点</h4>
<ul>
<li><strong>扩展性</strong>：新增操作只需添加新访问者。</li>
<li><strong>解耦</strong>：数据结构与操作分离。</li>
<li><strong>集中逻辑</strong>：操作集中在访问者中。</li>
</ul>
<hr />
<h4 id="缺点-21">6. 缺点</h4>
<ul>
<li><strong>结构稳定要求</strong>：元素类变化会影响所有访问者。</li>
<li><strong>复杂度</strong>：增加访问者类，提高系统复杂性。</li>
<li><strong>访问限制</strong>：需暴露元素接口给访问者。</li>
</ul>
<hr />
<h4 id="与迭代器模式的对比">7. 与迭代器模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>访问者模式</th>
<th>迭代器模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>扩展操作</td>
<td>顺序访问</td>
</tr>
<tr class="even">
<td><strong>关注点</strong></td>
<td>操作逻辑</td>
<td>遍历逻辑</td>
</tr>
<tr class="odd">
<td><strong>控制权</strong></td>
<td>访问者控制</td>
<td>客户端控制</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-21">8. 实际应用场景</h4>
<ul>
<li><strong>编译器</strong>：语法树遍历和操作（如类型检查）。</li>
<li><strong>文档处理</strong>：对文档元素执行统计或格式化。</li>
<li><strong>游戏</strong>：对不同对象执行渲染或碰撞检测。</li>
</ul>
<hr />
<h4 id="源码中的例子-21">9. 源码中的例子</h4>
<p>Java 中的 <code>javax.swing.tree.TreeVisitor</code>（概念类似）：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TreeVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Node node)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-21">10. 总结</h4>
<ul>
<li><strong>访问者模式</strong>通过访问者分离操作和结构，支持动态功能扩展。</li>
<li><strong>Java 实现</strong>依赖双重分派（<code>accept</code> 和
<code>visit</code>），实现灵活操作。</li>
<li><strong>UML 图</strong>展示了访问者与元素的关系。</li>
</ul>
<p>如果需要更复杂示例（如多访问者）或调整 UML，请告诉我！</p>
<h2 id="扩展模式extended-patterns">扩展模式（Extended Patterns）</h2>
<h3 id="依赖注入dependency-injection"><strong>依赖注入（Dependency
Injection）</strong></h3>
<p>依赖注入模式（Dependency Injection Pattern，简称
DI）是一种设计模式，用于实现控制反转（Inversion of
Control，IoC）。它通过将对象的依赖关系从对象内部创建转移到外部注入，从而解耦对象的创建和使用，提高代码的灵活性、可测试性和可维护性。依赖注入是
IoC 的一种具体实现方式。</p>
<p>以下是用 Java
实现依赖注入模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="依赖注入模式的定义">1. 依赖注入模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：将对象的依赖（即所需的服务或组件）从外部注入，而不是由对象自己创建。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦对象的创建和使用。</li>
<li>提高代码的可测试性（易于 mock 依赖）。</li>
<li>支持动态配置和替换依赖。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>对象依赖复杂或需频繁更换。</li>
<li>单元测试需要隔离依赖。</li>
<li>系统需要集中管理组件。</li>
</ul></li>
</ul>
<hr />
<h4 id="依赖注入模式的结构">2. 依赖注入模式的结构</h4>
<ul>
<li><strong>服务（Service）</strong>：被注入的依赖，提供具体功能。</li>
<li><strong>客户端（Client）</strong>：依赖服务的对象，使用注入的依赖。</li>
<li><strong>注入器（Injector）</strong>：负责创建和注入依赖，可以是手动实现或框架（如
Spring）。</li>
<li><strong>接口（Interface）</strong>：定义服务契约，解耦客户端和具体实现。</li>
</ul>
<h5 id="mermaid-uml-图-17">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Service &#123;
        &lt;&lt;interface&gt;&gt;
        +doSomething()
    &#125;
    class ConcreteService &#123;
        +doSomething()
    &#125;
    class Client &#123;
        -service: Service
        +setService(Service)
        +useService()
    &#125;
    class Injector &#123;
        +injectDependencies(Client)
    &#125;
    
    ConcreteService ..|&gt; Service : implements
    Client --&gt; Service : uses
    Injector --&gt; Client : injects
    Injector --&gt; ConcreteService : creates</code></pre>
<hr />
<h4 id="依赖注入的类型">3. 依赖注入的类型</h4>
<ol type="1">
<li><strong>构造函数注入</strong>：通过构造函数传递依赖。</li>
<li><strong>Setter 注入</strong>：通过 setter 方法设置依赖。</li>
<li><strong>接口注入</strong>：通过接口定义注入方法（较少使用）。</li>
</ol>
<hr />
<h4 id="java-实现示例-22">4. Java 实现示例</h4>
<p>以下是一个消息服务的依赖注入示例，展示构造函数和 Setter 注入。</p>
<h5 id="服务接口">4.1 服务接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体服务">4.2 具体服务</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体服务：邮件服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体服务：短信服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending SMS: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端构造函数注入">4.3 客户端（构造函数注入）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端：消息发送器（构造函数注入）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageSenderConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageSenderConstructor</span><span class="params">(MessageService service)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        service.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端setter-注入">4.4 客户端（Setter 注入）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端：消息发送器（Setter 注入）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageSenderSetter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MessageService service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setService</span><span class="params">(MessageService service)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">            service.sendMessage(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Service not set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注入器手动实现">4.5 注入器（手动实现）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注入器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyInjector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MessageSenderConstructor <span class="title function_">createConstructorSender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MessageSenderConstructor</span>(<span class="keyword">new</span> <span class="title class_">EmailService</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MessageSenderSetter <span class="title function_">createSetterSender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MessageSenderSetter</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageSenderSetter</span>();</span><br><span class="line">        sender.setService(<span class="keyword">new</span> <span class="title class_">SMSService</span>());</span><br><span class="line">        <span class="keyword">return</span> sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-22">4.6 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造函数注入</span></span><br><span class="line">        <span class="type">MessageSenderConstructor</span> <span class="variable">constructorSender</span> <span class="operator">=</span> DependencyInjector.createConstructorSender();</span><br><span class="line">        constructorSender.send(<span class="string">&quot;Hello via email&quot;</span>);  <span class="comment">// 输出: Sending email: Hello via email</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Setter 注入</span></span><br><span class="line">        <span class="type">MessageSenderSetter</span> <span class="variable">setterSender</span> <span class="operator">=</span> DependencyInjector.createSetterSender();</span><br><span class="line">        setterSender.send(<span class="string">&quot;Hello via SMS&quot;</span>);  <span class="comment">// 输出: Sending SMS: Hello via SMS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-22">5. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>定义依赖接口（<code>MessageService</code>），不直接创建实例。</li>
<li><strong>注入器</strong>创建具体服务（如
<code>EmailService</code>）并注入客户端。</li>
<li>客户端通过接口调用服务，完成功能。</li>
</ol>
<hr />
<h4 id="优点-22">6. 优点</h4>
<ul>
<li><strong>解耦</strong>：客户端不依赖具体实现，只依赖接口。</li>
<li><strong>可测试性</strong>：易于注入 mock 对象进行测试。</li>
<li><strong>灵活性</strong>：运行时可切换依赖实现。</li>
</ul>
<hr />
<h4 id="缺点-22">7. 缺点</h4>
<ul>
<li><strong>复杂度</strong>：手动注入增加代码量，需依赖框架简化。</li>
<li><strong>运行时错误</strong>：依赖未注入可能导致空指针异常。</li>
<li><strong>学习曲线</strong>：理解 IoC 和 DI 需一定经验。</li>
</ul>
<hr />
<h4 id="与工厂模式的对比-2">8. 与工厂模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>依赖注入模式</th>
<th>工厂模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>创建方式</strong></td>
<td>外部注入</td>
<td>工厂创建</td>
</tr>
<tr class="even">
<td><strong>控制权</strong></td>
<td>注入器控制</td>
<td>客户端控制</td>
</tr>
<tr class="odd">
<td><strong>耦合</strong></td>
<td>更低（接口依赖）</td>
<td>较高（工厂依赖）</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-22">9. 实际应用场景</h4>
<ul>
<li><strong>Spring 框架</strong>：通过 <code>@Autowired</code>
注入依赖。</li>
<li><strong>单元测试</strong>：注入 mock 对象（如 Mockito）。</li>
<li><strong>模块化系统</strong>：动态配置服务。</li>
</ul>
<hr />
<h4 id="源码中的例子spring-示例">10. 源码中的例子（Spring 示例）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageSender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageSender</span><span class="params">(MessageService service)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        service.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Email: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="总结-22">11. 总结</h4>
<ul>
<li><strong>依赖注入模式</strong>通过外部注入解耦依赖关系。</li>
<li><strong>Java 实现</strong>支持构造函数和 Setter
注入，手动或框架实现。</li>
<li><strong>UML 图</strong>展示了服务、客户端和注入器的关系。</li>
</ul>
<p>如果需要框架（如 Spring）示例或调整 UML，请告诉我！</p>
<h3
id="发布-订阅publish-subscribe"><strong>发布-订阅（Publish-Subscribe）</strong></h3>
<p>发布订阅模式（Publish-Subscribe Pattern，简称
Pub/Sub）是一种消息传递模式，虽然它与观察者模式（Observer
Pattern）有相似之处，但它更强调松耦合的异步通信。发布订阅模式通过一个中间消息代理（Broker）实现发布者（Publisher）和订阅者（Subscriber）之间的解耦，订阅者无需直接依赖发布者。</p>
<p>以下是用 Java
实现发布订阅模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="发布订阅模式的定义">1. 发布订阅模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：发布者发送消息到中间代理，订阅者通过订阅主题或频道接收消息。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦消息发送者和接收者。</li>
<li>支持异步、分布式通信。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>事件驱动系统（如 GUI 事件）。</li>
<li>消息队列（如 Kafka、RabbitMQ）。</li>
<li>实时通知（如股票价格更新）。</li>
</ul></li>
</ul>
<hr />
<h4 id="发布订阅模式的结构">2. 发布订阅模式的结构</h4>
<ul>
<li><strong>发布者（Publisher）</strong>：生成并发送消息。</li>
<li><strong>订阅者（Subscriber）</strong>：接收感兴趣的消息。</li>
<li><strong>消息代理（Broker）</strong>：管理订阅关系，分发消息。</li>
<li><strong>主题（Topic）</strong>：消息的分类，订阅者订阅特定主题。</li>
<li><strong>客户端（Client）</strong>：创建发布者和订阅者，发起交互。</li>
</ul>
<h5 id="mermaid-uml-图-18">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Publisher &#123;
        +publish(topic, message)
    &#125;
    class Subscriber &#123;
        +receive(topic, message)
    &#125;
    class MessageBroker &#123;
        -subscriptions: Map&lt;Topic, List&lt;Subscriber&gt;&gt;
        +subscribe(topic, Subscriber)
        +unsubscribe(topic, Subscriber)
        +publish(topic, message)
    &#125;
    class Client
    
    MessageBroker --&gt; Publisher : receives from
    MessageBroker --&gt; Subscriber : notifies
    Client --&gt; Publisher : uses
    Client --&gt; Subscriber : uses
    Client --&gt; MessageBroker : configures</code></pre>
<hr />
<h4 id="java-实现示例-23">3. Java 实现示例</h4>
<p>以下是一个简单的事件通知系统的发布订阅模式示例。</p>
<h5 id="消息代理">3.1 消息代理</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageBroker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Subscriber&gt;&gt; subscriptions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String topic, Subscriber subscriber)</span> &#123;</span><br><span class="line">        subscriptions.computeIfAbsent(topic, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unsubscribe</span><span class="params">(String topic, Subscriber subscriber)</span> &#123;</span><br><span class="line">        List&lt;Subscriber&gt; subscribers = subscriptions.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (subscribers != <span class="literal">null</span>) &#123;</span><br><span class="line">            subscribers.remove(subscriber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String topic, String message)</span> &#123;</span><br><span class="line">        List&lt;Subscriber&gt; subscribers = subscriptions.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (subscribers != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Subscriber subscriber : subscribers) &#123;</span><br><span class="line">                subscriber.receive(topic, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="订阅者接口">3.2 订阅者接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subscriber</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String topic, String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体订阅者">3.3 具体订阅者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体订阅者：邮件通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailSubscriber</span> <span class="keyword">implements</span> <span class="title class_">Subscriber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmailSubscriber</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String topic, String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; received email on &quot;</span> + topic + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体订阅者：短信通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSSubscriber</span> <span class="keyword">implements</span> <span class="title class_">Subscriber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SMSSubscriber</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String topic, String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; received SMS on &quot;</span> + topic + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="发布者">3.4 发布者</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewsPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MessageBroker broker;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NewsPublisher</span><span class="params">(MessageBroker broker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.broker = broker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String topic, String message)</span> &#123;</span><br><span class="line">        broker.publish(topic, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-23">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MessageBroker</span> <span class="variable">broker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBroker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建订阅者</span></span><br><span class="line">        <span class="type">Subscriber</span> <span class="variable">emailSub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmailSubscriber</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="type">Subscriber</span> <span class="variable">smsSub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SMSSubscriber</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅主题</span></span><br><span class="line">        broker.subscribe(<span class="string">&quot;news&quot;</span>, emailSub);</span><br><span class="line">        broker.subscribe(<span class="string">&quot;news&quot;</span>, smsSub);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建发布者</span></span><br><span class="line">        <span class="type">NewsPublisher</span> <span class="variable">publisher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewsPublisher</span>(broker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        publisher.publish(<span class="string">&quot;news&quot;</span>, <span class="string">&quot;Breaking news!&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Alice received email on news: Breaking news!</span></span><br><span class="line"><span class="comment">        Bob received SMS on news: Breaking news!</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消订阅</span></span><br><span class="line">        broker.unsubscribe(<span class="string">&quot;news&quot;</span>, smsSub);</span><br><span class="line">        publisher.publish(<span class="string">&quot;news&quot;</span>, <span class="string">&quot;Update!&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Alice received email on news: Update!</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-23">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建消息代理、订阅者和发布者。</li>
<li>订阅者通过代理订阅主题（<code>subscribe</code>）。</li>
<li>发布者发送消息到代理（<code>publish</code>），代理分发给订阅者（<code>receive</code>）。</li>
</ol>
<hr />
<h4 id="优点-23">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：发布者和订阅者无直接依赖，仅通过代理交互。</li>
<li><strong>灵活性</strong>：支持动态订阅和取消。</li>
<li><strong>异步性</strong>：可结合队列实现异步通信。</li>
</ul>
<hr />
<h4 id="缺点-23">6. 缺点</h4>
<ul>
<li><strong>复杂度</strong>：代理增加系统复杂性。</li>
<li><strong>性能</strong>：大量订阅者或消息可能影响分发效率。</li>
<li><strong>依赖代理</strong>：代理故障影响整个系统。</li>
</ul>
<hr />
<h4 id="与观察者模式的对比-1">7. 与观察者模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>发布订阅模式</th>
<th>观察者模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>耦合</strong></td>
<td>松耦合（通过代理）</td>
<td>紧耦合（直接依赖主题）</td>
</tr>
<tr class="even">
<td><strong>中介</strong></td>
<td>有独立代理</td>
<td>无（主题直接通知）</td>
</tr>
<tr class="odd">
<td><strong>通信</strong></td>
<td>异步支持强</td>
<td>通常同步</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-23">8. 实际应用场景</h4>
<ul>
<li><strong>消息队列</strong>：如 Kafka、RabbitMQ。</li>
<li><strong>事件总线</strong>：GUI 框架中的事件分发。</li>
<li><strong>实时系统</strong>：股票价格通知。</li>
</ul>
<hr />
<h4 id="源码中的例子-22">9. 源码中的例子</h4>
<p>Java 中的 <code>java.util.concurrent.Flow</code>（Java 9+）：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Flow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPublisher</span> <span class="keyword">implements</span> <span class="title class_">Publisher</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Subscriber&lt;? <span class="built_in">super</span> String&gt;&gt; subscribers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Subscriber&lt;? <span class="built_in">super</span> String&gt; subscriber)</span> &#123;</span><br><span class="line">        subscribers.add(subscriber);</span><br><span class="line">        subscriber.onSubscribe(<span class="keyword">new</span> <span class="title class_">Subscription</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(<span class="type">long</span> n)</span> &#123;&#125;</span><br><span class="line">            <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        subscribers.forEach(s -&gt; s.onNext(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-23">10. 总结</h4>
<ul>
<li><strong>发布订阅模式</strong>通过代理实现松耦合消息传递。</li>
<li><strong>Java 实现</strong>依赖代理分发，支持动态订阅。</li>
<li><strong>UML 图</strong>展示了发布者、订阅者和代理的关系。</li>
</ul>
<p>如果需要异步示例（如线程池）或调整 UML，请告诉我！</p>
<h3 id="模块模式module-pattern"><strong>模块模式（Module
Pattern）</strong></h3>
<p>我假设你指的是“模块模式”（Module
Pattern），可能是“模块”中的拼写或表述差异。模块模式不是经典的 GoF
设计模式，而是一种在 JavaScript
中广泛使用的设计模式，用于封装代码、隐藏实现细节并提供公共接口。它通过闭包和立即执行函数（IIFE）实现私有作用域和模块化。</p>
<p>由于你的问题要求用 Java，而 Java 的模块化机制与 JavaScript 不同（如
Java 使用类和包），我将讲解模块模式的核心思想，并将其适配到 Java
环境中，提供类似的实现方式（基于类的封装或 Java 9+
的模块系统）。以下是详细讲解。</p>
<hr />
<h4 id="模块模式的定义">1. 模块模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过封装隐藏私有成员，只暴露公共接口，实现数据隐私和模块化。</li>
<li><strong>目的</strong>：
<ul>
<li>防止全局命名空间污染。</li>
<li>提供清晰的 API，隐藏实现细节。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>需要封装逻辑和状态。</li>
<li>避免变量冲突。</li>
<li>分离关注点。</li>
</ul></li>
</ul>
<hr />
<h4 id="模块模式的结构javascript-视角">2. 模块模式的结构（JavaScript
视角）</h4>
<ul>
<li><strong>私有成员</strong>：通过闭包定义的变量和方法，仅模块内部可访问。</li>
<li><strong>公共接口</strong>：通过返回的对象暴露给外部。</li>
<li><strong>立即执行函数（IIFE）</strong>：创建模块作用域。</li>
</ul>
<h5 id="javascript-示例">JavaScript 示例</h5>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CounterModule</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 私有成员</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">incrementInternal</span>(<span class="params"></span>) &#123; count++; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共接口</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">incrementInternal</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Count: &quot;</span> + count);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">getCount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="title class_">CounterModule</span>.<span class="title function_">increment</span>();  <span class="comment">// 输出: Count: 1</span></span><br><span class="line"><span class="title class_">CounterModule</span>.<span class="title function_">increment</span>();  <span class="comment">// 输出: Count: 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">CounterModule</span>.<span class="title function_">getCount</span>());  <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure>
<hr />
<h4 id="java-中的模块模式适配">3. Java 中的模块模式适配</h4>
<p>Java 没有闭包和
IIFE，但可以通过类的封装（私有字段和公共方法）实现类似效果。Java 9
引入的模块系统（JPMS）进一步支持模块化。以下是两种方式的实现。</p>
<h5 id="使用类封装类似-javascript-模块模式">3.1 使用类封装（类似
JavaScript 模块模式）</h5>
<h6 id="模块类">模块类</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块类：计数器模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterModule</span> &#123;</span><br><span class="line">    <span class="comment">// 私有成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">incrementInternal</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        incrementInternal();</span><br><span class="line">        System.out.println(<span class="string">&quot;Count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例模式确保唯一实例（可选）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CounterModule</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterModule</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CounterModule</span><span class="params">()</span> &#123;&#125;  <span class="comment">// 私有构造防止外部实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CounterModule <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="客户端代码-24">客户端代码</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CounterModule</span> <span class="variable">counter</span> <span class="operator">=</span> CounterModule.getInstance();</span><br><span class="line">        counter.increment();  <span class="comment">// 输出: Count: 1</span></span><br><span class="line">        counter.increment();  <span class="comment">// 输出: Count: 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Current count: &quot;</span> + counter.getCount());  <span class="comment">// 输出: Current count: 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>说明</strong>：
<ul>
<li>私有字段 <code>count</code> 和方法 <code>incrementInternal</code>
隐藏实现。</li>
<li>公共方法 <code>increment</code> 和 <code>getCount</code>
暴露接口。</li>
<li>单例模式模拟 JavaScript 的单一模块实例。</li>
</ul></li>
</ul>
<h5 id="使用-java-9-模块系统jpms">3.2 使用 Java 9+ 模块系统（JPMS）</h5>
<p>Java 9 引入的模块系统提供了更高级的模块化支持，通过
<code>module-info.java</code> 定义模块边界。</p>
<h6 id="模块定义module-info.java">模块定义（module-info.java）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> counterModule &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.example.counter;  <span class="comment">// 暴露公共接口包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6
id="模块实现com.example.counter.countermodule">模块实现（com.example.counter.CounterModule）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.counter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterModule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">incrementInternal</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        incrementInternal();</span><br><span class="line">        System.out.println(<span class="string">&quot;Count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="客户端模块module-info.java">客户端模块（module-info.java）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> client &#123;</span><br><span class="line">    <span class="keyword">requires</span> counterModule;  <span class="comment">// 依赖 counterModule</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6
id="客户端代码com.example.client.main">客户端代码（com.example.client.Main）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.counter.CounterModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CounterModule</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterModule</span>();</span><br><span class="line">        counter.increment();  <span class="comment">// 输出: Count: 1</span></span><br><span class="line">        counter.increment();  <span class="comment">// 输出: Count: 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>说明</strong>：
<ul>
<li><code>module-info.java</code> 定义模块边界，控制包的可见性。</li>
<li>类似 JavaScript 的模块作用域，但更静态。</li>
</ul></li>
</ul>
<hr />
<h4 id="工作原理-24">4. 工作原理</h4>
<ol type="1">
<li><strong>封装</strong>：私有成员（如
<code>count</code>）隐藏在类或模块内部。</li>
<li><strong>暴露接口</strong>：通过公共方法（如
<code>increment</code>）提供访问。</li>
<li><strong>客户端</strong>：仅通过接口操作模块，无需了解实现。</li>
</ol>
<hr />
<h4 id="优点-24">5. 优点</h4>
<ul>
<li><strong>封装性</strong>：隐藏实现细节，保护数据。</li>
<li><strong>模块化</strong>：逻辑清晰，便于维护。</li>
<li><strong>复用性</strong>：单一模块可多次使用。</li>
</ul>
<hr />
<h4 id="缺点-24">6. 缺点</h4>
<ul>
<li><strong>灵活性低</strong>：Java 类封装静态，动态性不如
JavaScript。</li>
<li><strong>单例限制</strong>：单例模式可能不适合所有场景。</li>
<li><strong>JPMS 复杂性</strong>：模块系统配置较繁琐。</li>
</ul>
<hr />
<h4 id="与工厂模式的对比-3">7. 与工厂模式的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>模块模式</th>
<th>工厂模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>封装和模块化</td>
<td>创建对象</td>
</tr>
<tr class="even">
<td><strong>结构</strong></td>
<td>单一实例或模块</td>
<td>工厂类</td>
</tr>
<tr class="odd">
<td><strong>动态性</strong></td>
<td>较静态</td>
<td>动态创建</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-24">8. 实际应用场景</h4>
<ul>
<li><strong>工具类</strong>：封装工具函数（如 <code>Math</code>
类）。</li>
<li><strong>配置管理</strong>：隐藏配置细节，提供接口。</li>
<li><strong>服务模块</strong>：如日志或缓存服务。</li>
</ul>
<hr />
<h4 id="源码中的例子-23">9. 源码中的例子</h4>
<p>Java 中的 <code>java.util.Collections</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.sort(list);  <span class="comment">// 模块化接口</span></span><br></pre></td></tr></table></figure> -
<strong>说明</strong>：<code>Collections</code>
封装排序逻辑，隐藏实现。</p>
<hr />
<h4 id="总结-24">10. 总结</h4>
<ul>
<li><strong>模块模式</strong>通过封装实现私有性和公共接口。</li>
<li><strong>Java 实现</strong>可用类封装或 JPMS，模拟 JavaScript
模块化。</li>
<li><strong>UML 图</strong>（若需要）可展示单一模块与客户端关系。</li>
</ul>
<p>如果需要更复杂示例（如带配置的模块）或 UML 图，请告诉我！</p>
<h3
id="mvcmodel-view-controller"><strong>MVC（Model-View-Controller）</strong></h3>
<p>MVC 模式（Model-View-Controller
Pattern）是一种广泛使用的架构模式，用于组织代码，分分离用户界面、数据和控制逻辑。它通过将应用程序分为三个相互连接的部分，提高了代码的可维护性、可扩展性和模块化。</p>
<p>以下是用 Java 实现 MVC
模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="mvc-模式的定义">1. MVC 模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：将应用程序分为模型（Model）、视图（View）和控制器（Controller），实现职责分离。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦数据、界面和逻辑。</li>
<li>支持独立开发和测试。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>GUI 应用程序（如 Swing、JavaFX）。</li>
<li>Web 应用（如 Spring MVC）。</li>
<li>复杂交互系统。</li>
</ul></li>
</ul>
<hr />
<h4 id="mvc-模式的结构">2. MVC 模式的结构</h4>
<ul>
<li><strong>模型（Model）</strong>：管理数据和业务逻辑，独立于 UI。</li>
<li><strong>视图（View）</strong>：显示模型数据，负责用户界面。</li>
<li><strong>控制器（Controller）</strong>：处理用户输入，协调模型和视图。</li>
<li><strong>交互关系</strong>：
<ul>
<li>控制器接收用户输入，更新模型。</li>
<li>模型通知视图更新显示。</li>
<li>视图从模型获取数据。</li>
</ul></li>
</ul>
<h5 id="mermaid-uml-图-19">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Model &#123;
        -data: Data
        +setData(data)
        +getData() Data
        +notifyViews()
    &#125;
    class View &#123;
        -model: Model
        +update()
        +display()
    &#125;
    class Controller &#123;
        -model: Model
        -view: View
        +handleInput(input)
    &#125;
    
    Model --&gt; View : notifies
    View --&gt; Model : queries
    Controller --&gt; Model : updates
    Controller --&gt; View : controls</code></pre>
<hr />
<h4 id="java-实现示例-24">3. Java 实现示例</h4>
<p>以下是一个简单的计数器应用的 MVC 示例。</p>
<h5 id="模型model">3.1 模型（Model）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模型：计数器数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> List&lt;View&gt; views = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        notifyViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        count--;</span><br><span class="line">        notifyViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        views.add(view);</span><br><span class="line">        view.update();  <span class="comment">// 初始化视图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyViews</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (View view : views) &#123;</span><br><span class="line">            view.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="视图view">3.2 视图（View）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视图：显示计数器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterView</span> <span class="keyword">implements</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CounterModel model;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterView</span><span class="params">(CounterModel model)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        model.addView(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Current count: &quot;</span> + model.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="控制器controller">3.3 控制器（Controller）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制器：处理用户输入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CounterModel model;</span><br><span class="line">    <span class="keyword">private</span> CounterView view;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterController</span><span class="params">(CounterModel model, CounterView view)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        <span class="built_in">this</span>.view = view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        model.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        model.decrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-25">3.4 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CounterModel</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterModel</span>();</span><br><span class="line">        <span class="type">CounterView</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterView</span>(model);</span><br><span class="line">        <span class="type">CounterController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterController</span>(model, view);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟用户操作</span></span><br><span class="line">        controller.increment();  <span class="comment">// 输出: Current count: 1</span></span><br><span class="line">        controller.increment();  <span class="comment">// 输出: Current count: 2</span></span><br><span class="line">        controller.decrement();  <span class="comment">// 输出: Current count: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-25">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建模型、视图和控制器，关联三者。</li>
<li>用户通过控制器发起操作（如 <code>increment</code>）。</li>
<li>控制器更新模型，模型通知视图刷新显示。</li>
</ol>
<hr />
<h4 id="优点-25">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：模型、视图和控制器独立，互不干扰。</li>
<li><strong>可扩展</strong>：易于添加新视图或控制器。</li>
<li><strong>可测试</strong>：模型独立于 UI，便于单元测试。</li>
</ul>
<hr />
<h4 id="缺点-25">6. 缺点</h4>
<ul>
<li><strong>复杂度</strong>：小型应用可能显得过于繁琐。</li>
<li><strong>耦合风险</strong>：视图和控制器可能间接耦合。</li>
<li><strong>维护成本</strong>：多组件增加协调难度。</li>
</ul>
<hr />
<h4 id="与-mvpmvvm-的对比">7. 与 MVP/MVVM 的对比</h4>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>MVC</th>
<th>MVP</th>
<th>MVVM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>控制器角色</strong></td>
<td>协调视图和模型</td>
<td>主动更新视图</td>
<td>数据绑定</td>
</tr>
<tr class="even">
<td><strong>视图依赖</strong></td>
<td>依赖模型</td>
<td>依赖 Presenter</td>
<td>通过 ViewModel 绑定</td>
</tr>
<tr class="odd">
<td><strong>耦合</strong></td>
<td>中等</td>
<td>较低</td>
<td>最低</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-25">8. 实际应用场景</h4>
<ul>
<li><strong>Swing/JavaFX</strong>：GUI 组件分离。</li>
<li><strong>Spring MVC</strong>：Web 应用框架。</li>
<li><strong>游戏开发</strong>：游戏逻辑与渲染分离。</li>
</ul>
<hr />
<h4 id="源码中的例子-24">9. 源码中的例子</h4>
<p>Java Swing 中的 MVC： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Click&quot;</span>);</span><br><span class="line">button.addActionListener(e -&gt; System.out.println(<span class="string">&quot;Clicked&quot;</span>));  <span class="comment">// 控制器监听</span></span><br></pre></td></tr></table></figure> -
<strong>Model</strong>：按钮状态。 - <strong>View</strong>：按钮 UI。 -
<strong>Controller</strong>：<code>ActionListener</code>。</p>
<hr />
<h4 id="总结-25">10. 总结</h4>
<ul>
<li><strong>MVC
模式</strong>通过分离模型、视图和控制器实现职责分工。</li>
<li><strong>Java 实现</strong>依赖观察者机制协调视图更新。</li>
<li><strong>UML 图</strong>展示了三者之间的关系。</li>
</ul>
<p>如果需要更复杂示例（如多视图支持）或调整 UML，请告诉我！</p>
<h3
id="mvpmodel-view-presenter"><strong>MVP（Model-View-Presenter）</strong></h3>
<p>MVP 模式（Model-View-Presenter Pattern）是一种架构模式，演变自 MVC
模式，旨在进一步解耦视图和逻辑，增强可测试性。MVP
通过将视图（View）和模型（Model）之间的交互完全交给展示者（Presenter）处理，避免了视图直接依赖模型，提高了代码的模块化和清晰度。</p>
<p>以下是用 Java 实现 MVP
模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="mvp-模式的定义">1. MVP 模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过展示者（Presenter）协调视图和模型，视图只负责显示，Presenter
处理逻辑。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦视图和模型。</li>
<li>提高代码可测试性。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>GUI 应用程序需要清晰分离。</li>
<li>需要测试业务逻辑而不依赖 UI。</li>
<li>视图逻辑复杂。</li>
</ul></li>
</ul>
<hr />
<h4 id="mvp-模式的结构">2. MVP 模式的结构</h4>
<ul>
<li><strong>模型（Model）</strong>：管理数据和业务逻辑，与 MVC
类似。</li>
<li><strong>视图（View）</strong>：显示数据和用户界面，定义与 Presenter
交互的接口。</li>
<li><strong>展示者（Presenter）</strong>：处理用户输入，更新模型并控制视图。</li>
<li><strong>客户端（Client）</strong>：创建并连接组件。</li>
</ul>
<h5 id="mermaid-uml-图-20">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Model &#123;
        -data: Data
        +setData(data)
        +getData() Data
    &#125;
    class View &#123;
        &lt;&lt;interface&gt;&gt;
        +showData(data)
        +getInput() Input
    &#125;
    class ConcreteView &#123;
        +showData(data)
        +getInput() Input
    &#125;
    class Presenter &#123;
        -model: Model
        -view: View
        +handleInput(input)
    &#125;
    class Client
    
    ConcreteView ..|&gt; View : implements
    Presenter --&gt; Model : updates
    Presenter --&gt; View : controls
    ConcreteView --&gt; Presenter : notifies
    Client --&gt; Presenter : uses
    Client --&gt; ConcreteView : uses</code></pre>
<hr />
<h4 id="java-实现示例-25">3. Java 实现示例</h4>
<p>以下是一个计数器的 MVP 示例，Presenter 处理增减逻辑。</p>
<h5 id="模型model-1">3.1 模型（Model）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模型：计数器数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="视图接口view">3.2 视图接口（View）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视图接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CounterView</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showCount</span><span class="params">(<span class="type">int</span> count)</span>;  <span class="comment">// 显示计数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">incrementClicked</span><span class="params">()</span>;    <span class="comment">// 通知增操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrementClicked</span><span class="params">()</span>;    <span class="comment">// 通知减操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体视图concrete-view">3.3 具体视图（Concrete View）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体视图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleCounterView</span> <span class="keyword">implements</span> <span class="title class_">CounterView</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CounterPresenter presenter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsoleCounterView</span><span class="params">(CounterPresenter presenter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.presenter = presenter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCount</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Current count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incrementClicked</span><span class="params">()</span> &#123;</span><br><span class="line">        presenter.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrementClicked</span><span class="params">()</span> &#123;</span><br><span class="line">        presenter.decrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟用户操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simulateUserInteraction</span><span class="params">()</span> &#123;</span><br><span class="line">        incrementClicked();</span><br><span class="line">        decrementClicked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="展示者presenter">3.4 展示者（Presenter）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 展示者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterPresenter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CounterModel model;</span><br><span class="line">    <span class="keyword">private</span> CounterView view;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterPresenter</span><span class="params">(CounterModel model, CounterView view)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        <span class="built_in">this</span>.view = view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        model.increment();</span><br><span class="line">        view.showCount(model.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        model.decrement();</span><br><span class="line">        view.showCount(model.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-26">3.5 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CounterModel</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterModel</span>();</span><br><span class="line">        <span class="type">ConsoleCounterView</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleCounterView</span>(<span class="literal">null</span>);  <span class="comment">// 先创建视图</span></span><br><span class="line">        <span class="type">CounterPresenter</span> <span class="variable">presenter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterPresenter</span>(model, view);</span><br><span class="line">        view.presenter = presenter;  <span class="comment">// 注入 Presenter</span></span><br><span class="line"></span><br><span class="line">        view.simulateUserInteraction();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        Current count: 1</span></span><br><span class="line"><span class="comment">        Current count: 0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-26">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建模型、视图和展示者，关联三者。</li>
<li>视图捕获用户输入（如 <code>incrementClicked</code>），通知
Presenter。</li>
<li>Presenter 更新模型并调用视图方法刷新显示。</li>
</ol>
<hr />
<h4 id="优点-26">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：视图不直接访问模型，依赖 Presenter。</li>
<li><strong>可测试性</strong>：Presenter 无 UI 依赖，易于单元测试。</li>
<li><strong>清晰性</strong>：职责明确，逻辑集中。</li>
</ul>
<hr />
<h4 id="缺点-26">6. 缺点</h4>
<ul>
<li><strong>复杂度</strong>：小型应用可能显得繁琐。</li>
<li><strong>类数量</strong>：增加接口和实现类。</li>
<li><strong>双向依赖</strong>：视图和 Presenter 可能形成循环引用。</li>
</ul>
<hr />
<h4 id="与-mvc-的对比">7. 与 MVC 的对比</h4>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 34%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>MVP</th>
<th>MVC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>视图依赖</strong></td>
<td>不依赖模型</td>
<td>依赖模型</td>
</tr>
<tr class="even">
<td><strong>控制角色</strong></td>
<td>Presenter 主动更新视图</td>
<td>Controller 协调</td>
</tr>
<tr class="odd">
<td><strong>通信</strong></td>
<td>双向（View ↔︎ Presenter）</td>
<td>三方（View ↔︎ Controller ↔︎ Model）</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-26">8. 实际应用场景</h4>
<ul>
<li><strong>Android 开发</strong>：Activity/View 作为视图，Presenter
处理逻辑。</li>
<li><strong>桌面应用</strong>：Swing/JavaFX 的逻辑分离。</li>
<li><strong>测试驱动开发</strong>：隔离 UI 进行测试。</li>
</ul>
<hr />
<h4 id="源码中的例子-25">9. 源码中的例子</h4>
<p>Android 中的 MVP（伪代码）： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginView</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showLoginSuccess</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginPresenter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LoginView view;</span><br><span class="line">    <span class="keyword">private</span> LoginModel model;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginPresenter</span><span class="params">(LoginView view, LoginModel model)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.view = view;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (model.validate(username, password)) &#123;</span><br><span class="line">            view.showLoginSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-26">10. 总结</h4>
<ul>
<li><strong>MVP 模式</strong>通过 Presenter
分离视图和模型，增强解耦。</li>
<li><strong>Java 实现</strong>依赖接口和双向通信，支持灵活控制。</li>
<li><strong>UML 图</strong>展示了视图、Presenter 和模型的关系。</li>
</ul>
<p>如果需要更复杂示例（如多视图）或调整 UML，请告诉我！</p>
<h3
id="mvvmmodel-view-viewmodel"><strong>MVVM（Model-View-ViewModel）</strong></h3>
<p>MVVM 模式（Model-View-ViewModel Pattern）是一种架构模式，起源于微软的
WPF 和 Silverlight，广泛应用于现代前端框架（如
Angular、Vue.js）和桌面应用开发。它通过引入 ViewModel
层，将视图（View）和模型（Model）解耦，并利用数据绑定简化视图更新。MVVM
模式特别适合双向数据绑定的场景。</p>
<p>以下是用 Java 实现 MVVM
模式的详细讲解，包括定义、结构、代码示例及其优缺点。由于 Java
不原生支持双向数据绑定，我会通过观察者机制模拟绑定效果。</p>
<hr />
<h4 id="mvvm-模式的定义">1. MVVM 模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过 ViewModel
连接视图和模型，利用数据绑定实现视图与数据的自动同步。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦视图和业务逻辑。</li>
<li>简化视图更新，提高开发效率。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>视图频繁更新（如表单、实时数据）。</li>
<li>支持数据绑定的 UI 框架。</li>
<li>需要清晰分离 UI 和逻辑。</li>
</ul></li>
</ul>
<hr />
<h4 id="mvvm-模式的结构">2. MVVM 模式的结构</h4>
<ul>
<li><strong>模型（Model）</strong>：管理数据和业务逻辑。</li>
<li><strong>视图（View）</strong>：显示数据，响应用户输入。</li>
<li><strong>视图模型（ViewModel）</strong>：持有视图所需数据，处理逻辑，绑定模型和视图。</li>
<li><strong>绑定机制（Binding）</strong>：同步 View 和 ViewModel（Java
中需手动模拟）。</li>
<li><strong>客户端（Client）</strong>：创建组件并启动应用。</li>
</ul>
<h5 id="mermaid-uml-图-21">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Model &#123;
        -data: Data
        +setData(data)
        +getData() Data
    &#125;
    class View &#123;
        +display(data)
        +notifyInput(input)
    &#125;
    class ViewModel &#123;
        -model: Model
        -observers: List&lt;View&gt;
        +setValue(value)
        +getValue() Value
        +notifyViews()
    &#125;
    class Client
    
    ViewModel --&gt; Model : uses
    View --&gt; ViewModel : binds to
    ViewModel --&gt; View : notifies
    Client --&gt; View : uses
    Client --&gt; ViewModel : uses</code></pre>
<hr />
<h4 id="java-实现示例-26">3. Java 实现示例</h4>
<p>以下是一个计数器的 MVVM 示例，ViewModel
管理计数并通过观察者通知视图。</p>
<h5 id="模型model-2">3.1 模型（Model）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模型：计数器数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="视图view-1">3.2 视图（View）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视图：计数器显示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterView</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CounterViewModel viewModel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterView</span><span class="params">(CounterViewModel viewModel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.viewModel = viewModel;</span><br><span class="line">        viewModel.addObserver(<span class="built_in">this</span>::update);  <span class="comment">// 绑定 ViewModel</span></span><br><span class="line">        update(viewModel.getValue());  <span class="comment">// 初始化显示</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;View updated - Count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟用户输入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        viewModel.setValue(viewModel.getValue() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        viewModel.setValue(viewModel.getValue() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="视图模型viewmodel">3.3 视图模型（ViewModel）</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视图模型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CounterModel model;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Consumer&lt;Integer&gt;&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterViewModel</span><span class="params">(CounterModel model)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        model.setCount(value);</span><br><span class="line">        notifyViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> model.getCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Consumer&lt;Integer&gt; observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyViews</span><span class="params">()</span> &#123;</span><br><span class="line">        observers.forEach(observer -&gt; observer.accept(model.getCount()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-27">3.4 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CounterModel</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterModel</span>();</span><br><span class="line">        <span class="type">CounterViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterViewModel</span>(model);</span><br><span class="line">        <span class="type">CounterView</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterView</span>(viewModel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟用户操作</span></span><br><span class="line">        view.increment();  <span class="comment">// 输出: View updated - Count: 1</span></span><br><span class="line">        view.increment();  <span class="comment">// 输出: View updated - Count: 2</span></span><br><span class="line">        view.decrement();  <span class="comment">// 输出: View updated - Count: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-27">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>创建模型、ViewModel 和视图，关联三者。</li>
<li>视图绑定到 ViewModel，监听数据变化。</li>
<li>用户通过视图发起操作（如 <code>increment</code>），ViewModel
更新模型并通知视图刷新。</li>
</ol>
<hr />
<h4 id="优点-27">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：视图不直接访问模型，依赖 ViewModel。</li>
<li><strong>自动化</strong>：数据绑定减少手动更新代码。</li>
<li><strong>可测试性</strong>：ViewModel 独立于 UI，易于测试。</li>
</ul>
<hr />
<h4 id="缺点-27">6. 缺点</h4>
<ul>
<li><strong>复杂度</strong>：绑定机制增加实现难度（Java
中需手动）。</li>
<li><strong>性能</strong>：大量绑定可能影响效率。</li>
<li><strong>适用性</strong>：需框架支持（如
JavaFX）才充分发挥优势。</li>
</ul>
<hr />
<h4 id="与-mvcmvp-的对比">7. 与 MVC/MVP 的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>MVVM</th>
<th>MVC</th>
<th>MVP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>视图更新</strong></td>
<td>数据绑定</td>
<td>Controller 控制</td>
<td>Presenter 控制</td>
</tr>
<tr class="even">
<td><strong>视图依赖</strong></td>
<td>ViewModel</td>
<td>Model</td>
<td>Presenter</td>
</tr>
<tr class="odd">
<td><strong>耦合</strong></td>
<td>最低</td>
<td>中等</td>
<td>较低</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-27">8. 实际应用场景</h4>
<ul>
<li><strong>JavaFX</strong>：绑定属性到 UI。</li>
<li><strong>前端框架</strong>：Vue.js、WPF 的 MVVM。</li>
<li><strong>表单应用</strong>：实时同步输入和数据。</li>
</ul>
<hr />
<h4 id="源码中的例子javafx">9. 源码中的例子（JavaFX）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.beans.property.IntegerProperty;</span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.SimpleIntegerProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntegerProperty</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleIntegerProperty</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123; count.set(count.get() + <span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> IntegerProperty <span class="title function_">countProperty</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CounterViewModel</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterViewModel</span>();</span><br><span class="line">        vm.countProperty().addListener((obs, old, newVal) -&gt; </span><br><span class="line">            System.out.println(<span class="string">&quot;Count: &quot;</span> + newVal));</span><br><span class="line">        vm.increment();  <span class="comment">// 输出: Count: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="总结-27">10. 总结</h4>
<ul>
<li><strong>MVVM 模式</strong>通过 ViewModel 和绑定解耦视图和模型。</li>
<li><strong>Java
实现</strong>需手动模拟绑定（如观察者），框架支持更佳。</li>
<li><strong>UML 图</strong>展示了 ViewModel 的中介作用。</li>
</ul>
<p>如果需要更复杂示例（如双向绑定）或调整 UML，请告诉我！</p>
<h3 id="mvc-mvp-mvvm-比较">MVC, MVP, MVVM 比较</h3>
<p>以下是 MVC（Model-View-Controller）、MVP（Model-View-Presenter）和
MVVM（Model-View-ViewModel）三种架构模式的详细比较表格，涵盖定义、结构、职责、耦合性、数据流、测试性等关键方面。</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 27%" />
<col style="width: 27%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>特性</strong></th>
<th><strong>MVC (Model-View-Controller)</strong></th>
<th><strong>MVP (Model-View-Presenter)</strong></th>
<th><strong>MVVM (Model-View-ViewModel)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>定义</strong></td>
<td>通过控制器协调模型和视图，分离数据、UI 和逻辑。</td>
<td>通过展示者处理视图和模型交互，视图不直接访问模型。</td>
<td>通过 ViewModel 和数据绑定解耦视图和模型，强调自动化。</td>
</tr>
<tr class="even">
<td><strong>核心思想</strong></td>
<td>视图显示模型，控制器处理输入，模型管理数据。</td>
<td>Presenter 控制视图和模型，视图被动接收更新。</td>
<td>ViewModel 暴露数据和命令，视图通过绑定自动更新。</td>
</tr>
<tr class="odd">
<td><strong>结构</strong></td>
<td>- Model: 数据和逻辑<br>- View: UI<br>- Controller: 协调</td>
<td>- Model: 数据和逻辑<br>- View: UI 接口<br>- Presenter: 逻辑</td>
<td>- Model: 数据和逻辑<br>- View: UI<br>- ViewModel: 中介</td>
</tr>
<tr class="even">
<td><strong>职责分配</strong></td>
<td>- Model: 数据存储和业务逻辑<br>- View: 显示和输入<br>- Controller:
更新模型、控制视图</td>
<td>- Model: 数据存储和逻辑<br>- View: 显示和通知<br>- Presenter:
处理输入、更新视图</td>
<td>- Model: 数据和逻辑<br>- View: 显示<br>- ViewModel:
数据绑定和逻辑</td>
</tr>
<tr class="odd">
<td><strong>耦合性</strong></td>
<td>中等：View 直接依赖 Model，Controller 依赖两者</td>
<td>较低：View 只依赖 Presenter，Presenter 依赖 Model</td>
<td>最低：View 通过绑定依赖 ViewModel，ViewModel 依赖 Model</td>
</tr>
<tr class="even">
<td><strong>数据流</strong></td>
<td>- 用户 → Controller → Model → View</td>
<td>- 用户 → View → Presenter → Model → View</td>
<td>- 用户 → View → ViewModel → Model（绑定双向同步）</td>
</tr>
<tr class="odd">
<td><strong>视图更新</strong></td>
<td>Controller 主动更新 View</td>
<td>Presenter 主动更新 View</td>
<td>数据绑定自动更新 View</td>
</tr>
<tr class="even">
<td><strong>控制器/Presenter/ViewModel 角色</strong></td>
<td>Controller 协调模型和视图更新</td>
<td>Presenter 处理逻辑，主动控制视图</td>
<td>ViewModel 暴露数据和命令，视图绑定更新</td>
</tr>
<tr class="odd">
<td><strong>通信方式</strong></td>
<td>- View → Controller (输入)<br>- Model → View (通知)</td>
<td>- View → Presenter (通知)<br>- Presenter → View (更新)</td>
<td>- View ↔︎ ViewModel (绑定)<br>- ViewModel → Model (更新)</td>
</tr>
<tr class="even">
<td><strong>测试性</strong></td>
<td>Model 可独立测试，Controller 依赖 UI 难测</td>
<td>Presenter 可独立测试，View 可 mock</td>
<td>ViewModel 可独立测试，View 可 mock</td>
</tr>
<tr class="odd">
<td><strong>复杂度</strong></td>
<td>中等：简单应用可能繁琐</td>
<td>中等：需定义接口和实现</td>
<td>较高：绑定机制增加复杂性（Java 需手动实现）</td>
</tr>
<tr class="even">
<td><strong>优点</strong></td>
<td>- 解耦 UI 和逻辑<br>- 易于理解</td>
<td>- 视图与模型解耦<br>- 高测试性</td>
<td>- 视图自动更新<br>- 最低耦合</td>
</tr>
<tr class="odd">
<td><strong>缺点</strong></td>
<td>- View 依赖 Model<br>- 控制器可能臃肿</td>
<td>- 类数量增加<br>- View-Presenter 双向依赖</td>
<td>- 绑定复杂<br>- 性能开销（大量绑定）</td>
</tr>
<tr class="even">
<td><strong>适用场景</strong></td>
<td>- 传统 GUI<br>- Web 应用（如 Spring MVC）</td>
<td>- 测试驱动开发<br>- 复杂视图逻辑</td>
<td>- 数据驱动 UI<br>- 支持绑定的框架（如 JavaFX）</td>
</tr>
<tr class="odd">
<td><strong>Java 示例</strong></td>
<td>Controller 更新 Model，Model 通知 View</td>
<td>Presenter 处理输入，调用 View 更新</td>
<td>ViewModel 绑定数据，View 自动更新</td>
</tr>
<tr class="even">
<td><strong>典型框架</strong></td>
<td>Spring MVC、Struts</td>
<td>Android (早期)、GWT</td>
<td>JavaFX、WPF、Vue.js</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="详细说明">详细说明</h4>
<h5 id="数据流"><strong>数据流</strong></h5>
<ul>
<li><strong>MVC</strong>：用户输入通过控制器传递到模型，模型更新后通知视图显示（单向为主，视图可直接查询模型）。</li>
<li><strong>MVP</strong>：用户输入通过视图通知 Presenter，Presenter
更新模型并主动刷新视图（双向通信）。</li>
<li><strong>MVVM</strong>：用户输入直接影响
ViewModel（通过绑定），ViewModel
更新模型，视图自动同步（双向绑定）。</li>
</ul>
<h5 id="视图与模型关系"><strong>视图与模型关系</strong></h5>
<ul>
<li><strong>MVC</strong>：视图直接访问模型获取数据，可能导致耦合。</li>
<li><strong>MVP</strong>：视图通过 Presenter
间接访问模型，解耦更彻底。</li>
<li><strong>MVVM</strong>：视图通过 ViewModel
绑定访问数据，完全隔离模型。</li>
</ul>
<h5 id="测试性"><strong>测试性</strong></h5>
<ul>
<li><strong>MVC</strong>：控制器依赖视图，测试需模拟 UI。</li>
<li><strong>MVP</strong>：Presenter 不依赖具体视图实现，可轻松 mock View
接口。</li>
<li><strong>MVVM</strong>：ViewModel
独立于视图，测试只需验证数据逻辑。</li>
</ul>
<h5 id="java-示例代码片段"><strong>Java 示例代码片段</strong></h5>
<ol type="1">
<li><p><strong>MVC</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123; <span class="type">int</span> count; <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; count = c; &#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span> &#123; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> count)</span> &#123; System.out.println(count); &#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    Model m; View v;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123; m.setCount(m.count + <span class="number">1</span>); v.show(m.count); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>MVP</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">View</span> &#123; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> count)</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123; <span class="type">int</span> count; <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; count = c; &#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Presenter</span> &#123; Model m; View v; <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123; m.setCount(m.count + <span class="number">1</span>); v.show(m.count); &#125; &#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>MVVM</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123; <span class="type">int</span> count; <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; count = c; &#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    Model m; Consumer&lt;Integer&gt; observer;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> v)</span> &#123; m.setCount(v); observer.accept(v); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span> &#123; ViewModel vm; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> &#123; vm.observer = <span class="built_in">this</span>::show; &#125; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> v)</span> &#123; System.out.println(v); &#125; &#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<hr />
<h4 id="总结-28">总结</h4>
<ul>
<li><strong>MVC</strong>：适合传统应用，视图与模型直接交互。</li>
<li><strong>MVP</strong>：增强解耦，Presenter 主动控制，利于测试。</li>
<li><strong>MVVM</strong>：依赖数据绑定，视图最被动，适合现代 UI
框架。</li>
</ul>
<p>如果需要更具体示例或调整表格内容，请告诉我！</p>
<h3 id="仓储模式repository-pattern"><strong>仓储模式（Repository
Pattern）</strong></h3>
<p>仓储模式（Repository
Pattern）是一种设计模式，广泛用于数据访问层，旨在将数据访问逻辑从业务逻辑中分离出来。它通过提供一个类似集合的接口来操作数据，隐藏底层数据存储的实现细节（如数据库、文件系统），从而解耦应用程序与数据源。</p>
<p>以下是用 Java
实现仓储模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="仓储模式的定义">1. 仓储模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过仓储对象提供对数据的统一访问接口，封装数据操作逻辑。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦业务逻辑与数据访问。</li>
<li>提供一致的数据操作方式。</li>
<li>便于测试和替换数据源。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>需要隔离数据库操作。</li>
<li>数据源可能切换（如从 SQL 到 NoSQL）。</li>
<li>单元测试需要 mock 数据访问。</li>
</ul></li>
</ul>
<hr />
<h4 id="仓储模式的结构">2. 仓储模式的结构</h4>
<ul>
<li><strong>领域模型（Domain
Model）</strong>：表示业务实体的数据结构。</li>
<li><strong>仓储接口（Repository
Interface）</strong>：定义数据操作的抽象方法。</li>
<li><strong>具体仓储（Concrete
Repository）</strong>：实现仓储接口，封装数据访问逻辑。</li>
<li><strong>数据存储（Data
Store）</strong>：底层数据源（如数据库、文件）。</li>
<li><strong>客户端（Client）</strong>：使用仓储访问数据。</li>
</ul>
<h5 id="mermaid-uml-图-22">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class DomainModel &#123;
        -id: int
        -name: String
    &#125;
    class Repository &#123;
        &lt;&lt;interface&gt;&gt;
        +add(entity: DomainModel)
        +findById(id: int) DomainModel
        +remove(id: int)
    &#125;
    class ConcreteRepository &#123;
        -dataStore: DataStore
        +add(entity: DomainModel)
        +findById(id: int) DomainModel
        +remove(id: int)
    &#125;
    class DataStore &#123;
        +save(entity)
        +load(id)
        +delete(id)
    &#125;
    class Client
    
    ConcreteRepository ..|&gt; Repository : implements
    ConcreteRepository --&gt; DataStore : uses
    Client --&gt; Repository : uses</code></pre>
<hr />
<h4 id="java-实现示例-27">3. Java 实现示例</h4>
<p>以下是一个简单的用户管理的仓储模式示例，使用内存存储模拟数据源。</p>
<h5 id="领域模型">3.1 领域模型</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 领域模型：用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;User&#123;id=&quot;</span> + id + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&#125;&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="仓储接口">3.2 仓储接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仓储接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span>;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体仓储">3.3 具体仓储</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体仓储：内存实现的仓储</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InMemoryUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, User&gt; store = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        store.put(user.getId(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> store.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        store.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-28">3.4 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserRepository</span> <span class="variable">repository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserRepository</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        repository.add(user1);</span><br><span class="line">        repository.add(user2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">found</span> <span class="operator">=</span> repository.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Found: &quot;</span> + found);  <span class="comment">// 输出: Found: User&#123;id=1, name=&#x27;Alice&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除用户</span></span><br><span class="line">        repository.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After removal, find Bob: &quot;</span> + repository.findById(<span class="number">2</span>));  <span class="comment">// 输出: After removal, find Bob: null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="扩展数据库仓储">3.5 扩展：数据库仓储</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体仓储：数据库实现的仓储（伪代码）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataStore database;  <span class="comment">// 模拟数据库连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DatabaseUserRepository</span><span class="params">(DataStore database)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.database = database;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        database.save(user);  <span class="comment">// 假设 save 是数据库操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (User) database.load(id);  <span class="comment">// 假设 load 从数据库读取</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        database.delete(id);  <span class="comment">// 假设 delete 是数据库删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-28">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>通过仓储接口（<code>UserRepository</code>）操作数据。</li>
<li>具体仓储（如
<code>InMemoryUserRepository</code>）实现接口，封装数据访问逻辑。</li>
<li>底层数据存储（如内存或数据库）执行实际操作。</li>
</ol>
<hr />
<h4 id="优点-28">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：业务逻辑不依赖具体数据源。</li>
<li><strong>可测试性</strong>：易于 mock 仓储进行测试。</li>
<li><strong>一致性</strong>：提供类似集合的统一接口。</li>
</ul>
<hr />
<h4 id="缺点-28">6. 缺点</h4>
<ul>
<li><strong>额外层</strong>：增加抽象层，可能提高复杂度。</li>
<li><strong>实现成本</strong>：每个实体需定义仓储接口和实现。</li>
<li><strong>性能</strong>：抽象可能掩盖底层优化。</li>
</ul>
<hr />
<h4 id="与-dao-模式的对比">7. 与 DAO 模式的对比</h4>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 40%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>仓储模式</th>
<th>DAO 模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>目的</strong></td>
<td>封装数据访问，提供集合接口</td>
<td>数据访问对象，直接操作数据</td>
</tr>
<tr class="even">
<td><strong>抽象级别</strong></td>
<td>更高（业务导向）</td>
<td>较低（数据导向）</td>
</tr>
<tr class="odd">
<td><strong>接口风格</strong></td>
<td>类似集合（如 add、find）</td>
<td>数据库操作（如 CRUD）</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-28">8. 实际应用场景</h4>
<ul>
<li><strong>Spring Data</strong>：JPA 仓储接口。</li>
<li><strong>DDD（领域驱动设计）</strong>：仓储管理聚合根。</li>
<li><strong>测试</strong>：mock 数据访问层。</li>
</ul>
<hr />
<h4 id="源码中的例子spring-data">9. 源码中的例子（Spring Data）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Integer&gt; &#123;</span><br><span class="line">    <span class="comment">// 自动实现 CRUD 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>说明</strong>：Spring Data 提供仓储接口，自动生成实现。</li>
</ul>
<hr />
<h4 id="总结-29">10. 总结</h4>
<ul>
<li><strong>仓储模式</strong>通过接口封装数据访问，解耦业务与存储。</li>
<li><strong>Java 实现</strong>支持内存、数据库等多种存储方式。</li>
<li><strong>UML 图</strong>展示了仓储与数据源的关系。</li>
</ul>
<p>如果需要更复杂示例（如带查询方法）或调整 UML，请告诉我！</p>
<h3 id="服务定位器service-locator"><strong>服务定位器（Service
Locator）</strong></h3>
<p>服务定位器模式（Service Locator
Pattern）是一种设计模式，用于通过一个中央服务定位器（Service
Locator）来查找和获取服务或依赖，而不是直接在客户端中硬编码或手动创建。它是一种替代依赖注入（Dependency
Injection）的服务获取方式，旨在解耦客户端与具体服务的实现。</p>
<p>以下是用 Java
实现服务定位器模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="服务定位器模式的定义">1. 服务定位器模式的定义</h4>
<ul>
<li><strong>核心思想</strong>：通过服务定位器集中管理和提供服务实例，客户端只需知道服务接口和定位器。</li>
<li><strong>目的</strong>：
<ul>
<li>解耦客户端与服务实现。</li>
<li>提供统一的服务查找方式。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>服务实例创建复杂或需要缓存。</li>
<li>客户端需动态获取服务。</li>
<li>不想使用依赖注入框架。</li>
</ul></li>
</ul>
<hr />
<h4 id="服务定位器模式的结构">2. 服务定位器模式的结构</h4>
<ul>
<li><strong>服务接口（Service
Interface）</strong>：定义服务的契约。</li>
<li><strong>具体服务（Concrete Service）</strong>：实现服务接口。</li>
<li><strong>服务定位器（Service
Locator）</strong>：管理服务实例，提供查找方法。</li>
<li><strong>客户端（Client）</strong>：通过定位器获取服务并使用。</li>
</ul>
<h5 id="mermaid-uml-图-23">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Service &#123;
        &lt;&lt;interface&gt;&gt;
        +doSomething()
    &#125;
    class ConcreteServiceA &#123;
        +doSomething()
    &#125;
    class ConcreteServiceB &#123;
        +doSomething()
    &#125;
    class ServiceLocator &#123;
        -services: Map&lt;String, Service&gt;
        +getService(name: String) Service
    &#125;
    class Client
    
    ConcreteServiceA ..|&gt; Service : implements
    ConcreteServiceB ..|&gt; Service : implements
    ServiceLocator --&gt; Service : provides
    Client --&gt; ServiceLocator : uses
    Client --&gt; Service : uses</code></pre>
<hr />
<h4 id="java-实现示例-28">3. Java 实现示例</h4>
<p>以下是一个日志服务的服务定位器示例，客户端通过定位器获取不同日志服务。</p>
<h5 id="服务接口-1">3.1 服务接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体服务-1">3.2 具体服务</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体服务：控制台日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Console: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体服务：文件日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;File: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="服务定位器">3.3 服务定位器</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务定位器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceLocator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Logger&gt; services = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        services.put(<span class="string">&quot;console&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConsoleLogger</span>());</span><br><span class="line">        services.put(<span class="string">&quot;file&quot;</span>, <span class="keyword">new</span> <span class="title class_">FileLogger</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">getLogger</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> services.get(name);</span><br><span class="line">        <span class="keyword">if</span> (logger == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No logger found for: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-29">3.4 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取控制台日志服务</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">consoleLogger</span> <span class="operator">=</span> ServiceLocator.getLogger(<span class="string">&quot;console&quot;</span>);</span><br><span class="line">        consoleLogger.log(<span class="string">&quot;Hello from console&quot;</span>);  <span class="comment">// 输出: Console: Hello from console</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件日志服务</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">fileLogger</span> <span class="operator">=</span> ServiceLocator.getLogger(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">        fileLogger.log(<span class="string">&quot;Hello from file&quot;</span>);  <span class="comment">// 输出: File: Hello from file</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-29">4. 工作原理</h4>
<ol type="1">
<li><strong>服务定位器</strong>初始化时注册服务实例（静态或动态）。</li>
<li><strong>客户端</strong>通过定位器请求服务（<code>getLogger</code>），只需提供服务标识。</li>
<li>定位器返回服务实例，客户端调用服务方法。</li>
</ol>
<hr />
<h4 id="优点-29">5. 优点</h4>
<ul>
<li><strong>解耦</strong>：客户端不直接依赖服务实现。</li>
<li><strong>集中管理</strong>：服务实例在定位器中统一配置。</li>
<li><strong>简单性</strong>：无需复杂框架即可实现。</li>
</ul>
<hr />
<h4 id="缺点-29">6. 缺点</h4>
<ul>
<li><strong>隐式依赖</strong>：客户端依赖定位器，依赖关系不显式。</li>
<li><strong>全局状态</strong>：静态定位器可能导致单例问题。</li>
<li><strong>测试性差</strong>：相比依赖注入，难以 mock 服务。</li>
</ul>
<hr />
<h4 id="与依赖注入的对比">7. 与依赖注入的对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>服务定位器模式</th>
<th>依赖注入模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>依赖获取</strong></td>
<td>客户端主动请求</td>
<td>外部注入</td>
</tr>
<tr class="even">
<td><strong>控制权</strong></td>
<td>客户端控制</td>
<td>注入器控制</td>
</tr>
<tr class="odd">
<td><strong>耦合</strong></td>
<td>依赖定位器</td>
<td>依赖接口</td>
</tr>
<tr class="even">
<td><strong>测试性</strong></td>
<td>较差（需 mock 定位器）</td>
<td>较高（易 mock 依赖）</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-29">8. 实际应用场景</h4>
<ul>
<li><strong>JNDI</strong>：Java 的命名和目录接口。</li>
<li><strong>日志框架</strong>：如 SLF4J 的
<code>LoggerFactory</code>。</li>
<li><strong>遗留系统</strong>：集中管理服务实例。</li>
</ul>
<hr />
<h4 id="源码中的例子-26">9. 源码中的例子</h4>
<p>Java 中的 <code>javax.naming.InitialContext</code>（JNDI）：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">service</span> <span class="operator">=</span> context.lookup(<span class="string">&quot;java:comp/env/myService&quot;</span>);  <span class="comment">// 服务定位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-30">10. 总结</h4>
<ul>
<li><strong>服务定位器模式</strong>通过集中定位器提供服务访问，解耦客户端与实现。</li>
<li><strong>Java 实现</strong>依赖静态或动态注册，简单但隐式。</li>
<li><strong>UML 图</strong>展示了定位器与服务的关系。</li>
</ul>
<p>如果需要动态注册示例或调整 UML，请告诉我！</p>
<h3 id="事件溯源event-sourcing"><strong>事件溯源（Event
Sourcing）</strong></h3>
<p>事件溯源（Event
Sourcing）是一种架构模式，主要用于数据存储和状态管理。它不同于传统的
CRUD（创建、读取、更新、删除）方式，而是通过记录系统中发生的所有事件（Event）来构建和追踪应用程序状态。事件溯源的核心思想是将状态变化作为事件序列存储，而不是直接存储当前状态。</p>
<p>以下是用 Java
实现事件溯源模式的详细讲解，包括定义、结构、代码示例及其优缺点。</p>
<hr />
<h4 id="事件溯源的定义">1. 事件溯源的定义</h4>
<ul>
<li><strong>核心思想</strong>：将应用程序的状态变化记录为一系列不可变的事件，通过回放事件重建当前状态。</li>
<li><strong>目的</strong>：
<ul>
<li>提供完整的历史记录。</li>
<li>支持状态重建和审计。</li>
<li>增强系统的可扩展性和一致性。</li>
</ul></li>
<li><strong>适用场景</strong>：
<ul>
<li>需要审计或回溯（如金融系统）。</li>
<li>事件驱动架构（EDA）。</li>
<li>分布式系统（如微服务）。</li>
</ul></li>
</ul>
<hr />
<h4 id="事件溯源的结构">2. 事件溯源的结构</h4>
<ul>
<li><strong>事件（Event）</strong>：表示状态变化的不可变记录。</li>
<li><strong>事件存储（Event
Store）</strong>：持久化事件序列的存储。</li>
<li><strong>聚合（Aggregate）</strong>：业务实体，应用事件重建状态。</li>
<li><strong>事件处理器（Event
Handler）</strong>：处理事件并更新聚合状态。</li>
<li><strong>客户端（Client）</strong>：触发事件并查询状态。</li>
</ul>
<h5 id="mermaid-uml-图-24">Mermaid UML 图</h5>
<pre><code class="highlight mermaid">classDiagram
    class Event &#123;
        -id: String
        -type: String
        -data: Object
        +getId() String
        +getType() String
        +getData() Object
    &#125;
    class EventStore &#123;
        +append(event: Event)
        +getEvents(aggregateId: String) List&lt;Event&gt;
    &#125;
    class Aggregate &#123;
        -id: String
        -state: State
        +apply(Event)
        +getState() State
    &#125;
    class EventHandler &#123;
        +handle(Event, Aggregate)
    &#125;
    class Client
    
    EventStore --&gt; Event : stores
    Aggregate --&gt; Event : applies
    EventHandler --&gt; Event : processes
    EventHandler --&gt; Aggregate : updates
    Client --&gt; EventStore : saves to
    Client --&gt; Aggregate : queries</code></pre>
<hr />
<h4 id="java-实现示例-29">3. Java 实现示例</h4>
<p>以下是一个银行账户的事件溯源示例，记录存款和取款事件。</p>
<h5 id="事件类">3.1 事件类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AccountEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String accountId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountEvent</span><span class="params">(String accountId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountId = accountId;</span><br><span class="line">        <span class="built_in">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccountId</span><span class="params">()</span> &#123; <span class="keyword">return</span> accountId; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimestamp</span><span class="params">()</span> &#123; <span class="keyword">return</span> timestamp; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件：存款</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DepositEvent</span> <span class="keyword">extends</span> <span class="title class_">AccountEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepositEvent</span><span class="params">(String accountId, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(accountId);</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAmount</span><span class="params">()</span> &#123; <span class="keyword">return</span> amount; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件：取款</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithdrawalEvent</span> <span class="keyword">extends</span> <span class="title class_">AccountEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WithdrawalEvent</span><span class="params">(String accountId, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(accountId);</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAmount</span><span class="params">()</span> &#123; <span class="keyword">return</span> amount; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="事件存储">3.2 事件存储</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件存储（内存实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;AccountEvent&gt;&gt; events = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(AccountEvent event)</span> &#123;</span><br><span class="line">        events.computeIfAbsent(event.getAccountId(), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;AccountEvent&gt; <span class="title function_">getEvents</span><span class="params">(String accountId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> events.getOrDefault(accountId, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="聚合">3.3 聚合</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 聚合：银行账户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(AccountEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> DepositEvent) &#123;</span><br><span class="line">            balance += ((DepositEvent) event).getAmount();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> WithdrawalEvent) &#123;</span><br><span class="line">            balance -= ((WithdrawalEvent) event).getAmount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123; <span class="keyword">return</span> balance; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重建状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Account <span class="title function_">rebuild</span><span class="params">(String id, List&lt;AccountEvent&gt; events)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(id);</span><br><span class="line">        <span class="keyword">for</span> (AccountEvent event : events) &#123;</span><br><span class="line">            account.apply(event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码-30">3.4 客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventStore</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventStore</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">accountId</span> <span class="operator">=</span> <span class="string">&quot;acc1&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录事件</span></span><br><span class="line">        store.append(<span class="keyword">new</span> <span class="title class_">DepositEvent</span>(accountId, <span class="number">100.0</span>));</span><br><span class="line">        store.append(<span class="keyword">new</span> <span class="title class_">DepositEvent</span>(accountId, <span class="number">50.0</span>));</span><br><span class="line">        store.append(<span class="keyword">new</span> <span class="title class_">WithdrawalEvent</span>(accountId, <span class="number">30.0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重建账户状态</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> Account.rebuild(accountId, store.getEvents(accountId));</span><br><span class="line">        System.out.println(<span class="string">&quot;Account balance: &quot;</span> + account.getBalance());  <span class="comment">// 输出: Account balance: 120.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="工作原理-30">4. 工作原理</h4>
<ol type="1">
<li><strong>客户端</strong>触发事件（如存款），存储到事件存储。</li>
<li>事件存储保存不可变的事件序列。</li>
<li>需要状态时，聚合通过回放事件（<code>apply</code>）重建当前状态。</li>
</ol>
<hr />
<h4 id="优点-30">5. 优点</h4>
<ul>
<li><strong>审计性</strong>：完整事件历史，便于追踪和调试。</li>
<li><strong>灵活性</strong>：可重建任意历史状态。</li>
<li><strong>一致性</strong>：事件序列保证数据完整性。</li>
</ul>
<hr />
<h4 id="缺点-30">6. 缺点</h4>
<ul>
<li><strong>存储开销</strong>：事件量大时占用空间多。</li>
<li><strong>性能</strong>：状态重建需回放所有事件，效率低。</li>
<li><strong>复杂性</strong>：实现和维护较复杂。</li>
</ul>
<hr />
<h4 id="与传统状态存储对比">7. 与传统状态存储对比</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>事件溯源</th>
<th>传统状态存储</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>存储内容</strong></td>
<td>事件序列</td>
<td>当前状态</td>
</tr>
<tr class="even">
<td><strong>状态获取</strong></td>
<td>回放事件重建</td>
<td>直接读取</td>
</tr>
<tr class="odd">
<td><strong>历史记录</strong></td>
<td>完整</td>
<td>需额外实现</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="实际应用场景-30">8. 实际应用场景</h4>
<ul>
<li><strong>银行系统</strong>：记录交易历史。</li>
<li><strong>电商</strong>：订单状态追踪。</li>
<li><strong>CQRS</strong>：与命令查询职责分离结合。</li>
</ul>
<hr />
<h4 id="源码中的例子-27">9. 源码中的例子</h4>
<p>Java 中无直接内置实现，但类似概念见于日志框架： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似事件日志的记录</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;app&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;Deposit: 100&quot;</span>);  <span class="comment">// 事件记录</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-31">10. 总结</h4>
<ul>
<li><strong>事件溯源</strong>通过事件序列管理状态，支持审计和重建。</li>
<li><strong>Java 实现</strong>依赖事件类和存储，回放重建聚合。</li>
<li><strong>UML 图</strong>展示了事件与聚合的关系。</li>
</ul>
<p>如果需要更复杂示例（如快照优化）或调整 UML，请告诉我！</p>
]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
  </entry>
  <entry>
    <title>Android 示例：YUV 转 RGB</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/Android-%E7%A4%BA%E4%BE%8B%EF%BC%9AYUV-%E8%BD%AC-RGB.html</url>
    <content><![CDATA[<p>这个示例实现了一个简单的 OpenGL ES 2.0 渲染器，用于将 YUV420P
格式的图像帧转换为 RGB 并显示在屏幕上。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cmder.yuvgl</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.opengl.GLES20</span><br><span class="line"><span class="keyword">import</span> android.opengl.GLSurfaceView</span><br><span class="line"><span class="keyword">import</span> android.opengl.Matrix</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder</span><br><span class="line"><span class="keyword">import</span> java.nio.FloatBuffer</span><br><span class="line"><span class="keyword">import</span> javax.microedition.khronos.egl.EGLConfig</span><br><span class="line"><span class="keyword">import</span> javax.microedition.khronos.opengles.GL10</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YuvToRgbRenderer</span>(<span class="keyword">private</span> <span class="keyword">val</span> context: Context) : GLSurfaceView.Renderer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vertex shader source code (GLSL)</span></span><br><span class="line">    <span class="comment">// 顶点着色器处理全屏四边形的顶点坐标（aPosition）和纹理坐标（aTexCoord），通过uMVPMatrix变换顶点位置，传递纹理坐标给片段着色器。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> vertexShaderCode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        attribute vec4 aPosition;</span></span><br><span class="line"><span class="string">        attribute vec2 aTexCoord;</span></span><br><span class="line"><span class="string">        varying vec2 vTexCoord;</span></span><br><span class="line"><span class="string">        uniform mat4 uMVPMatrix;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        void main() &#123;</span></span><br><span class="line"><span class="string">            gl_Position = uMVPMatrix * aPosition;</span></span><br><span class="line"><span class="string">            vTexCoord = aTexCoord;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fragment shader source code (GLSL) for YUV420P to RGB conversion</span></span><br><span class="line">    <span class="comment">// Assumes three separate textures: Y (luminance), U (chroma blue), V (chroma red)</span></span><br><span class="line">    <span class="comment">// For other formats like NV21, adjust the sampling accordingly (e.g., VU interleaved).</span></span><br><span class="line">    <span class="comment">// 片段着色器从Y、U、V纹理中采样数据，应用BT.601标准矩阵将YUV转换为RGB颜色值，输出到gl_FragColor。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fragmentShaderCode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        precision mediump float;</span></span><br><span class="line"><span class="string">        varying vec2 vTexCoord;</span></span><br><span class="line"><span class="string">        uniform sampler2D yTexture;</span></span><br><span class="line"><span class="string">        uniform sampler2D uTexture;</span></span><br><span class="line"><span class="string">        uniform sampler2D vTexture;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        void main() &#123;</span></span><br><span class="line"><span class="string">            float y = texture2D(yTexture, vTexCoord).r;</span></span><br><span class="line"><span class="string">            float u = texture2D(uTexture, vTexCoord).r - 0.5;</span></span><br><span class="line"><span class="string">            float v = texture2D(vTexture, vTexCoord).r - 0.5;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            // YUV to RGB conversion matrix (BT.601 standard)</span></span><br><span class="line"><span class="string">            float r = y + 1.402 * v;</span></span><br><span class="line"><span class="string">            float g = y - 0.344136 * u - 0.714136 * v;</span></span><br><span class="line"><span class="string">            float b = y + 1.772 * u;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            gl_FragColor = vec4(r, g, b, 1.0);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Program handle</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> program: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handles for attributes and uniforms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> positionHandle: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> texCoordHandle: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mvpMatrixHandle: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> yTextureHandle: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> uTextureHandle: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> vTextureHandle: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Texture IDs</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> yTextureId: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> uTextureId: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> vTextureId: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MVP matrix</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mvpMatrix = FloatArray(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vertex data: positions and texture coordinates for a full-screen quad</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> vertexData = floatArrayOf(</span><br><span class="line">        -<span class="number">1f</span>, -<span class="number">1f</span>, <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">1f</span>,  <span class="comment">// Bottom-left</span></span><br><span class="line">        <span class="number">1f</span>, -<span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>, <span class="number">1f</span>,   <span class="comment">// Bottom-right</span></span><br><span class="line">        -<span class="number">1f</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">0f</span>,   <span class="comment">// Top-left</span></span><br><span class="line">        <span class="number">1f</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>, <span class="number">0f</span>     <span class="comment">// Top-right</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> vertexBuffer: FloatBuffer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Example YUV data dimensions (adjust based on your input)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> width: <span class="built_in">Int</span> = <span class="number">640</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> height: <span class="built_in">Int</span> = <span class="number">480</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Example YUV buffers (in real use, fill these from Camera or Video source)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> yBuffer: ByteBuffer</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> uBuffer: ByteBuffer</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> vBuffer: ByteBuffer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceCreated</span><span class="params">(gl: <span class="type">GL10</span>?, config: <span class="type">EGLConfig</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Compile and link shaders</span></span><br><span class="line">        <span class="comment">// 编译并链接顶点和片段着色器，创建OpenGL程序。</span></span><br><span class="line">        <span class="keyword">val</span> vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode)</span><br><span class="line">        <span class="keyword">val</span> fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderCode)</span><br><span class="line">        program = GLES20.glCreateProgram()</span><br><span class="line">        GLES20.glAttachShader(program, vertexShader)</span><br><span class="line">        GLES20.glAttachShader(program, fragmentShader)</span><br><span class="line">        GLES20.glLinkProgram(program)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get handles</span></span><br><span class="line">        <span class="comment">// 获取着色器中的属性和统一变量句柄（如aPosition、yTexture等）。</span></span><br><span class="line">        positionHandle = GLES20.glGetAttribLocation(program, <span class="string">&quot;aPosition&quot;</span>)</span><br><span class="line">        texCoordHandle = GLES20.glGetAttribLocation(program, <span class="string">&quot;aTexCoord&quot;</span>)</span><br><span class="line">        mvpMatrixHandle = GLES20.glGetUniformLocation(program, <span class="string">&quot;uMVPMatrix&quot;</span>)</span><br><span class="line">        yTextureHandle = GLES20.glGetUniformLocation(program, <span class="string">&quot;yTexture&quot;</span>)</span><br><span class="line">        uTextureHandle = GLES20.glGetUniformLocation(program, <span class="string">&quot;uTexture&quot;</span>)</span><br><span class="line">        vTextureHandle = GLES20.glGetUniformLocation(program, <span class="string">&quot;vTexture&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize vertex buffer</span></span><br><span class="line">        <span class="comment">// 初始化顶点缓冲区，定义一个全屏四边形（2个三角形组成）。</span></span><br><span class="line">        vertexBuffer = ByteBuffer.allocateDirect(vertexData.size * <span class="number">4</span>)</span><br><span class="line">            .order(ByteOrder.nativeOrder())</span><br><span class="line">            .asFloatBuffer()</span><br><span class="line">            .put(vertexData)</span><br><span class="line">            .apply &#123; position(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create textures</span></span><br><span class="line">        <span class="comment">// 创建三个纹理（Y、U、V），分别绑定到GL_TEXTURE0、GL_TEXTURE1、GL_TEXTURE2。</span></span><br><span class="line">        <span class="keyword">val</span> textureIds = IntArray(<span class="number">3</span>)</span><br><span class="line">        GLES20.glGenTextures(<span class="number">3</span>, textureIds, <span class="number">0</span>)</span><br><span class="line">        yTextureId = textureIds[<span class="number">0</span>]</span><br><span class="line">        uTextureId = textureIds[<span class="number">1</span>]</span><br><span class="line">        vTextureId = textureIds[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bind and set textures (initially empty, update in draw)</span></span><br><span class="line">        bindTexture(yTextureId, GLES20.GL_TEXTURE0)</span><br><span class="line">        bindTexture(uTextureId, GLES20.GL_TEXTURE1)</span><br><span class="line">        bindTexture(vTextureId, GLES20.GL_TEXTURE2)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize example YUV buffers (in real app, update these dynamically)</span></span><br><span class="line">        initializeYuvBuffers()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set orthographic projection</span></span><br><span class="line">        <span class="comment">// 设置单位矩阵作为MVP变换。</span></span><br><span class="line">        Matrix.setIdentityM(mvpMatrix, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceChanged</span><span class="params">(gl: <span class="type">GL10</span>?, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 根据屏幕尺寸设置OpenGL视口，确保渲染区域匹配屏幕。</span></span><br><span class="line">        GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDrawFrame</span><span class="params">(gl: <span class="type">GL10</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 清空屏幕，激活着色器程序。</span></span><br><span class="line">        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)</span><br><span class="line">        GLES20.glUseProgram(program)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update textures with YUV data</span></span><br><span class="line">        updateTextures()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set uniforms</span></span><br><span class="line">        <span class="comment">// 设置统一变量（MVP矩阵和纹理单元）。</span></span><br><span class="line">        GLES20.glUniformMatrix4fv(mvpMatrixHandle, <span class="number">1</span>, <span class="literal">false</span>, mvpMatrix, <span class="number">0</span>)</span><br><span class="line">        GLES20.glUniform1i(yTextureHandle, <span class="number">0</span>)</span><br><span class="line">        GLES20.glUniform1i(uTextureHandle, <span class="number">1</span>)</span><br><span class="line">        GLES20.glUniform1i(vTextureHandle, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enable attributes</span></span><br><span class="line">        <span class="comment">// 绑定顶点和纹理坐标数据，绘制四边形（GL_TRIANGLE_STRIP）。</span></span><br><span class="line">        <span class="keyword">val</span> stride = <span class="number">5</span> * <span class="number">4</span>  <span class="comment">// 5 floats per vertex * 4 bytes</span></span><br><span class="line">        vertexBuffer.position(<span class="number">0</span>)</span><br><span class="line">        GLES20.glVertexAttribPointer(</span><br><span class="line">            positionHandle,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            GLES20.GL_FLOAT,</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            stride,</span><br><span class="line">            vertexBuffer</span><br><span class="line">        )</span><br><span class="line">        GLES20.glEnableVertexAttribArray(positionHandle)</span><br><span class="line"></span><br><span class="line">        vertexBuffer.position(<span class="number">3</span>)</span><br><span class="line">        GLES20.glVertexAttribPointer(</span><br><span class="line">            texCoordHandle,</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            GLES20.GL_FLOAT,</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            stride,</span><br><span class="line">            vertexBuffer</span><br><span class="line">        )</span><br><span class="line">        GLES20.glEnableVertexAttribArray(texCoordHandle)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw quad</span></span><br><span class="line">        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Disable attributes</span></span><br><span class="line">        <span class="comment">// 禁用顶点属性，完成一帧渲染。</span></span><br><span class="line">        GLES20.glDisableVertexAttribArray(positionHandle)</span><br><span class="line">        GLES20.glDisableVertexAttribArray(texCoordHandle)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译GLSL着色器代码。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadShader</span><span class="params">(type: <span class="type">Int</span>, shaderCode: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> shader = GLES20.glCreateShader(type)</span><br><span class="line">        GLES20.glShaderSource(shader, shaderCode)</span><br><span class="line">        GLES20.glCompileShader(shader)</span><br><span class="line">        <span class="keyword">return</span> shader</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置纹理参数（如线性过滤和边缘处理）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindTexture</span><span class="params">(textureId: <span class="type">Int</span>, unit: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        GLES20.glActiveTexture(unit)</span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId)</span><br><span class="line">        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)</span><br><span class="line">        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)</span><br><span class="line">        GLES20.glTexParameteri(</span><br><span class="line">            GLES20.GL_TEXTURE_2D,</span><br><span class="line">            GLES20.GL_TEXTURE_WRAP_S,</span><br><span class="line">            GLES20.GL_CLAMP_TO_EDGE</span><br><span class="line">        )</span><br><span class="line">        GLES20.glTexParameteri(</span><br><span class="line">            GLES20.GL_TEXTURE_2D,</span><br><span class="line">            GLES20.GL_TEXTURE_WRAP_T,</span><br><span class="line">            GLES20.GL_CLAMP_TO_EDGE</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建测试用的YUV数据缓冲区。</span></span><br><span class="line"><span class="comment">     * 初始化YUV缓冲区，填充测试用的灰色数据（Y=128, U=128, V=128）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initializeYuvBuffers</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Example: Allocate buffers (in real use, get from CameraPreview or MediaCodec)</span></span><br><span class="line">        yBuffer = ByteBuffer.allocateDirect(width * height)</span><br><span class="line">        uBuffer = ByteBuffer.allocateDirect(width * height / <span class="number">4</span>)</span><br><span class="line">        vBuffer = ByteBuffer.allocateDirect(width * height / <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fill with dummy data for testing (e.g., gray image)</span></span><br><span class="line">        yBuffer.put(ByteArray(width * height) &#123; <span class="number">128.</span>toByte() &#125;)</span><br><span class="line">        uBuffer.put(ByteArray(width * height / <span class="number">4</span>) &#123; <span class="number">128.</span>toByte() &#125;)</span><br><span class="line">        vBuffer.put(ByteArray(width * height / <span class="number">4</span>) &#123; <span class="number">128.</span>toByte() &#125;)</span><br><span class="line">        yBuffer.position(<span class="number">0</span>)</span><br><span class="line">        uBuffer.position(<span class="number">0</span>)</span><br><span class="line">        vBuffer.position(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将YUV数据上传到纹理（Y全尺寸，U/V半尺寸）。</span></span><br><span class="line"><span class="comment">     * 更新Y、U、V纹理数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateTextures</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Update Y texture</span></span><br><span class="line">        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)</span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yTextureId)</span><br><span class="line">        GLES20.glTexImage2D(</span><br><span class="line">            GLES20.GL_TEXTURE_2D,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            GLES20.GL_LUMINANCE,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            GLES20.GL_LUMINANCE,</span><br><span class="line">            GLES20.GL_UNSIGNED_BYTE,</span><br><span class="line">            yBuffer</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update U texture (half size)</span></span><br><span class="line">        GLES20.glActiveTexture(GLES20.GL_TEXTURE1)</span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, uTextureId)</span><br><span class="line">        GLES20.glTexImage2D(</span><br><span class="line">            GLES20.GL_TEXTURE_2D,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            GLES20.GL_LUMINANCE,</span><br><span class="line">            width / <span class="number">2</span>,</span><br><span class="line">            height / <span class="number">2</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            GLES20.GL_LUMINANCE,</span><br><span class="line">            GLES20.GL_UNSIGNED_BYTE,</span><br><span class="line">            uBuffer</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update V texture (half size)</span></span><br><span class="line">        GLES20.glActiveTexture(GLES20.GL_TEXTURE2)</span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, vTextureId)</span><br><span class="line">        GLES20.glTexImage2D(</span><br><span class="line">            GLES20.GL_TEXTURE_2D,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            GLES20.GL_LUMINANCE,</span><br><span class="line">            width / <span class="number">2</span>,</span><br><span class="line">            height / <span class="number">2</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            GLES20.GL_LUMINANCE,</span><br><span class="line">            GLES20.GL_UNSIGNED_BYTE,</span><br><span class="line">            vBuffer</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In real app, call this to update YUV data from external source</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许外部更新YUV数据和尺寸（实际应用中从相机或视频解码器获取）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateYuvData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        newY: <span class="type">ByteArray</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        newU: <span class="type">ByteArray</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        newV: <span class="type">ByteArray</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        newWidth: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        newHeight: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        width = newWidth</span><br><span class="line">        height = newHeight</span><br><span class="line">        yBuffer = ByteBuffer.wrap(newY)</span><br><span class="line">        uBuffer = ByteBuffer.wrap(newU)</span><br><span class="line">        vBuffer = ByteBuffer.wrap(newV)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目地址：https://github.com/cmder/Demos/tree/main/YUVGL</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>YUV 如何转 RGB</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/YUV-%E5%A6%82%E4%BD%95%E8%BD%AC-RGB.html</url>
    <content><![CDATA[<p>YUV和RGB是两种常见的颜色编码格式，主要用于图像和视频处理。</p>
<p>RGB（红绿蓝）是一种基于加色模型的颜色表示方法，广泛用于显示设备（如屏幕）和图像处理。它由R（Red，红色）、G（Green，绿色）、B（Blue，蓝色）三个通道组成。每个通道通常用8位表示（0-255），因此RGB图像每个像素需要24位（3字节）来存储全彩信息。例如，纯红色的像素值为(255,
0, 0)，白色为(255, 255, 255)。</p>
<p>RGB直接对应人眼感知的红、绿、蓝三原色，适合显示和渲染。每个像素存储三个分量，数据量较大，不适合视频压缩和传输。主要用于显示器、相机传感器、图像编辑软件等需要高保真的场景。</p>
<p>RGB
有两个变种。1.RGBA增加了Alpha通道，用于表示透明度。2.16位/通道或浮点格式用于高动态范围（HDR）图像。</p>
<p>YUV
是一种颜色编码方式，常见于视频压缩和传输（如MPEG、H.264）。它将颜色信息分为亮度（Y）和色度（U、V）两个部分。Y（Luma，亮度）表示图像的明暗信息（灰度值），不含颜色信息。Y值决定了图像的黑白效果。U（Cb，蓝色色度）表示蓝色分量与亮度的差值。V（Cr，红色色度）表示红色分量与亮度的差值。色度（U、V）结合亮度（Y）可以重建出完整的颜色信息。</p>
<p>人眼对亮度变化更敏感，对色度变化的感知较弱。因此，YUV允许对色度（U、V）进行亚采样（减少分辨率），从而显著降低数据量。亚采样常见有三种类型，<strong>4:4:4</strong>（YUV444）：每个像素都有完整的Y、U、V分量，数据量与RGB相当。<strong>4:2:2</strong>（YUV422）：每两个像素共享一组U、V值，色度数据减半，常用于高质量视频。<strong>4:2:0</strong>（YUV420）：每四个像素（2x2块）共享一组U、V值，色度数据只有1/4，常见于视频压缩（如H.264、JPEG），这种采样方式是最常用的，如
NV12 / NV21。通过亚采样，YUV格式显著减少数据量，适合视频编码和传输。</p>
<p>YUV
适用于视频编码和解码（如MPEG、H.264、H.265）、电视广播、流媒体、图像压缩格式（如JPEG）。</p>
<p><strong>YUV与RGB的比较</strong>：</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 38%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>RGB</th>
<th>YUV</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>颜色表示</strong></td>
<td>红、绿、蓝三原色</td>
<td>亮度（Y）+色度（U、V）</td>
</tr>
<tr class="even">
<td><strong>数据量</strong></td>
<td>较大（每个像素3字节）</td>
<td>可通过亚采样减少数据量（如4:2:0）</td>
</tr>
<tr class="odd">
<td><strong>人眼感知</strong></td>
<td>直接对应显示颜色</td>
<td>亮度优先，色度可压缩</td>
</tr>
<tr class="even">
<td><strong>应用场景</strong></td>
<td>显示、图像编辑</td>
<td>视频压缩、传输、广播</td>
</tr>
<tr class="odd">
<td><strong>转换复杂度</strong></td>
<td>直接使用，无需转换</td>
<td>需要与RGB相互转换</td>
</tr>
<tr class="even">
<td><strong>压缩效率</strong></td>
<td>较低</td>
<td>较高</td>
</tr>
</tbody>
</table>
<p>YUV 转 RGB 有多种标准（BT.601、BT.709）。下面用 BT.601 标准（SD
视频）：</p>
<p>假设 YUV 范围：</p>
<ul>
<li>Y ∈ [0, 255]</li>
<li>U ∈ [0, 255]</li>
<li>V ∈ [0, 255]</li>
</ul>
<p>转换公式：</p>
<p><span class="math inline">\(\begin{cases} R = Y + 1.402 \times (V -
128) \\ G = Y - 0.344136 \times (U - 128) - 0.714136 \times (V - 128) \\
B = Y + 1.772 \times (U - 128) \end{cases}\)</span></p>
<p>注意：</p>
<ul>
<li>转换后需要 <strong>截断</strong>，保证 R/G/B ∈ [0, 255]。</li>
<li>如果使用浮点计算，效果最好。整型近似也可，但会有误差。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">yuvToRgb</span><span class="params">(y: <span class="type">Int</span>, u: <span class="type">Int</span>, v: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c = y - <span class="number">16</span></span><br><span class="line">    <span class="keyword">val</span> d = u - <span class="number">128</span></span><br><span class="line">    <span class="keyword">val</span> e = v - <span class="number">128</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> r = (<span class="number">1.164</span> * c + <span class="number">1.596</span> * e).toInt()</span><br><span class="line">    <span class="keyword">var</span> g = (<span class="number">1.164</span> * c - <span class="number">0.392</span> * d - <span class="number">0.813</span> * e).toInt()</span><br><span class="line">    <span class="keyword">var</span> b = (<span class="number">1.164</span> * c + <span class="number">2.017</span> * d).toInt()</span><br><span class="line"></span><br><span class="line">    r = r.coerceIn(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    g = g.coerceIn(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    b = b.coerceIn(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0xFF</span> shl <span class="number">24</span>) or (r shl <span class="number">16</span>) or (g shl <span class="number">8</span>) or b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过预计算 YUV 到 RGB
的映射表，可以在转换时直接查表，避免重复计算。</p>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> yuvToRgbLut = Array(<span class="number">256</span>) &#123; Array(<span class="number">256</span>) &#123; Array(<span class="number">256</span>) &#123; <span class="number">0</span> &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">initYuvToRgbLut</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (y <span class="keyword">in</span> <span class="number">0.</span><span class="number">.255</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (u <span class="keyword">in</span> <span class="number">0.</span><span class="number">.255</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (v <span class="keyword">in</span> <span class="number">0.</span><span class="number">.255</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> r = (y + <span class="number">1.402</span> * (v - <span class="number">128</span>)).toInt().coerceIn(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">                <span class="keyword">val</span> g = (y - <span class="number">0.344136</span> * (u - <span class="number">128</span>) - <span class="number">0.714136</span> * (v - <span class="number">128</span>)).toInt().coerceIn(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">                <span class="keyword">val</span> b = (y + <span class="number">1.772</span> * (u - <span class="number">128</span>)).toInt().coerceIn(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">                yuvToRgbLut[y][u][v] = (<span class="number">0xFF</span> shl <span class="number">24</span>) or (r shl <span class="number">16</span>) or (g shl <span class="number">8</span>) or b</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用现代CPU的SIMD（Single Instruction, Multiple
Data，单指令多数据）指令集（如SSE、AVX、NEON）可以加速YUV到RGB的转换。每个像素的转换公式相同，适合SIMD的并行处理。图像数据通常是连续的像素数组，可以一次性加载多个像素到SIMD寄存器中。SIMD指令（如SSE处理128位，AVX处理256位）允许同时处理多个像素（例如，SSE一次处理4个像素的YUV值，AVX可处理8个）。SIMD指令集（如SSE、AVX、NEON）通过宽寄存器和专用指令（如加法、乘法、打包/解包）并行执行这些运算，从而显著提高性能。</p>
<p>YUV数据通常存储为连续的Y、U、V分量（例如，YUV420格式中Y是单独的平面，U和V是交错或分开的平面）。需要确保数据加载到SIMD寄存器时是内存对齐的（16字节对齐用于SSE，32字节对齐用于AVX），以避免性能损失。视频处理中，YUV数据通常是8位无符号整数（uint8_t），RGB输出也是8位。SIMD整数指令（如_mm_add_epi16、
_mm_madd_epi16）可以高效处理这些数据。如果需要更高的精度（如浮点系数），可以使用32位浮点SIMD指令（如_mm_mul_ps、
_mm_add_ps），但需要额外的类型转换。YUV的Y范围通常是16-235，U、V范围是16-240，需在转换前进行偏移校正（例如，Y
= Y - 16）。</p>
<p>将Y、U、V值加载到SIMD寄存器后，使用向量乘法和加法指令并行计算。例如
SSE
使用_mm_mul_ps进行系数乘法，_mm_add_ps进行加法。一次处理4个（SSE）或8个（AVX）像素的Y、U、V值，生成对应的R、G、B值。由于不同的亚采样的
Y、U、V
分量的比例不同，需要分别处理。4:4:4格式：每个像素都有独立的Y、U、V值，直接加载并处理。4:2:0格式：需要对U、V值进行插值或重复，如使用SIMD的广播指令（如_mm_set1_epi16）将单个U、V值复制到多个像素的寄存器中。对于高质量转换，可以使用SIMD指令实现双线性插值，平滑U、V值的过渡。</p>
<p>RGB值需限制在0-255范围内。SIMD提供饱和指令（如SSE的_mm_packus_epi16或NEON的vqmovn_u16）以防止溢出。使用对齐存储指令（如_mm_store_si128或_mm256_store_si256）将结果写回内存。</p>
<p>以下是一个简化的SSE实现，用于4:4:4
YUV到RGB的转换（假设输入是8位整数，输出也是8位）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span> <span class="comment">// SSE2</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">yuv_to_rgb_sse</span><span class="params">(<span class="type">uint8_t</span>* yuv, <span class="type">uint8_t</span>* rgb, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; width * height; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载4个像素的Y、U、V</span></span><br><span class="line">        __m128i y = _mm_loadu_si128((__m128i*)(yuv + i * <span class="number">3</span>)); <span class="comment">// Y0, Y1, Y2, Y3</span></span><br><span class="line">        __m128i u = _mm_loadu_si128((__m128i*)(yuv + i * <span class="number">3</span> + <span class="number">1</span>)); <span class="comment">// U0, U1, U2, U3</span></span><br><span class="line">        __m128i v = _mm_loadu_si128((__m128i*)(yuv + i * <span class="number">3</span> + <span class="number">2</span>)); <span class="comment">// V0, V1, V2, V3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偏移校正：Y -= 16, U -= 128, V -= 128</span></span><br><span class="line">        y = _mm_sub_epi16(y, _mm_set1_epi16(<span class="number">16</span>));</span><br><span class="line">        u = _mm_sub_epi16(u, _mm_set1_epi16(<span class="number">128</span>));</span><br><span class="line">        v = _mm_sub_epi16(v, _mm_set1_epi16(<span class="number">128</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算R = Y + 1.140V</span></span><br><span class="line">        __m128i r = _mm_add_epi16(y, _mm_mullo_epi16(v, _mm_set1_epi16(<span class="number">1.140</span> * <span class="number">256</span>))); <span class="comment">// 固定点运算</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算G = Y - 0.395U - 0.581V</span></span><br><span class="line">        __m128i g = _mm_sub_epi16(y, _mm_add_epi16(</span><br><span class="line">            _mm_mullo_epi16(u, _mm_set1_epi16(<span class="number">0.395</span> * <span class="number">256</span>)),</span><br><span class="line">            _mm_mullo_epi16(v, _mm_set1_epi16(<span class="number">0.581</span> * <span class="number">256</span>))</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算B = Y + 2.032U</span></span><br><span class="line">        __m128i b = _mm_add_epi16(y, _mm_mullo_epi16(u, _mm_set1_epi16(<span class="number">2.032</span> * <span class="number">256</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 饱和到0-255</span></span><br><span class="line">        r = _mm_packus_epi16(r, r);</span><br><span class="line">        g = _mm_packus_epi16(g, g);</span><br><span class="line">        b = _mm_packus_epi16(b, b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储到RGB（交错存储：R0, G0, B0, R1, G1, B1, ...）</span></span><br><span class="line">        <span class="comment">// 需额外处理交错存储逻辑</span></span><br><span class="line">        _mm_storeu_si128((__m128i*)(rgb + i * <span class="number">3</span>), r); <span class="comment">// 简化，实际需交错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FFmpeg的libswscale库已高度优化YUV到RGB转换，支持SIMD（SSE、AVX、NEON）。</p>
<p>在 Android 平台上，可直接使用 OpenGL Shader
进行转换。这个方案适合适合 Android 相机预览或视频播放器，支持
NV12/NV21。它的原理是把 YUV 数据上传成纹理，通过 Shader 在 GPU 上做
YUV→RGB 转换，性能极高，几乎不占 CPU。</p>
<p>顶点 Shader 示例代码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex_shader.glsl</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> aPosition;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> aTexCoord;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = aPosition;</span><br><span class="line">    vTexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片元 Shader（支持 NV21/NV12）示例代码： <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment_shader.glsl</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vTexCoord;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> yTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> uvTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span> isNV21; <span class="comment">// 0 = NV12, 1 = NV21</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">float</span> y = <span class="built_in">texture2D</span>(yTexture, vTexCoord).r;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">texture2D</span>(uvTexture, vTexCoord).ra; <span class="comment">// R-&gt;U, A-&gt;V for two-channel texture</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> u = uv.x - <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> v = <span class="keyword">if</span>(isNV21 == <span class="number">1</span>) uv.x - <span class="number">0.5</span> <span class="keyword">else</span> uv.y - <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> r = y + <span class="number">1.402</span> * v;</span><br><span class="line">    <span class="type">float</span> g = y - <span class="number">0.344136</span> * u - <span class="number">0.714136</span> * v;</span><br><span class="line">    <span class="type">float</span> b = y + <span class="number">1.772</span> * u;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(r, g, b, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> UV
通道根据上传纹理时 NV12/NV21 数据安排，如果是 NV21 需交换 U/V。</p>
<p>上传 YUV 纹理示例代码： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uploadYUVTextures</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    yData: <span class="type">ByteArray</span>, uvData: <span class="type">ByteArray</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> textures = IntArray(<span class="number">2</span>)</span><br><span class="line">    GLES20.glGenTextures(<span class="number">2</span>, textures, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Y 纹理</span></span><br><span class="line">    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[<span class="number">0</span>])</span><br><span class="line">    GLES20.glTexImage2D(</span><br><span class="line">        GLES20.GL_TEXTURE_2D, <span class="number">0</span>, GLES20.GL_LUMINANCE,</span><br><span class="line">        width, height, <span class="number">0</span>, GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE, ByteBuffer.wrap(yData)</span><br><span class="line">    )</span><br><span class="line">    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)</span><br><span class="line">    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UV 纹理 (宽/2 x 高/2)</span></span><br><span class="line">    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[<span class="number">1</span>])</span><br><span class="line">    GLES20.glTexImage2D(</span><br><span class="line">        GLES20.GL_TEXTURE_2D, <span class="number">0</span>, GLES20.GL_LUMINANCE_ALPHA,</span><br><span class="line">        width / <span class="number">2</span>, height / <span class="number">2</span>, <span class="number">0</span>, GLES20.GL_LUMINANCE_ALPHA, GLES20.GL_UNSIGNED_BYTE,</span><br><span class="line">        ByteBuffer.wrap(uvData)</span><br><span class="line">    )</span><br><span class="line">    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)</span><br><span class="line">    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> textures</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取 RGB 数据示例代码： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRGBData</span><span class="params">(textureId: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> rgbData = ByteArray(width * height * <span class="number">4</span>) <span class="comment">// RGBA</span></span><br><span class="line">    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, framebufferId)</span><br><span class="line">    GLES20.glReadPixels(<span class="number">0</span>, <span class="number">0</span>, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, ByteBuffer.wrap(rgbData))</span><br><span class="line">    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> rgbData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 GPU 加速，1080p/4K 的视频可以实现实时的 YUV 到 RGB
的转换，极大地提高了性能和效率。通过调整纹理上传，可以支持不同的 YUV
格式，例如 NV12、NV21、I420 等，灵活扩展。在 Android
平台上，这种方法可以与视频播放器和相机预览无缝集成。</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>如何系统学习音视频</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E9%9F%B3%E8%A7%86%E9%A2%91.html</url>
    <content><![CDATA[<p>学习音视频技术涉及多个领域，包括音频处理、视频处理、编码解码、流媒体传输等。以下是一个系统化的音视频学习路线，适合初学者逐步深入，涵盖核心概念、工具和实践技能。</p>
<hr />
<h3 id="第一阶段基础知识准备">第一阶段：基础知识准备</h3>
<p>目标：掌握音视频学习所需的计算机科学和数学基础。</p>
<ol type="1">
<li><strong>计算机基础</strong>
<ul>
<li>学习计算机网络基础（TCP/IP、UDP、HTTP、RTSP等协议）。</li>
<li>了解操作系统原理（进程、线程、内存管理）。</li>
<li>掌握至少一门编程语言（如C/C++、Python或Java），C/C++在音视频开发中尤为重要。</li>
</ul></li>
<li><strong>数学基础</strong>
<ul>
<li>线性代数：矩阵运算，向量，用于图像处理和变换。</li>
<li>信号处理基础：傅里叶变换、时域/频域分析，理解音频信号和视频帧。</li>
<li>概率与统计：用于压缩算法和机器学习相关内容。</li>
</ul></li>
<li><strong>音视频基础概念</strong>
<ul>
<li>音频：采样率、位深度、声道、PCM格式。</li>
<li>视频：分辨率、帧率、色空间（RGB、YUV）、比特率。</li>
<li>编码与压缩：了解H.264、H.265、AAC等常见编解码标准。</li>
</ul></li>
</ol>
<p><strong>推荐资源</strong>： -
书籍：《计算机网络》（谢希仁）、《信号与系统》（奥本海姆）。 -
在线课程：Coursera的“Digital Signal Processing”或B站相关免费教程。 -
工具：安装FFmpeg，初步学习基本命令（如格式转换、提取音频）。</p>
<hr />
<h3 id="第二阶段音视频核心技术">第二阶段：音视频核心技术</h3>
<p>目标：深入理解音视频处理、编码解码和相关工具。</p>
<ol type="1">
<li><strong>音频处理</strong>
<ul>
<li>学习音频信号处理：滤波、均衡、混音、降噪。</li>
<li>掌握音频格式：WAV、MP3、AAC、FLAC。</li>
<li>实践：使用Audacity或Python库（如librosa、pydub）进行音频编辑和分析。</li>
</ul></li>
<li><strong>视频处理</strong>
<ul>
<li>理解视频帧、GOP（Group of Pictures）、I/P/B帧。</li>
<li>学习视频格式：MP4、AVI、MKV。</li>
<li>实践：使用OpenCV处理视频帧，尝试简单的图像处理（如滤镜、裁剪）。</li>
</ul></li>
<li><strong>编解码技术</strong>
<ul>
<li>深入学习H.264、H.265（HEVC）、AV1等视频编码标准。</li>
<li>学习AAC、Opus等音频编码标准。</li>
<li>理解编码工具：x264、x265、libavcodec。</li>
<li>实践：使用FFmpeg进行编码参数调整，分析码率和画质关系。</li>
</ul></li>
<li><strong>工具与库</strong>
<ul>
<li>FFmpeg：深入学习音视频转换、 muxing/demuxing、流处理。</li>
<li>GStreamer：用于构建音视频处理管道。</li>
<li>WebRTC：了解实时音视频通信基础。</li>
</ul></li>
</ol>
<p><strong>推荐资源</strong>： - 书籍：《H.264 and MPEG-4 Video
Compression》。 - 在线教程：FFmpeg官方文档、B站“FFmpeg从入门到精通”。 -
项目：用FFmpeg实现视频转码、添加水印、音频提取。</p>
<hr />
<h3 id="第三阶段流媒体与实时通信">第三阶段：流媒体与实时通信</h3>
<p>目标：掌握音视频的传输与实时处理技术。</p>
<ol type="1">
<li><strong>流媒体协议</strong>
<ul>
<li>学习RTMP、HLS、DASH、SRT等流媒体协议。</li>
<li>理解CDN（内容分发网络）的工作原理。</li>
<li>实践：搭建Nginx-RTMP服务器，推送RTMP流。</li>
</ul></li>
<li><strong>实时音视频通信</strong>
<ul>
<li>学习WebRTC：信令、ICE、STUN/TURN、SDP。</li>
<li>理解延迟优化、抖动缓冲、拥塞控制。</li>
<li>实践：用WebRTC实现一个简单的视频通话应用。</li>
</ul></li>
<li><strong>直播与点播</strong>
<ul>
<li>学习直播流程：推流、转码、分发、播放。</li>
<li>了解点播系统：视频切片、HLS/DASH分发。</li>
<li>实践：使用OBS推流到自建服务器，结合FFmpeg转码。</li>
</ul></li>
</ol>
<p><strong>推荐资源</strong>： - 书籍：《WebRTC: APIs and RTCWEB
Protocols》。 - 在线课程：Udemy的“WebRTC Practical Course”。 -
项目：搭建一个简单的直播系统，或用WebRTC实现视频会议。</p>
<hr />
<h3 id="第四阶段进阶与优化">第四阶段：进阶与优化</h3>
<p>目标：深入优化音视频系统，探索前沿技术。</p>
<ol type="1">
<li><strong>性能优化</strong>
<ul>
<li>学习音视频编码优化：减少延迟、降低码率、提高画质。</li>
<li>硬件加速：使用GPU（CUDA、OpenCL）或硬件编码器（QSV、NVENC）。</li>
<li>多线程处理：优化FFmpeg或GStreamer的并发性能。</li>
</ul></li>
<li><strong>跨平台开发</strong>
<ul>
<li>学习移动端音视频开发：iOS（AVFoundation）、Android（MediaCodec）。</li>
<li>学习Web端音视频：HTML5、WebRTC、WebAssembly。</li>
<li>实践：开发一个跨平台的音视频播放器。</li>
</ul></li>
<li><strong>AI与音视频</strong>
<ul>
<li>学习AI在音视频中的应用：超分辨率、视频修复、语音增强。</li>
<li>实践：使用PyTorch或TensorFlow实现视频帧插值或音频降噪。</li>
</ul></li>
</ol>
<p><strong>推荐资源</strong>： - 书籍：《Learning OpenCV》、《Deep
Learning for Computer Vision》。 - 在线课程：Coursera的“Deep Learning
Specialization”。 - 项目：实现一个AI驱动的视频增强工具。</p>
<hr />
<h3 id="第五阶段项目实战与职业发展">第五阶段：项目实战与职业发展</h3>
<p>目标：通过项目巩固知识，积累实战经验。</p>
<ol type="1">
<li><strong>项目实践</strong>
<ul>
<li>开发一个短视频编辑器（类似抖音效果）。</li>
<li>搭建一个企业级视频会议系统。</li>
<li>实现一个基于AI的实时字幕生成工具。</li>
</ul></li>
<li><strong>开源贡献</strong>
<ul>
<li>参与FFmpeg、GStreamer、WebRTC等开源项目。</li>
<li>提交bug修复或新功能，积累社区影响力。</li>
</ul></li>
<li><strong>职业准备</strong>
<ul>
<li>学习音视频相关的面试知识：编码原理、协议优化、系统设计。</li>
<li>准备作品集：展示项目代码、Demo和文档。</li>
<li>关注行业动态：AV1、8K、云游戏、元宇宙相关技术。</li>
</ul></li>
</ol>
<p><strong>推荐资源</strong>： -
项目平台：GitHub（搜索FFmpeg、WebRTC相关项目）。 -
职业资源：LeetCode（算法）、牛客网（音视频岗位面试题）。 - 社区：Stack
Overflow、Reddit的r/webrtc、r/ffmpeg。</p>
<hr />
<h3 id="学习建议">学习建议</h3>
<ol type="1">
<li><strong>时间规划</strong>：
<ul>
<li>初学者：6-12个月完成基础到进阶。</li>
<li>每天投入2-3小时，理论与实践结合。</li>
</ul></li>
<li><strong>实践驱动</strong>：
<ul>
<li>每学一个模块，尝试一个小项目（如用FFmpeg转码、WebRTC视频通话）。</li>
<li>记录学习笔记，整理成博客或GitHub仓库。</li>
</ul></li>
<li><strong>工具安装</strong>：
<ul>
<li>FFmpeg、OpenCV、GStreamer、OBS Studio。</li>
<li>开发环境：VS Code、PyCharm、Xcode（iOS）或Android Studio。</li>
</ul></li>
<li><strong>社区交流</strong>：
<ul>
<li>加入B站、知乎、CSDN的音视频学习群。</li>
<li>关注X上的音视频技术大V，获取最新资讯。</li>
</ul></li>
</ol>
<hr />
<h3 id="推荐学习路径时间表">推荐学习路径时间表</h3>
<table>
<thead>
<tr class="header">
<th>阶段</th>
<th>时间</th>
<th>重点内容</th>
<th>实践项目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>基础知识</td>
<td>1-2个月</td>
<td>计算机网络、信号处理、编程</td>
<td>FFmpeg格式转换</td>
</tr>
<tr class="even">
<td>核心技术</td>
<td>3-4个月</td>
<td>编解码、音频视频处理</td>
<td>视频编辑器</td>
</tr>
<tr class="odd">
<td>流媒体通信</td>
<td>3-4个月</td>
<td>RTMP、WebRTC、直播</td>
<td>直播系统</td>
</tr>
<tr class="even">
<td>进阶优化</td>
<td>2-3个月</td>
<td>硬件加速、AI应用</td>
<td>AI视频增强</td>
</tr>
<tr class="odd">
<td>项目实战</td>
<td>持续进行</td>
<td>综合项目、开源贡献</td>
<td>视频会议系统</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>播放器</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/%E6%92%AD%E6%94%BE%E5%99%A8.html</url>
    <content><![CDATA[<h1 id="结构">结构</h1>
<pre><code class="highlight mermaid">flowchart TD
 subgraph s1[&quot;核心播放流程&quot;]
        P(&quot;音频渲染&quot;)
        N(&quot;音频缓冲区&quot;)
        M(&quot;音频解码器&quot;)
        K(&quot;音频流&quot;)
        J(&quot;解复用器&quot;)
        I(&quot;格式解析器&quot;)
        H(&quot;文件输入&quot;)
        T(&quot;视频渲染&quot;)
        R(&quot;视频缓冲区&quot;)
        Q(&quot;视频解码器&quot;)
        L(&quot;视频流&quot;)
        U(&quot;音画同步模块&quot;)
        S(&quot;视频后处理&quot;)
        O(&quot;音频后处理&quot;)
  end
 subgraph s2[&quot;用户交互&quot;]
        AC[&quot;设置模块&quot;]
        B(&quot;播放控制模块&quot;)
        A[&quot;用户界面&quot;]
        Y(&quot;播放状态管理&quot;)
  end
    A --&gt; B &amp; Y
    B --&gt; C(&quot;播放/暂停/停止/快进/快退/音量/调速&quot;) &amp; G(&quot;媒体加载模块&quot;) &amp; Y
    G --&gt; H
    H --&gt; I
    I --&gt; J
    J --&gt; K &amp; L
    K --&gt; M
    M --&gt; N
    N --&gt; O
    O --&gt; U
    L --&gt; Q
    Q --&gt; R
    R --&gt; S
    S --&gt; U
    U --&gt; P &amp; T
    P --&gt; W(&quot;音频输出设备&quot;)
    T --&gt; X(&quot;视频输出设备&quot;)
    Y --&gt; Z(&quot;进度跟踪&quot;) &amp; AA(&quot;播放时间显示&quot;) &amp; AB(&quot;缓冲状态监控&quot;)
    AC --&gt; B &amp; AD(&quot;字幕管理&quot;)
    AD --&gt; T
    AE[&quot;错误处理模块&quot;] --&gt; G &amp; U &amp; Y</code></pre>
<h1 id="问题研究">问题研究</h1>
<h2 id="exoplayer-在低性能设备上解码渲染4k视频">ExoPlayer
在低性能设备上解码渲染4K视频</h2>
<p>在低性能设备上使用 ExoPlayer 解码和渲染 4K
视频时，确实有一些特别需要注意的地方，因为 4K 视频（通常是 3840x2160
分辨率）对硬件资源的需求较高，而低性能设备的处理能力、内存和功耗都有限。以下是一些关键点和优化建议：</p>
<h3 id="硬件解码支持">1. <strong>硬件解码支持</strong></h3>
<ul>
<li><strong>检查硬件解码能力</strong>：低性能设备可能不支持高效的硬件解码（如
H.264 或 H.265/HEVC 的 4K 解码）。在 ExoPlayer
中，默认会优先尝试硬件解码，但你需要确保设备的媒体解码器（MediaCodec）支持目标视频的编解码格式和分辨率。</li>
<li><strong>解决方法</strong>：使用 <code>MediaCodecInfo</code>
检查设备的解码能力。如果硬件不支持
4K，可以考虑降低分辨率（通过预处理或选择较低分辨率的流）或切换到软件解码（尽管这可能会导致性能瓶颈）。</li>
<li><strong>注意事项</strong>：硬件解码通常比软件解码更省电，但在低端设备上可能出现卡顿或崩溃，需做好异常处理。</li>
</ul>
<h3 id="性能优化">2. <strong>性能优化</strong></h3>
<ul>
<li><strong>降低分辨率或比特率</strong>：如果设备无法流畅处理
4K，可以通过自适应流媒体（如 HLS 或 DASH）选择较低分辨率的流。ExoPlayer
支持
<code>AdaptiveTrackSelection</code>，可以根据设备性能动态调整。</li>
<li><strong>帧率控制</strong>：4K 视频可能是 60fps
或更高，但低性能设备可能难以保持流畅播放。优先选择 24fps 或 30fps
的视频流。</li>
<li><strong>缓冲区管理</strong>：调整 ExoPlayer 的
<code>LoadControl</code> 参数（例如
<code>DefaultLoadControl</code>），减少缓冲区大小（如
<code>setMaxBufferMs</code>），以避免内存溢出。</li>
</ul>
<h3 id="内存管理">3. <strong>内存管理</strong></h3>
<ul>
<li><strong>内存限制</strong>：4K
视频解码需要大量内存，低性能设备可能只有 1-2GB
RAM。过大的缓冲区或未优化的渲染可能导致 OOM（Out of Memory）。</li>
<li><strong>解决方法</strong>：
<ul>
<li>使用 <code>DefaultAllocator</code> 并设置较小的缓冲区大小。</li>
<li>避免同时加载多个视频流。</li>
<li>确保及时释放资源（如调用 <code>player.release()</code>）。</li>
</ul></li>
</ul>
<h3 id="渲染优化">4. <strong>渲染优化</strong></h3>
<ul>
<li><strong>Surface 使用</strong>：在低性能设备上，尽量使用
<code>SurfaceView</code> 而不是
<code>TextureView</code>，因为前者对硬件加速支持更好，渲染效率更高。</li>
<li><strong>避免复杂
UI</strong>：如果视频播放器上叠加了复杂界面（如大量控件或动画），会增加
GPU 负担。尽量简化播放界面。</li>
<li><strong>分辨率适配</strong>：如果设备屏幕分辨率远低于 4K（如
720p），解码 4K
后再缩放到屏幕分辨率会浪费资源。可以考虑在解码前调整视频输出分辨率（需要服务器端支持或额外的预处理）。</li>
</ul>
<h3 id="功耗和散热">5. <strong>功耗和散热</strong></h3>
<ul>
<li><strong>问题</strong>：低性能设备的 CPU/GPU 在处理 4K
视频时可能长时间满载，导致过热或电量快速消耗。</li>
<li><strong>解决方法</strong>：
<ul>
<li>监控设备温度和性能状态（Android API 如
<code>Thermal API</code>），必要时降低播放质量。</li>
<li>尽量避免后台持续解码（如通过
<code>player.setPlayWhenReady(false)</code> 暂停未显示的视频）。</li>
</ul></li>
</ul>
<h3 id="exoplayer-配置建议">6. <strong>ExoPlayer 配置建议</strong></h3>
<p>以下是一个简单的 ExoPlayer 配置示例，适用于低性能设备：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建自定义 LoadControl 以优化缓冲</span></span><br><span class="line"><span class="type">DefaultLoadControl</span> <span class="variable">loadControl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultLoadControl</span>.Builder()</span><br><span class="line">    .setBufferDurationsMs(</span><br><span class="line">        <span class="number">1000</span>,  <span class="comment">// minBufferMs</span></span><br><span class="line">        <span class="number">5000</span>,  <span class="comment">// maxBufferMs</span></span><br><span class="line">        <span class="number">500</span>,   <span class="comment">// bufferForPlaybackMs</span></span><br><span class="line">        <span class="number">1000</span>)  <span class="comment">// bufferForPlaybackAfterRebufferMs</span></span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建渲染器工厂，优先硬件解码</span></span><br><span class="line"><span class="type">DefaultRenderersFactory</span> <span class="variable">renderersFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultRenderersFactory</span>(context)</span><br><span class="line">    .setEnableDecoderFallback(<span class="literal">true</span>); <span class="comment">// 如果硬件解码失败，尝试软件解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 ExoPlayer</span></span><br><span class="line"><span class="type">ExoPlayer</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExoPlayer</span>.Builder(context)</span><br><span class="line">    .setRenderersFactory(renderersFactory)</span><br><span class="line">    .setLoadControl(loadControl)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置自适应流选择</span></span><br><span class="line">TrackSelection.<span class="type">Factory</span> <span class="variable">trackSelectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdaptiveTrackSelection</span>.Factory();</span><br><span class="line">player.setTrackSelector(<span class="keyword">new</span> <span class="title class_">DefaultTrackSelector</span>(context, trackSelectionFactory));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载媒体</span></span><br><span class="line">player.setMediaItem(MediaItem.fromUri(<span class="string">&quot;your_4k_video_url&quot;</span>));</span><br><span class="line">player.prepare();</span><br><span class="line">player.setPlayWhenReady(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="测试与调试">7. <strong>测试与调试</strong></h3>
<ul>
<li><strong>设备测试</strong>：在目标低性能设备上反复测试，观察 CPU/GPU
使用率、掉帧率和崩溃情况。</li>
<li><strong>日志分析</strong>：启用 ExoPlayer 的
<code>AnalyticsListener</code>，收集播放过程中的性能数据（如
<code>onDroppedFrames</code> 或
<code>onDecoderInitialized</code>）。</li>
<li><strong>降级策略</strong>：如果检测到播放卡顿（例如通过
<code>onPlaybackStateChanged</code>
判断缓冲时间过长），提示用户切换到较低质量。</li>
</ul>
<h3 id="总结">总结</h3>
<p>在低性能设备上解码渲染 4K
视频，核心是权衡性能与体验。优先利用硬件解码，优化内存和缓冲策略，必要时通过自适应流降低分辨率或帧率。同时，密切关注设备的实际表现，确保播放稳定且不过载硬件。如果你的应用场景允许，建议提供用户手动切换画质的选项，以应对不同设备能力的差异。</p>
<h2 id="exoplayer-播放-drm-加密视频的过程">ExoPlayer 播放 DRM
加密视频的过程</h2>
<p>ExoPlayer 是 Android 平台上一个功能强大的开源媒体播放器，支持播放
DRM（数字版权管理）加密的视频。它通过与设备的 DRM
框架和内容解密模块（CDM）协作，解密并播放受保护的内容。以下是 ExoPlayer
播放 DRM 加密视频的详细过程：</p>
<ol type="1">
<li><strong>初始化 ExoPlayer</strong>
<ul>
<li>创建 ExoPlayer 实例，并配置媒体源（MediaSource），通常是 DASH 或 HLS
格式的加密视频流。<br />
</li>
<li>指定视频的 URI 和 DRM 配置（如 Widevine 的 UUID 和许可服务器
URL）。</li>
</ul></li>
<li><strong>检测 DRM 保护</strong>
<ul>
<li>ExoPlayer 解析媒体流时，检测到内容已加密（例如通过 CENC
标准）。<br />
</li>
<li>它会识别加密方案（例如 Widevine、PlayReady）并加载对应的 DRM
会话。</li>
</ul></li>
<li><strong>创建 DRM 会话</strong>
<ul>
<li>ExoPlayer 使用
<code>DefaultDrmSessionManager</code>（或自定义实现）与 Android 的
<code>MediaDrm</code> API 交互。<br />
</li>
<li>根据 DRM 配置，初始化一个 DRM
会话（DrmSession），准备与许可服务器通信。</li>
</ul></li>
<li><strong>请求许可（License Request）</strong>
<ul>
<li>ExoPlayer 从加密视频的元数据中提取密钥 ID（Key ID）。<br />
</li>
<li>使用 Key ID 向 DRM
许可服务器发送请求，附带设备信息和用户认证数据（如 token）。<br />
</li>
<li>请求通过 HTTP（通常是 POST）发送到许可服务器。</li>
</ul></li>
<li><strong>接收并处理许可（License Response）</strong>
<ul>
<li>许可服务器验证请求后，返回包含内容加密密钥（CEK）的许可数据。<br />
</li>
<li>ExoPlayer 将许可传递给 <code>MediaDrm</code>，由底层的
CDM（内容解密模块）处理并存储 CEK。</li>
</ul></li>
<li><strong>解密视频流</strong>
<ul>
<li>ExoPlayer 将加密的视频数据（通常是分段的 MP4 或 TS 文件）传递给
<code>MediaCodec</code>，由其调用 CDM 使用 CEK 进行解密。<br />
</li>
<li>解密过程在硬件级别完成，确保密钥和内容安全。</li>
</ul></li>
<li><strong>渲染与播放</strong>
<ul>
<li>解密后的视频帧被解码并渲染到 <code>Surface</code>
上，用户即可观看视频。<br />
</li>
<li>ExoPlayer 继续处理后续视频分段，重复解密和播放流程。</li>
</ul></li>
</ol>
<hr />
<h3 id="流程图">流程图</h3>
<pre><code class="highlight mermaid">graph TD
    A[初始化 ExoPlayer] --&gt; B[加载加密视频流&lt;br&gt;（DASH/HLS）]
    B --&gt; C[检测DRM保护]
    C --&gt; D[创建DRM会话&lt;br&gt;（DefaultDrmSessionManager）]
    D --&gt; E[提取Key ID]
    E --&gt; F[向许可服务器请求许可]
    F --&gt; G[服务器验证请求]
    G --&gt;|返回许可| H[接收并处理许可]
    H --&gt; I[将CEK传递给MediaDrm]
    I --&gt; J[解密视频流&lt;br&gt;（MediaCodec + CDM）]
    J --&gt; K[解码并渲染视频]
    K --&gt; L[播放视频]
    G --&gt;|验证失败| M[播放失败]</code></pre>
<hr />
<h3 id="代码示例">代码示例</h3>
<p>以下是一个简单的 ExoPlayer 配置 DRM 的代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 DRM 配置</span></span><br><span class="line"><span class="type">Uuid</span> <span class="variable">drmSchemeUuid</span> <span class="operator">=</span> C.WIDEVINE_UUID; <span class="comment">// Widevine 的 UUID</span></span><br><span class="line"><span class="type">String</span> <span class="variable">licenseUrl</span> <span class="operator">=</span> <span class="string">&quot;https://drm-server.com/license&quot;</span>;</span><br><span class="line"><span class="type">DrmSessionManager</span> <span class="variable">drmSessionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultDrmSessionManager</span>.Builder()</span><br><span class="line">    .setUuidAndExoMediaDrmProvider(drmSchemeUuid, FrameworkMediaDrm::<span class="keyword">new</span>)</span><br><span class="line">    .build(<span class="keyword">new</span> <span class="title class_">HttpMediaDrmCallback</span>(licenseUrl, <span class="keyword">new</span> <span class="title class_">DefaultHttpDataSource</span>.Factory()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ExoPlayer</span></span><br><span class="line"><span class="type">ExoPlayer</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExoPlayer</span>.Builder(context)</span><br><span class="line">    .setDrmSessionManager(drmSessionManager)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置媒体源</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;https://example.com/video.mpd&quot;</span>);</span><br><span class="line"><span class="type">MediaSource</span> <span class="variable">mediaSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DashMediaSource</span>.Factory(dataSourceFactory)</span><br><span class="line">    .setDrmSessionManager(drmSessionManager)</span><br><span class="line">    .createMediaSource(MediaItem.fromUri(uri));</span><br><span class="line">player.setMediaSource(mediaSource);</span><br><span class="line">player.prepare();</span><br><span class="line">player.play();</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="补充说明">补充说明</h3>
<ul>
<li><strong>支持的 DRM 系统</strong>：ExoPlayer 默认支持
Widevine，也可以通过自定义扩展支持 FairPlay 或 PlayReady。</li>
<li><strong>安全性</strong>：解密过程依赖设备的硬件安全模块（如
TEE），防止密钥泄露。</li>
<li><strong>错误处理</strong>：如果许可请求失败（例如网络问题或未授权），ExoPlayer
会抛出异常，需在应用中处理。</li>
<li>通常情况下，私钥在设备制造过程中由硬件厂商生成，通常在芯片生产或设备组装阶段完成。从
DRM 服务器获取的是公钥。</li>
<li><strong>解密</strong>：DRM 的 CDM（内容解密模块）使用
CEK（内容加密密钥）将加密的视频流（例如 AES-128 加密的 MPEG-TS 或 MP4
分段）转换为明文数据。</li>
<li><strong>解码</strong>：解密后的明文数据（通常是压缩格式，如
H.264、H.265）被 MediaCodec 解码为原始的视频帧（YUV 或 RGB 格式）。</li>
</ul>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>音视频</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91.html</url>
    <content><![CDATA[<h1 id="知识树">知识树</h1>
<pre><code class="highlight mermaid">graph LR
    A[音视频开发技术栈]
    
    A --&gt; B[音频基础]
    B --&gt; B1[音频采样]
    B --&gt; B2[音频格式 AAC/WAV/MP3]
    B --&gt; B3[声道处理]
    B --&gt; B4[音频混音]
    B --&gt; B5[降噪与回声消除]

    A --&gt; C[视频基础]
    C --&gt; C1[视频分辨率与帧率]
    C --&gt; C2[视频格式 MP4/AVI/MKV]
    C --&gt; C3[色彩空间 YUV/RGB]
    C --&gt; C4[视频渲染]

    A --&gt; D[编解码技术]
    D --&gt; D1[H.264/H.265]
    D --&gt; D2[VP8/VP9]
    D --&gt; D3[AV1]
    D --&gt; D4[AAC/Opus]
    D --&gt; D5[FFmpeg]
    D --&gt; D6[x264/x265]

    A --&gt; E[流媒体协议]
    E --&gt; E1[RTMP]
    E --&gt; E2[HLS]
    E --&gt; E3[DASH]
    E --&gt; E4[WebRTC]
    E --&gt; E5[RTSP]
    E --&gt; E6[SRT]

    A --&gt; F[音视频采集]
    F --&gt; F1[麦克风采集]
    F --&gt; F2[摄像头采集]
    F --&gt; F3[屏幕录制]
    F --&gt; F4[音频预处理]
    F --&gt; F5[视频预处理]

    A --&gt; G[播放器开发]
    G --&gt; G1[ExoPlayer]
    G --&gt; G2[MediaCodec]
    G --&gt; G3[OpenSL ES]
    G --&gt; G4[OpenGL ES]
    G --&gt; G5[VLC]
    G --&gt; G6[IJKPlayer]

    A --&gt; H[实时通信]
    H --&gt; H1[WebRTC]
    H --&gt; H2[QoS 优化]
    H --&gt; H3[Jitter Buffer]
    H --&gt; H4[网络自适应]
    H --&gt; H5[音视频同步]

    A --&gt; I[跨平台开发]
    I --&gt; I1[Android Media API]
    I --&gt; I2[iOS AVFoundation]
    I --&gt; I3[Windows DirectShow]
    I --&gt; I4[Flutter/Dart]
    I --&gt; I5[Electron]

    A --&gt; J[工具与库]
    J --&gt; J1[FFmpeg]
    J --&gt; J2[Libav]
    J --&gt; J3[GStreamer]
    J --&gt; J4[SDL]
    J --&gt; J5[OpenCV]
    J --&gt; J6[WebAssembly]

    A --&gt; K[性能优化]
    K --&gt; K1[多线程处理]
    K --&gt; K2[硬件加速]
    K --&gt; K3[缓冲管理]
    K --&gt; K4[延迟优化]
    K --&gt; K5[功耗优化]</code></pre>
<h1 id="基础知识">基础知识</h1>
<h2 id="音视频的本质与起源">1. 音视频的本质与起源</h2>
<p>音视频是我们感知世界的主要方式。<strong>音频</strong>是通过声波传递的声音，声波是空气中振动的物理现象，可以被麦克风捕捉为电信号。<strong>视频</strong>则是通过连续的图像（称为帧）记录动态视觉内容，结合光信号和人类视觉暂留效应（快速切换帧形成运动感）呈现出来。在实际应用中，音视频往往结合在一起，比如电影既有画面又有声音，共同构成完整的视听体验。</p>
<p>声音的特性由几个物理参数决定： -
<strong>频率</strong>：声波每秒振动的次数，单位是赫兹（Hz）。频率决定音高，比如小提琴的高频（尖锐）和低音鼓的低频（浑厚）。人类听觉范围大约是20Hz到20kHz。
- <strong>振幅</strong>：声波的强度，决定音量。振幅越大，声音越响。 -
<strong>波形</strong>：声波随时间变化的形状，决定音色。即使频率和振幅相同，小提琴和钢琴的声音也因波形不同而有差异。</p>
<p>视频的核心是<strong>帧</strong>，每帧是一张静态图片，通过每秒播放一定数量的帧（帧率，Frame
Rate）形成动态效果。常见的帧率有24FPS（电影标准）、30FPS（电视）、60FPS（游戏），帧率越高越流畅，但数据量也越大。视频的清晰度由<strong>分辨率</strong>决定，比如720p（1280×720）、1080p（1920×1080）、4K（3840×2160），分辨率越高，画面细节越丰富。</p>
<hr />
<h2 id="音频的数字化过程">2. 音频的数字化过程</h2>
<p>要把连续的模拟声波变成计算机能处理的数字信号，需要经过数字化过程。这个过程包括以下步骤：</p>
<ul>
<li><strong>采样</strong>：以固定频率截取声波的瞬时值。采样率（Sample
Rate）是每秒采样的次数，比如CD音频用44.1kHz（每秒44,100次）。采样率决定了音频的时间分辨率，根据奈奎斯特-香农采样定理，采样率必须至少是声音最高频率的两倍（比如20kHz需要40kHz），否则会出现混叠（Aliasing），高频细节丢失，声音听起来失真。专业录音可能用48kHz或96kHz，追求更高精度。</li>
<li><strong>量化</strong>：将采样值转化为离散的数字级别，用位深度（Bit
Depth）表示。16位深度有65,536个级别，24位更多。位深度决定动态范围（从最安静到最响的音量跨度），越高越细腻，量化噪声也越低。</li>
<li><strong>通道</strong>：音频可以有多个声道。单声道（Mono）只有一个通道，立体声（Stereo）有两个（左、右声道，提供空间感），5.1环绕声有六个（前左、前右、中、后左、后右、低音）。通道数影响沉浸感和数据量。</li>
</ul>
<p>举个例子，未压缩的CD音频（44.1kHz采样率、16位深度、立体声）的比特率是44,100
× 16 × 2 = 1,411,200
bits/s，约1.41Mbps。1分钟这样的音频大约占10.6MB，可见未压缩音频体积很大。</p>
<hr />
<h2 id="音频格式与压缩">3. 音频格式与压缩</h2>
<p>由于原始音频数据量庞大，不同的格式被开发出来，用于存储和传输：</p>
<ul>
<li><strong>PCM（脉冲编码调制）</strong>：最基础的数字音频形式，直接保存采样和量化的数据，没有压缩。WAV文件通常包含PCM数据，音质完美无损，常用于录音和专业编辑，但文件体积大。比如，1分钟CD质量的PCM音频就是10.6MB。</li>
<li><strong>无损压缩</strong>：像<strong>FLAC（Free Lossless Audio
Codec）</strong>通过预测编码和熵编码压缩数据，同时保留所有原始信息。解压后能完全还原，适合高保真音乐爱好者，文件大小比PCM小得多，但仍比有损格式大。</li>
<li><strong>有损压缩</strong>：
<ul>
<li><strong>MP3（MPEG-1 Audio Layer
3）</strong>：利用心理声学原理，丢弃人耳不易察觉的部分（比如被更响声音掩盖的高频），大幅减小文件大小。它基于频域变换（如离散余弦变换DCT），广泛用于在线音乐和便携设备。比特率（如128kbps）越低，音质损失越明显。</li>
<li><strong>AAC（Advanced Audio
Coding）</strong>：MP3的改进版，压缩效率更高，在相同比特率下音质更好，常用于流媒体（如YouTube、Apple
Music）。</li>
</ul></li>
</ul>
<p>音频处理还有一些常见技术，比如用<strong>均衡器</strong>调整不同频率的增益（增强低音或高音），或添加<strong>混响</strong>模拟空间反射（如演唱会效果），这些都依赖数字信号处理（DSP）。</p>
<hr />
<h2 id="视频的组成与特性">4. 视频的组成与特性</h2>
<p>视频比音频复杂，它不仅涉及时间维度（帧的连续性），还涉及空间维度（每帧的像素）。视频由一连串<strong>帧</strong>组成，每帧是一张完整的图片。<strong>帧率</strong>决定播放速度，比如电影用24FPS，电视用30FPS，游戏追求60FPS甚至更高。帧率低时画面卡顿，高时更流畅，但数据量也成倍增加。</p>
<p><strong>分辨率</strong>决定画面清晰度，比如720p（1280×720）、1080p（1920×1080）、4K（3840×2160）。分辨率越高，像素点越多，细节越丰富，但存储和传输成本也更高。比如，1080p每帧有207万像素，4K则是829万像素。</p>
<hr />
<h2 id="颜色模型">5. 颜色模型</h2>
<p>视频的颜色处理至关重要，因为它直接影响画面的视觉效果。常见的颜色模型包括：</p>
<ul>
<li><strong>RGB（红绿蓝）</strong>：用红、绿、蓝三原色表示颜色，每个通道通常8位（0-255，256级），每像素3字节。RGB是显示设备（如屏幕）的原生模型，适合原始视频数据。比如，1080p的RGB帧大小是1920
× 1080 × 3 =
6,220,800字节，未压缩的30FPS视频比特率高达186MB/s，显然不适合直接存储或传输。</li>
<li><strong>YUV（或YCbCr）</strong>：将颜色分解为<strong>亮度（Y）</strong>和<strong>色度（U、V）</strong>，亮度表示灰度信息，色度表示色彩信息。YUV的优势在于人眼对亮度更敏感，对色度分辨率要求低，因此可以对色度降采样，减少数据量。常见的采样模式包括：
<ul>
<li><strong>4:4:4</strong>：每个像素都有完整的Y、U、V值，数据量与RGB相同。</li>
<li><strong>4:2:2</strong>：每两个像素共享一组色度值，色度数据减半。</li>
<li><strong>4:2:0</strong>：每四个像素（2×2块）共享一组色度值，色度数据只有亮度的四分之一，广泛用于视频编码（如H.264）。
YUV在视频压缩中几乎是标配，因为它显著降低了带宽需求。</li>
</ul></li>
<li><strong>HSV（色相、饱和度、明度）</strong>：以色相（Hue，颜色种类）、饱和度（Saturation，纯度）、明度（Value，亮度）表示颜色，更符合人类直觉，常用在图像处理中（如调整色调），但视频编码中较少使用。</li>
</ul>
<p>未压缩的视频数据量惊人，比如1秒1080p、30FPS、RGB视频是186MB，1分钟就是11GB，这也是为什么视频必须压缩的原因。</p>
<hr />
<h2 id="视频的数字化与编码">6. 视频的数字化与编码</h2>
<p>视频的数字化过程类似于音频，先将光信号转为像素（采样），再将像素值量化（比如8位RGB或YUV）。但由于数据量巨大，视频几乎总是需要压缩编码：</p>
<ul>
<li><strong>帧类型</strong>：视频编码利用时间和空间的冗余来压缩。
<ul>
<li><strong>I帧（Intra
Frame，关键帧）</strong>：独立编码的完整帧，像一张压缩图片，数据量大，但可以作为参考点，通常用于视频开头或场景切换。</li>
<li><strong>P帧（Predicted
Frame，预测帧）</strong>：只记录与前帧的差异，依赖前面的I帧或P帧，节省空间。</li>
<li><strong>B帧（Bidirectional
Frame，双向预测帧）</strong>：参考前后帧进行预测，进一步压缩，但解码时需要更多计算，增加了复杂度。</li>
</ul></li>
<li><strong>编码标准</strong>：
<ul>
<li><strong>H.264（AVC，高级视频编码）</strong>：目前最普及的标准，通过块编码（将帧分成小块，如16×16宏块）、运动补偿（追踪物体移动）、离散余弦变换（DCT）压缩数据。它在低比特率下仍能保持高质量，广泛用于流媒体、蓝光和视频会议。</li>
<li><strong>H.265（HEVC，高效视频编码）</strong>：H.264的升级版，压缩效率翻倍（相同质量下比特率减半），特别适合4K和8K视频，但编码和解码更耗资源。</li>
<li><strong>VP9</strong>：Google的开源编码，与H.265性能接近，YouTube大量采用，支持高效的Web视频。</li>
<li><strong>AV1</strong>：最新的开源标准，由AOMedia开发，目标是超越H.265和VP9，适用于未来超高清视频。</li>
</ul></li>
</ul>
<p>视频处理还包括一些常见操作，比如<strong>剪辑</strong>（分割和拼接片段）、<strong>特效</strong>（添加滤镜、转场）、<strong>分辨率调整</strong>（上采样到4K或下采样到720p），这些依赖专业软件或库（如FFmpeg）。</p>
<hr />
<h2 id="音视频容器格式">7. 音视频容器格式</h2>
<p>单独的音频或视频流无法直接播放，需要用<strong>容器格式</strong>把它们打包。容器就像一个“文件包裹”，包含音频流、视频流和元数据（如字幕、时间戳），确保音画同步：</p>
<ul>
<li><strong>MP4</strong>：基于MPEG-4标准，支持H.264视频和AAC音频，兼容性极强，广泛用于在线视频和移动设备。</li>
<li><strong>AVI（Audio Video
Interleave）</strong>：微软的早期格式，结构简单，兼容性好，但不支持现代编码，逐渐被淘汰。</li>
<li><strong>MKV（Matroska）</strong>：开源格式，灵活性高，支持多种编码、多字幕轨道、多音轨，常用于高清电影爱好者。</li>
</ul>
<p>容器通过<strong>交错存储</strong>（音频和视频数据按时间顺序混合）保证同步，<strong>时间戳</strong>（Timestamp）则精确对齐音画。如果没有容器，播放器无法知道如何组合音视频。</p>
<hr />
<h2 id="音视频传输与播放">8. 音视频传输与播放</h2>
<p>现代音视频多以<strong>流媒体</strong>形式传输，即边下载边播放，避免等待整个文件下载完成。流媒体依赖缓冲区管理播放进度，常见协议包括：</p>
<ul>
<li><strong>RTMP（Real-Time Messaging
Protocol）</strong>：Adobe的实时流协议，延迟低（通常1-3秒），适合直播。</li>
<li><strong>HLS（HTTP Live
Streaming）</strong>：Apple的协议，把视频切成小段TS文件（通常10秒一段），支持自适应比特率（根据网络切换画质），广泛用于点播和直播。</li>
<li><strong>DASH（Dynamic Adaptive Streaming over
HTTP）</strong>：类似HLS的跨平台标准，支持动态调整画质，YouTube和Netflix常用。</li>
</ul>
<p><strong>播放器</strong>（如VLC、FFmpeg）的任务是解复用（Demux）容器，分离音视频流，分别解码音频（输出到扬声器）和视频（渲染到屏幕），并通过时间戳同步输出。如果音画不同步，会出现“声音早于画面”或“画面卡住声音继续”的问题。</p>
<hr />
<h2 id="其他关键概念">9. 其他关键概念</h2>
<ul>
<li><strong>比特率（Bitrate）</strong>：每秒传输的数据量，比如256kbps的MP3或5Mbps的H.264视频。比特率越高，质量越好，但文件或带宽需求也越大。比如，1080p视频可能用5Mbps，4K视频可能用20Mbps。</li>
<li><strong>延迟（Latency）</strong>：从采集到播放的时间差。直播追求低延迟（1秒以内），点播可以容忍更高延迟（几秒缓冲）。</li>
<li><strong>同步</strong>：音频和视频必须对齐，通常靠时间戳实现。编码和传输中如果时间戳出错，会导致音画错位。</li>
<li><strong>动态范围</strong>：音频中指最安静到最响的范围，视频中指亮度范围（如HDR支持更高的对比度）。</li>
<li><strong>HDR（High Dynamic
Range）</strong>：高动态范围视频，扩展亮度和色彩范围，适合4K电视，但需要H.265或VP9支持。</li>
</ul>
<hr />
<h2 id="数据量与现实考量">10. 数据量与现实考量</h2>
<p>未压缩的音视频数据量非常惊人： -
<strong>音频</strong>：1分钟CD质量（44.1kHz、16位、立体声，1.41Mbps）≈
10.6MB。 - <strong>视频</strong>：1秒1080p未压缩（30FPS、RGB，186MB/s）≈
186MB，1分钟≈ 11GB。</p>
<p>这也是为什么编码和压缩如此重要。实际中，MP3可能压缩到128kbps（1分钟约1MB），H.264视频压缩到5Mbps（1分钟约37.5MB），既保证质量又适合存储和传输。</p>
<h1 id="问题研究">问题研究</h1>
<h2 id="yuv-和-rgb-互相转化">YUV 和 RGB 互相转化</h2>
<h3 id="yuv-和-rgb-的基础概念">YUV 和 RGB 的基础概念</h3>
<p>在音视频处理中，<strong>RGB</strong> 和 <strong>YUV</strong>
是两种常见的颜色模型，它们各有特点，适用于不同的场景。</p>
<ul>
<li><p><strong>RGB（红绿蓝）</strong> RGB
是基于加色模型的颜色表示法，用红（Red）、绿（Green）、蓝（Blue）三原色组合来表示颜色。每个通道通常用
8 位（0-255 的范围，256 个级别），所以每像素需要 3 个字节。RGB
直接对应显示设备（如屏幕）的发光原理，红绿蓝三种光混合可以生成几乎所有可见颜色。比如，(255,
0, 0) 是纯红，(255, 255, 255) 是白，(0, 0, 0) 是黑。RGB
数据直观，但未压缩时数据量很大，比如 1080p 的一帧 RGB 图像是 1920 × 1080
× 3 = 6,220,800 字节。</p></li>
<li><p><strong>YUV（亮度与色度分离）</strong> YUV
是一种将颜色分解为<strong>亮度</strong>（Y）和<strong>色度</strong>（U、V）的模型。Y
表示灰度值（亮度），U（蓝色色度，Cb）和
V（红色色度，Cr）表示色彩信息。这种分离基于人眼的特性：我们对亮度变化更敏感，对色彩变化的感知较弱。YUV
的优势在于可以通过降采样色度（比如
4:2:0）大幅减少数据量，非常适合视频压缩和传输。常见的 YUV
格式中，每个通道也通常是 8
位，但实际数据量因采样模式不同而变化。</p></li>
</ul>
<hr />
<h3 id="为什么需要互相转化">为什么需要互相转化？</h3>
<p>RGB 和 YUV 的使用场景不同，导致它们之间经常需要转换： - <strong>RGB
到 YUV</strong>：视频编码（如 H.264、H.265）通常用
YUV，因为它便于压缩。原始视频采集（比如摄像头）可能是
RGB，编码前需要转为 YUV。 - <strong>YUV 到 RGB</strong>：解码后的 YUV
数据需要转为 RGB，才能在显示器上渲染，因为屏幕硬件直接处理 RGB。</p>
<p>这种转化在音视频处理链中无处不在，比如从摄像头采集到编码传输，再到播放器渲染，都涉及这两种模型的转换。</p>
<hr />
<h3 id="转化原理与公式">转化原理与公式</h3>
<p>YUV 和 RGB
的转换基于线性数学关系，核心是通过矩阵运算实现。以下是标准转换公式，基于
<strong>ITU-R BT.601</strong> 标准（适用于标清视频，稍后会提到 BT.709
的区别）：</p>
<h4 id="rgb-到-yuv">RGB 到 YUV</h4>
<p>假设 RGB 各通道的值范围是 [0, 255]，YUV 的 Y 在 [0, 255]，U 和 V 在
[-128, 127]（实际存储时偏移到 [0, 255]，即 U+128 和 V+128）： -
<strong>Y = 0.299R + 0.587G + 0.114B</strong> - <strong>U = -0.147R -
0.289G + 0.436B</strong> （偏移后：U’ = U + 128） - <strong>V = 0.615R -
0.515G - 0.100B</strong> （偏移后：V’ = V + 128）</p>
<p>这些系数来自人眼对红、绿、蓝的感知权重，绿色（G）对亮度的贡献最大（0.587），因为人眼对绿光最敏感。</p>
<h4 id="yuv-到-rgb">YUV 到 RGB</h4>
<p>反向转换，从 YUV（Y 在 [0, 255]，U’、V’ 在 [0, 255]，需先还原 U = U’
- 128，V = V’ - 128）到 RGB： - <strong>R = Y + 1.140V</strong> -
<strong>G = Y - 0.395U - 0.581V</strong> - <strong>B = Y +
2.032U</strong></p>
<p>这些公式确保转换是可逆的，理论上不会丢失信息（忽略浮点精度误差）。</p>
<h4 id="矩阵形式">矩阵形式</h4>
<p>可以用矩阵表达 RGB 到 YUV 的转换： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Y]   [ 0.299  0.587  0.114] [R]</span><br><span class="line">[U] = [-0.147 -0.289  0.436] [G] + [128]</span><br><span class="line">[V]   [ 0.615 -0.515 -0.100] [B]   [128]</span><br></pre></td></tr></table></figure> YUV 到 RGB
的逆矩阵： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R]   [1.000  0.000  1.140] [Y]</span><br><span class="line">[G] = [1.000 -0.395 -0.581] [U-128]</span><br><span class="line">[B]   [1.000  2.032  0.000] [V-128]</span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="示例计算">示例计算</h3>
<p>假设有一个 RGB 像素 (255, 128, 0)： - <strong>RGB 到 YUV</strong>： -
Y = 0.299 × 255 + 0.587 × 128 + 0.114 × 0 = 76.245 + 75.136 + 0 =
151.381 ≈ 151 - U = -0.147 × 255 - 0.289 × 128 + 0.436 × 0 = -37.485 -
36.992 + 0 = -74.477，U’ = -74.477 + 128 ≈ 54 - V = 0.615 × 255 - 0.515
× 128 - 0.100 × 0 = 156.825 - 65.92 + 0 = 90.905，V’ = 90.905 + 128 ≈
219 - 结果：YUV = (151, 54, 219)</p>
<ul>
<li><strong>YUV 到 RGB</strong>（验证可逆性）：
<ul>
<li>U = 54 - 128 = -74, V = 219 - 128 = 91</li>
<li>R = 151 + 1.140 × 91 = 151 + 103.74 ≈ 255</li>
<li>G = 151 - 0.395 × (-74) - 0.581 × 91 = 151 + 29.23 - 52.871 ≈
128</li>
<li>B = 151 + 2.032 × (-74) = 151 - 150.368 ≈ 0</li>
<li>结果：RGB = (255, 128, 0)，与原始值一致</li>
</ul></li>
</ul>
<hr />
<h3 id="不同标准的影响">不同标准的影响</h3>
<p>YUV 的具体系数因标准不同而变化： -
<strong>BT.601</strong>：用于标清视频（SD），上面的公式基于此。 -
<strong>BT.709</strong>：用于高清视频（HD），系数略有调整以适应更广的色域：
- Y = 0.2126R + 0.7152G + 0.0722B - U = -0.0999R - 0.3361G + 0.4360B - V
= 0.6150R - 0.5586G - 0.0564B -
<strong>BT.2020</strong>：用于超高清（4K/8K），进一步优化色域和动态范围。</p>
<p>不同标准反映了显示技术的发展，选择哪个标准取决于视频的分辨率和目标设备。比如，1080p
视频通常用 BT.709，4K HDR 视频用 BT.2020。</p>
<hr />
<h3 id="实际应用中的细节">实际应用中的细节</h3>
<h4 id="范围问题">1. 范围问题</h4>
<ul>
<li><strong>RGB</strong>：通常是全范围 [0, 255]。</li>
<li><strong>YUV</strong>：在视频编码中，Y 可能是有限范围 [16, 235]，U 和
V 是 [16, 240]（称为 Studio Range），而不是 [0, 255]（Full
Range）。这是为了兼容老式电视标准，预留边界值给控制信号。转换时需要缩放：
<ul>
<li>Y’ = 16 + (219/255) × Y</li>
<li>U’ = 16 + (224/255) × U</li>
</ul></li>
</ul>
<h4 id="色度降采样">2. 色度降采样</h4>
<p>YUV 在视频中常使用 4:2:0 或 4:2:2
采样，色度数据减少，导致转换时需要插值。比如，4:2:0 下，每 2×2
像素共享一组 U、V 值，转回 RGB
时，缺失的色度值要通过邻近像素估算，可能引入轻微误差。</p>
<h4 id="精度与性能">3. 精度与性能</h4>
<p>公式中的浮点运算在实际中会四舍五入（比如 151.381 取
151），可能导致微小偏差。硬件加速（如 GPU 或
DSP）通常用查表或整数运算优化性能。</p>
<hr />
<h3 id="代码示例">代码示例</h3>
<p>以下是用 C 语言实现的简单转换：</p>
<h4 id="rgb-到-yuv-1">RGB 到 YUV</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rgb_to_yuv</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> r, <span class="type">unsigned</span> <span class="type">char</span> g, <span class="type">unsigned</span> <span class="type">char</span> b, </span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">char</span>* y, <span class="type">unsigned</span> <span class="type">char</span>* u, <span class="type">unsigned</span> <span class="type">char</span>* v)</span> &#123;</span><br><span class="line">    *y = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b);</span><br><span class="line">    <span class="type">int</span> u_temp = (<span class="type">int</span>)(<span class="number">-0.147</span> * r - <span class="number">0.289</span> * g + <span class="number">0.436</span> * b + <span class="number">128</span>);</span><br><span class="line">    <span class="type">int</span> v_temp = (<span class="type">int</span>)(<span class="number">0.615</span> * r - <span class="number">0.515</span> * g - <span class="number">0.100</span> * b + <span class="number">128</span>);</span><br><span class="line">    *u = (<span class="type">unsigned</span> <span class="type">char</span>)(u_temp &lt; <span class="number">0</span> ? <span class="number">0</span> : (u_temp &gt; <span class="number">255</span> ? <span class="number">255</span> : u_temp));</span><br><span class="line">    *v = (<span class="type">unsigned</span> <span class="type">char</span>)(v_temp &lt; <span class="number">0</span> ? <span class="number">0</span> : (v_temp &gt; <span class="number">255</span> ? <span class="number">255</span> : v_temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="yuv-到-rgb-1">YUV 到 RGB</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">yuv_to_rgb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> u, <span class="type">unsigned</span> <span class="type">char</span> v, </span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">char</span>* r, <span class="type">unsigned</span> <span class="type">char</span>* g, <span class="type">unsigned</span> <span class="type">char</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> u_shift = u - <span class="number">128</span>;</span><br><span class="line">    <span class="type">int</span> v_shift = v - <span class="number">128</span>;</span><br><span class="line">    <span class="type">int</span> r_temp = (<span class="type">int</span>)(y + <span class="number">1.140</span> * v_shift);</span><br><span class="line">    <span class="type">int</span> g_temp = (<span class="type">int</span>)(y - <span class="number">0.395</span> * u_shift - <span class="number">0.581</span> * v_shift);</span><br><span class="line">    <span class="type">int</span> b_temp = (<span class="type">int</span>)(y + <span class="number">2.032</span> * u_shift);</span><br><span class="line">    *r = (<span class="type">unsigned</span> <span class="type">char</span>)(r_temp &lt; <span class="number">0</span> ? <span class="number">0</span> : (r_temp &gt; <span class="number">255</span> ? <span class="number">255</span> : r_temp));</span><br><span class="line">    *g = (<span class="type">unsigned</span> <span class="type">char</span>)(g_temp &lt; <span class="number">0</span> ? <span class="number">0</span> : (g_temp &gt; <span class="number">255</span> ? <span class="number">255</span> : g_temp));</span><br><span class="line">    *b = (<span class="type">unsigned</span> <span class="type">char</span>)(b_temp &lt; <span class="number">0</span> ? <span class="number">0</span> : (b_temp &gt; <span class="number">255</span> ? <span class="number">255</span> : b_temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用示例">使用示例</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> r = <span class="number">255</span>, g = <span class="number">128</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> y, u, v;</span><br><span class="line">    rgb_to_yuv(r, g, b, &amp;y, &amp;u, &amp;v);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;YUV: %d, %d, %d\n&quot;</span>, y, u, v); <span class="comment">// 输出约 (151, 54, 219)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> r_back, g_back, b_back;</span><br><span class="line">    yuv_to_rgb(y, u, v, &amp;r_back, &amp;g_back, &amp;b_back);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RGB: %d, %d, %d\n&quot;</span>, r_back, g_back, b_back); <span class="comment">// 约 (255, 128, 0)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="注意事项">注意事项</h3>
<ol type="1">
<li><strong>标准选择</strong>：确保使用正确的标准（BT.601、BT.709
等），否则颜色会偏差。</li>
<li><strong>范围调整</strong>：处理 Studio Range
时要缩放，否则亮度和色彩会不准确。</li>
<li><strong>性能优化</strong>：实时转换（如视频播放）建议用硬件加速（如
OpenGL 着色器）。</li>
<li><strong>误差累积</strong>：多次转换可能放大精度误差，尽量减少不必要的中转。</li>
</ol>
<hr />
<h3 id="总结">总结</h3>
<p>RGB 和 YUV
的互相转化是一个线性过程，核心是通过矩阵运算分离或重组亮度和色度信息。RGB
适合显示，YUV
适合压缩和传输，两者的转换贯穿音视频处理的始终。理解它们的公式和细节，能帮助我们更好地处理颜色相关问题，比如视频编码、图像渲染等。</p>
<h2 id="gop">GOP</h2>
<p><strong>GOP</strong>（Group of
Pictures，图像组）是视频编码中的一个重要概念，特别是在使用
MPEG、H.264、H.265
等基于帧间压缩的视频编码标准时。它指的是由一组连续的视频帧组成的一个单元，这些帧按照特定的顺序排列（包括
I 帧、P 帧和 B 帧），用于实现高效的视频压缩。以下是关于 GOP
的详细解释。</p>
<hr />
<h3 id="gop-的定义">1. GOP 的定义</h3>
<ul>
<li><strong>GOP</strong> 是一组从一个 <strong>I
帧</strong>（关键帧）开始，到下一个 I 帧之前的帧序列。</li>
<li>它包含以下帧类型：
<ul>
<li><strong>I 帧</strong>（Intra-coded
Frame）：帧内编码帧，独立编码，不依赖其他帧。</li>
<li><strong>P 帧</strong>（Predicted Frame）：前向预测帧，依赖前面的 I
帧或 P 帧。</li>
<li><strong>B 帧</strong>（Bi-directional Predicted
Frame）：双向预测帧，依赖前后的 I 帧或 P 帧。</li>
</ul></li>
<li>一个 GOP 通常以 I 帧开始，后面跟着一系列 P 帧和/或 B 帧，直到下一个
I 帧出现。</li>
</ul>
<h4 id="示例-gop-结构">示例 GOP 结构</h4>
<ul>
<li><strong>简单 GOP</strong>（无 B 帧）：<code>I P P P P</code></li>
<li><strong>复杂 GOP</strong>（有 B
帧）：<code>I B B P B B P B B P</code></li>
<li>每个 GOP 是一个独立的压缩单元。</li>
</ul>
<hr />
<h3 id="gop-的组成与长度">2. GOP 的组成与长度</h3>
<ul>
<li><strong>GOP 开始</strong>：总是以 I 帧开始，因为 I
帧是完整图像，可以独立解码。</li>
<li><strong>GOP 长度</strong>：
<ul>
<li>由两个 I 帧之间的帧数决定，通常称为 <strong>GOP Size</strong>。</li>
<li>例如：
<ul>
<li><code>I P P P</code>：GOP 长度 = 4。</li>
<li><code>I B B P B B P</code>：GOP 长度 = 7。</li>
</ul></li>
<li>GOP 长度可以固定（如每 30 帧一个 I 帧），也可以动态调整。</li>
</ul></li>
<li><strong>关键帧间隔（Keyframe Interval）</strong>：
<ul>
<li>GOP 长度通常由关键帧间隔决定，例如在 FFmpeg 中用 <code>-g</code>
参数设置。</li>
<li><code>-g 30</code> 表示每 30 帧一个 I 帧，GOP 长度为 30。</li>
</ul></li>
</ul>
<hr />
<h3 id="gop-的作用">3. GOP 的作用</h3>
<p>GOP 的设计是为了在视频压缩中平衡以下几个方面：</p>
<h4 id="压缩效率">(1) 压缩效率</h4>
<ul>
<li><strong>I 帧</strong> 数据量大，但独立性强。</li>
<li><strong>P 帧</strong> 和 <strong>B 帧</strong>
通过预测减少冗余数据：
<ul>
<li>P 帧参考前一帧。</li>
<li>B 帧参考前后帧，压缩率最高。</li>
</ul></li>
<li>一个长的 GOP（更多 P 和 B 帧）可以显著减少数据量。</li>
</ul>
<h4 id="随机访问">(2) 随机访问</h4>
<ul>
<li><strong>I 帧</strong> 是随机访问的入口点。
<ul>
<li>视频播放器可以从任意 I 帧开始解码（Seek 操作）。</li>
<li>GOP 越短，随机跳转越灵活，但数据量增加。</li>
</ul></li>
</ul>
<h4 id="容错性">(3) 容错性</h4>
<ul>
<li>如果网络传输丢包，解码器可以等到下一个 I 帧恢复。</li>
<li>短 GOP（更多 I 帧）容错性更好，但压缩效率低。</li>
</ul>
<h4 id="延迟控制">(4) 延迟控制</h4>
<ul>
<li><strong>短 GOP</strong>（少或无 B 帧）：延迟低，适合直播。</li>
<li><strong>长 GOP</strong>（多 B 帧）：延迟高，适合点播。</li>
</ul>
<hr />
<h3 id="gop-的类型">4. GOP 的类型</h3>
<p>根据是否包含 B 帧，GOP 可以分为两种类型：</p>
<h4 id="开放式-gopopen-gop">(1) 开放式 GOP（Open GOP）</h4>
<ul>
<li><strong>定义</strong>：B 帧可能参考前一个 GOP 的帧。</li>
<li><strong>特点</strong>：
<ul>
<li>压缩效率更高，因为跨 GOP 预测。</li>
<li>但解码时需要前一个 GOP 的数据，不完全独立。</li>
</ul></li>
<li><strong>适用</strong>：点播视频，追求高压缩率。</li>
</ul>
<h4 id="封闭式-gopclosed-gop">(2) 封闭式 GOP（Closed GOP）</h4>
<ul>
<li><strong>定义</strong>：GOP 内的帧只参考本 GOP 的帧，不跨 GOP。</li>
<li><strong>特点</strong>：
<ul>
<li>每个 GOP 独立，随机访问和容错性更好。</li>
<li>数据量稍大。</li>
</ul></li>
<li><strong>适用</strong>：直播或需要快速切换的场景。</li>
<li><strong>FFmpeg 配置</strong>： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input -c:v libx264 -g 30 -closed_gop 1 output.mp4</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="gop-在实际中的例子">5. GOP 在实际中的例子</h3>
<h4 id="直播场景">直播场景</h4>
<ul>
<li><strong>需求</strong>：低延迟，快速恢复。</li>
<li><strong>GOP 结构</strong>：<code>I P P P</code>（短 GOP，无 B
帧）。</li>
<li><strong>配置</strong>： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input -c:v libx264 -profile:v baseline -g 30 -tune zerolatency output.mp4</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="点播场景">点播场景</h4>
<ul>
<li><strong>需求</strong>：高压缩率，画质优先。</li>
<li><strong>GOP 结构</strong>：<code>I B B P B B P</code>（长 GOP，多 B
帧）。</li>
<li><strong>配置</strong>： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input -c:v libx264 -g 60 -bf 2 -b:v 2M output.mp4</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="gop-可视化">GOP 可视化</h4>
<p>假设帧率为 30fps： - <strong>GOP = I P P P</strong>（长度 4）： -
时长：4 / 30 = 0.133 秒。 - <strong>GOP = I B B P B B P</strong>（长度
7）： - 时长：7 / 30 = 0.233 秒。</p>
<hr />
<h3 id="gop-的优缺点">6. GOP 的优缺点</h3>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>短 GOP（如 I P P）</th>
<th>长 GOP（如 I B B P B B P）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>压缩效率</strong></td>
<td>低（更多 I 帧）</td>
<td>高（更多 B 帧）</td>
</tr>
<tr class="even">
<td><strong>延迟</strong></td>
<td>低（无需等待未来帧）</td>
<td>高（B 帧需前后参考）</td>
</tr>
<tr class="odd">
<td><strong>容错性</strong></td>
<td>高（I 帧频繁）</td>
<td>低（I 帧少）</td>
</tr>
<tr class="even">
<td><strong>随机访问</strong></td>
<td>快（I 帧多）</td>
<td>慢（I 帧少）</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="总结-1">7. 总结</h3>
<ul>
<li><strong>GOP</strong> 是视频编码中一组帧的集合，以 I 帧开始，包含 P
和 B 帧。</li>
<li><strong>作用</strong>：通过帧间预测提高压缩效率，同时支持随机访问和容错。</li>
<li><strong>选择</strong>：
<ul>
<li>短 GOP：直播、低延迟场景。</li>
<li>长 GOP：点播、高压缩场景。</li>
</ul></li>
</ul>
<h2 id="视频播放-low-latency">视频播放 <strong>Low Latency</strong></h2>
<p>在视频播放中实现 <strong>Low Latency（低延迟）</strong>
是关键需求，尤其是在直播、实时通信（如视频会议）或交互式应用（如云游戏）中。低延迟意味着从视频数据生成到播放的时间尽可能短。以下是实现视频低延迟加载的原理、技术方法及优化策略。</p>
<hr />
<h3 id="低延迟加载的核心原理">1. 低延迟加载的核心原理</h3>
<p>低延迟视频加载的目标是减少从数据源到显示的端到端延迟，主要涉及以下几个阶段：
- <strong>采集与编码</strong>：减少编码时间。 -
<strong>传输</strong>：降低网络传输延迟。 -
<strong>缓冲</strong>：最小化播放器缓冲区。 -
<strong>解码与渲染</strong>：加速解码和显示过程。</p>
<p>实现低延迟需要在这几个阶段进行优化，同时权衡画质、稳定性和延迟。</p>
<hr />
<h3 id="实现低延迟加载的技术方法">2. 实现低延迟加载的技术方法</h3>
<h4 id="优化编码">(1) 优化编码</h4>
<ul>
<li><strong>低延迟编码配置</strong>：
<ul>
<li>使用 <strong>H.264/H.265</strong> 的低延迟模式，设置
<code>profile</code> 为 <code>baseline</code> 或
<code>main</code>，避免复杂的预测（如 B 帧）。</li>
<li>设置 <code>keyframe interval（关键帧间隔）</code> 为较小的值（如 1-2
秒），以减少等待完整 GOP（Group of Pictures）的延迟。</li>
<li>禁用 B 帧（双向预测帧），只使用 I 帧和 P 帧，因为 B
帧需要未来的帧数据，会增加延迟。</li>
<li>示例（FFmpeg）： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input -c:v libx264 -profile:v baseline -g 30 -b:v 2M -tune zerolatency output.mp4</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-tune zerolatency</code>：启用零延迟优化。</li>
<li><code>-g 30</code>：每 30 帧一个关键帧。</li>
</ul></li>
</ul></li>
<li><strong>实时编码</strong>：
<ul>
<li>使用硬件编码器（如 NVIDIA NVENC、Intel Quick
Sync），比软件编码快得多。</li>
</ul></li>
</ul>
<h4 id="优化传输">(2) 优化传输</h4>
<ul>
<li><strong>选择低延迟协议</strong>：
<ul>
<li><strong>RTMP</strong>：实时消息传输协议，延迟通常在 1-3
秒，适合直播。</li>
<li><strong>WebRTC</strong>：超低延迟（&lt;500ms），用于实时通信，支持
UDP 传输。</li>
<li><strong>SRT（Secure Reliable Transport）</strong>：基于 UDP
的低延迟协议，适合不稳定网络。</li>
<li><strong>HLS Low-Latency（LL-HLS）</strong>：HLS
的低延迟版本，通过缩短分片长度（&lt;1s）和预加载分片实现延迟 2-5
秒。</li>
</ul></li>
<li><strong>减少分片长度</strong>：
<ul>
<li>在 HLS 或 DASH 中，将分片时长缩短（例如从 10s 减到
1s），客户端可以更快获取新数据。</li>
<li>LL-HLS 示例： <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hls_segment_duration</span> <span class="number">1s</span>;</span><br><span class="line"><span class="attribute">hls_playlist_length</span> <span class="number">3s</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>使用 UDP 而非 TCP</strong>：
<ul>
<li>TCP 的重传机制会增加延迟，而 UDP 丢包后直接跳过，适合低延迟场景（如
WebRTC）。</li>
</ul></li>
</ul>
<h4 id="优化播放器缓冲">(3) 优化播放器缓冲</h4>
<ul>
<li><strong>减少缓冲区大小</strong>：
<ul>
<li>默认播放器（如
ExoPlayer、AVPlayer）会缓冲几秒数据以保证流畅播放，低延迟场景需要将缓冲时间减到最小（例如
100-500ms）。</li>
<li>ExoPlayer 示例： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LoadControl</span> <span class="variable">loadControl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultLoadControl</span>.Builder()</span><br><span class="line">    .setBufferDurationsMs(<span class="number">500</span>, <span class="number">1000</span>, <span class="number">250</span>, <span class="number">500</span>) <span class="comment">// minBuffer, maxBuffer, bufferForPlayback, bufferForPlaybackAfterRebuffer</span></span><br><span class="line">    .build();</span><br><span class="line"><span class="type">SimpleExoPlayer</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleExoPlayer</span>.Builder(context)</span><br><span class="line">    .setLoadControl(loadControl)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>动态自适应缓冲</strong>：
<ul>
<li>根据网络状况动态调整缓冲大小，网络良好时减少缓冲，网络差时略增缓冲以避免卡顿。</li>
</ul></li>
</ul>
<h4 id="优化解码与渲染">(4) 优化解码与渲染</h4>
<ul>
<li><strong>硬件解码</strong>：
<ul>
<li>使用 GPU 加速解码（如 Android 的 MediaCodec、iOS 的
VideoToolbox），比软件解码（FFmpeg）快数倍。</li>
<li>示例（MediaCodec）： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MediaCodec</span> <span class="variable">codec</span> <span class="operator">=</span> MediaCodec.createDecoderByType(<span class="string">&quot;video/avc&quot;</span>);</span><br><span class="line">codec.configure(format, surface, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">codec.setVideoScalingMode(MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>实时渲染</strong>：
<ul>
<li>避免帧缓冲，直接将解码后的帧送至显示层（如
SurfaceView、TextureView）。</li>
<li>优化渲染管线，使用 OpenGL 或 Vulkan 减少 CPU-GPU 同步开销。</li>
</ul></li>
<li><strong>丢帧策略</strong>：
<ul>
<li>如果解码跟不上播放速度，主动丢弃非关键帧（P 帧），保留 I
帧，确保实时性。</li>
</ul></li>
</ul>
<h4 id="音画同步调整">(5) 音画同步调整</h4>
<ul>
<li><strong>以音频为主时钟</strong>：
<ul>
<li>低延迟场景中，音频缓冲也要尽量小（如 AudioTrack
的最小缓冲模式）。</li>
<li>Android 示例： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> AudioTrack.getMinBufferSize(<span class="number">44100</span>, AudioFormat.CHANNEL_OUT_STEREO, AudioFormat.ENCODING_PCM_16BIT);</span><br><span class="line"><span class="type">AudioTrack</span> <span class="variable">audioTrack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AudioTrack</span>(AudioManager.STREAM_MUSIC, <span class="number">44100</span>, AudioFormat.CHANNEL_OUT_STEREO, AudioFormat.ENCODING_PCM_16BIT, bufferSize, AudioTrack.MODE_STREAM);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>动态调整</strong>：
<ul>
<li>如果视频超前音频，延迟视频帧渲染；如果视频滞后，丢帧追赶。</li>
</ul></li>
</ul>
<hr />
<h3 id="具体实现示例">3. 具体实现示例</h3>
<h4 id="使用-webrtc">使用 WebRTC</h4>
<ul>
<li><strong>场景</strong>：超低延迟直播或视频通话。</li>
<li><strong>实现</strong>：
<ol type="1">
<li>服务端使用 WebRTC SFU（Selective Forwarding Unit）分发视频流。</li>
<li>客户端使用 WebRTC SDK（Android/iOS/Web）。</li>
<li>配置低延迟参数： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PeerConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> PeerConnectionFactory.builder().createPeerConnectionFactory();</span><br><span class="line"><span class="type">VideoCodecInfo</span> <span class="variable">codec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoCodecInfo</span>(<span class="string">&quot;H264&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"><span class="type">VideoEncoderFactory</span> <span class="variable">encoderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultVideoEncoderFactory</span>(eglBase.getEglBaseContext(), <span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
<h4 id="使用-exoplayer-ll-hls">使用 ExoPlayer + LL-HLS</h4>
<ul>
<li><strong>场景</strong>：低延迟 HTTP 直播。</li>
<li><strong>实现</strong>：
<ol type="1">
<li>服务端配置 LL-HLS（分片时长 1s）。</li>
<li>客户端减少缓冲： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HlsMediaSource</span> <span class="variable">hlsMediaSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HlsMediaSource</span>.Factory(dataSourceFactory)</span><br><span class="line">    .setAllowChunklessPreparation(<span class="literal">true</span>)</span><br><span class="line">    .createMediaSource(MediaItem.fromUri(uri));</span><br><span class="line">player.setMediaSource(hlsMediaSource);</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
<h4 id="使用-ffmpeg">使用 FFmpeg</h4>
<ul>
<li><strong>场景</strong>：自定义播放器。</li>
<li><strong>实现</strong>：
<ol type="1">
<li>配置低延迟解码： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">av_dict_set(&amp;options, <span class="string">&quot;low_delay&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">av_dict_set(&amp;options, <span class="string">&quot;buffer_size&quot;</span>, <span class="string">&quot;1024&quot;</span>, <span class="number">0</span>); <span class="comment">// 减小缓冲</span></span><br><span class="line">avformat_open_input(&amp;fmt_ctx, url, <span class="literal">NULL</span>, &amp;options);</span><br></pre></td></tr></table></figure></li>
<li>实时渲染，丢弃延迟帧。</li>
</ol></li>
</ul>
<hr />
<h3 id="常见问题及优化">4. 常见问题及优化</h3>
<h4 id="网络抖动">(1) 网络抖动</h4>
<ul>
<li><strong>问题</strong>：网络不稳定导致延迟或卡顿。</li>
<li><strong>解决</strong>：使用 FEC（前向纠错）或
ARQ（自动重传请求，但谨慎使用以避免增加延迟）。</li>
</ul>
<h4 id="解码性能不足">(2) 解码性能不足</h4>
<ul>
<li><strong>问题</strong>：高分辨率视频解码慢。</li>
<li><strong>解决</strong>：降低分辨率或帧率（如
720p@30fps），优先使用硬件解码。</li>
</ul>
<h4 id="缓冲不足导致卡顿">(3) 缓冲不足导致卡顿</h4>
<ul>
<li><strong>问题</strong>：缓冲过小，网络波动时播放中断。</li>
<li><strong>解决</strong>：动态调整缓冲（例如
100ms-1s），结合用户体验优化。</li>
</ul>
<hr />
<h3 id="总结-2">5. 总结</h3>
<p>实现低延迟视频加载需要从<strong>编码、传输、缓冲、解码与渲染</strong>全链路优化：
- <strong>编码</strong>：低延迟配置，无 B 帧。 -
<strong>传输</strong>：WebRTC、SRT 或 LL-HLS。 -
<strong>播放器</strong>：最小缓冲，硬件加速。 -
<strong>同步</strong>：动态调整音视频播放速度。</p>
<h2 id="音画同步">音画同步</h2>
<p>在播放器中实现<strong>音画同步</strong>（即音频和视频的同步播放）是一个复杂但核心的功能，确保用户体验流畅无延迟。音画不同步可能是视频卡顿、音频延迟或两者时间戳未对齐导致的。以下是播放器实现音画同步的原理、技术方法及常见解决方案。</p>
<hr />
<h3 id="音画同步的基本原理">1. 音画同步的基本原理</h3>
<p>音画同步的核心是确保音频和视频帧在正确的时间播放。这通常依赖于以下几个关键概念：</p>
<h4 id="时间戳timestamp">时间戳（Timestamp）</h4>
<ul>
<li>视频和音频数据在编码时会被打上时间戳（通常是
<strong>PTS</strong>，Presentation Time Stamp，表示展示时间）。</li>
<li>播放器通过比较当前播放时间（以某个参考时钟为准）与
PTS，决定何时渲染视频帧或播放音频样本。</li>
</ul>
<h4 id="参考时钟master-clock">参考时钟（Master Clock）</h4>
<ul>
<li>播放器需要一个统一的参考时钟来协调音频和视频的播放。</li>
<li>常见的参考时钟来源：
<ul>
<li><strong>音频时钟</strong>：以音频播放进度作为主时钟（最常用，因为人耳对音频延迟更敏感）。</li>
<li><strong>视频时钟</strong>：以视频帧渲染进度为主时钟。</li>
<li><strong>外部时钟</strong>：独立于音视频的系统时钟（如系统时间）。</li>
</ul></li>
</ul>
<h4 id="同步机制">同步机制</h4>
<ul>
<li>播放器会根据参考时钟，调整音频或视频的播放速度：
<ul>
<li>如果视频超前，延迟渲染视频帧。</li>
<li>如果视频滞后，丢帧或加速渲染。</li>
<li>如果音频超前或滞后，调整音频播放速度或丢弃/填充样本。</li>
</ul></li>
</ul>
<hr />
<h3 id="实现音画同步的步骤">2. 实现音画同步的步骤</h3>
<p>以下是一个典型的播放器（如基于 FFmpeg 或 Android
MediaPlayer）实现音画同步的流程：</p>
<h4 id="解复用demuxing">(1) 解复用（Demuxing）</h4>
<ul>
<li>从媒体文件中分离出音频流和视频流，获取各自的 PTS。</li>
<li>例如，使用 FFmpeg 的 <code>avformat_open_input</code> 和
<code>av_read_frame</code> 读取音视频包。</li>
</ul>
<h4 id="解码decoding">(2) 解码（Decoding）</h4>
<ul>
<li>将压缩的音频和视频数据解码为原始数据（PCM 音频样本和 YUV/RGB
视频帧）。</li>
<li>解码时保留 PTS，供后续同步使用。</li>
</ul>
<h4 id="选择参考时钟">(3) 选择参考时钟</h4>
<ul>
<li><strong>以音频为主时钟</strong>（推荐）：
<ul>
<li>音频播放是连续的，采样率固定（例如
44.1kHz），可以用播放的样本数计算当前时间。</li>
<li>计算公式：<code>audio_time = samples_played / sample_rate</code>。</li>
</ul></li>
<li><strong>以视频为主时钟</strong>：
<ul>
<li>视频帧率固定（例如
30fps），用帧数计算时间：<code>video_time = frame_count / frame_rate</code>。</li>
</ul></li>
<li><strong>外部时钟</strong>：
<ul>
<li>使用系统时间（如
<code>System.currentTimeMillis()</code>），但需要校准音视频设备的延迟。</li>
</ul></li>
</ul>
<h4 id="同步逻辑">(4) 同步逻辑</h4>
<ul>
<li><strong>比较 PTS 和参考时钟</strong>：
<ul>
<li>对于视频帧：<code>if (video_pts - master_clock &gt; threshold)</code>
则延迟渲染；<code>if (video_pts - master_clock &lt; -threshold)</code>
则丢帧。</li>
<li>对于音频：通常不丢帧，而是调整播放速度（如变速不变调）或插入静音。</li>
</ul></li>
<li><strong>阈值（threshold）</strong>：
<ul>
<li>通常设为 20-50ms，因为人耳和眼睛对小于这个范围的延迟不敏感。</li>
</ul></li>
</ul>
<h4 id="渲染">(5) 渲染</h4>
<ul>
<li><strong>视频渲染</strong>：将解码后的帧送至显示设备（如
OpenGL、SurfaceView），根据 PTS 和时钟决定渲染时机。</li>
<li><strong>音频渲染</strong>：将 PCM 数据送至音频设备（如
AudioTrack），通常由硬件驱动连续播放。</li>
</ul>
<hr />
<h3 id="具体实现方法">3. 具体实现方法</h3>
<p>以下是几种常见播放器框架的实现方式：</p>
<h4 id="ffmpeg-sdl">(1) FFmpeg + SDL</h4>
<ul>
<li><strong>流程</strong>：
<ol type="1">
<li>用 FFmpeg 解复用和解码音视频。</li>
<li>用 SDL
播放音频（SDL_OpenAudio）和渲染视频（SDL_CreateWindow）。</li>
<li>以音频时钟为主，计算当前播放时间。</li>
<li>在视频渲染线程中，比较 <code>video_pts</code> 和
<code>audio_time</code>，决定延迟或丢帧。</li>
</ol></li>
<li><strong>伪代码</strong>： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">get_audio_clock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> audio_samples_played / sample_rate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">video_refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> audio_time = get_audio_clock();</span><br><span class="line">    <span class="type">double</span> delay = video_pts - audio_time;</span><br><span class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0.05</span>) &#123;</span><br><span class="line">        sleep(delay); <span class="comment">// 延迟渲染</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delay &lt; <span class="number">-0.05</span>) &#123;</span><br><span class="line">        skip_frame(); <span class="comment">// 丢帧</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        render_frame(); <span class="comment">// 正常渲染</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="android-mediacodec-audiotrack">(2) Android MediaCodec +
AudioTrack</h4>
<ul>
<li><strong>流程</strong>：
<ol type="1">
<li>用 <code>MediaExtractor</code> 分离音视频流。</li>
<li>用 <code>MediaCodec</code> 解码视频到 <code>Surface</code>，音频到
<code>AudioTrack</code>。</li>
<li>用 <code>AudioTrack.getPlaybackHeadPosition()</code>
获取音频播放进度，计算参考时钟。</li>
<li>用 <code>MediaCodec.releaseOutputBuffer</code> 的
<code>presentationTimeUs</code> 参数控制视频帧渲染时机。</li>
</ol></li>
<li><strong>伪代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">getAudioTimeUs</span><span class="params">(AudioTrack track)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> track.getPlaybackHeadPosition() * <span class="number">1000000L</span> / sampleRate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">renderVideo</span><span class="params">(MediaCodec codec, <span class="type">long</span> videoPtsUs)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">audioTimeUs</span> <span class="operator">=</span> getAudioTimeUs(audioTrack);</span><br><span class="line">    <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> videoPtsUs - audioTimeUs;</span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">50000</span>) &#123;</span><br><span class="line">        Thread.sleep(diff / <span class="number">1000</span>); <span class="comment">// 延迟</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &lt; -<span class="number">50000</span>) &#123;</span><br><span class="line">        codec.releaseOutputBuffer(bufferIndex, <span class="literal">false</span>); <span class="comment">// 丢帧</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        codec.releaseOutputBuffer(bufferIndex, <span class="literal">true</span>); <span class="comment">// 渲染</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="exoplayer">(3) ExoPlayer</h4>
<ul>
<li>ExoPlayer 是 Android 上强大的播放器库，默认已实现音画同步。</li>
<li><strong>实现</strong>：
<ul>
<li>使用 <code>SimpleExoPlayer</code>，内部自动以音频为主时钟。</li>
<li>可通过 <code>PlaybackParameters</code> 调整播放速度，确保同步。</li>
</ul></li>
<li><strong>代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleExoPlayer</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleExoPlayer</span>.Builder(context).build();</span><br><span class="line">player.setMediaItem(MediaItem.fromUri(uri));</span><br><span class="line">player.prepare();</span><br><span class="line">player.play();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="常见问题及优化-1">4. 常见问题及优化</h3>
<h4 id="音频延迟">(1) 音频延迟</h4>
<ul>
<li><strong>原因</strong>：音频设备缓冲区过大。</li>
<li><strong>解决</strong>：减小 <code>AudioTrack</code>
缓冲区大小，或使用低延迟音频 API（如 AAudio）。</li>
</ul>
<h4 id="视频丢帧">(2) 视频丢帧</h4>
<ul>
<li><strong>原因</strong>：解码或渲染速度跟不上。</li>
<li><strong>解决</strong>：降低分辨率、使用硬件解码、优化渲染线程。</li>
</ul>
<h4 id="音画不同步阈值">(3) 音画不同步阈值</h4>
<ul>
<li><strong>优化</strong>：动态调整阈值（例如
20ms-100ms），根据设备性能和用户感知平衡。</li>
</ul>
<h4 id="变速播放">(4) 变速播放</h4>
<ul>
<li><strong>实现</strong>：使用音频变速算法（如 Sonic 或
SoundTouch），在不丢帧的情况下调整播放速度。</li>
</ul>
<hr />
<h3 id="总结-3">5. 总结</h3>
<ul>
<li><strong>核心</strong>：以音频为主时钟，通过 PTS
和参考时钟比较实现同步。</li>
<li><strong>关键技术</strong>：时间戳管理、缓冲控制、渲染时机调整。</li>
<li><strong>工具</strong>：FFmpeg、MediaCodec、ExoPlayer
等都提供了不同层次的同步支持。</li>
</ul>
<p>实现音画同步需要根据具体场景（实时流、点播、设备性能）选择合适的策略。</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>音视频SDK开发要掌握哪些技能</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91SDK%E5%BC%80%E5%8F%91%E8%A6%81%E6%8E%8C%E6%8F%A1%E5%93%AA%E4%BA%9B%E6%8A%80%E8%83%BD.html</url>
    <content><![CDATA[<p>“<strong>音视频 SDK 开发</strong>”是一个高度综合的工程领域，融合了
<strong>系统层、算法层、平台层、业务层</strong> 四个维度的技能。</p>
<p>系统地分成三个部分来讲：</p>
<blockquote>
<p><strong>① 必备语言与技术栈</strong> <strong>②
核心能力与模块划分</strong> <strong>③
项目练习路线（由浅入深）</strong></p>
</blockquote>
<hr />
<h2 id="一语言与技术栈总览">🧠 一、语言与技术栈总览</h2>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 38%" />
<col style="width: 20%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">层级</th>
<th style="text-align: left;">语言/工具</th>
<th style="text-align: left;">作用</th>
<th style="text-align: left;">重点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>底层性能层</strong></td>
<td style="text-align: left;"><strong>C / C++</strong></td>
<td
style="text-align: left;">实现音视频核心处理（编解码、渲染、封装、网络传输）</td>
<td
style="text-align: left;">内存管理、多线程、锁、智能指针、RAII、FFmpeg/NDK</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>跨平台层</strong></td>
<td style="text-align: left;"><strong>JNI / NDK / Objective-C /
Swift</strong></td>
<td style="text-align: left;">与 Android / iOS 交互，桥接 SDK 与系统
API</td>
<td style="text-align: left;">JNI 生命周期、JNI 层音视频 buffer
传递</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>上层控制层</strong></td>
<td style="text-align: left;"><strong>Kotlin / Java / Swift / Dart /
JS</strong></td>
<td style="text-align: left;">负责 SDK API 封装、事件回调、UI
层接口</td>
<td style="text-align: left;">熟悉 ExoPlayer / AVPlayer / Flutter plugin
/ WebRTC JS API</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>脚本与构建</strong></td>
<td style="text-align: left;"><strong>Python / Shell / CMake /
Gradle</strong></td>
<td style="text-align: left;">构建系统、自动化打包、CI/CD</td>
<td style="text-align: left;">CMakeLists.txt、Gradle AAR 打包、FFmpeg
构建脚本</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>并行与异步</strong></td>
<td style="text-align: left;"><strong>C++17 Thread / std::future /
coroutines / Kotlin 协程 / RxJava</strong></td>
<td style="text-align: left;">异步渲染、解码线程、数据流控制</td>
<td style="text-align: left;">主从线程模型、BufferQueue、渲染队列</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>图形渲染</strong></td>
<td style="text-align: left;"><strong>OpenGL ES / Metal / Vulkan /
EGL</strong></td>
<td style="text-align: left;">GPU 图像处理、滤镜、YUV 转 RGB、Surface
渲染</td>
<td style="text-align: left;">FBO、着色器、EGL context、纹理映射</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>网络传输</strong></td>
<td
style="text-align: left;"><strong>TCP/UDP/RTP/RTMP/HTTP-FLV/HLS/WebRTC</strong></td>
<td style="text-align: left;">实现流媒体上传与播放</td>
<td style="text-align: left;">Socket、延迟控制、抖动缓冲、RTP 打包</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>算法与多媒体基础</strong></td>
<td style="text-align: left;"><strong>FFmpeg / libyuv / OpenCV / Speex /
Opus / WebRTC Audio</strong></td>
<td style="text-align: left;">音视频编解码与信号处理</td>
<td style="text-align: left;">帧结构、PTS/DTS、Resample、AEC/NS、YUV
缩放</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="二核心能力模块图">🧩 二、核心能力模块图</h2>
<p>可以把音视频 SDK 拆成以下八大模块，每个模块都是一个学习阶段：</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 26%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">模块</th>
<th style="text-align: left;">目标</th>
<th style="text-align: left;">技术关键词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>1. 数据采集</strong></td>
<td style="text-align: left;">从摄像头、麦克风、文件读取数据</td>
<td style="text-align: left;">Camera2 / AVFoundation / AudioRecord /
AudioUnit</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>2. 编解码</strong></td>
<td style="text-align: left;">压缩与还原视频、音频</td>
<td style="text-align: left;">MediaCodec / FFmpeg / OpenH264 / Opus</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>3. 同步控制</strong></td>
<td style="text-align: left;">保证音画同步</td>
<td style="text-align: left;">时间戳 PTS/DTS、时钟同步、丢帧策略</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>4. 渲染显示</strong></td>
<td style="text-align: left;">显示到屏幕（Surface / Texture）</td>
<td style="text-align: left;">OpenGL ES / EGL / SurfaceTexture /
FBO</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>5. 网络传输</strong></td>
<td style="text-align: left;">采集端推流、播放端拉流</td>
<td style="text-align: left;">RTMP / RTP / HTTP-FLV / HLS / QUIC</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>6. 播放控制</strong></td>
<td style="text-align: left;">播放器状态机、缓冲策略、首帧优化</td>
<td style="text-align: left;">ExoPlayer / Media3 / 自研播放器</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>7. 特效与后处理</strong></td>
<td style="text-align: left;">美颜、滤镜、贴纸、字幕</td>
<td style="text-align: left;">Shader、GPUImage、libyuv、字幕绘制</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>8. 封装与 SDK API</strong></td>
<td style="text-align: left;">对上层 App 提供统一接口</td>
<td style="text-align: left;">C++ 封装、JNI 桥接、插件化架构</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="三项目练习路线循序渐进">🧱 三、项目练习路线（循序渐进）</h2>
<p>下面是一条实战路线，从<strong>基础理解 → 自研组件 → SDK
架构设计</strong>逐步升级。</p>
<hr />
<h3 id="阶段-1多媒体入门基础"><strong>阶段
1：多媒体入门基础</strong></h3>
<p><strong>目标</strong>：理解音视频数据流的基本组成。</p>
<p><strong>练习项目：</strong></p>
<ol type="1">
<li>用 FFmpeg 命令行实现视频转码、剪辑、抽帧。</li>
<li>写个简单 C++ 程序：调用 FFmpeg
打印视频帧信息（pts、codec、fps）。</li>
<li>学习 YUV 图像格式，写程序把 NV21 → RGB 保存为 PNG。</li>
</ol>
<p><strong>掌握重点</strong>：</p>
<ul>
<li>YUV / PCM 数据格式</li>
<li>帧率、分辨率、码率、GOP、PTS/DTS 的概念</li>
<li>FFmpeg API 基础（avformat_open_input、avcodec_send_packet 等）</li>
</ul>
<hr />
<h3 id="阶段-2播放器内核实现exoplayer-自研"><strong>阶段
2：播放器内核实现（ExoPlayer / 自研）</strong></h3>
<p><strong>目标</strong>：从输入流到屏幕显示。</p>
<p><strong>练习项目：</strong></p>
<ol type="1">
<li><p><strong>Android 自研播放器 Demo：</strong></p>
<ul>
<li>使用 MediaExtractor + MediaCodec 解码本地 mp4；</li>
<li>用 SurfaceView 或 TextureView 显示。</li>
</ul></li>
<li><p><strong>首帧优化实验：</strong></p>
<ul>
<li>比较 ExoPlayer 默认启动 vs 自研管线；</li>
<li>记录首帧耗时，尝试预解码或提前创建 Surface。</li>
</ul></li>
</ol>
<p><strong>掌握重点</strong>：</p>
<ul>
<li>Surface / SurfaceTexture / EGL / OpenGL 渲染链路；</li>
<li>ExoPlayer 的 Renderer / Decoder / LoadControl 模块；</li>
<li>首帧优化、缓冲策略、自适应码率（ABR）基础。</li>
</ul>
<hr />
<h3 id="阶段-3音频处理与同步"><strong>阶段
3：音频处理与同步</strong></h3>
<p><strong>目标</strong>：理解音画同步与音频处理管线。</p>
<p><strong>练习项目：</strong></p>
<ol type="1">
<li>用 AudioRecord + OpenSL ES / AudioTrack 实现录播与播放。</li>
<li>加入延迟队列，让视频帧与音频帧对齐（PTS 同步）。</li>
<li>加入回声消除（AEC）或噪声抑制（NS）模块（使用 WebRTC Audio
Processing）。</li>
</ol>
<p><strong>掌握重点</strong>：</p>
<ul>
<li>采样率、声道、位宽；</li>
<li>回音消除、降噪；</li>
<li>A/V 同步算法（时间戳、系统时钟、丢帧策略）。</li>
</ul>
<hr />
<h3 id="阶段-4实时流媒体"><strong>阶段 4：实时流媒体</strong></h3>
<p><strong>目标</strong>：实现推流与拉流。</p>
<p><strong>练习项目：</strong></p>
<ol type="1">
<li>用 FFmpeg 实现本地摄像头 RTMP 推流（C++）。</li>
<li>Android 端用 ExoPlayer / 自研播放器播放流媒体。</li>
<li>分析延迟、卡顿、缓冲区大小的关系。</li>
</ol>
<p><strong>掌握重点</strong>：</p>
<ul>
<li>RTMP / RTP / HLS / HTTP-FLV 协议；</li>
<li>网络抖动缓冲；</li>
<li>延迟优化（首帧、码率、自适应缓冲）。</li>
</ul>
<hr />
<h3 id="阶段-5渲染与特效"><strong>阶段 5：渲染与特效</strong></h3>
<p><strong>目标</strong>：实现视频滤镜、美颜、叠加。</p>
<p><strong>练习项目：</strong></p>
<ol type="1">
<li>用 OpenGL ES 实现灰度滤镜、模糊滤镜；</li>
<li>用 FBO 实现多层滤镜合成；</li>
<li>视频帧叠加文字、图片水印；</li>
<li>研究 SubtitlePainter（Media3 UI 模块）源码了解字幕渲染。</li>
</ol>
<p><strong>掌握重点</strong>：</p>
<ul>
<li>OpenGL ES 纹理、着色器、FBO；</li>
<li>libyuv 图像旋转与缩放；</li>
<li>GPU 滤镜链。</li>
</ul>
<hr />
<h3 id="阶段-6sdk-封装与架构"><strong>阶段 6：SDK
封装与架构</strong></h3>
<p><strong>目标</strong>：封装一个可复用的音视频 SDK。</p>
<p><strong>练习项目：</strong></p>
<ol type="1">
<li>设计统一的
<code>PlayerManager</code>、<code>RenderView</code>、<code>MediaItem</code>。</li>
<li>对外暴露简单接口：<code>prepare() / play() / pause() / release()</code>。</li>
<li>支持插件化：日志、埋点、滤镜、License 验证模块可热插拔。</li>
<li>构建 Demo App 调用 SDK 播放本地与网络视频。</li>
</ol>
<p><strong>掌握重点</strong>：</p>
<ul>
<li>JNI 封装：C++ ↔︎ Kotlin；</li>
<li>跨模块依赖管理（Gradle、CMake）；</li>
<li>AAR 构建、CI/CD 流程；</li>
<li>插件式架构与责任链设计模式。</li>
</ul>
<hr />
<h3 id="阶段-7高级进阶方向选择性深入"><strong>阶段
7：高级进阶方向（选择性深入）</strong></h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">方向</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>实时通信（RTC）</strong></td>
<td style="text-align: left;">WebRTC 原理、延迟优化、带宽自适应</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>云端转码与分发</strong></td>
<td style="text-align: left;">FFmpeg + GPU 硬编/软编、CDN 分发</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>AI + 视频处理</strong></td>
<td style="text-align: left;">人脸检测、美颜、手势识别、超分辨率</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>多路播放与拼接</strong></td>
<td style="text-align: left;">多 Surface / FBO 合成 / 画中画</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>播放器内核优化</strong></td>
<td style="text-align: left;">缓冲策略、线程模型、性能分析</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="四学习建议与进阶路线图">🧭 四、学习建议与进阶路线图</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">阶段 1：多媒体基础 →  </span><br><span class="line">阶段 2：播放解码 →  </span><br><span class="line">阶段 3：音频同步 →  </span><br><span class="line">阶段 4：推流传输 →  </span><br><span class="line">阶段 5：渲染特效 →  </span><br><span class="line">阶段 6：SDK 封装 →  </span><br><span class="line">阶段 7：AI/RTC/云服务方向拓展</span><br></pre></td></tr></table></figure>
<p>建议你按照每个阶段完成一个 <strong>可运行 Demo 项目</strong>， 每个
Demo 尽量包含：</p>
<ul>
<li>完整的编译链路（C++ + Android）</li>
<li>代码结构图（模块划分）</li>
<li>README 与测试用例</li>
</ul>
<hr />
<h1 id="音视频-sdk-开发-12-周全路线图">🎯 音视频 SDK 开发 12
周全路线图</h1>
<blockquote>
<p>面向 Android 平台开发者（Kotlin + C++ + NDK + OpenGL ES），目标是在
12 周内完成从底层解码 → 渲染 → 推流 → SDK 封装 的完整体系。</p>
</blockquote>
<hr />
<h2 id="总体阶段划分">🧩 总体阶段划分</h2>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">阶段</th>
<th style="text-align: left;">周数</th>
<th style="text-align: left;">目标</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>阶段 1</strong></td>
<td style="text-align: left;">第 1–2 周</td>
<td style="text-align: left;">夯实多媒体与 C++/NDK 基础</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>阶段 2</strong></td>
<td style="text-align: left;">第 3–4 周</td>
<td style="text-align: left;">熟悉解码与播放（ExoPlayer /
MediaCodec）</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>阶段 3</strong></td>
<td style="text-align: left;">第 5–6 周</td>
<td style="text-align: left;">自研播放器（含 OpenGL 渲染管线）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>阶段 4</strong></td>
<td style="text-align: left;">第 7–8 周</td>
<td style="text-align: left;">音频采集与播放 + 音画同步</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>阶段 5</strong></td>
<td style="text-align: left;">第 9–10 周</td>
<td style="text-align: left;">推流与实时传输（RTMP/HTTP-FLV）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>阶段 6</strong></td>
<td style="text-align: left;">第 11–12 周</td>
<td style="text-align: left;">SDK 封装、插件化设计、优化与发布</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="第-12-周多媒体与-ndk-基础">📘 第 1–2 周：多媒体与 NDK 基础</h2>
<h3 id="目标">🎯 目标</h3>
<p>掌握 C/C++、NDK 构建、FFmpeg 基础 API、YUV/PCM 数据结构。</p>
<h3 id="项目任务">🧱 项目任务</h3>
<ol type="1">
<li>使用 FFmpeg 打印视频帧信息（PTS、DTS、分辨率、时长）</li>
<li>用 C++ 读取 YUV 文件并保存成 PNG</li>
<li>用 JNI 调用 FFmpeg，在 Android 输出视频元信息</li>
</ol>
<h3 id="代码产出结构">📂 代码产出结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MediaIntro/</span><br><span class="line"> ├── app/</span><br><span class="line"> │   └── MainActivity.kt</span><br><span class="line"> ├── native/</span><br><span class="line"> │   ├── CMakeLists.txt</span><br><span class="line"> │   └── ffmpeg_info.cpp</span><br></pre></td></tr></table></figure>
<h3 id="能力提升">🚀 能力提升</h3>
<ul>
<li>掌握 JNI 基础调用</li>
<li>理解 YUV / PCM 数据流</li>
<li>熟悉 FFmpeg avformat/avcodec 基础 API</li>
</ul>
<hr />
<h2 id="第-34-周系统播放器与解码理解">📘 第 3–4
周：系统播放器与解码理解</h2>
<h3 id="目标-1">🎯 目标</h3>
<p>熟悉 MediaExtractor / MediaCodec 工作流程；了解 ExoPlayer 架构。</p>
<h3 id="项目任务-1">🧱 项目任务</h3>
<ol type="1">
<li>用 <strong>MediaExtractor + MediaCodec</strong> 解码本地 mp4
文件；</li>
<li>自定义 SurfaceView 播放视频；</li>
<li>跑通 ExoPlayer demo 并阅读 Renderer 模块源码；</li>
<li>对比系统解码和 ExoPlayer 的缓冲逻辑。</li>
</ol>
<h3 id="代码产出结构-1">📂 代码产出结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SimplePlayer/</span><br><span class="line"> ├── player/</span><br><span class="line"> │   ├── ExtractDecodePlayer.kt</span><br><span class="line"> │   ├── SurfaceRenderView.kt</span><br><span class="line"> └── exoplayer_demo/</span><br><span class="line">     └── ExoPlayerActivity.kt</span><br></pre></td></tr></table></figure>
<h3 id="能力提升-1">🚀 能力提升</h3>
<ul>
<li>理解 Android 播放链：Extractor → Codec → Surface</li>
<li>掌握 Surface / SurfaceTexture / EGLContext 概念</li>
<li>能解释首帧延迟、缓冲策略</li>
</ul>
<hr />
<h2 id="第-56-周自研视频渲染管线opengl-es">📘 第 5–6
周：自研视频渲染管线（OpenGL ES）</h2>
<h3 id="目标-2">🎯 目标</h3>
<p>实现自研播放器的渲染层（OpenGL ES + EGL + FBO）。</p>
<h3 id="项目任务-2">🧱 项目任务</h3>
<ol type="1">
<li>C++ 层实现 YUV → RGB 转换 shader；</li>
<li>Java 层创建 EGLSurface 并绑定到 SurfaceTexture；</li>
<li>实现简单滤镜（灰度、反相、模糊）；</li>
<li>视频帧时间戳同步显示。</li>
</ol>
<h3 id="代码产出结构-2">📂 代码产出结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GLPlayer/</span><br><span class="line"> ├── native/</span><br><span class="line"> │   ├── gl_renderer.cpp</span><br><span class="line"> │   ├── shader_utils.cpp</span><br><span class="line"> ├── render/</span><br><span class="line"> │   ├── GLRenderer.kt</span><br><span class="line"> │   └── VideoSurface.kt</span><br></pre></td></tr></table></figure>
<h3 id="能力提升-2">🚀 能力提升</h3>
<ul>
<li>掌握 OpenGL ES 绘制管线</li>
<li>理解 FBO、多纹理合成</li>
<li>能独立实现简单滤镜与特效</li>
</ul>
<hr />
<h2 id="第-78-周音频采集与播放-音画同步">📘 第 7–8 周：音频采集与播放 +
音画同步</h2>
<h3 id="目标-3">🎯 目标</h3>
<p>实现音频录制、播放、混音、同步控制。</p>
<h3 id="项目任务-3">🧱 项目任务</h3>
<ol type="1">
<li>使用 AudioRecord 录音、AudioTrack 播放；</li>
<li>将音频数据与视频帧时间戳同步播放；</li>
<li>使用 WebRTC AudioProcessing
模块加入噪声抑制（NS）和回声消除（AEC）；</li>
<li>可视化波形输出。</li>
</ol>
<h3 id="代码产出结构-3">📂 代码产出结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVSyncDemo/</span><br><span class="line"> ├── audio/</span><br><span class="line"> │   ├── AudioRecordManager.kt</span><br><span class="line"> │   ├── AudioTrackPlayer.kt</span><br><span class="line"> │   └── WebRTCAudioProcessor.cpp</span><br><span class="line"> └── sync/</span><br><span class="line">     └── AVSyncController.kt</span><br></pre></td></tr></table></figure>
<h3 id="能力提升-3">🚀 能力提升</h3>
<ul>
<li>掌握 A/V 同步策略（基于 PTS）</li>
<li>理解音频处理链路（录制 → 处理 → 播放）</li>
<li>初步了解 WebRTC 音频模块集成</li>
</ul>
<hr />
<h2 id="第-910-周推流与实时传输">📘 第 9–10 周：推流与实时传输</h2>
<h3 id="目标-4">🎯 目标</h3>
<p>实现 RTMP 推流、HTTP-FLV 拉流，理解延迟优化与缓冲控制。</p>
<h3 id="项目任务-4">🧱 项目任务</h3>
<ol type="1">
<li>使用 FFmpeg 实现 RTMP 推流（Camera → RTMP Server）；</li>
<li>播放端拉流显示（基于 ExoPlayer）；</li>
<li>对比 HLS、HTTP-FLV、RTMP 延迟表现；</li>
<li>测试弱网环境下的重连策略。</li>
</ol>
<h3 id="代码产出结构-4">📂 代码产出结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StreamDemo/</span><br><span class="line"> ├── push/</span><br><span class="line"> │   ├── RtmpPusher.cpp</span><br><span class="line"> │   └── PushController.kt</span><br><span class="line"> ├── play/</span><br><span class="line"> │   ├── FlvPlayer.kt</span><br><span class="line"> │   └── ExoWrapper.kt</span><br></pre></td></tr></table></figure>
<h3 id="能力提升-4">🚀 能力提升</h3>
<ul>
<li>掌握 RTMP 协议基础与封包</li>
<li>理解缓冲、延迟、重连、丢帧策略</li>
<li>能实现一个端到端的推流与播放流程</li>
</ul>
<hr />
<h2 id="第-1112-周sdk-封装与发布">📘 第 11–12 周：SDK 封装与发布</h2>
<h3 id="目标-5">🎯 目标</h3>
<p>将所有模块封装为可复用 SDK（AAR），支持插件化、日志与回调。</p>
<h3 id="项目任务-5">🧱 项目任务</h3>
<ol type="1">
<li>抽象 <code>MediaPlayerManager</code> 与 <code>MediaItem</code>
接口；</li>
<li>模块化：decoder、renderer、audio、network、ui；</li>
<li>支持插件注册机制（日志、埋点、License 校验）；</li>
<li>打包成 AAR 并提供 Demo App；</li>
<li>编写 README 与接口文档。</li>
</ol>
<h3 id="代码产出结构-5">📂 代码产出结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MediaSDK/</span><br><span class="line"> ├── core/</span><br><span class="line"> │   ├── MediaPlayerManager.kt</span><br><span class="line"> │   ├── DecoderModule.cpp</span><br><span class="line"> │   ├── RendererModule.cpp</span><br><span class="line"> ├── plugins/</span><br><span class="line"> │   ├── LogPlugin.kt</span><br><span class="line"> │   ├── LicensePlugin.kt</span><br><span class="line"> ├── sdk/</span><br><span class="line"> │   └── build.gradle (AAR 输出)</span><br><span class="line"> └── demo/</span><br><span class="line">     └── MainActivity.kt</span><br></pre></td></tr></table></figure>
<h3 id="能力提升-5">🚀 能力提升</h3>
<ul>
<li>完整 SDK 架构设计</li>
<li>模块隔离与接口抽象</li>
<li>插件化与责任链模式</li>
<li>SDK 打包与文档编写流程</li>
</ul>
<hr />
<h2 id="附工具与调试建议">📈 附：工具与调试建议</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">工具</th>
<th style="text-align: left;">用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Android Studio
Profiler</strong></td>
<td style="text-align: left;">CPU、内存、帧率分析</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Systrace / Perfetto</strong></td>
<td style="text-align: left;">系统级性能与线程调度</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>FFprobe / Wireshark</strong></td>
<td style="text-align: left;">流媒体分析</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>RenderDoc</strong></td>
<td style="text-align: left;">OpenGL ES 调试</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Oboe / WebRTC Audio
Debug</strong></td>
<td style="text-align: left;">音频延迟与处理可视化</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="最终成果12-周后你能做到">💪 最终成果（12 周后你能做到）</h2>
<ul>
<li>独立构建一套 <strong>Android 跨平台音视频
SDK</strong>（含播放器、渲染、推流）</li>
<li>理解音视频系统的全链路：采集 → 编码 → 传输 → 解码 → 渲染</li>
<li>能调优首帧、延迟、丢帧、音画同步等核心问题</li>
<li>能阅读并修改 ExoPlayer、WebRTC、FFmpeg 源码</li>
<li>能胜任 <strong>多媒体 SDK / 播放器内核 / RTC 研发</strong> 岗位</li>
</ul>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>音视频面试题集锦</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6.html</url>
    <content><![CDATA[<h2 id="采集">采集</h2>
<h3 id="ios-如何实现夜晚自动提示打开手电筒">iOS
如何实现夜晚自动提示打开手电筒？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA">https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA</a></p></li>
<li><p>当夜晚使用共享单车扫码时，应该都见过提示“打开手电筒”，在
<code>iOS</code>
中我们如何实现呢？主要基于图像环境光参数，参考如下代码。</p></li>
<li><p><code>iOS</code> 视频采集设置
<code>AVCaptureVideoDataOutput AVCaptureVideoDataOutputSampleBufferDelegate</code>，通过获取
<code>CMSampleBufferRef</code>
每一帧视频数据环境参数进行判断即可。</p></li>
</ul>
<h3 id="谈谈-ios-音视频采集相关接口和数据结构的设计">谈谈 iOS
音视频采集相关接口和数据结构的设计？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-cwQbkbHqmMKRPk0YhBG6g</p></li>
<li><p>通常我们通过 AVCaptureSession 相关的 API
来进行音视频的采集，其中主要组件分为 Input、Output、Session
几个部分</p></li>
<li><p>对于视频采集，一般直接使用 AVCaptureSession 的 API 即可</p></li>
<li><p>对于音频采集，除了可以使用 AVCaptureSession
来进行音频采集外，还可以使用 AudioUnit。</p></li>
</ul>
<h2 id="音频算法">音频算法</h2>
<h3
id="你对视频倍速播放的时候是否有改变音调">你对视频倍速播放的时候，是否有改变音调？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>倍速变大和变小都会带来变调的问题，目前流行的开源项目有 soundtouch
和 sonic
来达到变速不变调的效果，最经典的就是使用时域压扩（TSM）的算法。</p></li>
</ul>
<h3
id="直播中发现有回声可能的原因是什么">直播中发现有回声，可能的原因是什么？</h3>
<ul>
<li><a
href="https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA">https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA</a></li>
</ul>
<h3 id="聊聊对音视频同步的理解">聊聊对音视频同步的理解？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/Ampeeb15Wk2WfgLWMkHywg</p></li>
<li><p>音视频对齐方式有三种：</p>
<ul>
<li><p>以音频时钟为基准</p></li>
<li><p>以视频时钟为基准</p></li>
<li><p>以第三方时钟为基准</p></li>
</ul></li>
<li><p>实际情况下，如果用上面那种简单的方式，慢慢的就会出现音视频不同步的情况，主要原因是同步时，时间粒度太大了，难以精准控制。所以需要引入一个参考时钟（要求参考时钟上的时间是恒定线性递增的）来提高音频时钟的时间粒度，比如：系统时间，进而进行精准时钟对齐。最后以音频时钟为准，视频放快了就减慢播放速度，播放快了就丢帧或加快播放的速度。</p></li>
</ul>
<h2 id="图像算法">图像算法</h2>
<h3 id="为什么在-yuv-转-rgb-转换中-uv-分量要减去-0.5">为什么在 YUV 转
RGB 转换中 UV 分量要减去 0.5？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/HlLwri7rFNSs9C6rxZ90gw</p></li>
<li><p>在进行 YUV 到 RGB 的转换时，为了将 U 和 V 的取值范围从对称的 -128
到 127 归一化为非对称的 0 到 255，并且将中心点从 128 移动到 0，需要对 U
和 V 进行偏移量的减法操作。具体来说，通过减去 0.5（或 128
对应的小数形式），可以将 U 和 V 的取值范围转换为 0 到 255，从而与 RGB
的取值范围相匹配。</p></li>
</ul>
<h3
id="纹理抗锯齿有哪些算法各有哪些利弊">纹理抗锯齿有哪些算法？各有哪些利弊?</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/N-PzPA4rSHGtE6KIjnEX4Q</p></li>
<li><p>FXAA（快速近似抗锯齿）</p></li>
<li><p>SSAA（超级采样抗锯齿）</p></li>
<li><p>MSAA（多重采样抗锯齿）</p></li>
</ul>
<h2 id="特效">特效</h2>
<h3 id="opengl-如何实现二分屏效果">OpenGL 如何实现二分屏效果？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-cwQbkbHqmMKRPk0YhBG6g</p></li>
<li><p>以纹理 y 坐标中间分屏为例，代码如下：</p>
<ul>
<li>precision highp float; varying lowp vec2 varyTextCoord; uniform
sampler2D inputTexture;</li>
</ul></li>
</ul>
<p>void main() { float y; if (varyTextCoord.y &gt;= 0.0 &amp;&amp;
varyTextCoord.y &lt;= 0.5) { y = varyTextCoord.y + 0.25; } else { y =
varyTextCoord.y - 0.25; } gl_FragColor = texture2D(inputTexture,
vec2(varyTextCoord.x, y)); }</p>
<h2 id="编解码">编解码</h2>
<h3 id="什么是-dts-和-pts它们有什么区别">什么是 DTS 和
PTS？它们有什么区别？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>DTS 是解码时间戳；PTS 是显示时间戳。 虽然 DTS、PTS
是用于指导播放端的行为，但它们是在编码的时候由编码器生成的。
当视频流中没有 B 帧时，通常 DTS 和 PTS 的顺序是一致的。但如果有 B
帧时，就回到了我们前面说的问题：解码顺序和播放顺序不一致了。DTS
告诉我们该按什么顺序解码这几帧图像，PTS
告诉我们该按什么顺序显示这几帧图像。</p></li>
</ul>
<h3 id="什么是-idr-帧它和-i-帧有什么区别">什么是 IDR 帧？它和 I
帧有什么区别？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>IDR 帧全称叫做 Instantaneous Decoder Refresh，是 I 帧的一种。IDR
帧的作用是立刻刷新，重新算一个新的序列开始编码，使错误不致传播。 IDR
帧有如下特性：</p></li>
<li><p>IDR 帧一定是 I 帧，严格来说 I 帧不一定是 IDR 帧（但一般 I 帧就是
IDR 帧）；</p></li>
<li><p>对于 IDR 帧来说，在 IDR 帧之后的所有帧都不能引用任何 IDR
帧之前的帧的内容。与此相反，对于普通的 I 帧来说，位于其之后的 B 和 P
帧可以引用位于普通 I 帧之前的 I 帧（普通 I
帧有被跨帧参考的可能）；</p></li>
<li><p>播放器永远可以从一个 IDR
帧播放，因为在它之后没有任何帧引用之前的帧。因此，视频开头的 I 帧一定是
IDR 帧；一个封闭类 GOP 的开头的 I 帧也一定是 IDR 帧。
所以，在直播场景通常每个 I 帧都是 IDR
帧，这样服务端下发流数据的时候总是从一个 I
帧开始，播放器就可以立即开始播放。</p></li>
</ul>
<h3 id="什么是-sps-和-pps它们有什么区别">什么是 SPS 和
PPS？它们有什么区别？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>SPS，Sequence Paramater
Set，保存了一组编码后的图像序列所依赖的全局参数。 PPS，Picture Paramater
Set，保存了每一帧编码后的图像所依赖的参数。 SPS
中的信息至关重要，如果其中的数据丢失，解码过程就可能失败。SPS 和 PPS
通常作为解码器的初始化参数。一般情况，SPS 和 PPS 所在的 NAL
单元位于整个码流的起始位置，但是在某些场景下，在码率中间也可能出现这两种结构：</p></li>
<li><p>解码器要在码流中间开始解码。比如，直播流。</p></li>
<li><p>编码器在编码过程中改变了码率的参数。比如，图像的分辨率。</p></li>
</ul>
<h3 id="什么是-sei我们可以用它来做什么">什么是
SEI？我们可以用它来做什么？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>SEI 即补充增强信息（Supplemental Enhancement
Information），属于码流范畴，它提供了向视频码流中加入额外信息的方法，是
H.264 标准的特性之一。 SEI的基本特征如下：</p></li>
<li><p>并非解码过程的必须选项；</p></li>
<li><p>可能对解码过程（容错、纠错）有帮助；</p></li>
<li><p>集成在视频码流中。 在直播场景，我们通常使用 SEI
来携带推流端的信息，一直随着直播流传输到播放端。由于 SEI
是绑定着视频帧，所以它可以支持诸如：</p></li>
<li><p>统计直播推流端到播放端延时。</p></li>
<li><p>支持和视频帧绑定的内容交互。比如，直播答题在播放端的弹窗等。</p></li>
</ul>
<h3
id="如何根据-nalu-裸流数据来判断其是-h.264-编码还是-h.265-编码">如何根据
NALU 裸流数据来判断其是 H.264 编码还是 H.265 编码？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q">https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q</a></p></li>
<li><p>1）通常在处理音视频数据时，我们如何选择解码器？ 通常我们不是根据
NALU
裸流数据中的信息来选择解码器，而是根据媒体封装层的信息来确定解码器。
媒体封装层是表示媒体数据是什么封装格式的，比如
MP4、FLV。在这层信息里，通常会携带码流编码格式的信息。 拿 MP4
来说，我们可以根据 Sample Description Box(moov/trak/mdia/minf/stbl/stsd)
中的信息来确定其封装的码流的编码格式。 对于 FLV，我们可以根据
VideoTagHeader 中的 CodecID 等信息来确定其封装的码流的编码格式。
这样的好处是效率比较高，解封装的时候就可以确定选择何种解码器了。
2）怎么识别 NALU 裸流数据的编码格式是 H.264 还是 H.265？
但是，如果出现题目中的情况，没有对码流进行封装，而是直接传输码流时，这时候
NALU
中有什么字段能标识自己的编码格式吗？答案是，没有这样明确的字段能标识码流的编码格式。
但是这个问题也不是不能解决，因为 H.264、H.265
码流本身也是遵循一定格式规范的，我们可以按照它的格式规范进行探测，如果能解析出来正确的信息，那也可以确定它的编码格式。
比如，拿 H.265 来说，FFmpeg 中 hevcdec.c 就有对其码流数据进行探测的函数
hevc_probe(…)。 所以，我们可以按照编码格式规范探测，比如 H.265
如果解析出了 pps、sps、vps 的各字段信息符合规范，就认为它是 H.265
的编码；如果不是，在你们的码流格式范围中就只剩 H.264
了；接下来将码流数据交给对应的解码器解码即可。</p></li>
</ul>
<h3 id="什么是-open-gop什么是-closed-gop">什么是 Open GOP？什么是 Closed
GOP ?</h3>
<ul>
<li>这里说的封闭类 GOP，也就是我们常说的 Closed GOP。 Closed GOP
即只允许 GOP 中的帧参考当前 GOP 中的其他帧。 相对与 Closed GOP，还存在
Open Gop，Open Gop 允许一个 Gop 中的帧跨 GOP 参考其他 GOP 中的帧。
在实际应用中，如果是在 HLS、DASH
等自适应流媒体的场景下，为了实现码流之间的无缝切换，也必须使用 ClosedGOP
。 在 x264 中，Open GOP 是默认关闭的。 在 x265 中，Open GOP
则是默认开启的，如果要关闭 Open GOP选项，则需要在你的 x265
配置中加入以下代码 open-gop=0。</li>
</ul>
<h3 id="为什么会有-yuv-这种数据它相比-rgb-数据有什么优点">为什么会有 YUV
这种数据？它相比 RGB 数据有什么优点？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q">https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q</a></p></li>
<li><p>RGB 工业显示器要求一幅彩色图像由分开的 R、G、B
信号组成，而电视显示器则需要混合信号输入，为了实现对这两种标准的兼容，NTSC（美国国家电视系统委员会）制定了
YIQ
颜色模型，它的主要优点是可以实现对彩色电视和黑白电视的兼容，即可以用黑白电视收看彩色电视信号。YUV
颜色模型则是在 YIQ 的基础上发展而来。 YUV
颜色模型中用亮度、色度来表示颜色。它的亮度信息和色度信息是分离的，其中 Y
表示亮度通道，U 和 V 则表示色度通道。如果只有 Y 信息，没有 U、V
信息，那么表示的图像就是灰度图像。YUV 常用在各种影像处理场景中。YUV
在对照片或视频编码时，考虑到人眼对亮度信息的敏感度高于色度信息，允许降低色度的带宽。这样一来就可以对色度信息进行压缩，所以
YUV 可以相对 RGB
使用更少的数据带宽。比如常见的采样格式有：4:2:1、4:1:1、4:2:0
等，它们分别相对 RGB 压缩了 33.3%、50%、50% 的数据量。</p></li>
</ul>
<h3
id="对-yuv-格式有了解吗yuv-数据做转换是怎样实现的比如说-yuv422-转为-yuv420">对
YUV 格式有了解吗？YUV 数据做转换是怎样实现的，比如说 YUV422 转为
YUV420？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>YUV 格式是传输视频常用的格式，因为相对于 RGB
格式它可以节省更多空间。</p></li>
<li><p>YUV 的格式有很多，例如：YUV444、YUV422、YUV420，常用的 YUV 格式是
YUV420 格式。Y 表示亮度信息，是人眼最敏感的分量，UV
则表示色度信息。</p></li>
<li><p>YUV420 表示采样方式：UV 分量具有 2:1 的水平采样，2:1
的垂直采样，这里并不是指只有 U，没有 V，而是对于每一行，只有一个 U 或者
V 分量，如果第一行是 4:2:0，那么下一行就是 4:0:2。</p></li>
<li><p>可以用工具 YUVView 直接打开 YUV 格式的数据。</p></li>
<li><p>YUV 数据因为计算量大和数据量大可以都放到 GPU 存储和计算，YUV422
转 YUV420 可以利用 OpenGL 将 YUV422 的 UV 数据转换成 texture 纹理，编写
shader 做格式转换逻辑继而生成 YUV420 的 UV texture，再通过 readPixel
将显存的 UV 数据读取出来。转换逻辑即将纹理 UV 分量隔行采样。</p></li>
</ul>
<h3 id="pcm-音频数据是怎么组织的">PCM 音频数据是怎么组织的？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ">https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ</a></p></li>
<li><p>模拟数据 → 采样 → 量化 → 编码 → 数字信号</p></li>
</ul>
<h3 id="说一下对信号时域频域的理解">说一下对信号时域、频域的理解？</h3>
<ul>
<li><a
href="https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ">https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ</a></li>
</ul>
<h3 id="pcm-数据经过-aac-编码器编码后直接写-.aac-文件会怎么样">PCM
数据经过 AAC 编码器编码后，直接写 .aac 文件会怎么样？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ">https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ</a></p></li>
<li><p>正常播放器会没法识别播放（因为不知道声道数，采样率等信息）。一般要这样做：正常需要在编码每帧数据后，结合编码后的数据生成
ADTS 头，然后将 <code>ADTS 头 + 编码后的数据</code>
整体写入文件，循环往复，才能生成可正常播放的 .aac
文件（当然也可以是：<code>1 个 ADTS + 多帧编码数据</code>
这样的组合）。</p></li>
</ul>
<h3 id="pcm-数据操作的最小单元是多少字节">PCM
数据操作的最小单元是多少字节？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/lYKGrt4rOISncyFwYRM2cQ</p></li>
<li><p>音频 PCM
数据，如果要进行编辑，那么其最小操作单元是：<code>声道数 * 位数 / 8 * 1 个采样点</code>。</p></li>
</ul>
<h3 id="简要介绍一下对-h.264-的了解">简要介绍一下对 H.264 的了解？</h3>
<ul>
<li><a
href="https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw">https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw</a></li>
</ul>
<h3 id="h.264-编码框架分层目的是什么">H.264
编码框架分层目的是什么？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw">https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw</a></p></li>
<li><p>对 H.264
编码框架进行分层的主要目标是为了有高的视频压缩比和良好的网络亲和性。</p></li>
<li><p>VCL 层负责视频的信号处理，包含压缩，量化等处理，NAL
层则负责解决编码后数据的网络传输。</p></li>
<li><p>这样可以将 VCL 和 NAL
的处理放到不同平台来处理，可以减少因为网络环境不同对 VCL
的比特流进行重构和重编码。</p></li>
<li><p>这样将编码和网络传输进行隔离，使功能单一、便于维护。</p></li>
</ul>
<h3 id="h.264-如何根据-nalu-判断当前视频帧的类型">H.264 如何根据 NALU
判断当前视频帧的类型？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw">https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw</a></p></li>
<li><p>NALU
结构一般为：<code>[NALU Header][NALU Payload]</code>，可以根据
<code>[NALU Header]</code> 这 1 个字节来获取帧类型</p></li>
</ul>
<h3 id="介绍一下-ipb-帧编码解码显示顺序">介绍一下 I、P、B
帧编码、解码、显示顺序？</h3>
<ul>
<li><a
href="https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw">https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw</a></li>
</ul>
<h3 id="h.264-与-h.265-有什么区别">H.264 与 H.265 有什么区别？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw">https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw</a></p></li>
<li><ul>
<li>H.265 也称为高效视频编码 (HEVC)，是 H.264
的升级和更高级的版本；</li>
</ul></li>
<li><ul>
<li>H.265 的编码架构大致上 和 H.264
的架构相似，主要也包含：帧内预测（intra prediction）、帧间预测（inter
prediction）、转换（transform）、量化（quantization）、去区块滤波器（deblocking
filter）、熵编码（entropy coding）等模块。但在 H.265
编码架构中，整体被分为了三个基本单位，分别是编码单位（coding unit,
CU）、预测单位（predict unit, PU）和转换单位（transform unit,
TU）；</li>
</ul></li>
<li><ul>
<li>比起 H.264，H.265
提供了更多不同的工具来降低码率，以编码单位来说，H.264
中每个宏块（macroblock/MB）大小最大为 16x16 像素，而 H.265
的编码单位最大为 64x64；</li>
</ul></li>
<li><ul>
<li>H.265 的帧内预测模式支持 35 种方向（而 H.264 只支持 8
种），并且提供了更好的运动补偿处理和矢量预测方法。</li>
</ul></li>
</ul>
<h3 id="如何代码实现-psnr-来评估编码质量">如何代码实现 PSNR
来评估编码质量？</h3>
<ul>
<li><a
href="https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA">https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA</a></li>
</ul>
<h3 id="如何测试码率质量甜点">如何测试码率质量甜点？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA">https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA</a></p></li>
<li><p>在视频领域，质量甜点指的是在既定的码率和屏幕大小下通过设定合理的分辨率和帧率来得到最佳视频主观质量体验。因为编码复杂度和编解码质量亦不是线性关系，两者之间也存在一个<em>质量甜点</em>。在音频领域也有类似的情况，针对具体的情况，我们可以测试手机的编码质量来选择指定分辨率、帧率时对应的码率甜点。</p></li>
</ul>
<h3 id="android-surface-解码如何支持带角度视频">Android Surface
解码如何支持带角度视频？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA">https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA</a></p></li>
<li><p><strong>1）直接解码到 Surface</strong></p>
<ul>
<li>需要通过 <code>MediaFormat</code> 设置解码参，通过
<code>MediaFormat.KEY_ROTATION</code>
配置旋转角度，则可以正确显示。</li>
</ul></li>
<li><p><strong>2）解码到 SurfaceTexture</strong></p>
<ul>
<li>解码到 <code>SurfaceTexture</code>，通过
<code>MediaFormat.KEY_ROTATION</code>
配置旋转角度，但输出纹理提供接口获取旋转矩阵，<code>mSurfaceTexture.getSurfaceTexture().getTransformMatrix</code>，拿到旋转矩阵后通过
<code>FBO</code>
渲染调整为正确尺寸，这种模式好处可以将解码后数据经过自定义处理传递给编码层与渲染上屏。</li>
</ul></li>
</ul>
<h3 id="ios-如何实现-hdr-转-sdr">iOS 如何实现 HDR 转 SDR？</h3>
<ul>
<li><a
href="https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A">https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A</a></li>
</ul>
<h3 id="介绍一下-ffmpeg-中关于-timebase-的基础知识与应用">介绍一下
FFmpeg 中关于 timebase 的基础知识与应用？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg">https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg</a></p></li>
<li><p>timebase 在 FFmpeg 的定义是一个 AVRational
结构体，用分子和分母表示。</p></li>
</ul>
<h3 id="如何识别一个视频是-hdr-视频">如何识别一个视频是 HDR 视频？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg">https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg</a></p></li>
<li><p>iOS 判断一个视频是否是 HDR 视频的方法：判断是否带有 HDR 特征的
track 即可。</p>
<ul>
<li>NSArray&lt;AVAssetTrack <em>&gt; </em>hdrTracks = [asset
tracksWithMediaCharacteristic:AVMediaCharacteristicContainsHDRVideo]; if
(hdrTracks.count &gt; 0){ return YES; }</li>
</ul></li>
<li><p>Android 需要我们自己解析出
colortransforfunction和ccolorStandard。</p></li>
</ul>
<h3
id="请问-android-上如何识别一个视频是哪种格式的-hdr-视频hdr10dolbyvisionhlghdr10">请问
Android 上如何识别一个视频是哪种格式的 HDR
视频：HDR10+/DolbyVision/HLG/HDR10？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA">https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA</a></p></li>
<li><p>Dolby：MediaExtractor 可以解析出 minetype，如果是
video/dolby-vision 则格式为 Dolby 视频；</p></li>
<li><p>HLG：解析出 METADATA_KEY_COLOR_TRANSFER，如果颜色转换函数是 HLG
则格式为 HLG 视频；</p></li>
<li><p>HDR10/HDR10+：可以通过硬件解码出来的 mediaFormat 变化回调
onOutputFormatChanged 来判断，代码如下： public void
onOutputFormatChanged(<span class="citation"
data-cites="NonNull">@NonNull</span> MediaCodec mediaCodec, <span
class="citation" data-cites="NonNull">@NonNull</span> MediaFormat
mediaFormat) { if (format.containsKey(MediaFormat.KEY_HDR10_PLUS_INFO)){
Log.d(TAG, “hdr10”); } else if
(format.containsKey(MediaFormat.KEY_HDR_STATIC_INFO)){ Log.d(TAG,
“hdr10+”); } }</p></li>
</ul>
<h3 id="hevc-opengop-的新增的帧类型有哪些在开发中需要注意什么">HEVC
OpenGOP 的新增的帧类型有哪些，在开发中需要注意什么？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA">https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA</a></p></li>
<li><p>IRAP（Intra Random Access
Pictures）：随机访问帧。解码器可以从该帧开始解码。IRAP
包含三种帧类型：瞬时解码器刷新帧（IDR）、干净随机访问帧（CRA）、断开链路访问帧（BLA）。视频的解码过程始终要从
IRAP 帧开始。</p></li>
<li><p>前导帧（Leading
pictures）：按输出顺序位于随机访问点图片之前，但在编码视频序列中在随机访问点图片之后进行编码。</p>
<ul>
<li><p>RADL（Random Access Decodable Leading
pictures）：按照编码顺序独立于随机访问点之前的图片的引导帧被称为随机访问可解码前导帧。</p></li>
<li><p>RASL（Random Access Skipped Leading
pictures）：按照编码顺序使用随机访问点之前的图片进行预测的前导帧可能会被损坏。这些被称为随机访问跳过前导帧。</p></li>
</ul></li>
<li><p>尾随帧（Trailing pictures）：在输出和解码顺序上均在 IRAP
和前导图片之后。</p></li>
<li><p>TSA（Temporal Sublayer Access）和 STSA（Stepwise Temporal
Sublayer
Access）：标记解码器需要切换视频分辨率的帧，也是编码分层逻辑里面的分层转换点。</p></li>
</ul>
<h3 id="介绍一下-android-14-引入了-ultra-hdr-image-格式">介绍一下
Android 14 引入了 Ultra HDR Image 格式？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA">https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA</a></p></li>
<li><p>Ultra HDR 图片格式的原理是结合了标准 8-bit JPEG
基础图像与一个较低分辨率的、带有增益映射的 JPEG 图像以及用于 HDR
重建的元数据。首先，它通过加入一个标准 8-bit 的 JPEG
压缩图像，这个图像提供了基础的色彩和细节。然后，它关联了一个较低分辨率的
JPEG
图像，这个图像带有增益映射，可以提供额外的细节和动态范围。最后，它还包含了用于
HDR 重建的元数据，这些元数据可以用来创建 HDR 图像。</p></li>
</ul>
<h3
id="ios-平台上如何判断-videotoolbox-是否支持某种编码格式h.264hevc-等或者某种颜色空间呢">iOS
平台上如何判断 VideoToolbox 是否支持某种编码格式（H.264、HEVC
等）或者某种颜色空间呢？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ">https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ</a></p></li>
<li><p>1）判断 VideoToolbox 是否支持一种编码格式，首先可以查一下
<code>CMFormatDescription.h</code> 文件的 <code>CMVideoCodecType</code>
枚举中有没有对应的编码格式。对于具体的设备是否支持某种编码格式，可以用类似下面的代码检查：</p></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">BOOL</span> supportHEVC = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">	<span class="keyword">if</span> (&amp;VTIsHardwareDecodeSupported) &#123;</span><br><span class="line">		supportHEVC = VTIsHardwareDecodeSupported(kCMVideoCodecType_HEVC);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2）判断是否支持某一种类型的颜色空间，可以先看看
<code>CVPixelBuffer.h</code> 文件中的 <code>kCVPixelFormatType</code>
关于颜色空间的声明。</li>
</ul>
<h3
id="android-平台上使用-mediacodec-编码如何告知编码器结束编码">Android
平台上使用 MediaCodec 编码，如何告知编码器结束编码？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ">https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ</a></p></li>
<li><p>当我们想要告知编码器结束编码的时候，其实是在 Executing 状态中，从
Running 子状态中流转到 End-of-Stream 子状态中，并且在 MediaCodec
使用结束后，调用 <code>release()</code> 方法将其释放。</p></li>
<li><p>当 MediaCodec 的输入队列中接受了一个带有
<code>_BUFFER_FLAG_END_OF_STREAM_</code> 标志的输入帧时，MediaCodec
会继续输出剩余的编码数据。直到收到 End-of-Stream
的编码帧后，可以认为编码器已经从之前的 Running 状态运行到 End-of-Stream
状态。</p></li>
<li><p>在输入带有 <code>_BUFFER_FLAG_END_OF_STREAM_</code>
标志的输入帧后，不可再继续向 MediaCodec 输入数据，除非 MediaCodec 已经被
Flush、Stop 或 Restart。</p></li>
</ul>
<h3
id="android-平台上使用-mediacodec-异步编码使用-surface-作为编码输入源的流程和使用-bytebuffer-作为编码输入源有什么区别">Android
平台上使用 MediaCodec 异步编码，使用 Surface 作为编码输入源的流程和使用
ByteBuffer 作为编码输入源有什么区别？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ">https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ</a></p></li>
<li><p>使用 ByteBuffer 异步编码的时候，Surface 和 ByteBuffer 都需要设置
MediaCodec 的 <code>setCallback</code>
方法设置相关的回调。区别在于：</p></li>
<li><ul>
<li>在使用 ByteBuffer 作为输入源的时候，我们需要在
<code>onInputBufferAvailable</code> 的时候根据 index 拿到空闲的
ByteBuffer，塞入有效的数据后，再调用 <code>queueInputBuffer</code>
传回给 codec 进行编码。</li>
</ul></li>
<li><ul>
<li>在使用 Surface 作为输入源的时候，Surface 会自己管理
buffer，<code>dequeueInputBuffer</code> 和 <code>getInputBuffers</code>
的调用都被认为是非法的。因此 <code>onInputBufferAvailable</code>
方法不会回调，我们需要把数据直接送到 Surface 上进行渲染。</li>
</ul></li>
</ul>
<h3 id="聊聊-ios-cvpixelbufferref-相关的细节">聊聊 iOS CVPixelBufferRef
相关的细节？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/Ampeeb15Wk2WfgLWMkHywg</p></li>
<li><p>CVPixelBufferRef 像素缓冲区，是 iOS
平台进行视频编解码及图像处理相关最重要的数据结构之一。它的定义是 typedef
CVImageBufferRef CVPixelBufferRef。CVPixelBuffer 是在 CVImageBuffer
的基础上实现了内存存储。并且，CVPixelBuffer 还可以实现 CPU 和 GPU
共享内存，为图像处理提供更高的效率。</p></li>
</ul>
<h3 id="如何获取视频流中的-qp-值">如何获取视频流中的 QP 值？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/HlLwri7rFNSs9C6rxZ90gw</li>
</ul>
<h3 id="视频编码对-qp-值的控制有哪些">视频编码对 QP
值的控制有哪些？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/HlLwri7rFNSs9C6rxZ90gw</li>
</ul>
<h3 id="ios-如何使用分段转码如何设置分片大小">iOS
如何使用分段转码，如何设置分片大小？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/N-PzPA4rSHGtE6KIjnEX4Q</p></li>
<li><p>初始化 AVAssetWriter 时可以设置 outputFileTypeProfile =
AVFileTypeProfileMPEG4AppleHLS 即可打开 MP4 分段转码。</p></li>
<li><p>通过 preferredOutputSegmentInterval
设置转码后的每片大小。如果想手动切片，需要设置
preferredOutputSegmentInterval =
kCMTimeIndefinite，并且在每次想要切片的位置调用 flushSegment
接口强制分片，注意调用接口的时机必须是 Sync 帧前。即每片的开始帧都是
Sync 帧。</p></li>
</ul>
<h3
id="videotoolbox-中是不是不存在平面格式planar对应的-yuv420yuv422-和-yuv444-的-ostype-常量">VideoToolbox
中是不是不存在平面格式（planar）对应的 YUV420、YUV422 和 YUV444 的
OSType 常量？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/N-PzPA4rSHGtE6KIjnEX4Q</p></li>
<li><p>iOS 的 API
中能找到的平面格式有：kCVPixelFormatType_420YpCbCr8Planar、kCVPixelFormatType_420YpCbCr8PlanarFullRange，这两种平面格式分别对应
y420 和
f420。对这两种格式测试下来，目前系统播放器支持，系统相机不支持。yuv422
和 yuv444 的平面格式目前没找到。</p></li>
</ul>
<h3 id="ios-中系统-api-提供了哪些视频编码的方式">iOS 中系统 API
提供了哪些视频编码的方式？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/sKvPn2pLRYdJzx6RepKp1Q</p></li>
<li><p>AVFoundation 框架：通过 AVFoundation 框架，可以使用 AVAssetWriter
和 AVAssetWriterInput 类来实现编码视频。</p></li>
<li><p>VideoToolbox 框架：使用 VideoToolbox，可以利用 iOS
设备上的硬件编码器来实现高效的视频编码。</p></li>
</ul>
<h3 id="videotoolbox-视频帧解码失败以后应该如何重试">Videotoolbox
视频帧解码失败以后应该如何重试？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/sKvPn2pLRYdJzx6RepKp1Q</p></li>
<li><p>1、重新初始化解码器：尝试重新初始化 Videotoolbox
解码器，有时候重新初始化可以解决解码过程中的一些临时问题。</p></li>
<li><p>2、检查视频文件：确保视频文件没有损坏或者格式不正确。有时候解码失败是因为视频文件本身的问题，可以尝试使用其他工具或者重新获取视频文件。</p></li>
<li><p>3、检查当前内存：在解码过程中如果 CMSampleBuffer
不及时释放，可能会导致内存过高导致解码器报 -11800 通用错误。</p></li>
<li><p>4、尝试重新解码当前帧：将当前帧以及当前 gop
内前序帧都重新输入给解码器。</p></li>
</ul>
<h3 id="如何使用-psnr-对视频转码质量进行评估">如何使用 PSNR
对视频转码质量进行评估？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/sKvPn2pLRYdJzx6RepKp1Q</p></li>
<li><p>1、计算图像差异：获得原始视频帧和转码后的未经过任何图像效果处理的视频帧使用同一解码器解码，并将它们的每一帧转换成相同的格式（比如
YUV 格式）。</p></li>
<li><p>2、计算 PSNR 值：使用以下公式计算每一帧的 PSNR 值。</p></li>
<li><p>3、计算平均 PSNR：将所有帧的 PSNR 值求平均，得到视频的平均 PSNR
值。</p></li>
<li><p>4、分析结果：根据平均 PSNR 值来评估转码后视频的质量。较高的 PSNR
值表示转码后的视频质量与原始视频相似度较高，而较低的 PSNR
值则表示质量损失较大。</p></li>
</ul>
<h3 id="videotoolbox-遵循哪种视频码率控制策略如何设置">VideoToolbox
遵循哪种视频码率控制策略？如何设置？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/JbEGcM95fL3i7g30dTDtOw</p></li>
<li><p>CBR（Constant Bit
Rate）恒定码率：一定时间范围内比特率基本保持的恒定。</p></li>
<li><p>VBR（Variable Bit
Rate）可变码率：码率分配根据图像内容的复杂度进行。</p></li>
<li><p>ABR（Average
Bitrate）平均目标码率：控制一段时间内的编码平均码率。</p></li>
</ul>
<h3 id="annex-b-如何转换为-avcc">Annex B 如何转换为 AVCC？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/JbEGcM95fL3i7g30dTDtOw</p></li>
<li><p>1、解析 Annex B 格式：读取字节流，识别每个 NAL
单元的起始码，确定每个 NAL 单元的开始和结束位置。</p></li>
<li><p>2、去除起始码：去除每个 NAL 单元的起始码。</p></li>
<li><p>3、计算长度：对于每个 NAL
单元，计算其长度（以字节为单位）。</p></li>
<li><p>4、写入长度前缀：将每个 NAL 单元的长度作为字节序列写入到 AVCC
格式的流中，可能 1 个字节，2 字节或者 4 字节（较为常见），NAL
单元长度会存储在 AVCC 的 extradata 中。</p></li>
<li><p>5、根据 Annex B 的 SPS 和 PPS 生成对应的 extradata。</p></li>
<li><p>6、写入 NAL 单元数据：在长度字段后面写入去除起始码后的 NAL
单元数据。</p></li>
</ul>
<h3 id="ios-中如何判断一个视频帧是不是关键帧">iOS
中如何判断一个视频帧是不是关键帧？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/JbEGcM95fL3i7g30dTDtOw</p></li>
<li><p>在 VideoToolbox 中，可以通过检查给定的
<code>CMSampleBuffer</code> 是否是视频帧，并且是否是关键帧。</p></li>
</ul>
<h3 id="ffmpeg-编码的流程是什么">FFmpeg 编码的流程是什么？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/lYKGrt4rOISncyFwYRM2cQ</p></li>
<li><p><code>av_register_all()</code>：注册 FFmpeg
所有编解码器。</p></li>
<li><p><code>avformat_alloc_context()</code>：初始化输出码流的
AVFormatContext。</p></li>
<li><p><code>avio_open()</code>：打开输出文件。</p></li>
<li><p><code>av_new_stream()</code>：创建输出码流的 AVStream。</p></li>
<li><p><code>avcodec_find_encoder()</code>：查找编码器。</p></li>
<li><p><code>avcodec_open2()</code>：打开编码器。</p></li>
<li><p><code>avformat_write_header()</code>：写文件头（对于某些没有文件头的封装格式，不需要此函数，比如
MPEG2TS）。</p></li>
<li><p><code>avcodec_send_frame()</code>：编码核心接口新接口，发送一帧视频给编码器。即是
AVFrame（存储YUV像素数据）。</p></li>
<li><p><code>avcodec_receive_packet()</code>：编码核心接口新接口，接收编码器编码后的一帧视频，AVPacket（存储
H.264 等格式的码流数据）。</p></li>
<li><p><code>av_write_frame()</code>：将编码后的视频码流写入文件。</p></li>
<li><p><code>flush_encoder()</code>：输入的像素数据读取完成后调用此函数。用于输出编码器中剩余的
AVPacket。</p></li>
<li><p><code>av_write_trailer()</code>：写文件尾（对于某些没有文件头的封装格式，不需要此函数，比如
MPEG2TS）。</p></li>
</ul>
<h3
id="ios-音频帧-cmsamplebufferref-中的-kcmformatdescriptionextension_verbatimisosampleentry-保存哪些信息是否可以去掉">iOS
音频帧 CMSampleBufferRef 中的
kCMFormatDescriptionExtension_VerbatimISOSampleEntry
保存哪些信息，是否可以去掉？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/lYKGrt4rOISncyFwYRM2cQ</li>
</ul>
<h2 id="媒体封装">媒体封装</h2>
<h3
id="什么是-mp4-的-moov-box我们在封装-mp4-时通常怎么处理它为什么">什么是
MP4 的 moov Box？我们在封装 MP4 时通常怎么处理它？为什么？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>moov Box 即 Movie Box，MP4 中存储所有媒体数据的索引信息的
Box。moov Box 可以说是 MP4 文件中最重要的
Box，一般播放器的实现都需要读取到 moov 的数据才能开始播放流程。
对于通过网络播放 MP4 视频的场景，都建议将视频处理为 moov 前置。因为 moov
前置后，从网络读取和播放 MP4 文件时，就可以较快获取到 moov
的数据并开始播放。</p></li>
</ul>
<h3 id="aac-封装到-mp4-中是否需要为每个-aac-packet-添加-adts">AAC 封装到
MP4 中，是否需要为每个 AAC packet 添加 ADTS？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ">https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ</a></p></li>
<li><p>不需要，原因如下：</p></li>
<li><p>1）我们所说的 AAC 文件实际是 AAC 封装格式，其实在 AAC
编码格式的基础上添加了 ADTS 头等信息，组装成 AAC 封装格式的；</p></li>
<li><p>2）将 AAC 编码后的数据存放到 MP4 中，就需要按照 MP4
的封装格式来进行存储；</p></li>
<li><p>3）MP4 中实际将类似 ADTS 这些信息存放到了 moov 中的音频通道对应的
box 中了。</p></li>
</ul>
<h3 id="ios-如何支持封装-fmp4-格式">iOS 如何支持封装 FMP4 格式？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A">https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A</a></p></li>
<li><p><code>AVAssetWriter</code>
设置以下参数即可，系统会按照设置的切片时长回调
<code>didOutputSegmentData</code> 返回数据，仅 iOS 14
系统以上才可以。</p></li>
</ul>
<h3 id="ffmpeg-如何支持封装-fmp4-格式">FFmpeg 如何支持封装 FMP4
格式？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A">https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A</a></p></li>
<li><p><code>FMP4</code> 数据格式参考第 2 题，<code>FFmpeg</code> 实现
<code>FMP4</code> 需要通过 <code>Muxer</code> 配置参数，设置
<code>avio_alloc_context</code> 回调数据，具体分片通过控制
<code>av_write_frame(formatContext, NULL)</code>
调用时机执行相关策略。</p></li>
</ul>
<h2 id="媒体传输">媒体传输</h2>
<h3 id="rtmp-消息分优先级的设计有什么好处">RTMP
消息分优先级的设计有什么好处？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>RTMP 的消息优先级是：控制消息 &gt; 音频消息 &gt;
视频消息。当网络传输能力受限时，优先传输高优先级消息的数据。
要使优先级能够有效执行，分块也很关键：将大消息切割成小块，可以避免大的低优先级的消息（如视频消息）堵塞了发送缓冲从而阻塞了小的高优先级的消息（如音频消息或控制消息）。</p></li>
</ul>
<h3 id="cdn-在直播中有哪些运用">CDN 在直播中有哪些运用？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q">https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q</a></p></li>
<li><p>CDN 的全称为 Content Delivery
Network，即内容分发网络，是一个策略性部署的整体系统，主要用来解决由于网络带宽小、用户访问量大、网点分布不均匀等导致用户访问网站速度慢的问题。这中间就有了很多的
CDN 节点。
具体实现是通过在现有的网络中，增加一层新的网络架构，将网站的内容发布到离用户最近的网络节点上，这样用户可以就近获取所需的内容，解决之前网络拥塞、访问延迟高的问题，提高用户体验。
CDN 直播中常用的流媒体协议包括 RTMP、HLS、HTTP FLV 等。RTMP（Real Time
Messaging Protocol）是基于 TCP 的，由 Adobe 公司为 Flash
播放器和服务器之间音频、视频传输开发的开放协议。HLS（HTTP Live
Streaming）是基于 HTTP 的，是 Apple 公司开放的音视频传输协议。HTTP FLV
则是将 RTMP 封装在 HTTP 协议之上的，可以更好的穿透防火墙等。 CDN
架构设计比较复杂，不同的 CDN
厂商，也在对其架构进行不断的优化，所以架构不能统一而论。这里只是对一些基本的架构进行简单的剖析。CDN
主要包含：源站、缓存服务器、智能
DNS、客户端等几个主要组成部分。</p></li>
</ul>
<p>-源站：是指发布内容的原始站点。添加、删除和更改网站的文件，都是在源站上进行的；另外缓存服务器所抓取的对象也全部来自于源站。对于直播来说，源站为主播客户端。</p>
<p>-缓存服务器：是直接提供给用户访问的站点资源，由一台或数台服务器组成；当用户发起访问时，他的访问请求被智能
DNS
定位到离他较近的缓存服务器。如果用户所请求的内容刚好在缓存里面，则直接把内容返还给用户；如果访问所需的内容没有被缓存，则缓存服务器向邻近的缓存服务器或直接向源站抓取内容，然后再返还给用户。</p>
<p>-智能 DNS：是整个 CDN
技术的核心，它主要根据用户的来源，以及当前缓存服务器的负载情况等，将其访问请求指向离用户比较近且负载较小的缓存服务器。通过智能
DNS
解析，让用户访问同服务商下、负载较小的服务器，可以消除网络访问慢的问题，达到加速作用。</p>
<p>-客户端：即发起访问的普通用户。对于直播来说，就是观众客户端，例如手机客户端，PC
客户端。</p>
<h3
id="为什么视频会议用-udp如果用-tcp-实现音视频需要建立几次连接用-udp-实现音视频有什么方法可以保证通话质量">为什么视频会议用
UDP？如果用 TCP 实现音视频，需要建立几次连接？用 UDP
实现音视频，有什么方法可以保证通话质量？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q">https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q</a></p></li>
<li><p>1）为什么视频会议用 UDP？
视频会议场景最重要的体验指标一般是『通话延时』和『语音音质』两方面。
在传输层使用 UDP 的主要考虑是为了降低通话延时。因为 UDP 的不需要 TCP
那样的面向连接、可靠传输、拥塞控制等机制，这些机制（比如三次握手建连、丢包重传等）通常都会带来相对
UDP 更高的延时。
当然，另外一方面原因是人们对视频会议中图像信息的损失容忍度是比较高的，这样即使
UDP 无法保证可靠性，有时候还是可以接受的。 2）如果用 TCP
实现音视频，需要建立几次连接？ 可以做到只建连一次，多路复用。
也可以音频和视频各使用一路连接。 3）用 UDP
实现音视频，有什么方法可以保证通话质量？ 使用 UDP
享受了低延时，牺牲了可靠性。但可靠性牺牲太多导致不可用也是不可接受的，所以还需要做一些机制来保证一定的可靠性，比如我们可以参考
WebRTC 的机制： -NACK：通过丢包重传解决丢包问题，会增加延时。
-FEC：通过冗余数据解决丢包问题，会增加带宽占用。
-JitterBuffer：通过队列对接收到的数据进行缓冲，出队时将数据包均匀平滑的取出，解决视频的乱序与抖动。
-NetEQ：类似 JitterBuffer，解决音频的乱序与抖动。</p></li>
</ul>
<h3
id="rtmp-和-rtsp-有什么区别使用-rtsp-是基于-udp-传输的话我们怎样进行乱序重排">RTMP
和 RTSP 有什么区别？使用 RTSP 是基于 UDP
传输的话，我们怎样进行乱序重排？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>RTMP 和 RTSP 的区别:</p></li>
<li><p>RTMP 使用 TCP
作为传输层协议，能保证不丢包和接收顺序，传输质量高。</p></li>
<li><p>RTSP 使用 RTP 格式协议和 RTCP
控制协议，命令与数据分离。传输层协议一般会选择
UDP，延迟比较低，传输效率高。</p></li>
<li><p>RTSP 中的 RTP 格式头中有 SequenceNumber
字段，可以通过这个序号实现排序。</p></li>
</ul>
<h3
id="假如给你一堆乱序的-rtp-包应该怎样实现乱序重排">假如给你一堆乱序的
RTP 包，应该怎样实现乱序重排？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>可以利用接收 RTP 包缓冲队列使用包的序号进行排序。</p></li>
<li><p>在丢包情况下为保证传输质量会引入 NACK 和 FEC 机制。</p></li>
<li><p>NACK 表示接收端通知发送端一些包丢失，发送 NACK 包请求重传；FEC
前向纠错值的是每个包携带一些冗余信息可以在部分包丢失的时候利用其他包进行重建。</p></li>
<li><p>如果重传次数过多，包无法重建，或者丢的包过多，此时可以丢帧直接跳过丢失的部分。</p></li>
</ul>
<h3
id="你在项目中是怎么降低端到端的延时的">你在项目中是怎么降低端到端的延时的？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>下面是直播走 RTMP 推流、HTTP-FLV
播放方案降低端到端延迟的思路：</p></li>
<li><p>推流端的延迟包含编码延迟和发送缓存队列引入的延迟。可以通过调节编码参数（B
帧、码率、帧率）减小编码延迟但会影响画质。另外可以提高上传的传输性能来减小传输时长。</p></li>
<li><p>CDN
链路上的传输延迟。包括推流的链路和播放回源的链路，这部分延迟不是太大，但依旧会引入几百
ms 的延迟。</p></li>
<li><p>CDN 拉流边缘节点的吐流策略会直接影响延迟的大小。直播流编码的 GOP
的长度，CDN 在客户端拉流时吐几秒的数据、按照 GOP
分隔如何丢数据，这些策略都会影响延时。</p></li>
<li><p>播放端可以通过对当前已下载的 buffer
进行倍速播放和跳帧来降低缓存从而达到降低延迟。注意如果倍速过大，声音是会明显变调的，需要通过算法来调整。跳帧一定要注意视频跳到
I 帧，音频对齐视频进行丢弃。</p></li>
</ul>
<h2 id="渲染">渲染</h2>
<h3 id="opengl-是按照什么架构设计的">OpenGL 是按照什么架构设计的？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>OpenGL 的渲染架构是 Client/Server
模式：Client（客户端）指的是我们在 CPU 上运行的一些代码，比如我们会编写
OC/C++/Java 代码调用 OpenGL 的一些 API；而
Server（服务端）则对应的是图形渲染管线，会调用 GPU
芯片。我们开发的过程就是不断用 Client 通过 OpenGL 提供的通道去向 Server
端传输渲染指令，来间接的操作 GPU 芯片。</p>
<ul>
<li></li>
</ul></li>
</ul>
<h3 id="什么是渲染上下文context">什么是渲染上下文（Context）？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>OpenGL 自身是一个巨大的状态机（State Machine）：一系列的变量描述
OpenGL 此刻应当如何运行。OpenGL 的状态通常被称为 OpenGL
上下文（Context）。我们通过改变上下文中的状态来改变接下来绘画的属性和操作的缓冲对象，然后
OpenGL
利用当前的上下文（Context）的状态去渲染。因此状态的改变要非常小心，因为是状态是全局，会影响接下来的所有渲染操作。</p></li>
</ul>
<h3 id="什么是离屏渲染">什么是离屏渲染？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>GPU 渲染机制：CPU 计算好显示内容提交到 GPU，GPU
渲染完成后将渲染结果放入帧缓冲区，随后屏幕控制器会按照 VSync
信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p></li>
<li><p>当前屏幕渲染，指的是 GPU
的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p></li>
<li><p>离屏渲染，指的是 GPU
在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p></li>
<li><p>特殊的离屏渲染：如果将不在 GPU
的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的离屏渲染方式：CPU
渲染。</p></li>
</ul>
<h3
id="为什么离屏渲染会造成性能损耗">为什么离屏渲染会造成性能损耗？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>当使用离屏渲染的时候会很容易造成性能消耗，因为离屏渲染会单独在内存中创建一个屏幕外缓冲区并进行渲染，而屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的。</p></li>
<li><p>由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU
没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p></li>
</ul>
<h3 id="什么是-opengl-渲染管线pipeline">什么是 OpenGL
渲染管线（Pipeline）？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>OpenGL 渲染管线就是 OpenGL
的工作流程，指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。</p></li>
<li><p>图形渲染管线可以大致被划分为两个主要部分：第一部分把你的 3D
坐标转换为 2D 坐标；第二部分是把 2D
坐标转变为实际的有颜色的像素。</p></li>
</ul>
<h3 id="opengl-渲染管线主要包含哪些部分">OpenGL
渲染管线主要包含哪些部分？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>OpenGL 的渲染管线其实也是类似的一个过程，它的工序包括：顶点着色器
→ 图元装配 → 几何着色器 → 光栅化 → 片段着色器 → 测试与混合。</p>
<ul>
<li></li>
</ul></li>
</ul>
<h3 id="为什么说-opengl-渲染管线中的着色器shader是可编程管线">为什么说
OpenGL 渲染管线中的着色器（Shader）是可编程管线？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>OpenGL 渲染管线中着色器允许开发者自己配置，这样我们就可以使用
GLSL（OpenGL Shading
Language）来编写自己的着色器替换默认的着色器，从而更细致地控制图形渲染管线中的特定部分。</p></li>
</ul>
<h3
id="有哪些着色器可以由程序员进行编程">有哪些着色器可以由程序员进行编程？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>可编程的着色器有：顶点着色器（Vertex
Shader）、几何着色器（Geometry Shader）、片段着色器（Fragment
Shader）。常用的是顶点着色器和片段着色器。</p></li>
</ul>
<h3 id="什么是-vboebo-和-vao">什么是 VBO、EBO 和 VAO？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>可以认为它们是在 OpenGL 中处理数据的三大类缓冲内存对象。</p></li>
<li><p>VBO（Vertex Buffer Objects）顶点缓冲区对象，指的是在 GPU
显存里面存储的顶点数据（位置、颜色）。</p></li>
<li><p>EBO（Element Buffer
Object）图元索引缓冲区对象，指的是为了更高效的利用数据，存储索引来达到减少重复数据的索引数据。</p></li>
<li><p>VAO（Vertex Array Object）顶点数组对象，主要作用是用于管理 VBO 或
EBO，减少 glBindBuffer、glEnableVertexAttribArray、glVertexAttribPointer
这些调用操作，高效地实现在顶点数组配置之间切换。</p></li>
</ul>
<h3 id="vertex-buffer-object-的布局格式是怎样的">Vertex Buffer Object
的布局格式是怎样的？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>如图</p>
<ul>
<li></li>
</ul></li>
</ul>
<h3 id="vertex-array-object-的布局格式是怎样的">Vertex Array Object
的布局格式是怎样的？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>当 VAO 只管理 VBO 时，布局格式如下图所示：</p>
<ul>
<li></li>
</ul></li>
<li><p>当 VAO 管理 VBO 和 EBO 时，布局格式如下图所示：</p>
<ul>
<li></li>
</ul></li>
</ul>
<h3
id="你在项目中使用过-sdl-进行渲染能否讲一下-sdl-渲染">你在项目中使用过
SDL 进行渲染，能否讲一下 SDL 渲染？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>SDL（Simple DirectMedia
Layer）是一套开放源代码的跨平台多媒体开发库，使用 C
语言写成。其主要用于游戏开发中的多媒体处理，如：视频渲染、音频播放、鼠标键盘控制等操作。它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层
API 库。</p></li>
<li><p>SDL 的基本流程如下：</p>
<ul>
<li><p>1、初始化 SDL</p></li>
<li><p>2、创建窗口</p></li>
<li><p>3、创建渲染器</p></li>
<li><p>4、清空缓冲区</p></li>
<li><p>5、绘制要显示的内容</p></li>
<li><p>6、最终将缓冲区内容渲染到 Window 窗口上</p></li>
<li><p>7、销毁渲染器</p></li>
<li><p>8、销毁窗口</p></li>
<li><p>9、退出 SDL</p></li>
</ul></li>
</ul>
<h3
id="opengl-的双缓冲机制是什么eglcreatewindowsurfaceeglcreatepbufffersurface-和双缓冲机制有什么关联吗">OpenGL
的双缓冲机制是什么？eglCreateWindowSurface、eglCreatePbuffferSurface
和双缓冲机制有什么关联吗？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA">https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA</a></p></li>
<li><p>双缓冲机制主要目的是为了解决计算机图形学中的屏幕闪烁和画面流畅性问题。该机制通过在内存中创建两个缓冲区：一个用于绘制图像的后缓冲区，一个用于显示图像的前缓冲区，来避免因为输入输出速度不匹配造成的界面闪烁、卡顿等现象。这个问题是很老的问题了，目前的系统基本都已经支持双缓冲了。</p></li>
<li><p>双缓冲机制与的 eglCreateWindowSurface、eglCreatePbuffferSurface
这两个方法没有直接的关系。这两个方法是为了实现当前屏幕渲染和离屏渲染的功能，eglCreateWindowSurface
是创建屏幕上的渲染区域来实现屏幕渲染，eglCreatePbuffferSurface
是创建屏幕外的渲染区域来实现离屏渲染。也就是说你创建
eglCreateWindowSurface 就自动支持双缓冲机制了。</p></li>
</ul>
<h3
id="想要把-iosandroid-应用开发中-opengl-es-渲染相关模块下沉到-c-实现双端共用要怎么实现">想要把
iOS、Android 应用开发中 OpenGL ES 渲染相关模块下沉到 C++
实现双端共用要怎么实现？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ">https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ</a></p></li>
<li><ul>
<li>1、创建一个 C++ 的渲染引擎模块。该模块将负责处理 OpenGL ES
的渲染逻辑。您可以使用现有的 C++ 图形库，如 Angle、Diligent Engine
等，或者自己编写一个。</li>
</ul></li>
<li><ul>
<li>2、将渲染逻辑从 iOS 和 Android 应用中移动到 C++
渲染业务模块。包括创建 OpenGL ES
上下文、编译和链接着色器程序、设置渲染状态、绘制图形等。</li>
</ul></li>
<li><ul>
<li>3、封装 C++ 接口层。为了在 iOS 和 Android 应用中使用 C++
渲染模块，您需要封装 C++ 接口层，该接口层需要定义 iOS 和 Android
业务层代码与渲染模块交互的函数和方法。这样，应用程序可以通过调用这些接口来使用
C++ 渲染模块。</li>
</ul></li>
<li><ul>
<li>4、处理平台特定的差异。由于 iOS 和 Android
平台的差异，您可能需要处理一些平台特定的差异，例如，处理不同的输入事件、处理不同的窗口管理等。在
C++ 接口中，可以定义平台特定的函数，然后在 iOS 和 Android
应用中实现这些函数。</li>
</ul></li>
</ul>
<h3 id="使用-opengl-绘制时对于二维坐标需要注意什么">使用 OpenGL
绘制时对于二维坐标需要注意什么？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-cwQbkbHqmMKRPk0YhBG6g</p></li>
<li><p>搞清楚顶点坐标与纹理坐标</p></li>
<li><p>FBO 与 glViewport</p></li>
</ul>
<h3 id="聊聊-opengl-glflush-和-glfinish-区别">聊聊 OpenGL glFlush 和
glFinish 区别？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-oC7782W_Sh0qxTQAZ7Y8g</p></li>
<li><p>一般来说，我们在使用 OpenGL
的时候，指令不是立即执行的。它们首先被送到指令缓冲区，然后才被送到硬件执行。glFinish
和 glFlush 都是强制将命令缓冲区的内容提交给硬件执行。</p></li>
<li><p>一般使用 glFlush 的目的是确保在调用之后，CPU 没有 OpenGL
相关的事情需要做，命令会送到硬件执行。调用 glFinish
的目的是确保当返回之后，没有相关工作留下需要继续做。</p></li>
</ul>
<h3 id="怎么实现-opengl-多线程同步">怎么实现 OpenGL 多线程同步？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-oC7782W_Sh0qxTQAZ7Y8g</p></li>
<li><p>一般情况下我们调用 OpenGL 方法后，并不是马上有效果的，如果在 B
线程使用 A 线程的纹理有概率出现渲染异常，因为 A
纹理还没有渲染完成。</p></li>
<li><p>glFinish 同步方案</p></li>
<li><p>Fence 同步方案</p></li>
</ul>
<h3 id="如何实现-opengl-资源共享">如何实现 OpenGL 资源共享？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-oC7782W_Sh0qxTQAZ7Y8g</p></li>
<li><p>在使用 eglCreateContext 时， 可以传入一个已创建成功的上下文，
这样就可以得到一个共享的上下文 (Shared Context)。</p></li>
<li><p>可以共享的资源：</p>
<ul>
<li><p>纹理；</p></li>
<li><p>shader；</p></li>
<li><p>program 着色器程序；</p></li>
<li><p>buffer 类对象，如 VBO、 EBO、 RBO 等 。</p></li>
</ul></li>
<li><p>不可以共享的资源：</p>
<ul>
<li>FBO 帧缓冲区对象（不属于 buffer 类）； VAO 顶点数组对象（不属于
buffer 类）。 在不可以共享的资源中，FBO 和 VAO 属于资源管理型对象，FBO
负责管理几种缓冲区，本身不占用资源，VAO 负责管理 VBO 或 EBO
，本身也不占用资源。</li>
</ul></li>
</ul>
<h3 id="opengl-纹理缓存要如何设计">OpenGL 纹理缓存要如何设计？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-oC7782W_Sh0qxTQAZ7Y8g</p></li>
<li><p>需要一个可复用的纹理数组，设置一个最大上限。</p></li>
<li><p>每个纹理需要忙碌或空闲的状态，当空闲情况下可以进行复用。</p></li>
<li><p>一个 FBO
频繁更换绑定不同的纹理，将内容数据刷新到指定纹理上。</p></li>
<li><p>外层纹理使用完成后将纹理状态设置为空闲。</p></li>
</ul>
<h3 id="介绍一下-glreadpixels">介绍一下 glReadPixels？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/QyK-l2LX-xbauRop3AJ9xQ</p></li>
<li><p>glReadPixels 是 OpenGL ES 的
API，通常用于从帧缓冲区中读取像素数据，OpenGL ES 2.0 和 3.0
均支持。使用非常方便，但是效率也是最低的。</p></li>
</ul>
<h3 id="介绍一下-imagereader">介绍一下 ImageReader？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/QyK-l2LX-xbauRop3AJ9xQ</p></li>
<li><p>ImageReader 是 Android
中的一个类，用于获取相机设备的图像数据。它可以用于捕获相机拍摄的静态图像或实时预览帧，并提供对图像数据的访问和处理。</p></li>
</ul>
<h3 id="介绍一下-pbopixel-buffer-object">介绍一下 PBO（Pixel Buffer
Object）？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/QyK-l2LX-xbauRop3AJ9xQ</p></li>
<li><p>OpenGL PBO（Pixel Buffer
Object），被称为像素缓冲区对象，主要被用于异步像素传输操作。PBO
仅用于执行像素传输，不连接到纹理，且与 FBO （帧缓冲区对象）无关。OpenGL
PBO（像素缓冲区对象） 类似于 VBO（顶点缓冲区对象），PBO 开辟的也是 GPU
缓存，而存储的是图像数据。PBO 是 OpenGL ES 3.0
开始提供的一种方式，主要应用于从内存快速复制纹理到显存，或从显存复制像素数据到内存。</p></li>
</ul>
<h3 id="介绍一下-hardwarebuffer">介绍一下 HardwareBuffer？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/QyK-l2LX-xbauRop3AJ9xQ</p></li>
<li><p>HardwareBuffer 官方介绍为一种底层的内存 buffer
对象，可在不同进程间共享，可映射到不同硬件系统，如
GPU、传感器等，从构造函数可以看出，其可以指定 format 和
usage，用来让底层选择最合适的实现，目前 format
主要是渲染相关的纹理格式，Android 11 之后支持了 BLOB 格式，可用来做 NN
相关的数据共享。</p></li>
</ul>
<h3 id="使用-opengl-pbo-为什么能提高效率">使用 OpenGL PBO
为什么能提高效率？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/N-PzPA4rSHGtE6KIjnEX4Q</p></li>
<li><p>减少 CPU 等待：PBO 支持异步传输，这意味着 CPU
在发起传输请求后不必等待 GPU 完成传输，可以继续执行其他任务。</p></li>
<li><p>减少数据拷贝：使用 PBO 可以减少从 CPU 内存到 GPU
内存的数据拷贝次数。例如，当更新纹理时，可以先将数据复制到 PBO，然后由
GPU 直接从 PBO 读取，而不是每次都从 CPU 内存中复制。</p></li>
<li><p>提高带宽利用：PBO 允许更有效地利用内存带宽，因为它减少了 CPU 和
GPU 之间的数据传输量。</p></li>
<li><p>优化显存利用：使用 PBO
可以避免在每次更新纹理时销毁和重新创建纹理内存，从而优化显存的利用率。</p></li>
<li><p>双缓冲或多缓冲技术：通过使用两个或多个 PBO，可以在一个 PBO 进行
GPU 操作的同时，使用 CPU 填充另一个
PBO，从而实现更高效的流水线操作。</p></li>
</ul>
<h3 id="什么是-vao什么是-vbo它们的作用是什么">什么是 VAO，什么是
VBO，它们的作用是什么？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/sKvPn2pLRYdJzx6RepKp1Q</p></li>
<li><p>VBO</p>
<ul>
<li><p>VBO 主要用于存储顶点数据，如顶点坐标、法线、颜色等。</p></li>
<li><p>通过将顶点数据存储在 GPU 的显存中，可以提高渲染效率，因为 GPU
能够更快地访问这些数据，而无需反复从 CPU 内存中读取。</p></li>
</ul></li>
<li><p>VAO</p>
<ul>
<li><p>VAO（Vertex Array Object）顶点数组对象，主要作用是用于管理 VBO 或
EBO。</p></li>
<li><p>VBO
保存了一个模型的顶点属性信息，每次绘制模型之前需要绑定顶点的所有信息，当数据量很大时，重复这样的动作变得非常麻烦。VAO
可以把这些所有的配置都存储在一个对象中，每次绘制模型时，只需要绑定这个
VAO 对象就可以了，可以减少 glBindBuffer 、glEnableVertexAttribArray、
glVertexAttribPointer
这些调用操作，高效地实现在顶点数组配置之间切换。</p></li>
</ul></li>
</ul>
<h3
id="纹理有哪些环绕方式wrapping">纹理有哪些环绕方式（wrapping）？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/JbEGcM95fL3i7g30dTDtOw</p></li>
<li><p>重复（GL_Repeat）</p></li>
<li><p>镜像重复（GL_MIRRORED_REPEAT）</p></li>
<li><p>夹取到边缘（GL_CLAMP_TO_EDGE）</p></li>
<li><p>夹取到边框（GL_CLAMP_TO_BORDER）</p></li>
</ul>
<h3 id="调试-opengl-特效的时候图像不对有什么调试技巧能快速排查原因">调试
OpenGL 特效的时候图像不对，有什么调试技巧能快速排查原因？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/ktWZ0kTtVO8iqhTIYqTJ3w</li>
</ul>
<h3
id="自己实现播放器时利用-ffmpeg-拿到解码后数据封装成-cvpixelbuffer-缓存用于渲染但是缓存后数据只有几帧但为什么内存占用有时候会有几百兆">自己实现播放器时利用
FFmpeg 拿到解码后数据封装成 CVPixelbuffer
缓存用于渲染，但是缓存后数据只有几帧，但为什么内存占用有时候会有几百兆？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/ktWZ0kTtVO8iqhTIYqTJ3w</p></li>
<li><p>自己创建 <code>CVPixelBuffer</code>
缓存即使你在程序中及时释放但是系统真正释放的时机可能会延迟，导致占用内存过高。</p></li>
</ul>
<h2 id="直播推流">直播推流</h2>
<h3 id="直播打开成功率如何优化">直播打开成功率如何优化？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/xjChNR6Y0zgJzmyS-2n8gQ</li>
</ul>
<h3 id="直播播放秒开如何优化">直播播放秒开如何优化？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/xjChNR6Y0zgJzmyS-2n8gQ</li>
</ul>
<h3 id="直播播放卡顿如何优化">直播播放卡顿如何优化？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/xjChNR6Y0zgJzmyS-2n8gQ</li>
</ul>
<h3 id="直播延时如何优化">直播延时如何优化？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/xjChNR6Y0zgJzmyS-2n8gQ</li>
</ul>
<h3 id="直播美颜如何实现">直播美颜如何实现？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/IKDY_slQg_J_01xyE_wENA</li>
</ul>
<h3 id="直播间礼物特效的如何实现">直播间礼物特效的如何实现？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/IKDY_slQg_J_01xyE_wENA</li>
</ul>
<h3 id="直播连麦的如何实现">直播连麦的如何实现？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/IKDY_slQg_J_01xyE_wENA</li>
</ul>
<h3 id="直播间的回声消除如何实现">直播间的回声消除如何实现？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/IKDY_slQg_J_01xyE_wENA</li>
</ul>
<h3
id="在实现类似-obs-的实时的图片gif-贴片叠加和替换效果时遇到了性能瓶颈请问如何实现快速的-gif-贴片叠加和替换">在实现类似
OBS 的实时的图片、GIF
贴片叠加和替换效果时遇到了性能瓶颈，请问如何实现快速的 GIF
贴片叠加和替换？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/ktWZ0kTtVO8iqhTIYqTJ3w</li>
</ul>
<h2 id="视频生产及编辑">视频生产及编辑</h2>
<h3 id="视频编辑中如何实现视频倒放">视频编辑中如何实现视频倒放？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw">https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw</a></p></li>
<li><p>如果用最直接的思路去实现视频倒放，那就是把视频中的每一帧图像都解码出来逆排序一下，然后将原视频的
pts
时间戳一一对应的关联上逆排序后的每一帧，再重新编码就可以了。</p></li>
<li><p>这个思路在实际实现时会有几个问题：解码后的视频帧放在内存或磁盘可能都还挺大的；完整的解码、逆排序、编码一整个视频可能耗时较长。</p></li>
<li><p>对于这些问题我们可以采取分而治之、并行提效的思路。因为视频本身可以按照
GOP 单元独立编解码，所以我们可以把视频的每一个 GOP
单元取出来分别做解码、逆排序、编码，最后再把处理后的所有 GOP 重新 remux
封装起来即可。</p></li>
<li><p>其中逆排序过程中，对于一个 GOP
的各帧处理流程大致是这样的：比如一个 GOP 的各视频帧及对应的 pts 分别是
<code>1(0), 2(30), 3(60), 4(90)</code>，那逆排序后就是
<code>4(0), 3(30), 2(60), 1(90)</code>。</p></li>
</ul>
<h3
id="拍短视频想把同时播放的音乐录制下来一般要经过怎样的处理流程">拍短视频想把同时播放的音乐录制下来一般要经过怎样的处理流程？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ">https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ</a></p></li>
<li><p>有一种方案是把麦克风采集声音中的外放音乐声进行回声消除，然后再添加上音乐的原始音轨。一般在
iOS 设备上可以考虑这种方案。但是在 Android
设备上我们通常不这样做，原因有下面几点：</p></li>
<li><p>对音乐进行回声消除的同时也会对麦克风采集到的其他声音有抑制效果，导致最后整体的声音效果不好；</p></li>
<li><p>手机播放音乐到麦克风采集到声音之间有一定的延时，不同的 Android
设备的延时差异较大，这个延时估算不准确会影响回声消除的效果。</p></li>
<li><p>一般情况我们可以按照下面的流程来处理：</p></li>
<li><p>1）音乐外放的情况，直接通过外放播放音乐，声音通过麦克风录制下来；</p></li>
<li><p>2）戴耳机或手机静音的情况，音乐不会被麦克风录制下来；</p></li>
<li><p>3）录制完成时，将录制得到的视频中的音轨（这里面可能包含已经和其他外音被采集下来的音乐）和音乐原始的音轨进行叠加增强。</p></li>
</ul>
<h3 id="android-camera-如何优化视频录制的卡顿">Android Camera
如何优化视频录制的卡顿？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA">https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA</a></p></li>
<li><p><strong>1）视频录制流程</strong></p>
<ul>
<li><ul>
<li>打开 <code>Camera</code>。</li>
</ul></li>
<li><ul>
<li>创建 <code>SurfaceTextue</code> ，将 <code>Camera</code>
输出的数据渲染到 <code>SurfaceTextue</code>。</li>
</ul></li>
<li><ul>
<li><code>SurfaceTexture</code> 拿到的结果进行特效处理。</li>
</ul></li>
<li><ul>
<li>特效处理的结果异步分发给 <code>RenderView</code> 预览与
<code>MediaCodec</code> 编码。</li>
</ul></li>
<li><ul>
<li>编码后的结果进行 <code>Muxer</code> 合成 <code>MP4</code>
视频。</li>
</ul></li>
</ul></li>
<li><p><strong>2）视频录制流程优化</strong></p>
<ul>
<li><ul>
<li>相机、编码根据不同机型控制不同帧率、分辨率。</li>
</ul></li>
<li><ul>
<li>实现丢帧模块，将采集后的帧进入丢帧模块进行控制帧率，降低渲染以及编码性能。</li>
</ul></li>
<li><ul>
<li>采集、渲染、编码按照多个线程处理，每个模块发挥最优性能。</li>
</ul></li>
<li><ul>
<li>预览视图优先采用 <code>SurfaceView</code>，少量使用
<code>TextureView</code>，因为 <code>TextureView</code>
占用主线程渲染。</li>
</ul></li>
<li><ul>
<li>编码优先使用 <code>Surface</code> 异步编码。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="转码速度优化的几点建议">转码速度优化的几点建议？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A">https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A</a></p></li>
<li><p><strong>1）解码</strong></p>
<ul>
<li><ul>
<li>优先使用系统硬件解码，软件解码仅兜底使用。</li>
</ul></li>
<li><ul>
<li>解码方式优先使用异步。</li>
</ul></li>
<li><ul>
<li>解码器可以创建复用池。</li>
</ul></li>
<li><ul>
<li>Android 解码优先考虑 <code>Surface</code> 解码方式。</li>
</ul></li>
</ul></li>
<li><p><strong>2）多线程并发</strong></p>
<ul>
<li><ul>
<li>转码分为解码与编码，通常编码更加耗时，这样解码线程可保持几帧
<code>Cache</code> 数据供编码获取。</li>
</ul></li>
<li><ul>
<li>同一个视频可以分片转码为 <code>FMP4</code> ，最终拼接为一个
<code>FMP4</code>，并发数目设置参考 2-5。</li>
</ul></li>
</ul></li>
<li><p><strong>3）其它</strong></p>
<ul>
<li><ul>
<li>码率不高的视频无需转码。</li>
</ul></li>
<li><ul>
<li>对于帧率过高、码率过高视频可降低相关参数，提高转码速度。</li>
</ul></li>
<li><ul>
<li>视频转码与发布可结合优化策略，例如一边分片转码一边上传。</li>
</ul></li>
<li><ul>
<li>针对不同场景进行指定策略处理，例如添加了音乐仅转码音频，仅转换封装格式使用
<code>Remuxer</code>。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="seek-优化的几点建议">Seek 优化的几点建议？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A">https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A</a></p></li>
<li><p><strong>1）解码</strong></p>
<ul>
<li><ul>
<li>优先使用系统硬件解码，软件解码仅兜底使用。</li>
</ul></li>
<li><ul>
<li>解码方式优先使用异步。</li>
</ul></li>
<li><ul>
<li>解码器可以创建复用池。</li>
</ul></li>
<li><ul>
<li>Android 解码优先考虑 <code>Surface</code> 。</li>
</ul></li>
<li><ul>
<li>对于 Seek 过程中的帧可以不输出数据，例如 iOS
<code>kVTDecodeFrame_DoNotOutputFrame</code>。</li>
</ul></li>
</ul></li>
<li><p><strong>2）其它</strong></p>
<ul>
<li><ul>
<li>对于 Seek 过程中的帧可以丢弃非参考帧。</li>
</ul></li>
<li><ul>
<li>优先判断 Seek 帧是否命中缓存。</li>
</ul></li>
<li><ul>
<li>优先找到 Seek 帧最近的关键帧。</li>
</ul></li>
<li><ul>
<li>对于向右侧 Seek 优先判断是否与当前解码帧同一个
<code>GOP</code>，同一个 <code>GOP</code> 无需
<code>Flush</code>，继续解码即可。</li>
</ul></li>
<li><ul>
<li>对于 Seek 位置精准度可以给一点空隙，例如 100ms
内偏差用户无感，这样可以利用缓存优势以及最近关键帧。</li>
</ul></li>
<li><ul>
<li>对于 Seek 超级频繁可以选择丢弃某些帧。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="音视频编辑-sdk-一般包含哪些模块各模块是什么职责">音视频编辑 SDK
一般包含哪些模块？各模块是什么职责？</h3>
<ul>
<li><a
href="https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA">https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA</a></li>
</ul>
<h3
id="音视频编辑中转码流程-pipeline-的线程模型和缓冲区要怎么设计">音视频编辑中转码流程
pipeline 的线程模型和缓冲区要怎么设计？</h3>
<ul>
<li><a
href="https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA">https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA</a></li>
</ul>
<h3
id="如何降低处理音视频链路中的内存峰值">如何降低处理音视频链路中的内存峰值？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-cwQbkbHqmMKRPk0YhBG6g</p></li>
<li><p>降低采集参数：</p>
<ul>
<li><p>降低采集视频分辨率</p></li>
<li><p>降低采集视频帧率</p></li>
</ul></li>
<li><p>降低并发任务数量：</p>
<ul>
<li>将任务分优先级，按照优先级串行执行，这样既能降低内存峰值，也会降低
CPU 峰值</li>
</ul></li>
</ul>
<h3
id="在编辑-sdk-中的播放器和播放-sdk-中的视频播放存在哪些区别呢编辑场景的播放器对-opengl-的使用有哪些进阶的用法">在编辑
SDK 中的播放器和播放 SDK 中的视频播放存在哪些区别呢？编辑场景的播放器对
OpenGL 的使用有哪些进阶的用法？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/HlLwri7rFNSs9C6rxZ90gw</p></li>
<li><p>剪辑方向的视频播放与播放器的视频播放相比最大的区别就是：需要处理更复杂渲染场景。</p></li>
<li><p>处理复杂的输入和渲染。</p></li>
<li><p>处理多线程渲染。</p></li>
<li><p>渲染流程结构可以做优化设计。</p></li>
<li><p>调试和报错。</p></li>
</ul>
<h3 id="ios-动态图片如何获取原始视频">iOS
动态图片如何获取原始视频？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/ktWZ0kTtVO8iqhTIYqTJ3w</li>
</ul>
<h3
id="为什么自制的动态图片导出到相册无法识别成动态图片">为什么自制的动态图片导出到相册无法识别成动态图片？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/-MeeGfwy3MDiZsuxL-VKHw</li>
</ul>
<h3 id="ios-如何实现音频内录录制当前所有手机的声音集合">iOS
如何实现音频内录，录制当前所有手机的声音集合？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-MeeGfwy3MDiZsuxL-VKHw</p></li>
<li><p>使用 ReplayKit。</p></li>
</ul>
<h3
id="应该选择哪种复杂字体渲染的方案-非-uiview-的能力">应该选择哪种复杂字体渲染的方案
(非 UIView 的能力)？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/-MeeGfwy3MDiZsuxL-VKHw</li>
</ul>
<h3 id="ios-如何在不解码的情况下给视频添加-metadata">iOS
如何在不解码的情况下给视频添加 Metadata？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/-MeeGfwy3MDiZsuxL-VKHw</li>
</ul>
<h2 id="播放器">播放器</h2>
<h3 id="点播的倍速播放要如何实现">点播的倍速播放要如何实现？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw">https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw</a></p></li>
<li><p>点播的倍速播放分为视频处理和音频处理部分。</p></li>
<li><p>1）视频处理</p>
<ul>
<li><p>对应视频数据的处理，核心逻辑就是按照倍速重新计算各视频帧的 pts
时间戳。</p></li>
<li><p>比如，对一个视频做 2 倍速播放，假设原来各视频帧的 pts 依次是
<code>0, 30, 60, 90 ...</code>，倍速处理及将它们除以 2 变成
<code>0, 15, 30, 45 ...</code>。这样处理后，视频的帧率和总时长相应的也发生了变化，帧率变为原来的
2 倍，总时长变为原来的 1/2。</p></li>
<li><p>但是，如果对视频进行高倍速播放，比如 10 倍速，这时候如果只处理
pts，原视频的时间戳除以 10 变成 <code>0, 3, 6, 9 ...</code>，这时候 3ms
一帧，帧率达到了
333fps，已经超过了屏幕硬件的刷新率，根本渲染不过来。所以对于高倍速播放：第一步，我们像上面一样在处理完
pts；第二步，我们还需要设定最大帧率的限制，并按照这个最大帧率来进行丢帧。</p></li>
<li><p>假如我们设定最大帧率是 60fps，这时候我们每 17ms
只需要一帧，上面的 <code>0, 3, 6, 9, 12, 15, 18 ...</code>
经过丢帧和帧率处理可能就变成了
<code>0, 17(18→17), 34(33→34) ...</code>。</p></li>
<li><p>高倍速播放还有另外的问题：解码性能是否跟得上、网络视频的下载速度是否跟得上等等。对于这些问题，我们可能还需要其他方案来解决，比如：在客户端在解码前就要丢弃非参考帧，对不需要解码的帧直接丢弃等等；在服务端对高倍速视频进行预处理，提前做好时间戳和丢帧处理，当用户切换高倍速时，帮用户切换资源即可。</p></li>
</ul></li>
<li><p>2）音频处理</p>
<ul>
<li>音频是每秒几 K 到几十 K
的采样点，对于音频数据的处理，如果只是跟视频一样，简单的处理 pts
时间戳会出现噪音、杂音，体验很差。音频一般需要进行重采样处理。比如，原来的音频是
48K 的采样率，播放设置了使用 48K 的采样率进行音频渲染，这时候要对音频做
2 倍速播放，可以将音频数据每秒 48K 个采样点重采样降低到 24K
个（把音频数据的采样率处理为 24K），当播放还是使用 48K
的采样率来播放时，每秒需要 48K 个采样点，这时候就需要 2s
的数据，这时候音频的播放速度就变成了原来的 2
倍。使用这样的方式来实现音频倍速，可以解决只简单处理 pts
带来的噪音、杂音问题，但是音频的播放会变调：快播时，声调会变高，听起来尖细；慢播时，声调会变低，听起来低沉。</li>
</ul></li>
</ul>
<h3
id="播放器解码后的帧缓冲区一般设置多大合适">播放器解码后的帧缓冲区一般设置多大合适？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw">https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw</a></p></li>
<li><p>对于播放器来说，在渲染之前一般会有一个解码后的帧缓冲区用于后续渲染。</p></li>
<li><p>使用 FFmpeg 软解码、Android MediaCodec
硬解码时，给编码器的数据是按照 dts 顺序输入的，解码器输出数据是按照 pts
输出的。但是使用 iOS VideoToolbox 硬解码时，解码器输出数据并没有按照 pts
顺序，而是解一帧出一帧，需要我们自己排序。</p></li>
<li><p>这样在使用 iOS VideoToolbox
硬解码时，还可以在这个缓冲区还可以用来对解码后的帧按 pts
做重排来保证正确的渲染顺序。</p></li>
<li><p>这个重排主要是针对 B 帧，因为 B
帧可能会依赖后面的帧才能完成解码，如果解码后的帧缓冲区太小，可能导致按照渲染顺序本该渲染的
B
帧由于依赖帧还未解码而出现播放卡顿。但是解码后的帧缓冲区也不是越大越好，因为解码后的视频帧数据是比较大的，会占用不少内存，缓冲区过大会造成播放器的内存占用过大。</p></li>
<li><p>那么这个缓冲区应该设置多大比较合适呢？这个其实取决于解码器需要的重排窗口大小，解码后的帧缓冲区大小只要不超过这个重排窗口尺寸即可。要计算重排窗口的大小通常可能会用到下面这几个参数：</p></li>
<li><p><code>max_ref_frames</code></p></li>
<li><p><code>max_num_reorder_frames</code></p></li>
</ul>
<h3
id="如何监控视频播放黑屏花屏绿屏等异常">如何监控视频播放黑屏、花屏、绿屏等异常？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw">https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw</a></p></li>
<li><p>视频播放时如果遇到黑屏、花屏、绿屏通常会伴有解码器的报错或异常信息，我们可以上报这些异常信息来实现对这些情况的监控。</p></li>
<li><p>但是也有一些情况，即使出现黑屏、花屏、绿屏的情况了，解码器也没有报错或异常，这时候就需要我们对解码后的画面进行检测来识别这些问题。一般可以这样：</p></li>
<li><ul>
<li>用传统的图像处理算法来识别。对于黑屏、绿屏可以用传统图像处理算法来进行识别，但这里也会有一些误识别的问题，比如视频本身就有些亮度较低、正常全黑帧、正常全绿帧的情况，可能也会被识别为异常。</li>
</ul></li>
<li><ul>
<li>训练 AI 模型类识别。对于花屏，可以训练 AI
模型来进行识别。训练过程可以通过人工构造丢帧视频的方法来生成花屏样本，同时筛选出无花屏问题的正常样本，基于这两类样本来做二分类模型的训练。</li>
</ul></li>
</ul>
<h3
id="如何通过优化播放器来优化音乐播放体验比如提升音质或音效">如何通过优化播放器来优化音乐播放体验，比如提升音质或音效？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg">https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg</a></p></li>
<li><p>在播放侧可以使用自动增益控制算法（AGC）来提升音效。AGC
算法通过自动调整音频信号的增益，使其保持在一定的范围内，这种算法可以避免因音频信号的幅度变化而引起的声音过大或过小的问题，保证了音频信号的稳定性和可听性，目前有开源的实现例如
webrtcagc，可以把算法移植到自己的项目中。</p></li>
</ul>
<h3
id="如果让你设计一个播放器的架构你会分哪几层">如果让你设计一个播放器的架构，你会分哪几层？</h3>
<ul>
<li><a
href="https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA">https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA</a></li>
</ul>
<h3 id="ffmpeg-中-avformat_open_input-经历了什么步骤">FFmpeg 中
avformat_open_input() 经历了什么步骤？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/lYKGrt4rOISncyFwYRM2cQ</p></li>
<li><p>打开输入媒体流</p></li>
<li><p>初始化输入媒体流</p></li>
<li><p>探测输入格式，根据当前参数进行打分，最终根据分数最高的那个配置作为最终格式</p></li>
<li><p>打开 avio</p></li>
</ul>
<h2 id="综合多媒体框架及服务">综合多媒体框架及服务</h2>
<h3 id="webrtc-中的-ice-作用">WebRTC 中的 ICE 作用？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/zujLvqBgOadxcZuer7uXJA</p></li>
<li><p>主要负责帮助位于不同网络环境（尤其是 NAT
之后）的两个端点建立直接的连接。</p></li>
</ul>
<h3 id="webrtc-中媒体协商过程">WebRTC 中媒体协商过程？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/zujLvqBgOadxcZuer7uXJA</p></li>
<li><p>创建 Offer</p></li>
<li><p>设置 Local Description</p></li>
<li><p>发送 Offer</p></li>
<li><p>接收 Offer 和创建 Answer</p></li>
<li><p>设置 Remote Description</p></li>
<li><p>设置 Answer 的 Local Description</p></li>
<li><p>发送 Answer</p></li>
<li><p>接收 Answer 和设置 Remote Description</p></li>
<li><p>ICE Candidate 交换</p></li>
<li><p>连接建立和媒体流传输</p></li>
</ul>
<h3 id="webrtc-nat-有几种类型">WebRTC NAT 有几种类型？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/zujLvqBgOadxcZuer7uXJA</p></li>
<li><p>完全锥型（Full Cone NAT）</p></li>
<li><p>地址限制锥型（Address-Restricted Cone NAT）</p></li>
<li><p>端口限制锥型（Port-Restricted Cone NAT）</p></li>
<li><p>对称型 NAT（Symmetric NAT）</p></li>
</ul>
<h3 id="webrtc-中的-gcc-机制">WebRTC 中的 GCC 机制？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/zujLvqBgOadxcZuer7uXJA</p></li>
<li><p>一种重要的拥塞控制机制，用于自适应地调整视频流的码率，以适应网络条件的变化，确保音视频通信的流畅性和清晰度。</p></li>
<li><p>基于RTCP反馈的码率控制</p></li>
<li><p>REMB（Receiver Estimated Maximum Bitrate）</p></li>
<li><p>发送端的码率控制</p></li>
</ul>
<h2 id="工具">工具</h2>
<h3 id="介绍一下-simd-以及它在音视频处理中的应用">介绍一下 SIMD
以及它在音视频处理中的应用？</h3>
<ul>
<li><p><a
href="https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg">https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg</a></p></li>
<li><p>SIMD（Single Instruction Multiple
Data）是一种并行计算的技术，它允许在单个指令中同时处理多个数据元素。SIMD
指令集通常由处理器提供，用于加速向量化计算，从而提高程序的性能。</p></li>
<li><p>1）在音频处理中，SIMD
可以用于实时音频效果处理，如均衡器、压缩器、混响器等，通过同时处理多个音频样本，可以提高音频处理的效率和实时性。</p></li>
<li><p>2）在视频处理中，SIMD
可以用于加速图像处理算法，如图像滤波、边缘检测、图像压缩等，通过同时处理多个像素，可以提高图像处理的速度和质量。</p></li>
<li><p>3）在视频编码中，SIMD 可以用于加速压缩和解压算法，如 H.264、H.265
编码器一些实现中，可以通过并行处理视频数据来提高视频编解码的效率和性能。</p></li>
</ul>
<h2 id="业务场景">业务场景</h2>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>Android Framework 开发</title>
    <url>/Android/Framework/Android-Framework-%E5%BC%80%E5%8F%91.html</url>
    <content><![CDATA[<h1 id="知识结构">知识结构</h1>
<pre><code class="highlight mermaid">graph LR
    A[Android Framework 开发技术栈]
    
    A --&gt; B[系统架构]
    B --&gt; B1[应用层]
    B --&gt; B2[Framework 层]
    B --&gt; B3[Native 层]
    B --&gt; B4[HAL 硬件抽象层]
    B --&gt; B5[Linux Kernel]

    A --&gt; C[核心组件]
    C --&gt; C1[ActivityManager]
    C --&gt; C2[WindowManager]
    C --&gt; C3[PackageManager]
    C --&gt; C4[ResourceManager]
    C --&gt; C5[ContentProvider]
    C --&gt; C6[View System]
    C --&gt; C7[NotificationManager]
    C --&gt; C8[TelephonyManager]

    A --&gt; D[进程与通信]
    D --&gt; D1[Binder IPC]
    D --&gt; D2[AIDL]
    D --&gt; D3[ Zygote]
    D --&gt; D4[SystemServer]
    D --&gt; D5[Handler 机制]
    D --&gt; D6[ASHMEM 共享内存]

    A --&gt; E[运行时]
    E --&gt; E1[ART]
    E --&gt; E2[Dalvik]
    E --&gt; E3[JNI]
    E --&gt; E4[Native Libraries]

    A --&gt; F[服务与模块]
    F --&gt; F1[System Services]
    F --&gt; F2[PowerManager]
    F --&gt; F3[AudioFlinger]
    F --&gt; F4[SurfaceFlinger]
    F --&gt; F5[InputManager]
    F --&gt; F6[MediaFramework]

    A --&gt; G[硬件相关]
    G --&gt; G1[HAL 接口定义语言 HIDL]
    G --&gt; G2[Sensor Framework]
    G --&gt; G3[Camera HAL]
    G --&gt; G4[Audio HAL]
    G --&gt; G5[GPU/Graphics]

    A --&gt; H[工具与调试]
    H --&gt; H1[ADB]
    H --&gt; H2[Logcat]
    H --&gt; H3[Systrace]
    H --&gt; H4[Dumpsys]
    H --&gt; H5[Android Source Build]

    A --&gt; I[定制与优化]
    I --&gt; I1[ROM 定制]
    I --&gt; I2[Bootloader]
    I --&gt; I3[OTA 更新]
    I --&gt; I4[Security SELinux]
    I --&gt; I5[Performance Tuning]</code></pre>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>Android MediaCodec 的使用和源码实现分析</title>
    <url>/Android/Framework/Android-MediaCodec-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<p><code>MediaCodec</code> 是 Android 提供的底层多媒体编解码
API，允许开发者使用系统硬件编解码器对音视频数据进行压缩/解压。</p>
<h1 id="使用流程图像音频通用">使用流程（图像/音频通用）</h1>
<p><code>MediaCodec</code>
提供了同步和异步两种使用模式，推荐使用异步模式（API 21
及以上）。无论是编码器（Encoder）还是解码器（Decoder），MediaCodec
的典型使用流程是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Configure → Start → (queueInputBuffer / dequeueOutputBuffer) → Stop → Release</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p><strong>创建 MediaCodec 实例</strong>：</p>
<p>通过 <code>MediaCodec.createByCodecName</code> 或
<code>MediaCodec.createEncoderByType</code> /
<code>MediaCodec.createDecoderByType</code> 创建编码器或解码器，指定
MIME 类型（如
<code>"video/avc"</code>、<code>"audio/mp4a-latm"</code>）。配置
<code>MediaFormat</code>，设置参数如分辨率、码率、采样率等。</p></li>
<li><p><strong>配置 MediaCodec</strong>：</p>
<p>调用 <code>configure()</code> 方法，传入
<code>MediaFormat</code>、Surface（视频解码时可选）等参数，指定编码或解码模式。</p></li>
<li><p><strong>启动 MediaCodec</strong>：</p>
<p>调用 <code>start()</code> 进入执行状态。</p></li>
<li><p><strong>处理输入输出缓冲区</strong>：</p>
<p><strong>输入缓冲区</strong>：通过 <code>dequeueInputBuffer()</code>
获取可用的输入缓冲区索引，将数据（如原始 PCM 或 YUV
数据）写入缓冲区，然后调用 <code>queueInputBuffer()</code> 提交。</p>
<p><strong>输出缓冲区</strong>：通过 <code>dequeueOutputBuffer()</code>
获取处理后的数据，处理后调用 <code>releaseOutputBuffer()</code>
释放。</p></li>
<li><p><strong>停止和释放</strong>：</p>
<p>调用 <code>stop()</code> 和 <code>release()</code>
停止并释放资源。</p></li>
</ol>
<p><strong>异步模式</strong>（API 21+）：使用 <code>setCallback()</code>
设置回调，处理输入输出缓冲区事件，避免手动轮询。在
<code>onInputBufferAvailable</code> 中填充数据，在
<code>onOutputBufferAvailable</code> 中处理结果。</p>
<h2 id="同步示例">同步示例：</h2>
<p>以解码 H.264 视频为例（原始数据为裸流 <code>.h264</code>）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> codec = MediaCodec.createDecoderByType(<span class="string">&quot;video/avc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> format = MediaFormat.createVideoFormat(<span class="string">&quot;video/avc&quot;</span>, width, height)</span><br><span class="line">format.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, <span class="number">0</span>)</span><br><span class="line">codec.configure(format, surface, <span class="literal">null</span>, <span class="number">0</span>)</span><br><span class="line">codec.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> inputBuffers = codec.inputBuffers</span><br><span class="line"><span class="keyword">val</span> outputBuffers = codec.outputBuffers</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="keyword">val</span> inIndex = codec.dequeueInputBuffer(<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">if</span> (inIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> inputBuffer = inputBuffers[inIndex]</span><br><span class="line">        inputBuffer.clear()</span><br><span class="line">        <span class="keyword">val</span> sampleSize = readH264Frame(inputBuffer)</span><br><span class="line">        <span class="keyword">if</span> (sampleSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            codec.queueInputBuffer(inIndex, <span class="number">0</span>, sampleSize, presentationTimeUs, <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            codec.queueInputBuffer(inIndex, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, MediaCodec.BUFFER_FLAG_END_OF_STREAM)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> bufferInfo = MediaCodec.BufferInfo()</span><br><span class="line">    <span class="keyword">val</span> outIndex = codec.dequeueOutputBuffer(bufferInfo, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">if</span> (outIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 解码帧已就绪，在 Surface 上显示</span></span><br><span class="line">        codec.releaseOutputBuffer(outIndex, <span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (outIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">        <span class="keyword">val</span> newFormat = codec.outputFormat</span><br><span class="line">        Log.d(<span class="string">&quot;MediaCodec&quot;</span>, <span class="string">&quot;Output format changed: <span class="variable">$newFormat</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">codec.stop()</span><br><span class="line">codec.release()</span><br></pre></td></tr></table></figure>
<h2 id="异步示例">异步示例：</h2>
<p>使用 <code>MediaCodec</code> 异步模式进行视频解码的示例（ H.264
视频解码到 Surface ）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.media.MediaCodec;</span><br><span class="line"><span class="keyword">import</span> android.media.MediaFormat;</span><br><span class="line"><span class="keyword">import</span> android.view.Surface;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec mediaCodec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MIME_TYPE</span> <span class="operator">=</span> <span class="string">&quot;video/avc&quot;</span>; <span class="comment">// H.264</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIMEOUT_US</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 10ms 超时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startDecoder</span><span class="params">(Surface surface, <span class="type">byte</span>[] sps, <span class="type">byte</span>[] pps)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建解码器</span></span><br><span class="line">            mediaCodec = MediaCodec.createDecoderByType(MIME_TYPE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置 MediaFormat</span></span><br><span class="line">            <span class="type">MediaFormat</span> <span class="variable">format</span> <span class="operator">=</span> MediaFormat.createVideoFormat(MIME_TYPE, <span class="number">1920</span>, <span class="number">1080</span>); <span class="comment">// 分辨率</span></span><br><span class="line">            format.setByteBuffer(<span class="string">&quot;csd-0&quot;</span>, ByteBuffer.wrap(sps)); <span class="comment">// SPS</span></span><br><span class="line">            format.setByteBuffer(<span class="string">&quot;csd-1&quot;</span>, ByteBuffer.wrap(pps)); <span class="comment">// PPS</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置异步回调</span></span><br><span class="line">            mediaCodec.setCallback(<span class="keyword">new</span> <span class="title class_">MediaCodec</span>.Callback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInputBufferAvailable</span><span class="params">(MediaCodec codec, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取输入缓冲区</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">inputBuffer</span> <span class="operator">=</span> codec.getInputBuffer(index);</span><br><span class="line">                    <span class="comment">// 从数据源获取数据（示例中假设有数据）</span></span><br><span class="line">                    <span class="type">byte</span>[] data = getVideoData(); <span class="comment">// 需实现</span></span><br><span class="line">                    <span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">                        inputBuffer.put(data);</span><br><span class="line">                        codec.queueInputBuffer(index, <span class="number">0</span>, data.length, getPresentationTimeUs(), <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 结束标志</span></span><br><span class="line">                        codec.queueInputBuffer(index, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, MediaCodec.BUFFER_FLAG_END_OF_STREAM);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOutputBufferAvailable</span><span class="params">(MediaCodec codec, <span class="type">int</span> index, MediaCodec.BufferInfo info)</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放输出缓冲区到 Surface</span></span><br><span class="line">                    <span class="keyword">if</span> ((info.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != <span class="number">0</span>) &#123;</span><br><span class="line">                        codec.stop();</span><br><span class="line">                        codec.release();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    codec.releaseOutputBuffer(index, <span class="literal">true</span>); <span class="comment">// 渲染到 Surface</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(MediaCodec codec, MediaCodec.CodecException e)</span> &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOutputFormatChanged</span><span class="params">(MediaCodec codec, MediaFormat format)</span> &#123;</span><br><span class="line">                    <span class="comment">// 输出格式变化</span></span><br><span class="line">                    <span class="comment">// 可处理新的 MediaFormat</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置并启动</span></span><br><span class="line">            mediaCodec.configure(format, surface, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">            mediaCodec.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟获取视频数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getVideoData() &#123;</span><br><span class="line">        <span class="comment">// 替换为实际数据源（如文件、网络流）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟获取时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getPresentationTimeUs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() / <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止解码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mediaCodec != <span class="literal">null</span>) &#123;</span><br><span class="line">            mediaCodec.stop();</span><br><span class="line">            mediaCodec.release();</span><br><span class="line">            mediaCodec = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用方法</strong>：</p>
<ol type="1">
<li>创建 <code>Surface</code>（如通过 <code>SurfaceView</code>
获取）。</li>
<li>提供 H.264 流的 SPS（Sequence Parameter Set，序列参数集） 和
PPS（Picture Parameter Set，图像参数集）数据。</li>
<li>调用 <code>startDecoder()</code> 传入 Surface 和 SPS/PPS。</li>
<li>数据源需实现 <code>getVideoData()</code>，提供 H.264 帧数据。</li>
<li>调用 <code>stop()</code> 释放资源。</li>
</ol>
<h2 id="编码示例">编码示例：</h2>
<p>与解码类似，只是配置为 <code>CONFIGURE_FLAG_ENCODE</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">format.setInteger(MediaFormat.KEY_BIT_RATE, <span class="number">125000</span>)</span><br><span class="line">format.setInteger(MediaFormat.KEY_FRAME_RATE, <span class="number">15</span>)</span><br><span class="line">format.setInteger(MediaFormat.KEY_COLOR_FORMAT,</span><br><span class="line">                  MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible)</span><br><span class="line">format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">codec.configure(format, <span class="literal">null</span>, <span class="literal">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE)</span><br></pre></td></tr></table></figure>
<p>然后从 <code>inputBuffer</code> 填入 YUV，读取
<code>outputBuffer</code> 得到压缩后的 H264。</p>
<h1 id="常见使用注意点">常见使用注意点</h1>
<p><strong>线程安全</strong>：</p>
<p><code>MediaCodec</code>
本身非线程安全，所有操作应在同一线程或通过同步机制处理。异步模式中，回调运行在内部线程，需确保数据处理线程安全。</p>
<p><strong>缓冲区管理</strong>：</p>
<p>输入缓冲区需确保数据格式正确（如 YUV 帧格式、PCM
采样率）。输出缓冲区可能返回 <code>INFO_</code> 状态（如
<code>INFO_OUTPUT_FORMAT_CHANGED</code>），需处理这些状态。不要长时间持有缓冲区，避免阻塞。</p>
<p><strong>硬件限制</strong>：</p>
<p>不同设备支持的编解码器和参数（如分辨率、帧率）不同，需通过
<code>MediaCodecInfo</code>
查询支持的功能。硬件解码器可能有缓冲区数量限制，需合理管理。</p>
<p><strong>配置 MediaFormat</strong>：</p>
<p>编码器需设置合理的码率、帧率、I
帧间隔等，避免过高参数导致性能问题。解码器需匹配输入数据的格式（如 H.264
的 SPS/PPS）。</p>
<p><strong>错误处理</strong>：</p>
<p>处理
<code>MediaCodec.CodecException</code>，可能由硬件或配置错误引发。检查
<code>isRecoverable()</code> 或
<code>isTransient()</code>，决定是否重试或重启。</p>
<p><strong>异步 vs 同步</strong>：</p>
<p>异步模式更适合现代应用，避免阻塞主线程。同步模式适合简单场景，但需手动轮询，可能影响性能。</p>
<p><strong>Surface 使用</strong>：</p>
<p>视频解码时，输出到 <code>Surface</code> 可提高效率，但需确保
<code>Surface</code> 有效。编码器不支持 <code>Surface</code>
输出，需手动处理输出数据。</p>
<p><strong>性能优化</strong>：</p>
<p>使用硬件加速（优先选择硬件编解码器）。避免频繁创建/销毁
<code>MediaCodec</code> 实例，复用实例以降低开销。</p>
<p><strong>输入数据必须是“帧”对齐的</strong>：</p>
<p>如果你是从网络流（如 RTP/RTMP）中接收数据，确保每次
<code>queueInputBuffer()</code>
的数据是一帧（NALU），否则容易出现花屏或丢帧。</p>
<p><strong><code>MediaCodec</code> 必须按严格顺序调用</strong>：</p>
<p><code>configure()</code> → <code>start()</code> →
<code>queue/dequeue</code> → <code>stop()</code> →
<code>release()</code></p>
<p>调用顺序错了会抛出 <code>IllegalStateException</code></p>
<p><strong>Surface 与 ByteBuffer 二选一</strong>：</p>
<p>解码可以输出到 Surface（适合显示）或
ByteBuffer（适合处理图像）。若使用 Surface 解码，不可访问
<code>outputBuffer</code>。</p>
<p><strong>解码时可能遇到 format change</strong>：</p>
<p><code>dequeueOutputBuffer()</code> 返回
<code>INFO_OUTPUT_FORMAT_CHANGED</code> 时必须处理新的输出格式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> newFormat = codec.outputFormat</span><br><span class="line"><span class="comment">// 处理新的分辨率等信息</span></span><br></pre></td></tr></table></figure>
<p><strong>记得处理 EOS（End Of Stream）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">queueInputBuffer(..., MediaCodec.BUFFER_FLAG_END_OF_STREAM)</span><br></pre></td></tr></table></figure>
<p>当 EOS 输入后，<code>dequeueOutputBuffer</code> 最终返回的
<code>bufferInfo.flags</code> 也会包含 EOS，代表流结束。</p>
<p><strong>使用 <code>setCallback()</code>
进行异步处理（可选）</strong>：</p>
<p>从 Android 5.0 开始，支持异步 API：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">codec.setCallback(<span class="keyword">object</span> : MediaCodec.Callback() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInputBufferAvailable</span><span class="params">(codec: <span class="type">MediaCodec</span>, index: <span class="type">Int</span>)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOutputBufferAvailable</span><span class="params">(codec: <span class="type">MediaCodec</span>, index: <span class="type">Int</span>, info: <span class="type">BufferInfo</span>)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(codec: <span class="type">MediaCodec</span>, e: <span class="type">MediaCodec</span>.<span class="type">CodecException</span>)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOutputFormatChanged</span><span class="params">(codec: <span class="type">MediaCodec</span>, format: <span class="type">MediaFormat</span>)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="源码实现">源码实现</h1>
<p><code>MediaCodec</code> 的底层实现基于 Android 的多媒体框架，主要依赖
AOSP 的 <code>stagefright</code> 和硬件抽象层（HAL）。</p>
<p><strong>架构概览</strong>：</p>
<p><code>MediaCodec</code> 是 Java 层 API，通过 JNI 调用 C++ 层的
<code>MediaCodec</code>
（<code>frameworks/av/media/libstagefright/MediaCodec.cpp</code>）。底层通过
<code>OMX</code>（OpenMAX IL）与硬件编解码器交互，或使用软件编解码器（如
FFmpeg 或 Google 的软件编解码器）。</p>
<p><strong>初始化与配置</strong>：</p>
<p><code>MediaCodec::CreateByType</code> 或 <code>CreateByName</code>
调用 <code>OMXClient</code>
初始化硬件解码器，查询设备支持的编解码器列表（<code>MediaCodecList</code>）。<code>configure()</code>
方法将 <code>MediaFormat</code> 转换为 OMX
参数，设置编码/解码参数（如分辨率、码率）。</p>
<p><strong>缓冲区处理</strong>：</p>
<p>输入输出缓冲区通过 <code>AMessage</code> 和 <code>ABuffer</code> 在
C++ 层管理，映射到 Java 层的 <code>ByteBuffer</code>。异步模式使用
<code>Looper</code> 和 <code>Handler</code> 机制分发回调事件。</p>
<p><strong>硬件加速</strong>：</p>
<p>硬件解码通过 <code>OMX</code> 层与芯片厂商提供的驱动交互（如
Qualcomm、MediaTek
的硬件编解码器）。源码中，<code>OMXCodec</code>（<code>frameworks/av/media/libstagefright/OMXCodec.cpp</code>）负责与硬件通信，处理缓冲区和帧数据。</p>
<p><strong>错误处理</strong>：</p>
<p>底层通过 <code>status_t</code> 返回错误码，映射到 Java 层的
<code>MediaCodec.CodecException</code>。常见错误包括硬件资源不足、格式不支持等。</p>
<p><strong>关键类与文件</strong>：</p>
<ul>
<li><code>MediaCodec.java</code>：Java 层 API 入口。</li>
<li><code>MediaCodec.cpp</code>：C++ 层实现，桥接 Java 和 OMX。</li>
<li><code>OMXCodec.cpp</code>：硬件编解码器交互逻辑。</li>
<li><code>MediaCodecList.cpp</code>：管理支持的编解码器信息。</li>
</ul>
<p><strong>调用链（解码器）</strong>：</p>
<p>Android <code>MediaCodec</code> 底层通过 JNI 调用了 C++ 层的
<code>MediaCodec</code>，最终与硬件编解码器通信：</p>
<ul>
<li>Java 层类：<code>android.media.MediaCodec</code></li>
<li>Native
层类：<code>android_media_MediaCodec.cpp</code>、<code>MediaCodec.cpp</code></li>
<li>底层服务：<code>MediaCodecService</code> → <code>OMX</code> → HAL →
硬件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MediaCodec.configure() → native_configure() → MediaCodec.cpp::configure()</span><br><span class="line">  ↓</span><br><span class="line">CodecLooper 创建 Codec（如 OMXCodec、C2Codec）</span><br><span class="line">  ↓</span><br><span class="line">SurfaceTexture 或 BufferQueue 创建输出目标</span><br></pre></td></tr></table></figure>
<p><strong>源码路径（Android AOSP）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frameworks/av/media/libstagefright/</span><br><span class="line">    MediaCodec.cpp</span><br><span class="line">    MediaCodecBuffer.cpp</span><br><span class="line">    ...</span><br><span class="line">frameworks/av/services/mediacodec/</span><br><span class="line">    MediaCodecService.cpp</span><br></pre></td></tr></table></figure>
<h1 id="补充说明">补充说明</h1>
<p><strong>调试技巧</strong>：</p>
<p>使用 <code>adb logcat</code> 查看 <code>MediaCodec</code>
日志，定位错误。检查 <code>MediaCodecInfo</code> 确保设备支持目标 MIME
类型和参数。验证输入数据的完整性（如 H.264 的 NAL 单元）。</p>
<p><strong>性能优化</strong>：</p>
<p>使用 <code>Surface</code>
输出视频解码结果，减少数据拷贝。批量处理缓冲区，降低调用频率。优先选择硬件编解码器（名称通常包含厂商标识，如
<code>OMX.qcom</code>）。</p>
<p><strong>常见问题</strong>：</p>
<p><strong>黑屏</strong>：可能是 <code>Surface</code>
无效或输入数据格式错误。<strong>卡顿</strong>：检查帧率、码率是否过高，或缓冲区处理不及时。<strong>崩溃</strong>：检查是否正确释放资源，或硬件不支持指定参数。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>Android 图形渲染框架</title>
    <url>/Android/Framework/Android-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%A1%86%E6%9E%B6.html</url>
    <content><![CDATA[<p>Android 的图形渲染框架负责将应用程序的 UI 元素（View、Canvas、OpenGL
等）渲染到屏幕上。它的核心目标是高效、流畅地将图形内容从应用程序传递到硬件显示设备。整个框架涉及多个层次，包括应用层、系统层、图形
API 以及硬件层。</p>
<p>用户交互、动画、布局变化等会调用 <code>View.invalidate()</code> 或
<code>requestLayout()</code>。<code>Choreographer</code>
会在下一帧（VSync 信号到来时）调用
<code>ViewRootImpl.doFrame()</code>。这个绘制必须在VSync
屏幕刷新信号发送时间间隔完成，否则会导致掉帧。</p>
<p>绘制包括以下三个流程：</p>
<ol type="1">
<li><strong>measure</strong>：测量每个 View
的大小（<code>View.measure()</code> → <code>onMeasure()</code>）。</li>
<li><strong>layout</strong>：确定 View
在父布局中的位置（<code>View.layout()</code> →
<code>onLayout()</code>）。</li>
<li><strong>draw</strong>：绘制内容（<code>View.draw()</code> →
<code>dispatchDraw()</code>）。</li>
</ol>
<p>绘制到 Canvas 有两种模式，一种是通过 CPU 绘制 Bitmap
位图，称为软绘制，另一种是通过 GPU
进行绘制，即硬件加速，<code>Canvas</code> 是
<code>HardwareCanvas</code>，绘制操作会记录为渲染命令列表
<code>DisplayList</code>，不直接画到屏幕。</p>
<p>从 Android 3.0+ 开始默认开启硬件加速模式，在这个模式下，在
<code>View.draw()</code> 中，绘制命令不是立即执行，而是调用
<code>RecordingCanvas</code> 把
<code>drawRect</code>、<code>drawBitmap</code> 这些指令录制成 GPU
可以理解的命令列表。这样可以避免每次绘制都经过
<code>Java → Native</code> 的高频调用。从 Android 5.0 开始引入了
<code>RenderThread</code>，通过独立线程处理 GPU 绘制，减少 UI
线程卡顿。UI 线程只生成 DisplayList，提交给 RenderThread。RenderThread
用 OpenGL ES（或 Vulkan）把 DisplayList 转换成 GPU 绘制指令，并绘制到
Surface 的缓冲区。Android 默认使用 <strong>Skia</strong> 图形库调用
OpenGL ES。从 Android 10 开始支持 <strong>Vulkan
Renderer</strong>（更高性能）。</p>
<p>绘制结果需要存放到一个 Surface，Surface 可以理解成显存中的画布，由
<code>SurfaceView</code>、<code>TextureView</code> 或 Window
产生，内部持有一个 <strong>BufferQueue</strong>。BufferQueue
是生产者-消费者模型，其中的生产者是应用进程的 RenderThread，消费者是
SurfaceFlinger。BufferQueue
使用双缓冲和三缓冲工作模式，双缓冲和三缓冲的概念源自更底层的图形缓冲机制，BufferQueue
只是 Android 中承载这种机制的实现载体。在 Android 图形渲染中，CPU（UI
Thread/RenderThread）和 GPU（绘制）是异步工作的。如果只有一个缓冲区，CPU
正在写数据时，GPU 就不能读，会造成撕裂或花屏，必须等 CPU 写完，GPU
才能渲染，这样就容易卡顿，无法充分利用硬件并行性，因此需要
<strong>多缓冲</strong> 来解耦 <strong>生产者（绘制端）</strong> 和
<strong>消费者（显示端）</strong>
的速度。三缓冲比双缓冲多一个备用缓冲，防止生产者被阻塞，提升流畅度。</p>
<p>接下来 Android 的系统服务 <strong>SurfaceFlinger</strong>
负责把多个应用窗口的 Surface
合成到最终屏幕图像中。<strong>SurfaceFlinger</strong> 从每个应用的
BufferQueue 中取出最新的图像缓冲，这些 Surface
可能来自主界面、弹窗、系统栏等不同应用，如果硬件支持 HWC，由
<strong>Hardware Composer</strong> 合成，性能更好，否则由 GPU
合成。SurfaceFlinger 等待硬件发来的 VSync
屏幕刷新信号来提交下一帧。这就是为什么 Android 的绘制频率通常是 60Hz /
90Hz / 120Hz。</p>
<p>如果硬件支持，<strong>Hardware Composer HAL</strong> 提供接口让
SurfaceFlinger 把图层交给硬件直接合成，避免 GPU 额外消耗。HWC
会直接把合成结果交给显示驱动
Framebuffer。显示驱动负责把像素信号传给屏幕的 TCON（Timing
Controller），最终刷新到 LCD/OLED 面板。</p>
<p>这其中，Skia 是 Android 的底层 2D 图形库（Chrome 也用它），它支持 CPU
渲染（软件）和GPU 渲染（OpenGL ES / Vulkan），Canvas 的所有 API（如
drawLine、drawPath）最终都会调用 Skia。</p>
<p>总结一下，在这个图形绘制过程中存在 4 个关键线程：</p>
<ol type="1">
<li>UI Thread：执行 View 的 measure/layout/draw，生成 DisplayList。</li>
<li>RenderThread：处理 GPU 绘制命令，渲染到 Surface。</li>
<li>SurfaceFlinger Thread：合成多个 Surface，提交到屏幕。</li>
<li>HWC Thread：硬件合成，驱动输出到屏幕。</li>
</ol>
<p>根据这个过程，可以得出一些性能优化的方向。由于绘制内容在 UI
主线程生成，开发者应避免阻塞 UI 线程的操作，如复杂计算或 I/O。View
的绘制指令被缓存为 DisplayList
以避免重复计算，开发者可以通过仅重绘发生变化的 View（通过
<code>invalidate()</code> 或 <code>requestLayout()</code>
）来优化重绘，同时尽量减少 View
树的变化，优化布局复杂度。同一像素被多次绘制会导致性能浪费，可以使用
<code>clipRect</code> 或 <code>clipPath</code>
限制绘制区域，避免不必要的背景重叠，同时使用 Android Studio 的 GPU
渲染分析工具来检测 Overdraw 。</p>
<p>一些常见的渲染问题及解决方法：</p>
<ol type="1">
<li>掉帧（Jank）。原因：UI 线程或 RenderThread
过载。解决：优化布局、减少复杂动画、使用异步任务。</li>
<li>画面撕裂。原因：渲染与屏幕刷新不同步。解决：确保 VSync
正常工作，避免禁用硬件加速。</li>
<li>高内存占用。原因：过多的 GraphicBuffer 或复杂的 View 树。解决：优化
View 层级，使用轻量级组件（如 ConstraintLayout）。</li>
<li>兼容性问题。原因：不同设备对 OpenGL ES 或 Vulkan
的支持不同。解决：提供软件渲染作为回退方案，测试多款设备。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>Android RecyclerView 缓存机制</title>
    <url>/Android/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Android-RecyclerView-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html</url>
    <content><![CDATA[<p>RecyclerView 通过多级缓存（Scrap、Cache、ViewCacheExtension 和
RecycledViewPool）来最小化 View 创建和数据绑定的开销。</p>
<p>RecyclerView 的缓存由 <code>Recycler</code> 类管理，它是 RecyclerView
的内部成员。<code>Recycler</code> 使用以下字段存储不同级别的缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="literal">null</span>;  <span class="comment">// 用于变更的 Scrap，通常在 DiffUtil 等场景</span></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ViewCacheExtension mViewCacheExtension;  <span class="comment">// 开发者自定义扩展</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">RecycledViewPool</span> <span class="variable">mRecyclerPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecycledViewPool</span>();  <span class="comment">// 默认每个 ViewType 缓存 5 个</span></span><br></pre></td></tr></table></figure>
<ul>
<li>mAttachedScrap：存储仍附加到 RecyclerView 但临时不可见的
ViewHolder（例如动画或布局变更中）。</li>
<li>mChangedScrap：类似 mAttachedScrap，但用于数据变更的
ViewHolder（例如使用 AdapterHelper）。</li>
<li>mCachedViews：快速缓存，默认大小 2（可通过
<code>setItemViewCacheSize(int)</code> 调整），存储最近移除的
ViewHolder，保留绑定状态。</li>
<li>mViewCacheExtension：可选的开发者自定义缓存（通过
<code>setViewCacheExtension()</code> 设置）。</li>
<li>mRecyclerPool：回收池，按 ViewType 分组存储重置后的
ViewHolder，默认每个类型 5 个（可通过
<code>setMaxRecycledViews(int viewType, int max)</code> 调整）。</li>
</ul>
<p>这些字段形成了缓存的层次：Scrap（最高优先级，零开销复用）→ Cache →
Extension → Pool → 新创建。</p>
<h3
id="viewholder-获取流程trygetviewholderforpositionbydeadline-方法">ViewHolder
获取流程（tryGetViewHolderForPositionByDeadline 方法）</h3>
<p>当 RecyclerView 需要一个 ViewHolder 时（例如在布局填充中），它调用
<code>Recycler.getViewForPosition(int position)</code>，后者委托给
<code>tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs)</code>。这个方法是缓存机制的核心，按优先级从缓存中查找
ViewHolder，如果找不到则创建新实例。以下是简化后的源码逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Recycler.tryGetViewHolderForPositionByDeadline 方法（关键摘录）</span></span><br><span class="line">ViewHolder <span class="title function_">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="type">int</span> position, <span class="type">boolean</span> dryRun, <span class="type">long</span> deadlineNs)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 参数校验 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 步骤1: 从 Scrap 中查找（最高优先级）</span></span><br><span class="line">    <span class="keyword">if</span> (mState.isPreLayout()) &#123;</span><br><span class="line">        holder = getChangedScrapViewForPosition(position);  <span class="comment">// 从 mChangedScrap 中找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);  <span class="comment">// 从 mAttachedScrap 或隐藏视图中找</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offsetPosition</span> <span class="operator">=</span> mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> mAdapter.getItemViewType(offsetPosition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2: 从 Cache (mCachedViews) 中查找匹配 position 的 ViewHolder</span></span><br><span class="line">        holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 验证 holder 是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (!validateViewHolderForOffsetPosition(holder, offsetPosition, dryRun)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                    holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class="line">                    <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                        removeDetachedView(holder.itemView, <span class="literal">false</span>);</span><br><span class="line">                        holder.unScrap();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                        holder.clearReturnedFromScrapFlag();</span><br><span class="line">                    &#125;</span><br><span class="line">                    recycleViewHolderInternal(holder);</span><br><span class="line">                &#125;</span><br><span class="line">                holder = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fromScrapOrHiddenOrCache = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span> &amp;&amp; viewCacheExtension != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 步骤3: 从 ViewCacheExtension 中查找（如果开发者设置了）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mViewCacheExtension.getViewForPositionAndType(<span class="built_in">this</span>, position, type);</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">            holder = getChildViewHolder(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 步骤4: 从 RecycledViewPool 中查找</span></span><br><span class="line">        holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="literal">null</span>) &#123;</span><br><span class="line">            holder.resetInternal();  <span class="comment">// 重置 holder 状态</span></span><br><span class="line">            <span class="keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class="line">                invalidateDisplayListInt(holder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 步骤5: 创建新 ViewHolder（最昂贵操作）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> getNanoTime();</span><br><span class="line">        <span class="keyword">if</span> (deadlineNs != FOREVER_NS &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 超时返回 null</span></span><br><span class="line">        &#125;</span><br><span class="line">        holder = mAdapter.createViewHolder(RecyclerView.<span class="built_in">this</span>, type);  <span class="comment">// 调用 Adapter.onCreateViewHolder</span></span><br><span class="line">        <span class="keyword">if</span> (ALLOW_THREAD_GAP_WORK) &#123;</span><br><span class="line">            <span class="type">RecyclerView</span> <span class="variable">innerView</span> <span class="operator">=</span> findNestedRecyclerView(holder.itemView);</span><br><span class="line">            <span class="keyword">if</span> (innerView != <span class="literal">null</span>) &#123;</span><br><span class="line">                holder.mNestedRecyclerView = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(innerView);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> getNanoTime();</span><br><span class="line">        mRecyclerPool.factorInCreateTime(type, end - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 后续处理：绑定数据、预布局等 ...</span></span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程解释： 1. Scrap 优先：先从 <code>mAttachedScrap</code> 或
<code>mChangedScrap</code> 中查找（通过
<code>getChangedScrapViewForPosition</code> 和
<code>getScrapOrHiddenOrCachedHolderForPosition</code>）。Scrap 中的
ViewHolder 无需重置，直接复用，适合动画或快速滑动场景。 2. Cache
检查：如果 Scrap 为空，从 <code>mCachedViews</code> 中找匹配 ID 或类型的
ViewHolder（<code>getScrapOrCachedViewForId</code>）。如果找到，验证位置有效性；无效则回收。
3. Extension（可选）：调用自定义的
<code>ViewCacheExtension.getViewForPositionAndType</code>。 4. Pool
回收：从 <code>mRecyclerPool</code>
获取（<code>getRecycledView(type)</code>），并调用
<code>holder.resetInternal()</code> 重置状态（清除标志、数据等）。 5.
新创建：调用
<code>Adapter.createViewHolder</code>，并记录创建时间以优化未来决策（考虑到
deadline 超时）。</p>
<p>这个方法支持 “dry run” 模式（不实际移除 ViewHolder）和
deadline（纳秒级超时），用于预取或并发优化。</p>
<h3 id="viewholder-回收流程recycleviewholderinternal-方法">ViewHolder
回收流程（recycleViewHolderInternal 方法）</h3>
<p>当 ViewHolder 不再需要时（例如滑动出屏），RecyclerView 调用
<code>recycleViewHolderInternal(ViewHolder holder)</code>
将其放入适当缓存。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Recycler.recycleViewHolderInternal 方法（关键摘录）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recycleViewHolderInternal</span><span class="params">(ViewHolder holder)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 校验 holder 是否可回收 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cached</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">recycled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldBeKeptAsScrap(holder) || holder.itemView.getParent() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 holder 仍在使用或需要 Scrap，放入 Scrap</span></span><br><span class="line">        <span class="keyword">if</span> (transientStatePreventsRecycling || holder.isTmpDetached()) &#123;</span><br><span class="line">            scrapView(holder.itemView);  <span class="comment">// 放入 mAttachedScrap</span></span><br><span class="line">            cached = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mViewCacheMax &lt;= <span class="number">0</span> || forceCache || holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_UPDATE)) &#123;</span><br><span class="line">        <span class="comment">// 如果 Cache 已满或 holder 无效，直接回收到 Pool</span></span><br><span class="line">        addViewHolderToRecycledViewPool(holder, <span class="literal">true</span>);</span><br><span class="line">        recycled = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试放入 Cache (mCachedViews)</span></span><br><span class="line">        <span class="keyword">if</span> (mCachedViews.size() &gt;= mViewCacheMax &amp;&amp; !mCachedViews.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// Cache 满时，移除最旧的并回收到 Pool</span></span><br><span class="line">            recycleCachedViewAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mCachedViews.add(holder);  <span class="comment">// 添加到 Cache</span></span><br><span class="line">        cached = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cached &amp;&amp; !recycled &amp;&amp; holder.isRecyclable()) &#123;</span><br><span class="line">        <span class="comment">// 默认回收到 Pool</span></span><br><span class="line">        mRecyclerPool.putRecycledView(holder);</span><br><span class="line">        recycled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回收逻辑解释： - Scrap：如果 holder
有临时状态（<code>isTmpDetached()</code>）或仍在父视图中，放入
<code>mAttachedScrap</code>（通过 <code>scrapView</code>）。 -
Cache：如果 Cache
未满（<code>mCachedViews.size() &lt; mViewCacheMax</code>），直接添加。Cache
满时，移除最早的（<code>recycleCachedViewAt(0)</code>）并移到 Pool。 -
Pool：调用 <code>mRecyclerPool.putRecycledView(holder)</code>，按
ViewType 存储。如果 Pool 满（默认 5），丢弃最旧的。进入 Pool 前，调用
<code>Adapter.onViewRecycled(holder)</code> 释放资源。 -
特殊处理：无效或移除的 holder 直接回收到 Pool，避免污染 Cache。</p>
<p>相关辅助方法： -
<code>addViewHolderToRecycledViewPool(ViewHolder holder, boolean dispatchRecycled)</code>：重置
holder 并放入 Pool，同时调用 <code>onViewRecycled</code>。 -
<code>RecycledViewPool.putRecycledView(ViewHolder scrap)</code>：内部使用
SparseArray&lt;ArrayList<ViewHolder>&gt; 按类型存储。</p>
<h3 id="recycledviewpool-的实现">RecycledViewPool 的实现</h3>
<p><code>RecycledViewPool</code> 是静态可共享的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RecycledViewPool 类（关键摘录）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RecycledViewPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SparseArray&lt;ScrapData&gt; mScrap = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mAttachCountForPoolingContainer</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScrapData</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">mMaxScrap</span> <span class="operator">=</span> DEFAULT_MAX_SCRAP;  <span class="comment">// 默认 5</span></span><br><span class="line">        <span class="comment">// ... 其他字段如创建时间 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putRecycledView</span><span class="params">(ViewHolder scrap)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewType</span> <span class="operator">=</span> scrap.getItemViewType();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = getScrapDataForType(viewType).mScrapHeap;</span><br><span class="line">        <span class="keyword">if</span> (getScrapDataForType(viewType).mMaxScrap &lt;= scrapHeap.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 满则丢弃</span></span><br><span class="line">        &#125;</span><br><span class="line">        scrap.resetInternal();</span><br><span class="line">        scrapHeap.add(scrap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ViewHolder <span class="title function_">getRecycledView</span><span class="params">(<span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ScrapData</span> <span class="variable">scrapData</span> <span class="operator">=</span> getScrapDataForType(viewType);</span><br><span class="line">        <span class="keyword">if</span> (!scrapData.mScrapHeap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;</span><br><span class="line">            <span class="keyword">return</span> scrapHeap.remove(scrapHeap.size() - <span class="number">1</span>);  <span class="comment">// LIFO 取出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>按类型管理：使用 SparseArray 存储每个 ViewType 的 ScrapData，每个
ScrapData 有 mScrapHeap (ArrayList) 和 mMaxScrap。</li>
<li>放入/取出：LIFO（后进先出）原则，放入前重置 holder。</li>
</ul>
<h3 id="性能优化与注意事项">性能优化与注意事项</h3>
<ul>
<li>缓存大小调整：<code>setItemViewCacheSize(int size)</code> 修改
<code>mRequestedCacheMax</code>，影响 mCachedViews。</li>
<li>共享 Pool：多个 RecyclerView 可共享同一个
Pool（<code>setRecycledViewPool</code>），减少内存。</li>
<li>预取与超时：<code>tryGetViewHolderForPositionByDeadline</code> 支持
deadlineNs，防止主线程阻塞（结合 GapWorker 预取）。</li>
<li>常见问题：源码中多处校验标志（如 FLAG_INVALID），防止回收无效
holder。开发者需在 <code>onViewRecycled</code> 释放资源，避免泄漏。</li>
<li>DiffUtil 集成：数据更新时，使用 mChangedScrap 处理变更
ViewHolder。</li>
</ul>
<h3 id="总结">总结</h3>
<p>RecyclerView 的缓存机制通过 <code>Recycler</code>
的多级结构高效工作：Scrap 用于即时复用，Cache 保留绑定状态，Extension
自定义，Pool
作为最后储备。核心方法<code>tryGetViewHolderForPositionByDeadline</code>
按序查找，<code>recycleViewHolderInternal</code> 智能回收。这种设计使
RecyclerView 在长列表中保持流畅，开发者可通过 API
调整以适应具体场景。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>应用开发</category>
      </categories>
  </entry>
  <entry>
    <title>Android 应用开发</title>
    <url>/Android/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.html</url>
    <content><![CDATA[<h1 id="知识结构">知识结构</h1>
<pre><code class="highlight mermaid">graph LR
    A[Android 开发技术栈]
    
    A --&gt; B[基础组件]
    B --&gt; B1[Activity]
    B --&gt; B2[Service]
    B --&gt; B3[BroadcastReceiver]
    B --&gt; B4[ContentProvider]
    B --&gt; B5[Fragment]
    B --&gt; B6[Intent]
    B --&gt; B7[WebView]
    B --&gt; B8[WorkManager]
    B --&gt; B9[Android 启动模式]
    B --&gt; B10[Android 6.0 权限系统]

    A --&gt; C[架构与设计模式]
    C --&gt; C1[MVC]
    C --&gt; C2[MVP]
    C --&gt; C3[MVVM]
    C --&gt; C4[AOP]

    A --&gt; D[UI 与布局]
    D --&gt; D1[XML 布局]
    D --&gt; D2[ConstraintLayout]
    D --&gt; D3[RecyclerView]
    D --&gt; D4[屏幕适配]
    D --&gt; D5[自定义 View]
    D --&gt; D6[动画]

    A --&gt; E[运行时与系统]
    E --&gt; E1[ART vs Dalvik]
    E --&gt; E2[Android 系统架构]
    E --&gt; E3[进程与线程]
    E --&gt; E4[Handler 机制]

    A --&gt; F[性能优化]
    F --&gt; F1[代码混淆]
    F --&gt; F2[内存泄漏]
    F --&gt; F3[热修复]
    F --&gt; F4[启动优化]
    F --&gt; F5[网络优化]
    F --&gt; F6[电量优化]

    A --&gt; G[网络与数据]
    G --&gt; G1[HTTP/HTTPS]
    G --&gt; G2[JSON/XML 解析]
    G --&gt; G3[Room 数据库]
    G --&gt; G4[SharedPreferences]
    G --&gt; G5[文件存储]

    A --&gt; H[Jetpack]
    H --&gt; H1[Compose]
    H --&gt; H2[ViewModel]
    H --&gt; H3[LiveData]
    H --&gt; H4[Navigation]
    H --&gt; H5[Room]
    H --&gt; H6[WorkManager]

    A --&gt; I[第三方库]
    I --&gt; I1[Dagger2]
    I --&gt; I2[RxJava]
    I --&gt; I3[Retrofit]
    I --&gt; I4[OkHttp]
    I --&gt; I5[Glide/Picasso]
    I --&gt; I6[LeakCanary]
    I --&gt; I7[Butterknife]
    I --&gt; I8[ARouter]
    I --&gt; I9[EventBus]

    A --&gt; J[开发与发布]
    J --&gt; J1[Gradle 构建]
    J --&gt; J2[Google Play 发布流程]
    J --&gt; J3[持续集成]
    J --&gt; J4[版本控制 Git]

    A --&gt; K[调试与分析]
    K --&gt; K1[Logcat]
    K --&gt; K2[反编译]
    K --&gt; K3[Profilers]
    K --&gt; K4[ADB]</code></pre>
<h1 id="android">Android</h1>
<h2 id="view-事件分发流程">View 事件分发流程</h2>
<p>在 Android 中，View
的事件分发流程是处理用户触摸（Touch）事件的核心机制，主要涉及
<code>MotionEvent</code>
对象的传递和处理。事件分发决定了触摸事件（如点击、滑动等）如何从顶层的
<code>Activity</code> 传递到 <code>ViewGroup</code> 和最终的
<code>View</code>，以及在这些组件之间如何被拦截、消费或传递。以下是
Android 中 View 事件分发的详细流程和关键方法：</p>
<hr />
<h3 id="事件分发的起点">1. 事件分发的起点</h3>
<p>触摸事件通常以 <code>MotionEvent</code> 对象的形式从操作系统传递给
Android 应用程序。事件分发的起点一般是从 <code>Activity</code>
开始，具体流程如下：</p>
<ul>
<li><strong>事件来源</strong>：用户通过屏幕触摸生成
<code>MotionEvent</code>，操作系统将事件传递给当前活动（Activity）的窗口管理器（WindowManager）。</li>
<li><strong>进入 Activity</strong>：<code>Activity</code> 的
<code>dispatchTouchEvent(MotionEvent event)</code>
方法首先接收事件。</li>
</ul>
<hr />
<h3 id="关键方法和分发流程">2. 关键方法和分发流程</h3>
<p>事件分发涉及三个主要方法：<code>dispatchTouchEvent()</code>、<code>onInterceptTouchEvent()</code>（仅适用于
<code>ViewGroup</code>）和
<code>onTouchEvent()</code>。以下是它们的职责和在分发流程中的作用：</p>
<h4 id="dispatchtoucheventmotionevent-event">2.1
<code>dispatchTouchEvent(MotionEvent event)</code></h4>
<ul>
<li><strong>作用</strong>：分发触摸事件，决定事件是继续向下传递还是被当前组件消费。</li>
<li><strong>返回值</strong>：
<ul>
<li>返回
<code>true</code>：表示当前组件消费了事件，事件停止传播（不会继续传递给子视图或父视图）。</li>
<li>返回
<code>false</code>：表示当前组件不处理事件，事件继续传递（如果有父视图，则向上回传；如果没有父视图，则事件终止）。</li>
<li>调用
<code>super.dispatchTouchEvent(event)</code>：将事件交给默认逻辑处理，通常会继续向下传递（对于
<code>ViewGroup</code> 可能进入 <code>onInterceptTouchEvent</code>，对于
<code>View</code> 可能进入 <code>onTouchEvent</code>）。</li>
</ul></li>
<li><strong>流程</strong>：
<ul>
<li>在 <code>Activity</code> 中，<code>dispatchTouchEvent</code>
通常会将事件传递给其根视图（通常是 <code>DecorView</code> 或
<code>ContentView</code>）。</li>
<li>在 <code>ViewGroup</code> 中，<code>dispatchTouchEvent</code>
会先调用 <code>onInterceptTouchEvent</code>
判断是否拦截事件，如果不拦截，则继续传递给子视图。</li>
<li>在 <code>View</code> 中，<code>dispatchTouchEvent</code> 通常会调用
<code>onTouchEvent</code>。</li>
</ul></li>
</ul>
<h4 id="onintercepttoucheventmotionevent-event仅-viewgroup-拥有">2.2
<code>onInterceptTouchEvent(MotionEvent event)</code>（仅
<code>ViewGroup</code> 拥有）</h4>
<ul>
<li><strong>作用</strong>：<code>ViewGroup</code>
专有的方法，用于决定是否拦截触摸事件。</li>
<li><strong>返回值</strong>：
<ul>
<li>返回 <code>true</code>：表示 <code>ViewGroup</code>
拦截事件，事件不会传递给子视图，而是由当前 <code>ViewGroup</code> 的
<code>onTouchEvent</code> 处理。</li>
<li>返回 <code>false</code>：表示不拦截事件，事件继续向下传递给子视图的
<code>dispatchTouchEvent</code>。</li>
</ul></li>
<li><strong>注意</strong>：默认实现返回
<code>false</code>（不拦截），开发者可以重写此方法来自定义拦截逻辑。</li>
</ul>
<h4 id="ontoucheventmotionevent-event">2.3
<code>onTouchEvent(MotionEvent event)</code></h4>
<ul>
<li><strong>作用</strong>：处理触摸事件的具体逻辑，通常由
<code>View</code> 或 <code>ViewGroup</code>
实现，用于响应用户的触摸操作（如点击、滑动等）。</li>
<li><strong>返回值</strong>：
<ul>
<li>返回 <code>true</code>：表示消费了事件，事件停止传播。</li>
<li>返回 <code>false</code>：表示不消费事件，事件继续向上回传给父视图的
<code>dispatchTouchEvent</code>（如果有父视图）。</li>
</ul></li>
<li><strong>默认行为</strong>：
<ul>
<li>如果 <code>View</code> 可点击（<code>isClickable()</code> 返回
<code>true</code>），<code>onTouchEvent</code> 默认返回
<code>true</code>，表示消费事件。</li>
<li>如果 <code>View</code> 不可点击，默认返回
<code>false</code>，事件继续向上回传。</li>
</ul></li>
</ul>
<hr />
<h3 id="事件分发的完整流程">3. 事件分发的完整流程</h3>
<p>以下是触摸事件从 <code>Activity</code> 到 <code>View</code>
的典型分发流程（以 <code>ACTION_DOWN</code>
事件为例，<code>ACTION_MOVE</code> 和 <code>ACTION_UP</code>
事件遵循类似逻辑，但需要注意事件序列的连续性）：</p>
<h4 id="从-activity-开始">3.1 从 <code>Activity</code> 开始</h4>
<ol type="1">
<li>用户触摸屏幕，操作系统生成 <code>MotionEvent</code> 并传递给
<code>Activity</code> 的 <code>dispatchTouchEvent</code>。</li>
<li><code>Activity</code> 的 <code>dispatchTouchEvent</code> 通常调用
<code>super.dispatchTouchEvent</code>，将事件传递给其根视图（<code>DecorView</code>
或 <code>ContentView</code>）。
<ul>
<li>如果 <code>Activity</code> 的 <code>onTouchEvent</code> 返回
<code>true</code>，事件被消费，流程结束。</li>
<li>否则，事件继续向下传递。</li>
</ul></li>
</ol>
<h4 id="进入-viewgroup">3.2 进入 <code>ViewGroup</code></h4>
<ol start="3" type="1">
<li>事件到达 <code>ViewGroup</code> 的
<code>dispatchTouchEvent</code>。</li>
<li><code>ViewGroup</code> 先调用 <code>onInterceptTouchEvent</code>：
<ul>
<li>如果返回 <code>true</code>，事件被拦截，<code>ViewGroup</code> 的
<code>onTouchEvent</code> 处理事件。</li>
<li>如果返回 <code>false</code>，事件继续传递给子视图。</li>
</ul></li>
<li>如果有子视图，<code>ViewGroup</code>
会遍历子视图，找到被触摸的子视图（通常通过 <code>hitTestResult</code>
判断触摸点是否在子视图范围内），然后调用子视图的
<code>dispatchTouchEvent</code>。</li>
</ol>
<h4 id="进入-view">3.3 进入 <code>View</code></h4>
<ol start="6" type="1">
<li>事件到达具体的 <code>View</code>（非 <code>ViewGroup</code>）的
<code>dispatchTouchEvent</code>。</li>
<li><code>View</code> 的 <code>dispatchTouchEvent</code> 通常调用
<code>onTouchEvent</code>：
<ul>
<li>如果 <code>onTouchEvent</code> 返回
<code>true</code>，事件被消费，流程结束。</li>
<li>如果返回 <code>false</code>，事件向上回传给父视图的
<code>dispatchTouchEvent</code>。</li>
</ul></li>
</ol>
<h4 id="事件回传向上传播">3.4 事件回传（向上传播）</h4>
<ul>
<li>如果某个 <code>View</code> 或 <code>ViewGroup</code> 的
<code>onTouchEvent</code> 返回
<code>false</code>，事件会向上回传到其父视图的
<code>dispatchTouchEvent</code>，直到 <code>Activity</code>
或被某个组件消费。</li>
<li>如果整个链条没有组件消费事件，事件最终被丢弃。</li>
</ul>
<hr />
<h3 id="关键注意事项">4. 关键注意事项</h3>
<ul>
<li><strong>事件序列</strong>：触摸事件通常以
<code>ACTION_DOWN</code>（按下）、<code>ACTION_MOVE</code>（移动）、<code>ACTION_UP</code>（抬起）序列出现。如果
<code>ACTION_DOWN</code> 没有被消费，后续的 <code>ACTION_MOVE</code> 和
<code>ACTION_UP</code> 也不会传递。</li>
<li><strong>优先级</strong>：<code>onTouchListener</code>（如果设置）优先于
<code>onTouchEvent</code> 处理事件。如果 <code>onTouchListener</code>
返回 <code>true</code>，<code>onTouchEvent</code> 不会被调用。</li>
<li><strong>可点击性</strong>：<code>View</code> 的
<code>isClickable()</code>、<code>isLongClickable()</code> 等属性影响
<code>onTouchEvent</code> 的默认行为。</li>
<li><strong>自定义事件分发</strong>：开发者可以重写
<code>dispatchTouchEvent</code>、<code>onInterceptTouchEvent</code> 和
<code>onTouchEvent</code> 来实现自定义逻辑。</li>
</ul>
<hr />
<h3 id="示例代码伪代码">5. 示例代码（伪代码）</h3>
<p>以下是一个简单的示例，展示如何重写事件分发方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomViewGroup</span> <span class="keyword">extends</span> <span class="title class_">ViewGroup</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义分发逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* 特定条件 */</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 消费事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event); <span class="comment">// 继续分发</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 决定是否拦截事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 拦截事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不拦截</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理触摸事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// 处理按下事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 消费事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不消费，事件向上回传</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结">6. 总结</h3>
<p>Android 中 View 的事件分发流程是一个从上到下（<code>Activity</code> →
<code>ViewGroup</code> →
<code>View</code>）再从下到上（回传）的过程，主要依赖
<code>dispatchTouchEvent</code>、<code>onInterceptTouchEvent</code> 和
<code>onTouchEvent</code>
三种方法。理解这些方法的返回值（<code>true</code> 或
<code>false</code>）和调用顺序是掌握事件分发的关键。</p>
<h3 id="流程图">7. 流程图</h3>
<pre><code class="highlight mermaid">graph TD
    A[&quot;触摸事件 MotionEvent&quot;] --&gt; B[&quot;Activity.dispatchTouchEvent&quot;]
    B --&gt; C&#123;&quot;Activity.onTouchEvent 返回 true/false&quot;&#125;
    C -- true --&gt; D[&quot;事件消费，流程结束&quot;]
    C -- false --&gt; E[&quot;ViewGroup.dispatchTouchEvent&quot;]
    E --&gt; F&#123;&quot;onInterceptTouchEvent 返回 true/false&quot;&#125;
    F -- true --&gt; G[&quot;ViewGroup.onTouchEvent&quot;]
    G --&gt; H&#123;&quot;返回 true/false&quot;&#125;
    H -- true --&gt; D
    H -- false --&gt; I[&quot;事件回传至父视图&quot;]
    F -- false --&gt; J[&quot;View.dispatchTouchEvent&quot;]
    J --&gt; K[&quot;View.onTouchEvent&quot;]
    K --&gt; L&#123;&quot;返回 true/false&quot;&#125;
    L -- true --&gt; D
    L -- false --&gt; I
    A:::start
    B:::activity
    E:::viewgroup
    F:::viewgroup
    G:::viewgroup
    J:::view
    K:::view
    classDef start fill:#000000,color:#ffffff
    classDef activity fill:#0000FF,color:#ffffff
    classDef viewgroup fill:#FFA500,color:#000000
    classDef view fill:#FFFF00,color:#000000</code></pre>
<h2 id="android-绘制渲染流程">Android 绘制渲染流程</h2>
<p>在 Android 中，从上层的 <code>View</code>（应用层）到 Framework
层（系统框架层），再到底层的 HAL（Hardware Abstraction
Layer，硬件抽象层）的绘制渲染流程，涉及多个层次的协作，包括应用逻辑、Android
框架、JNI、本地库（如
Skia、OpenGL/Vulkan）和硬件驱动。这是一个从高层次用户界面绘制到低层次硬件渲染的完整链条。以下是详细讲解：</p>
<hr />
<h3 id="总体概述">1. 总体概述</h3>
<p>Android 的绘制渲染流程从应用层的 <code>View</code> 开始，经过
Framework 层的协调（如
<code>ViewRootImpl</code>、<code>SurfaceFlinger</code>），最终通过 HAL
层与硬件（GPU 和显示屏）交互。整个流程可以分为以下几个层次： -
<strong>应用层（上层 View）</strong>：<code>View</code> 和
<code>ViewGroup</code> 的绘制逻辑。 - <strong>Framework
层</strong>：系统框架（如
<code>ViewRootImpl</code>、<code>Choreographer</code>、<code>SurfaceFlinger</code>）管理和调度渲染。
- <strong>Native 层</strong>：JNI 和本地库（如 Skia
图形库、OpenGL/Vulkan）处理图形绘制。 - <strong>HAL
层</strong>：硬件抽象层，连接操作系统和硬件（如 GPU
驱动、显示驱动）。</p>
<p>流程通常由 VSYNC 信号驱动，确保与屏幕刷新同步（约 16ms 一次，60
FPS）。</p>
<hr />
<h3 id="应用层上层-view从-view-到-viewrootimpl">2. 应用层（上层
View）：从 <code>View</code> 到 <code>ViewRootImpl</code></h3>
<h4 id="绘制触发">2.1 绘制触发</h4>
<ul>
<li><strong>起点</strong>：应用层通过 <code>View</code> 和
<code>ViewGroup</code> 实现 UI 逻辑。当需要绘制或更新 UI 时（例如
<code>setContentView</code>、<code>invalidate()</code>、<code>requestLayout()</code>），触发绘制。</li>
<li><strong>关键组件</strong>：
<ul>
<li><strong>View</strong>：通过
<code>onMeasure</code>（测量）、<code>onLayout</code>（布局）、<code>onDraw</code>（绘制）完成尺寸计算、位置确定和内容渲染。</li>
<li><strong>ViewGroup</strong>：管理子视图的测量、布局和绘制（通过
<code>measureChildren</code>、<code>onLayout</code>、<code>dispatchDraw</code>）。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li>用户或代码调用 <code>invalidate()</code> 或
<code>requestLayout()</code>，标记 <code>View</code> 或
<code>ViewGroup</code> 需要重新绘制。</li>
<li><code>View</code> 通过 <code>draw(Canvas)</code>
绘制内容，<code>ViewGroup</code> 通过 <code>dispatchDraw</code>
递归绘制子视图。</li>
<li>这些操作最终由 <code>ViewRootImpl</code> 协调。</li>
</ol></li>
</ul>
<h4 id="viewrootimpl-的角色">2.2 <code>ViewRootImpl</code> 的角色</h4>
<ul>
<li><code>ViewRootImpl</code> 是应用层和 Framework 层的桥梁，负责：
<ul>
<li>发起测量、布局和绘制（<code>performTraversals</code>）。</li>
<li>与 <code>WindowManager</code> 交互，管理
<code>Surface</code>（用于渲染的缓冲区）。</li>
<li>监听 VSYNC 信号，通过 <code>Choreographer</code>
确保绘制与屏幕刷新同步。</li>
</ul></li>
<li><strong>方法</strong>：
<ul>
<li><code>performTraversals</code>：调用
<code>measure</code>、<code>layout</code>、<code>draw</code>，完成整个绘制流程。</li>
<li><code>draw</code>：将 <code>View</code> 层次结构渲染到
<code>Canvas</code>，并提交到 <code>Surface</code>。</li>
</ul></li>
</ul>
<hr />
<h3 id="framework-层从-viewrootimpl-到-surfaceflinger">3. Framework
层：从 <code>ViewRootImpl</code> 到 <code>SurfaceFlinger</code></h3>
<h4 id="choreographer-和-vsync">3.1 <code>Choreographer</code> 和
VSYNC</h4>
<ul>
<li><strong>VSYNC 信号</strong>：每隔约 16ms（60 FPS），系统发出 VSYNC
信号，通知 UI 线程开始绘制。</li>
<li><strong>Choreographer</strong>：
<ul>
<li>监听 VSYNC 信号，调用 <code>doFrame</code>，触发
<code>ViewRootImpl</code> 的 <code>performTraversals</code>。</li>
<li>确保绘制和渲染与屏幕刷新同步，避免丢帧（jank）。</li>
</ul></li>
</ul>
<h4 id="surface-和-canvas">3.2 <code>Surface</code> 和
<code>Canvas</code></h4>
<ul>
<li><strong>Surface</strong>：
<ul>
<li><code>Surface</code> 是 Framebuffer
的抽象，存储最终的像素数据。</li>
<li><code>ViewRootImpl</code> 创建 <code>Surface</code>
并将其绑定到窗口。</li>
</ul></li>
<li><strong>Canvas</strong>：
<ul>
<li><code>View</code> 的 <code>draw</code> 方法使用 <code>Canvas</code>
进行绘制，<code>Canvas</code> 操作 <code>Surface</code> 的缓冲区。</li>
<li>绘制内容通过 <code>Skia</code> 图形库（Native 层）转换为像素。</li>
</ul></li>
</ul>
<h4 id="surfaceflinger">3.3 <code>SurfaceFlinger</code></h4>
<ul>
<li><strong>作用</strong>：Framework 层的渲染服务，负责将多个
<code>Surface</code>（来自不同应用或窗口）合成并输出到屏幕。</li>
<li><strong>流程</strong>：
<ol type="1">
<li><code>ViewRootImpl</code> 将绘制结果提交到
<code>Surface</code>。</li>
<li><code>SurfaceFlinger</code> 接收所有 <code>Surface</code>，根据 Z
序（层级）进行合成。</li>
<li>使用硬件加速（OpenGL/Vulkan）将合成结果渲染到显示缓冲区（Framebuffer）。</li>
</ol></li>
<li><strong>硬件加速</strong>：默认启用硬件加速，<code>SurfaceFlinger</code>
通过 GPU 加速合成和渲染。</li>
</ul>
<hr />
<h3 id="native-层jni-和图形库如-skiaopenglvulkan">4. Native 层：JNI
和图形库（如 Skia、OpenGL/Vulkan）</h3>
<h4 id="jnijava-native-interface">4.1 JNI（Java Native Interface）</h4>
<ul>
<li><strong>作用</strong>：连接 Java（应用层和 Framework 层）与
C/C++（Native 层）。</li>
<li><strong>流程</strong>：
<ul>
<li><code>View</code> 和 <code>ViewRootImpl</code> 通过 JNI 调用 Native
层的函数。</li>
<li>例如，<code>Canvas</code> 的绘制操作最终调用 Skia 的 Native
函数。</li>
</ul></li>
</ul>
<h4 id="skia-图形库">4.2 Skia 图形库</h4>
<ul>
<li><strong>作用</strong>：Android 的 2D 图形库，用于处理
<code>Canvas</code> 的绘制操作。</li>
<li><strong>功能</strong>：
<ul>
<li>渲染文字、形状、位图等 2D 图形。</li>
<li>将 <code>Canvas</code> 的绘制指令转换为像素数据，存储到
<code>Surface</code>。</li>
</ul></li>
<li><strong>与硬件交互</strong>：Skia 可以直接与 GPU 交互（通过 OpenGL
或 Vulkan），加速渲染。</li>
</ul>
<h4 id="openglvulkan">4.3 OpenGL/Vulkan</h4>
<ul>
<li><strong>作用</strong>：3D 图形 API，用于硬件加速渲染。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>Skia 或 <code>SurfaceFlinger</code> 使用 OpenGL/Vulkan 将 2D/3D
图形渲染到 GPU 的缓冲区。</li>
<li>GPU 执行渲染指令，生成像素数据。</li>
<li>像素数据存储到 <code>Surface</code> 或 Framebuffer。</li>
</ol></li>
<li><strong>硬件加速</strong>：OpenGL/Vulkan 通过 GPU
优化复杂的绘制操作（如动画、复杂 UI）。</li>
</ul>
<hr />
<h3 id="hal-层硬件抽象层">5. HAL 层：硬件抽象层</h3>
<h4 id="hal-的作用">5.1 HAL 的作用</h4>
<ul>
<li>HAL 是操作系统和硬件之间的接口层，屏蔽硬件差异，确保 Android
框架可以与不同设备（CPU、GPU、显示屏）交互。</li>
<li>在绘制渲染中，HAL 主要涉及：
<ul>
<li><strong>GPU 驱动</strong>：处理 OpenGL/Vulkan
的渲染指令，执行图形计算。</li>
<li><strong>显示驱动</strong>：将 Framebuffer
的像素数据输出到物理屏幕。</li>
</ul></li>
</ul>
<h4 id="硬件交互流程">5.2 硬件交互流程</h4>
<ol type="1">
<li><strong>GPU 渲染</strong>：
<ul>
<li><code>SurfaceFlinger</code> 通过 HAL 调用 GPU 驱动，使用
OpenGL/Vulkan 渲染 <code>Surface</code> 数据。</li>
<li>GPU 在帧缓冲区（Framebuffer）中生成最终像素。</li>
</ul></li>
<li><strong>显示输出</strong>：
<ul>
<li>HAL 的显示驱动将 Framebuffer 内容传输到显示控制器（Display
Controller）。</li>
<li>显示控制器将像素数据刷新到物理屏幕，通常通过 LCD 或 OLED
面板显示。</li>
</ul></li>
<li><strong>VSYNC 同步</strong>：
<ul>
<li>HAL 层确保渲染和显示与显示设备的刷新率同步（通过 VSYNC 信号）。</li>
</ul></li>
</ol>
<hr />
<h3 id="完整流程的总结">6. 完整流程的总结</h3>
<h4 id="时间线">6.1 时间线</h4>
<ul>
<li><strong>应用层</strong>：<code>View</code> 调用
<code>invalidate()</code> 或 <code>requestLayout()</code>，触发
<code>ViewRootImpl</code> 的 <code>performTraversals</code>。</li>
<li><strong>Framework 层</strong>：<code>ViewRootImpl</code>
测量、布局、绘制内容到 <code>Surface</code>，<code>SurfaceFlinger</code>
合成多个 <code>Surface</code>。</li>
<li><strong>Native 层</strong>：Skia 处理 2D 绘制，OpenGL/Vulkan 加速 3D
渲染。</li>
<li><strong>HAL 层</strong>：GPU 驱动渲染像素，显示驱动输出到屏幕。</li>
</ul>
<h4 id="关键路径">6.2 关键路径</h4>
<ol type="1">
<li><strong>应用层</strong> → <strong>Framework 层</strong>：
<ul>
<li><code>View</code> → <code>ViewRootImpl</code> → <code>Surface</code>
→ <code>SurfaceFlinger</code>。</li>
</ul></li>
<li><strong>Framework 层</strong> → <strong>Native 层</strong>：
<ul>
<li><code>Canvas</code> → Skia → OpenGL/Vulkan。</li>
</ul></li>
<li><strong>Native 层</strong> → <strong>HAL 层</strong>：
<ul>
<li>GPU 驱动 → 显示驱动 → 物理屏幕。</li>
</ul></li>
</ol>
<h4 id="vsync-的作用">6.3 VSYNC 的作用</h4>
<ul>
<li>VSYNC
信号贯穿整个流程，确保绘制、渲染和显示同步，避免撕裂（tearing）或丢帧。</li>
</ul>
<hr />
<h3 id="性能优化与问题">7. 性能优化与问题</h3>
<ul>
<li><strong>应用层</strong>：优化 <code>onDraw</code> 和
<code>onMeasure</code>，减少不必要的重绘。</li>
<li><strong>Framework 层</strong>：使用硬件加速，优化
<code>SurfaceFlinger</code> 合成逻辑。</li>
<li><strong>Native 层</strong>：利用 Skia 和 OpenGL/Vulkan 的性能，减少
CPU 负载。</li>
<li><strong>HAL 层</strong>：确保 GPU
和显示驱动高效工作，匹配设备刷新率。</li>
</ul>
<p><strong>常见问题</strong>： -
<strong>掉帧（Jank）</strong>：主线程阻塞或渲染未同步 VSYNC。 -
<strong>过度绘制</strong>：<code>View</code>
绘制区域重叠，增加渲染负担。 - <strong>硬件兼容性</strong>：不同设备 GPU
或显示驱动可能导致性能差异。</p>
<hr />
<h3 id="总结-1">8. 总结</h3>
<p>从上层 <code>View</code> 到 Framework 层再到 HAL 层的 Android
绘制渲染流程，体现了多层次协作：应用层的 UI 逻辑通过 <code>View</code>
和 <code>ViewRootImpl</code> 触发，Framework 层通过
<code>SurfaceFlinger</code> 和 <code>Choreographer</code>
管理渲染，Native 层使用 Skia 和 OpenGL/Vulkan 加速图形处理，HAL
层最终将像素输出到硬件屏幕。这种分层设计确保了跨设备兼容性、性能优化和用户体验的平滑性。</p>
<h3 id="流程图-1">9. 流程图</h3>
<pre><code class="highlight mermaid">graph TD
    A[&quot;应用启动或 UI 更新 (invalidate/requestLayout)&quot;]:::start --&gt; B[&quot;View.invalidate() 或 requestLayout()&quot;]:::app
    B --&gt; C&#123;&quot;需要重新绘制？&quot;&#125;
    C -- 是 --&gt; D[&quot;ViewRootImpl.performTraversals()&quot;]:::framework
    C -- 否 --&gt; A
    D --&gt; E[&quot;View.measure()&quot;]:::app
    E --&gt; F&#123;&quot;是 ViewGroup？&quot;&#125;
    F -- 是 --&gt; G[&quot;ViewGroup.measureChildren()&quot;]:::app
    F -- 否 --&gt; H[&quot;View.onMeasure()&quot;]:::app
    G --&gt; H
    H --&gt; I[&quot;View.layout()&quot;]:::app
    I --&gt; J&#123;&quot;是 ViewGroup？&quot;&#125;
    J -- 是 --&gt; K[&quot;ViewGroup.onLayout()&quot;]:::app
    J -- 否 --&gt; L[&quot;View.setFrame()&quot;]:::app
    K --&gt; L
    L --&gt; M[&quot;View.draw()&quot;]:::app
    M --&gt; N&#123;&quot;是 ViewGroup？&quot;&#125;
    N -- 是 --&gt; O[&quot;ViewGroup.dispatchDraw()&quot;]:::app
    N -- 否 --&gt; P[&quot;View.onDraw()&quot;]:::app
    O --&gt; P
    P --&gt; Q[&quot;Canvas 提交至 Surface&quot;]:::framework
    Q --&gt; R[&quot;SurfaceFlinger 合成与渲染&quot;]:::framework
    R --&gt; S((&quot;VSYNC 信号同步？&quot;)):::sync
    S -- 是 --&gt; T[&quot;屏幕显示 (Framebuffer)&quot;]:::start
    S -- 否 --&gt; U[&quot;等待 VSYNC&quot;]:::framework
    U --&gt; S

    %% 定义颜色样式
    classDef start fill:#000000,color:#ffffff
    classDef app fill:#00FF00,color:#000000
    classDef framework fill:#0000FF,color:#ffffff
    classDef sync fill:#000000,color:#ffffff</code></pre>
<h2 id="view-绘制流程">View 绘制流程</h2>
<p>在 Android 中，<code>View</code>
的绘制流程是实现用户界面（UI）显示的核心机制，它由测量（Measure）、布局（Layout）和绘制（Draw）三个阶段组成。这些阶段通过
<code>View</code> 和 <code>ViewGroup</code> 的协作完成，最终由
<code>ViewRootImpl</code> 协调并渲染到屏幕上。以下是 Android
<code>View</code>
绘制流程的详细讲解，包括每个阶段的重要方法及其参数的解释，不提供流程图。</p>
<hr />
<h3 id="绘制流程的总体概述">1. 绘制流程的总体概述</h3>
<p><code>View</code> 的绘制流程通常由以下情况触发： - 应用启动时调用
<code>setContentView</code> 设置布局。 - 代码调用
<code>invalidate()</code> 或 <code>requestLayout()</code> 更新 UI。 -
用户交互（如触摸、滚动）或动画导致内容变化。 绘制流程与
VSYNC（垂直同步信号）同步，通过 <code>Choreographer</code>
确保与屏幕刷新（约 16ms，60 FPS）保持一致，避免掉帧（jank）。</p>
<p>整个流程分为三个主要阶段： 1. <strong>测量（Measure）</strong>：确定
<code>View</code> 的尺寸（宽度和高度）。 2.
<strong>布局（Layout）</strong>：确定 <code>View</code>
的位置（左、上、右、下坐标）。 3. <strong>绘制（Draw）</strong>：将
<code>View</code> 的内容渲染成像素并显示到屏幕上。</p>
<p>以下是每个阶段的详细说明，包括关键方法及其参数。</p>
<hr />
<h3 id="测量阶段measure">2. 测量阶段（Measure）</h3>
<h4 id="目的">2.1 目的</h4>
<p>测量阶段的目标是计算每个 <code>View</code>
的尺寸（<code>mMeasuredWidth</code> 和
<code>mMeasuredHeight</code>），确保符合父视图的布局约束。</p>
<h4 id="关键方法及其参数">2.2 关键方法及其参数</h4>
<h5 id="view.measureint-widthmeasurespec-int-heightmeasurespec">2.2.1
<code>View.measure(int widthMeasureSpec, int heightMeasureSpec)</code></h5>
<ul>
<li><strong>作用</strong>：根据父视图提供的 <code>MeasureSpec</code>
测量 <code>View</code> 的尺寸。</li>
<li><strong>参数</strong>：
<ul>
<li><code>widthMeasureSpec</code>：整数类型，表示宽度的测量规格，包含模式和大小。
<ul>
<li>模式（通过 <code>MeasureSpec.getMode()</code> 获取）：
<ul>
<li><code>MeasureSpec.UNSPECIFIED</code>：无限制，子视图可自由指定大小（很少见）。</li>
<li><code>MeasureSpec.EXACTLY</code>：精确模式，父视图指定固定大小（如
<code>match_parent</code> 或具体 dp 值）。</li>
<li><code>MeasureSpec.AT_MOST</code>：最大模式，子视图大小不超过父视图的可用空间（如
<code>wrap_content</code>）。</li>
</ul></li>
<li>大小（通过 <code>MeasureSpec.getSize()</code>
获取）：父视图允许的最大或固定尺寸（以像素为单位）。</li>
</ul></li>
<li><code>heightMeasureSpec</code>：类似
<code>widthMeasureSpec</code>，表示高度的测量规格。</li>
</ul></li>
<li><strong>返回值</strong>：无，直接调用 <code>onMeasure</code>
计算尺寸并设置 <code>mMeasuredWidth</code> 和
<code>mMeasuredHeight</code>。</li>
<li><strong>流程</strong>：
<ol type="1">
<li><code>ViewRootImpl</code> 或父 <code>ViewGroup</code>
调用此方法，传入 <code>MeasureSpec</code>。</li>
<li><code>View</code> 根据 <code>MeasureSpec</code>
和自身布局参数（<code>layoutParams</code>）计算尺寸。</li>
<li>调用 <code>onMeasure</code> 完成具体测量逻辑。</li>
</ol></li>
</ul>
<h5 id="view.onmeasureint-widthmeasurespec-int-heightmeasurespec">2.2.2
<code>View.onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code></h5>
<ul>
<li><strong>作用</strong>：<code>View</code> 或 <code>ViewGroup</code>
重写此方法自定义测量逻辑，计算并设置 <code>mMeasuredWidth</code> 和
<code>mMeasuredHeight</code>。</li>
<li><strong>参数</strong>：同 <code>measure</code>
方法，<code>widthMeasureSpec</code> 和 <code>heightMeasureSpec</code>
描述宽高约束。</li>
<li><strong>返回值</strong>：无，但必须调用
<code>setMeasuredDimension(width, height)</code> 设置最终尺寸。</li>
<li><strong>注意</strong>：
<ul>
<li><code>setMeasuredDimension(int measuredWidth, int measuredHeight)</code>：设置测量后的宽度和高度。</li>
<li>必须确保尺寸符合 <code>MeasureSpec</code>
的模式和大小限制，否则可能导致布局异常。</li>
</ul></li>
<li><strong>默认实现</strong>：
<ul>
<li>对于普通 <code>View</code>，根据 <code>MeasureSpec</code>
模式计算默认尺寸（例如 <code>EXACTLY</code>
直接使用指定大小，<code>AT_MOST</code> 使用 <code>padding</code>
和内容大小）。</li>
<li>对于 <code>ViewGroup</code>，调用 <code>measureChildren</code>
测量子视图，汇总子视图尺寸。</li>
</ul></li>
</ul>
<h5
id="viewgroup.measurechildrenint-widthmeasurespec-int-heightmeasurespec">2.2.3
<code>ViewGroup.measureChildren(int widthMeasureSpec, int heightMeasureSpec)</code></h5>
<ul>
<li><strong>作用</strong>：<code>ViewGroup</code>
用于测量所有子视图的尺寸。</li>
<li><strong>参数</strong>：同 <code>measure</code>，传递给子视图的
<code>MeasureSpec</code>。</li>
<li><strong>返回值</strong>：无，递归调用子视图的
<code>measure</code>。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>遍历子视图，调用每个子视图的 <code>measure</code>。</li>
<li>根据子视图的 <code>layoutParams</code> 和父视图的
<code>MeasureSpec</code> 调整子视图的测量规格。</li>
</ol></li>
</ul>
<h4 id="测量阶段的注意事项">2.3 测量阶段的注意事项</h4>
<ul>
<li>测量只关心尺寸，不涉及位置。</li>
<li>开发者可重写 <code>onMeasure</code> 自定义测量逻辑，但必须遵守
<code>MeasureSpec</code> 约束。</li>
<li>如果 <code>View</code> 尺寸发生变化，可能触发
<code>requestLayout()</code>，重新测量和布局。</li>
</ul>
<hr />
<h3 id="布局阶段layout">3. 布局阶段（Layout）</h3>
<h4 id="目的-1">3.1 目的</h4>
<p>布局阶段的目标是根据测量结果确定每个 <code>View</code>
的位置（<code>mLeft</code>、<code>mTop</code>、<code>mRight</code>、<code>mBottom</code>），确保
<code>View</code> 在屏幕上的正确摆放。</p>
<h4 id="关键方法及其参数-1">3.2 关键方法及其参数</h4>
<h5 id="view.layoutint-l-int-t-int-r-int-b">3.2.1
<code>View.layout(int l, int t, int r, int b)</code></h5>
<ul>
<li><strong>作用</strong>：设置 <code>View</code>
的边界，确定其在屏幕上的位置。</li>
<li><strong>参数</strong>：
<ul>
<li><code>l</code>：左边界（<code>mLeft</code>），相对于父视图的 x
坐标。</li>
<li><code>t</code>：上边界（<code>mTop</code>），相对于父视图的 y
坐标。</li>
<li><code>r</code>：右边界（<code>mRight</code>），<code>mLeft + mMeasuredWidth</code>。</li>
<li><code>b</code>：下边界（<code>mBottom</code>），<code>mTop + mMeasuredHeight</code>。</li>
</ul></li>
<li><strong>返回值</strong>：无，直接设置 <code>View</code>
的边界属性。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>父 <code>ViewGroup</code> 调用此方法，传入子视图的边界值。</li>
<li><code>View</code> 更新
<code>mLeft</code>、<code>mTop</code>、<code>mRight</code>、<code>mBottom</code>，确定位置。</li>
<li>如果 <code>View</code> 是 <code>ViewGroup</code>，递归调用子视图的
<code>layout</code>。</li>
</ol></li>
</ul>
<h5 id="view.onlayoutboolean-changed-int-l-int-t-int-r-int-b">3.2.2
<code>View.onLayout(boolean changed, int l, int t, int r, int b)</code></h5>
<ul>
<li><strong>作用</strong>：<code>ViewGroup</code>
重写此方法，定位其子视图。</li>
<li><strong>参数</strong>：
<ul>
<li><code>changed</code>：布尔值，指示布局是否发生变化（<code>true</code>
表示尺寸或位置有变化）。</li>
<li><code>l</code>、<code>t</code>、<code>r</code>、<code>b</code>：当前
<code>ViewGroup</code> 的边界，与 <code>layout</code> 的参数相同。</li>
</ul></li>
<li><strong>返回值</strong>：无，负责调用子视图的 <code>layout</code>
方法。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>根据子视图的 <code>mMeasuredWidth</code> 和
<code>mMeasuredHeight</code>，计算每个子视图的
<code>l</code>、<code>t</code>、<code>r</code>、<code>b</code>。</li>
<li>调用子视图的 <code>layout</code> 设置其位置。</li>
</ol></li>
<li><strong>默认实现</strong>：空实现，开发者需重写以自定义子视图布局。</li>
</ul>
<h4 id="布局阶段的注意事项">3.3 布局阶段的注意事项</h4>
<ul>
<li>布局依赖测量结果，必须在测量完成后执行。</li>
<li>位置可能受父视图的 <code>padding</code>、<code>margin</code>
和布局参数（如 <code>LinearLayout</code> 的权重）影响。</li>
<li>开发者可重写 <code>onLayout</code>
自定义子视图位置，但需确保不超出父视图范围。</li>
</ul>
<hr />
<h3 id="绘制阶段draw">4. 绘制阶段（Draw）</h3>
<h4 id="目的-2">4.1 目的</h4>
<p>绘制阶段的目标是将 <code>View</code> 的内容渲染成像素，并通过
<code>Canvas</code> 提交到 <code>Surface</code>，最终显示在屏幕上。</p>
<h4 id="关键方法及其参数-2">4.2 关键方法及其参数</h4>
<h5 id="view.drawcanvas-canvas">4.2.1
<code>View.draw(Canvas canvas)</code></h5>
<ul>
<li><strong>作用</strong>：绘制 <code>View</code>
的内容，包括背景、内容和子视图。</li>
<li><strong>参数</strong>：
<ul>
<li><code>canvas</code>：<code>Canvas</code>
对象，用于绘制图形，管理像素数据。</li>
</ul></li>
<li><strong>返回值</strong>：无，执行绘制逻辑并提交到
<code>Surface</code>。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>调用 <code>drawBackground</code> 绘制背景。</li>
<li>如果需要，调用 <code>saveLayer</code>
保存图层（用于透明度或复杂效果）。</li>
<li>调用 <code>onDraw</code> 绘制 <code>View</code> 内容。</li>
<li>如果是 <code>ViewGroup</code>，调用 <code>dispatchDraw</code>
绘制子视图。</li>
<li>绘制前景和装饰（如边框、滚动条）。</li>
<li>提交 <code>Canvas</code> 内容到 <code>Surface</code>。</li>
</ol></li>
</ul>
<h5 id="view.ondrawcanvas-canvas">4.2.2
<code>View.onDraw(Canvas canvas)</code></h5>
<ul>
<li><strong>作用</strong>：<code>View</code>
重写此方法自定义绘制逻辑。</li>
<li><strong>参数</strong>：
<ul>
<li><code>canvas</code>：<code>Canvas</code>
对象，用于绘制图形（例如文字、形状、图片）。</li>
</ul></li>
<li><strong>返回值</strong>：无，直接在 <code>Canvas</code>
上绘制内容。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>使用 <code>Canvas</code> 的方法（如
<code>drawText</code>、<code>drawRect</code>、<code>drawBitmap</code>）绘制内容。</li>
<li>确保绘制区域在 <code>View</code> 的边界内。</li>
</ol></li>
<li><strong>默认实现</strong>：空实现，开发者需重写以实现自定义绘制。</li>
</ul>
<h5 id="viewgroup.dispatchdrawcanvas-canvas">4.2.3
<code>ViewGroup.dispatchDraw(Canvas canvas)</code></h5>
<ul>
<li><strong>作用</strong>：<code>ViewGroup</code>
绘制其所有子视图。</li>
<li><strong>参数</strong>：
<ul>
<li><code>canvas</code>：<code>Canvas</code>
对象，传递给子视图进行绘制。</li>
</ul></li>
<li><strong>返回值</strong>：无，递归调用子视图的
<code>draw</code>。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>遍历子视图，调用每个子视图的 <code>draw</code>。</li>
<li>确保子视图按 Z 序（层级）绘制（通常从后向前）。</li>
</ol></li>
</ul>
<h4 id="绘制阶段的注意事项">4.3 绘制阶段的注意事项</h4>
<ul>
<li>绘制依赖测量和布局结果，确保内容按正确尺寸和位置渲染。</li>
<li>使用硬件加速（默认开启）通过 OpenGL/Vulkan 提升性能。</li>
<li>避免过度绘制（Overdraw），优化 <code>onDraw</code>
逻辑减少不必要的绘制。</li>
</ul>
<hr />
<h3 id="从应用层到-hal-层的完整渲染绘制流程">5. 从应用层到 HAL
层的完整渲染绘制流程</h3>
<h4 id="应用层">5.1 应用层</h4>
<ul>
<li><strong>触发</strong>：通过 <code>invalidate()</code> 或
<code>requestLayout()</code> 标记 UI 更新，调用 <code>View</code>
的绘制方法。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>应用层 <code>View</code> 或 <code>ViewGroup</code> 调用
<code>invalidate()</code>（仅重绘）或
<code>requestLayout()</code>（重测、重排、重绘）。</li>
<li><code>ViewRootImpl</code> 接收到请求，调用
<code>performTraversals</code>，执行测量、布局、绘制。</li>
<li>测量阶段确定 <code>View</code>
尺寸，布局阶段确定位置，绘制阶段渲染内容到 <code>Canvas</code>。</li>
</ol></li>
</ul>
<h4 id="framework-层">5.2 Framework 层</h4>
<ul>
<li><strong>协调与渲染</strong>：
<ul>
<li><code>ViewRootImpl</code> 协调测量、布局、绘制，提交内容到
<code>Surface</code>。</li>
<li><code>SurfaceFlinger</code> 合成多个 <code>Surface</code>，通过
<code>Choreographer</code> 同步 VSYNC 信号。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li><code>Canvas</code> 内容提交到 <code>Surface</code>。</li>
<li><code>SurfaceFlinger</code> 合成 <code>Surface</code>，调用 Native
层渲染。</li>
<li>VSYNC 确保渲染与屏幕刷新同步。</li>
</ol></li>
</ul>
<h4 id="native-层">5.3 Native 层</h4>
<ul>
<li><strong>图形处理</strong>：
<ul>
<li>通过 JNI 调用 Skia（2D 图形库）和 OpenGL/Vulkan（3D
硬件加速）渲染。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li><code>Canvas</code> 绘制操作通过 JNI 传递到 Native 层。</li>
<li>Skia 处理 2D 绘制，OpenGL/Vulkan 加速 3D 渲染。</li>
<li>像素数据存储到 <code>Surface</code> 或 Framebuffer。</li>
</ol></li>
</ul>
<h4 id="hal-层">5.4 HAL 层</h4>
<ul>
<li><strong>硬件交互</strong>：
<ul>
<li>GPU 驱动处理渲染指令，显示驱动输出到屏幕。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li>GPU 驱动接收 OpenGL/Vulkan 指令，生成像素数据到 Framebuffer。</li>
<li>显示驱动将 Framebuffer 内容传输到显示控制器。</li>
<li>显示控制器刷新像素到物理屏幕（LCD 或 OLED）。</li>
</ol></li>
</ul>
<hr />
<h3 id="invalidate-和-requestlayout-的详细区别">6.
<code>invalidate()</code> 和 <code>requestLayout()</code>
的详细区别</h3>
<h4 id="invalidate">6.1 <code>invalidate()</code></h4>
<ul>
<li><strong>作用</strong>：标记 <code>View</code> 或
<code>ViewGroup</code> 的内容需要重新绘制，但不影响尺寸或位置。</li>
<li><strong>参数</strong>：无直接参数，调用
<code>view.invalidate()</code>。</li>
<li><strong>触发场景</strong>：
<ul>
<li>背景色、文字内容、绘制逻辑变化，但布局和尺寸不变。</li>
<li>例如：<code>setBackgroundColor()</code>、<code>setText()</code> 或
<code>onDraw()</code> 更新。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li>标记 <code>View</code> 的脏区域（dirty region）。</li>
<li><code>ViewRootImpl</code> 在下一个 VSYNC 信号触发
<code>draw()</code>，仅执行绘制阶段。</li>
<li>不触发测量或布局阶段。</li>
</ol></li>
<li><strong>性能影响</strong>：开销较小，仅重绘当前 <code>View</code>
和受影响区域。</li>
<li><strong>典型用例</strong>：动画、状态变化（如按钮颜色变化）。</li>
</ul>
<h4 id="requestlayout">6.2 <code>requestLayout()</code></h4>
<ul>
<li><strong>作用</strong>：标记 <code>View</code> 或
<code>ViewGroup</code> 的布局需要重新计算，可能影响尺寸和位置。</li>
<li><strong>参数</strong>：无直接参数，调用
<code>view.requestLayout()</code>。</li>
<li><strong>触发场景</strong>：
<ul>
<li>布局参数变化（如
<code>layout_width</code>、<code>layout_height</code>）。</li>
<li>子视图添加/移除或尺寸变化。</li>
<li>父视图或子视图的可见性、位置变化。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li>标记 <code>View</code> 及其父视图需要重新布局。</li>
<li><code>ViewRootImpl</code> 在下一个 VSYNC 信号触发
<code>performTraversals</code>，执行测量、布局和绘制三个阶段。</li>
<li>可能导致整个视图树的重绘。</li>
</ol></li>
<li><strong>性能影响</strong>：开销较大，可能重测、重排、重绘整个视图树。</li>
<li><strong>典型用例</strong>：动态调整布局（如添加
<code>View</code>、<code>setVisibility()</code>）。</li>
</ul>
<h4 id="对比总结">6.3 对比总结</h4>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 35%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th><code>invalidate()</code></th>
<th><code>requestLayout()</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>作用</strong></td>
<td>标记需要重绘（只绘制阶段）</td>
<td>标记需要重新布局（测量、布局、绘制）</td>
</tr>
<tr class="even">
<td><strong>触发场景</strong></td>
<td>内容变化（如颜色、文字）</td>
<td>尺寸或位置变化（布局参数、子视图）</td>
</tr>
<tr class="odd">
<td><strong>影响范围</strong></td>
<td>只影响当前 <code>View</code> 的绘制</td>
<td>可能影响整个视图树</td>
</tr>
<tr class="even">
<td><strong>性能开销</strong></td>
<td>较小（只重绘）</td>
<td>较大（可能重测、重排、重绘）</td>
</tr>
<tr class="odd">
<td><strong>调用方法</strong></td>
<td><code>view.invalidate()</code></td>
<td><code>view.requestLayout()</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="性能优化与注意事项">7. 性能优化与注意事项</h3>
<ul>
<li><strong>测量阶段</strong>：确保 <code>onMeasure</code>
高效，避免复杂计算；遵守 <code>MeasureSpec</code> 约束。</li>
<li><strong>布局阶段</strong>：优化 <code>onLayout</code>
逻辑，减少递归调用；避免频繁触发 <code>requestLayout()</code>。</li>
<li><strong>绘制阶段</strong>：优化 <code>onDraw</code>
减少过度绘制，使用硬件加速提升性能；避免阻塞主线程。</li>
<li><strong>VSYNC 同步</strong>：确保绘制与 VSYNC 同步，避免丢帧。</li>
<li><strong>调试工具</strong>：使用 Android Studio 的 Layout Inspector
和 Profile GPU Rendering 分析性能瓶颈。</li>
</ul>
<hr />
<h3 id="总结-2">8. 总结</h3>
<p>Android <code>View</code>
的绘制流程由测量、布局和绘制三个阶段组成，涉及
<code>View</code>、<code>ViewGroup</code>、<code>ViewRootImpl</code>
和底层渲染管道（<code>SurfaceFlinger</code>、Skia、OpenGL/Vulkan、HAL）。每个阶段的关键方法（如
<code>measure</code>、<code>layout</code>、<code>draw</code>）及其参数（如
<code>MeasureSpec</code>、<code>Canvas</code>）确保 UI
的正确性和性能。<code>invalidate()</code> 和
<code>requestLayout()</code>
的区别在于触发范围和性能影响，前者仅重绘，后者可能重测、重排、重绘，开发者需根据场景选择合适的方法。</p>
<h2
id="android中ipc方式各种方式优缺点">Android中IPC方式、各种方式优缺点</h2>
<p>在 Android 中，IPC（Inter-Process
Communication，进程间通信）是指两个不同进程之间的通信机制。由于 Android
应用运行在各自独立的进程中，为了安全性和性能优化，进程间通信需要通过专门的机制来完成。Android
提供了多种 IPC 方式，每种方式各有优缺点，常见的 IPC 方式包括：</p>
<ol type="1">
<li><strong>Bundle</strong></li>
<li><strong>Messenger</strong></li>
<li><strong>AIDL（Android Interface Definition Language）</strong></li>
<li><strong>ContentProvider</strong></li>
<li><strong>BroadcastReceiver</strong></li>
<li><strong>Socket</strong></li>
</ol>
<p>下面详细介绍每种 IPC 方式及其优缺点。</p>
<h3 id="bundle">1. <strong>Bundle</strong></h3>
<h4 id="概述">概述：</h4>
<p><code>Bundle</code> 是 Android 内置的简单数据传递方式，通常用于在
<code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>
等组件之间传递数据。它主要用于在同一个应用的不同组件之间传递简单数据。</p>
<h4 id="优点">优点：</h4>
<ul>
<li>使用简单：不需要复杂的定义和管理，只需要打包和传递键值对。</li>
<li>速度快：适合在同一进程的组件之间传递少量数据。</li>
<li>Android 内置支持：大多数 Android 组件都原生支持
<code>Bundle</code>。</li>
</ul>
<h4 id="缺点">缺点：</h4>
<ul>
<li>仅支持基本类型数据：<code>Bundle</code> 只能存储基本类型（如
<code>int</code>、<code>boolean</code>）和少数系统类型（如
<code>Parcelable</code> 对象）。</li>
<li>进程间使用受限：用于进程间通信时，只能传递少量、简单的数据，不适合复杂的数据结构。</li>
</ul>
<h4 id="适用场景">适用场景：</h4>
<ul>
<li>同一应用内不同组件之间的简单数据传递。</li>
</ul>
<h3 id="messenger">2. <strong>Messenger</strong></h3>
<h4 id="概述-1">概述：</h4>
<p><code>Messenger</code> 是基于 <code>Handler</code> 的一种轻量级的 IPC
方式，适用于一对一的进程间通信。它通过 <code>Message</code>
传递数据，并支持在不同进程中通过 <code>Handler</code> 处理消息。</p>
<h4 id="优点-1">优点：</h4>
<ul>
<li>易于实现：通过消息的发送与接收机制，适合简单的 IPC。</li>
<li>基于 <code>Handler</code>，非常适合一对一的消息通信。</li>
<li>传输过程安全：所有消息都封装在 <code>Message</code> 对象中。</li>
</ul>
<h4 id="缺点-1">缺点：</h4>
<ul>
<li>不支持复杂的数据结构：与 <code>Bundle</code>
一样，只适用于简单的数据类型传输。</li>
<li>不适合多线程或高并发场景：<code>Messenger</code>
本质上是串行处理的，无法支持并发通信。</li>
<li>仅适用于一对一通信：不支持多个客户端同时与服务端通信。</li>
</ul>
<h4 id="适用场景-1">适用场景：</h4>
<ul>
<li>轻量级、一对一的进程间通信，适用于少量数据传输。</li>
</ul>
<h3 id="aidlandroid-interface-definition-language">3.
<strong>AIDL（Android Interface Definition Language）</strong></h3>
<h4 id="概述-2">概述：</h4>
<p>AIDL 是 Android
提供的支持进程间通信的工具，允许定义跨进程的接口。它适用于复杂的数据传递和多进程环境下的通信。AIDL
的原理是通过 Binder 机制实现客户端与服务端的通信。</p>
<h4 id="优点-2">优点：</h4>
<ul>
<li>强大的 IPC 支持：可以传递复杂的数据类型，如
<code>List</code>、<code>Map</code>，甚至自定义对象。</li>
<li>支持多进程：可以用于多客户端与同一服务端的并发通信。</li>
<li>自动生成代码：AIDL 会根据接口定义生成对应的代理类和服务端代码。</li>
</ul>
<h4 id="缺点-2">缺点：</h4>
<ul>
<li>实现复杂：需要编写 <code>.aidl</code>
文件，手动管理接口和服务端实现。</li>
<li>性能开销：由于数据序列化和反序列化的开销较大，AIDL 通信效率比
<code>Messenger</code> 稍低。</li>
<li>数据传递需要深度复制：对象必须实现 <code>Parcelable</code>
接口，数据在传递时被复制，无法共享对象的引用。</li>
</ul>
<h4 id="适用场景-2">适用场景：</h4>
<ul>
<li>复杂的进程间通信，特别是需要在不同进程之间传递复杂数据结构时。</li>
</ul>
<h3 id="contentprovider">4. <strong>ContentProvider</strong></h3>
<h4 id="概述-3">概述：</h4>
<p><code>ContentProvider</code> 是 Android
用于共享数据的机制，适用于应用间的数据共享。它允许应用通过 URI
来访问和操作其他应用的数据，支持增删改查等操作。典型的例子是 Android
系统的联系人、媒体文件等都是通过 <code>ContentProvider</code>
共享数据的。</p>
<h4 id="优点-3">优点：</h4>
<ul>
<li>数据共享机制：适用于不同应用间的数据共享。</li>
<li>支持 SQL 风格的数据操作：提供类似数据库的 <code>CRUD</code>
操作接口，方便对数据进行管理。</li>
<li>安全性：通过 URI 权限控制，可以限制其他应用访问
<code>ContentProvider</code> 中的数据。</li>
</ul>
<h4 id="缺点-3">缺点：</h4>
<ul>
<li>仅适用于数据共享：<code>ContentProvider</code>
适合管理和共享结构化数据，不适用于实时通信。</li>
<li>实现复杂：<code>ContentProvider</code>
的实现需要处理多种操作（如查询、插入、删除等），并且需要处理 URI
匹配和权限控制。</li>
</ul>
<h4 id="适用场景-3">适用场景：</h4>
<ul>
<li>不同应用间的数据共享，例如联系人、日历、媒体等数据。</li>
</ul>
<h3 id="broadcastreceiver">5. <strong>BroadcastReceiver</strong></h3>
<h4 id="概述-4">概述：</h4>
<p><code>BroadcastReceiver</code> 是 Android
的广播机制，允许应用在进程间或应用间发送广播消息，通知其他应用或组件执行相应操作。广播可以是系统广播，也可以是应用自定义广播。</p>
<h4 id="优点-4">优点：</h4>
<ul>
<li>广泛适用：适用于一对多的通信方式，可以通知多个接收方。</li>
<li>松耦合：发送者和接收者之间不需要直接联系，方便应用内不同模块之间的通信。</li>
<li>适合全局事件通知：系统事件（如电池状态变化、网络变化）通常通过广播通知。</li>
</ul>
<h4 id="缺点-4">缺点：</h4>
<ul>
<li>数据传输效率较低：广播消息一般用于传递简单数据，复杂数据传输效率较低。</li>
<li>不适合实时通信：广播的通信是异步的，无法保证消息的实时性。</li>
<li>安全问题：广播可能被其他应用截获，需小心数据安全。</li>
</ul>
<h4 id="适用场景-4">适用场景：</h4>
<ul>
<li>一对多的通信场景，适用于系统全局事件或应用内的全局消息通知。</li>
</ul>
<h3 id="socket">6. <strong>Socket</strong></h3>
<h4 id="概述-5">概述：</h4>
<p><code>Socket</code> 是一种网络通信方式，支持进程间通过网络协议（如
TCP、UDP）进行数据传输。Android 中也可以通过 <code>Socket</code>
在不同进程或不同设备间通信。</p>
<h4 id="优点-5">优点：</h4>
<ul>
<li>适合网络通信：<code>Socket</code>
可以在本地或远程进程间通信，甚至可以跨设备通信。</li>
<li>高度灵活：适用于需要自定义通信协议的场景。</li>
<li>支持大量数据传输：可以通过流的形式传输大量数据。</li>
</ul>
<h4 id="缺点-5">缺点：</h4>
<ul>
<li>实现复杂：需要手动处理网络连接、通信协议、数据包的解析与处理。</li>
<li>安全性问题：需要处理网络传输中的安全问题，如数据加密、身份认证等。</li>
</ul>
<h4 id="适用场景-5">适用场景：</h4>
<ul>
<li>适用于大数据传输或复杂网络通信场景，尤其是在进程间或设备间需要实时通信时。</li>
</ul>
<h3 id="各种方式的对比总结">各种方式的对比总结</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 34%" />
<col style="width: 30%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>IPC 方式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bundle</td>
<td>简单易用，适合传递基本数据类型</td>
<td>只能用于传递简单数据类型，跨进程使用受限</td>
<td>应用内组件之间的简单数据传递</td>
</tr>
<tr class="even">
<td>Messenger</td>
<td>轻量级，基于 <code>Handler</code> 的一对一通信，简单且易实现</td>
<td>不支持复杂数据结构，不适合多线程和并发场景</td>
<td>简单的一对一进程间通信</td>
</tr>
<tr class="odd">
<td>AIDL</td>
<td>支持复杂数据类型和并发通信，适合多进程场景</td>
<td>实现复杂，性能开销较大</td>
<td>复杂的进程间通信，需传递复杂数据时</td>
</tr>
<tr class="even">
<td>ContentProvider</td>
<td>适合应用间的数据共享，支持 SQL 风格的操作</td>
<td>实现复杂，仅适用于数据共享，无法用于实时通信</td>
<td>应用间的结构化数据共享</td>
</tr>
<tr class="odd">
<td>BroadcastReceiver</td>
<td>支持一对多通信，适合全局消息广播和系统事件通知</td>
<td>不适合实时通信，数据传输效率低</td>
<td>一对多的全局消息广播或系统事件通知</td>
</tr>
<tr class="even">
<td>Socket</td>
<td>灵活，支持大数据传输和跨设备通信</td>
<td>实现复杂，需要处理网络协议和安全问题</td>
<td>大量数据的实时传输或跨设备通信</td>
</tr>
</tbody>
</table>
<p>每种 IPC
方式适用于不同的场景，选择合适的方式可以提高开发效率和应用性能。</p>
<h2 id="binder机制的作用和原理">Binder机制的作用和原理</h2>
<p><strong>Binder</strong> 是 Android
中最重要的进程间通信（IPC）机制之一，Binder
的设计兼顾了高效性、安全性和灵活性，在 Android
系统中几乎所有的进程间通信都基于 Binder 机制，例如
<code>AIDL</code>、<code>Messenger</code>、<code>ContentProvider</code>
等都是通过 Binder 实现的。Binder 也是 Android 系统服务（如
<code>ActivityManagerService</code>、<code>WindowManagerService</code>
等）的通信基础。</p>
<h3 id="binder-的作用">Binder 的作用</h3>
<ol type="1">
<li><strong>进程间通信（IPC）</strong>：Binder 提供了一种高效的 IPC
机制，允许不同进程之间交换数据或请求服务。</li>
<li><strong>安全性</strong>：Binder 内核实现了身份验证机制，可以通过
UID（用户 ID） 验证通信双方的身份，保证进程间通信的安全性。</li>
<li><strong>高效性</strong>：Binder
使用内核缓冲区避免了数据的多次复制，减少了内存和 CPU 的消耗。</li>
<li><strong>轻量级</strong>：与传统的 Linux IPC
机制（如管道、消息队列、共享内存等）相比，Binder
更轻量级，性能更好，设计上更适合 Android 移动设备的资源受限环境。</li>
</ol>
<h3 id="binder-的原理">Binder 的原理</h3>
<p>Binder 是 Android 特有的 IPC 机制，底层由 Linux
内核驱动支持。它的工作原理包括以下几个关键组件：</p>
<ol type="1">
<li><p><strong>Binder 驱动</strong>：Binder 的核心是一个位于内核空间的
Binder
驱动程序（<code>/dev/binder</code>），负责管理和协调进程之间的数据传递、身份验证和资源管理。</p></li>
<li><p><strong>Binder 线程池</strong>：每个进程中负责处理 IPC
请求的服务端都会维护一个 Binder
线程池，这些线程负责处理来自客户端的请求。Binder
线程池的大小是动态调整的，当有新的请求时，线程池会处理该请求。</p></li>
<li><p><strong>Binder 引用（Binder Reference）</strong>：在 Binder
通信中，客户端和服务端通过 <code>Binder</code>
对象进行交互。客户端持有服务端的一个 <code>Binder</code>
引用，实际的通信是通过引用传递的。</p></li>
<li><p><strong>Binder 代理（Proxy）</strong>：在客户端进程中，Binder
通信通过代理对象（<code>Binder Proxy</code>）实现。代理对象封装了与服务端通信的细节，客户端通过代理对象调用服务端的方法，实际上是通过
<code>Binder</code> 驱动将请求传递给服务端。</p></li>
<li><p><strong>Binder 通信流程</strong>：Binder
使用请求-响应的方式实现通信。当客户端调用代理对象的某个方法时，该调用会封装为一个
<code>Transaction</code>，通过 <code>Binder</code>
驱动传递给服务端。服务端处理完请求后，将结果通过 <code>Binder</code>
驱动返回给客户端。</p></li>
</ol>
<h4 id="具体的通信流程">具体的通信流程：</h4>
<ol type="1">
<li><strong>客户端请求</strong>：
<ul>
<li>客户端进程通过调用 <code>Binder</code>
代理对象发起请求。代理对象将请求打包成 <code>Parcel</code>，并通过
Binder 驱动发送给服务端进程。</li>
</ul></li>
<li><strong>Binder 驱动处理</strong>：
<ul>
<li><code>Parcel</code>
包含请求的详细信息，包括调用的方法、参数等。Binder
驱动将这些信息传递给服务端的 Binder 线程池。</li>
</ul></li>
<li><strong>服务端处理</strong>：
<ul>
<li>服务端的某个线程从 Binder 线程池中取出请求并解包
<code>Parcel</code>，调用相应的业务逻辑进行处理，处理完后将结果打包成
<code>Parcel</code> 并通过 Binder 驱动返回给客户端。</li>
</ul></li>
<li><strong>客户端接收结果</strong>：
<ul>
<li>客户端进程的代理对象从 Binder
驱动接收到结果并解包，返回给应用程序。</li>
</ul></li>
</ol>
<h3 id="binder-通信的几个关键概念">Binder 通信的几个关键概念</h3>
<ol type="1">
<li><p><strong>Binder 驱动</strong>： Binder
的核心是一个内核态的驱动程序
<code>binder</code>，这个驱动程序负责管理客户端与服务端之间的通信。Binder
驱动程序主要负责以下几件事情：</p>
<ul>
<li>管理进程间的 <code>Binder</code> 句柄和引用。</li>
<li>负责将客户端请求发送给服务端，并返回结果给客户端。</li>
<li>提供跨进程的身份验证。</li>
</ul></li>
<li><p><strong>Parcel</strong>： <code>Parcel</code> 是 Android
中用于序列化和反序列化数据的容器。Binder 在传输数据时，必须将数据打包成
<code>Parcel</code> 对象。<code>Parcel</code> 支持基本数据类型（如
<code>int</code>、<code>String</code>），也支持复杂数据类型（如
<code>Parcelable</code> 对象）。</p></li>
<li><p><strong>Binder 线程池</strong>： 每个服务端进程会维护一个
<code>Binder</code> 线程池，负责处理来自客户端的 IPC
请求。每当客户端发起请求时，Binder
线程池中的某个线程会处理该请求。线程池的大小动态调整，能够提高服务端处理请求的效率。</p></li>
</ol>
<h3 id="binder-的数据传输过程">Binder 的数据传输过程</h3>
<ul>
<li><p><strong>数据的序列化和反序列化</strong>：Binder
通信中，所有数据通过 <code>Parcel</code>
序列化后进行传输。在客户端，方法调用时，参数会被写入
<code>Parcel</code>，传递给 Binder 驱动。在服务端，Binder 驱动将
<code>Parcel</code> 中的数据交给服务端的线程，线程读取
<code>Parcel</code> 并执行相应的操作。处理结果也会打包成
<code>Parcel</code> 返回给客户端。</p></li>
<li><p><strong>进程身份验证</strong>：Binder
内核驱动提供了进程的身份验证机制。每个通过 Binder
通信的进程都有一个唯一的标识符（UID），Binder
驱动会验证通信双方的身份，确保只有授权的进程才能通信。</p></li>
</ul>
<h3 id="binder-的优缺点">Binder 的优缺点</h3>
<h4 id="优点-6">优点：</h4>
<ol type="1">
<li><p><strong>高效性</strong>：Binder
的数据传输通过内核共享内存的方式实现，避免了传统 IPC
机制（如管道、Socket）中数据的多次拷贝，提高了通信效率。</p></li>
<li><p><strong>安全性</strong>：Binder
通过内核态的身份认证机制，确保通信的安全性。每次进程间通信时，Binder
驱动会验证通信双方的身份，防止未经授权的进程参与通信。</p></li>
<li><p><strong>支持一对多通信</strong>：Binder
允许多个客户端与一个服务端通信，并且多个进程可以同时访问同一个服务端。</p></li>
<li><p><strong>灵活性强</strong>：Binder
支持多种数据类型的传输，包括基本数据类型和自定义的
<code>Parcelable</code> 对象，适应性强。</p></li>
</ol>
<h4 id="缺点-6">缺点：</h4>
<ol type="1">
<li><p><strong>实现复杂</strong>：Binder
的底层实现非常复杂，涉及到内核态的驱动程序、进程间的通信协议和数据的序列化等。虽然
Android 提供了 <code>AIDL</code>、<code>Messenger</code>
等高级抽象来简化 Binder 的使用，但直接使用 Binder 的门槛较高。</p></li>
<li><p><strong>性能开销</strong>：尽管 Binder 比传统的 IPC
机制效率高，但序列化和反序列化数据依然会带来一定的性能开销。特别是在传输大量数据时，性能下降明显。</p></li>
</ol>
<h3 id="binder-与传统-linux-ipc-机制的对比">Binder 与传统 Linux IPC
机制的对比</h3>
<p>Binder 是 Android 特有的 IPC 机制，与传统的 Linux IPC
机制（如管道、消息队列、共享内存、Socket）相比，它有以下优点：</p>
<ul>
<li><strong>安全性更强</strong>：Binder
内置身份验证机制，确保通信的双方是可信任的进程。而传统的 Linux IPC
机制往往缺乏这种验证，容易受到攻击。</li>
<li><strong>数据传输更高效</strong>：Binder
使用共享内存减少了数据的拷贝次数，提升了传输效率。相比之下，传统 IPC
机制的数据传输通常需要多次拷贝。</li>
<li><strong>使用更简单</strong>：虽然 Binder 实现复杂，但 Android 提供了
<code>AIDL</code>、<code>Messenger</code> 等更高层次的
API，简化了开发者的使用体验。而传统 IPC
机制的使用往往需要编写大量的低层代码。</li>
</ul>
<h3 id="总结-3">总结</h3>
<p><strong>Binder</strong> 是 Android
系统中进程间通信的核心机制，提供了高效、安全、灵活的 IPC 能力。通过
Binder，Android
实现了系统服务和应用程序之间的通信，支持应用进程之间的高效数据交换。Binder
的主要优势在于它的高效性、安全性和易用性，尽管实现复杂，但 Android
提供了多种高层抽象（如 AIDL、Messenger 等）来简化开发者的使用。</p>
<h2 id="ams是如何管理activity的">AMS是如何管理Activity的</h2>
<p>在 Android 系统中，<code>AMS</code>（Activity Manager Service）
是负责管理应用进程、Activity、任务和应用生命周期的核心服务。<code>AMS</code>
在应用启动、Activity
切换、生命周期管理、任务栈管理等方面起着关键作用。它通过与
<code>Binder</code> 机制交互，协调应用进程和系统进程，管理 Activity
的创建、启动、切换、销毁等操作。</p>
<h3 id="ams-的基本概述">1. <strong>AMS 的基本概述</strong></h3>
<p><code>ActivityManagerService</code> 是 Android Framework
层的一个核心服务，用于管理应用的四大组件（Activity、Service、BroadcastReceiver、ContentProvider）。它位于
<code>system_server</code> 进程中，负责协调不同应用进程的行为。</p>
<ul>
<li><strong>启动 Activity</strong>：管理 Activity 的启动流程。</li>
<li><strong>管理 Activity 栈</strong>：负责维护和管理 Activity
的任务栈。</li>
<li><strong>控制 Activity 生命周期</strong>：管理每个 Activity
的生命周期状态（如启动、暂停、恢复、销毁）。</li>
<li><strong>管理进程和任务</strong>：通过管理任务栈（Task
Stack），调度不同的任务和进程。</li>
</ul>
<h3 id="ams-的核心角色">2. <strong>AMS 的核心角色</strong></h3>
<p><code>AMS</code> 通过与
<code>ActivityThread</code>、<code>WindowManagerService</code>、<code>PackageManagerService</code>
等系统服务协作，管理 Activity 的启动、生命周期及任务栈。它通过
<code>Binder</code> IPC 机制与应用进程通信。</p>
<ul>
<li><strong>ActivityThread</strong>：应用进程的主线程，负责执行应用中的
Activity 生命周期回调，处理 <code>AMS</code> 发来的消息。</li>
<li><strong>WindowManagerService
(WMS)</strong>：管理窗口的显示，<code>AMS</code> 与 <code>WMS</code>
协作来完成 Activity 的界面显示和切换。</li>
<li><strong>PackageManagerService
(PMS)</strong>：管理应用的安装、卸载和相关信息，<code>AMS</code>
通过它来检查应用的合法性。</li>
</ul>
<h3 id="ams-如何管理-activity">3. <strong>AMS 如何管理
Activity</strong></h3>
<p><code>AMS</code> 在管理 Activity 时，主要负责以下几个方面：</p>
<h4 id="启动-activity">1. <strong>启动 Activity</strong></h4>
<p>Activity 的启动是一个复杂的过程，<code>AMS</code>
是启动流程的核心。整个启动过程大致可以分为以下几步：</p>
<ol type="1">
<li><p><strong>应用请求启动 Activity</strong>： 应用通过
<code>startActivity()</code> 方法向 <code>ActivityManagerService</code>
请求启动一个 Activity，这个请求最终会通过 <code>Binder</code> 机制到达
<code>AMS</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应用调用 startActivity()</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, TargetActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>AMS 接收启动请求</strong>： <code>AMS</code> 收到
<code>startActivity()</code>
请求后，会检查请求的合法性（例如是否具有相应的权限），然后通过
<code>startActivityAsUser()</code> 方法处理启动请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, </span></span><br><span class="line"><span class="params">    Intent intent, String resolvedType, ...)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivity(caller, intent, ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>创建或调度进程</strong>： 如果目标 <code>Activity</code>
所在的应用进程已经存在，<code>AMS</code>
会将启动请求发送给对应的进程；如果进程不存在，<code>AMS</code> 会通过
<code>Zygote</code> 启动一个新的进程。</p></li>
<li><p><strong>通过 Binder 通知 ActivityThread 启动 Activity</strong>：
<code>AMS</code> 通过 <code>ApplicationThreadProxy</code>（应用进程的
Binder 接口）向应用的 <code>ActivityThread</code> 发送启动 Activity
的请求。</p></li>
<li><p><strong>ActivityThread 创建 Activity 并启动</strong>： 应用进程的
<code>ActivityThread</code> 收到请求后，会调用
<code>Instrumentation</code> 创建目标 Activity，并执行 Activity
的生命周期方法（如
<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> &#123;</span><br><span class="line">    <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> performLaunchActivity(r, customIntent);</span><br><span class="line">    activity.performResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="activity-的生命周期管理">2. <strong>Activity
的生命周期管理</strong></h4>
<p><code>AMS</code> 负责管理每个 Activity 的生命周期状态。当应用的
Activity 切换、暂停或销毁时，<code>AMS</code>
会调度相应的生命周期方法。</p>
<ol type="1">
<li><p><strong>启动生命周期</strong>： 在 Activity
启动时，<code>AMS</code> 会调度应用进程的 <code>ActivityThread</code>
调用 Activity 的
<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>
方法。</p></li>
<li><p><strong>暂停和恢复生命周期</strong>： 当用户切换到另一个 Activity
时，<code>AMS</code> 会调用当前 Activity 的 <code>onPause()</code>
方法。随后，它会启动新的 Activity，并调用其 <code>onResume()</code>
方法。</p></li>
<li><p><strong>销毁生命周期</strong>： 当 <code>AMS</code> 检测到某个
Activity 不再需要时（如用户离开应用或内存不足时），它会调度
<code>ActivityThread</code> 调用 Activity 的 <code>onDestroy()</code>
方法，销毁该 Activity。</p></li>
</ol>
<h4 id="任务栈管理">3. <strong>任务栈管理</strong></h4>
<p><code>AMS</code> 使用 <strong>任务栈</strong>（Task Stack）来管理
Activity。每个任务栈代表一个任务，栈中的每个元素是一个
<code>Activity</code> 实例。任务栈以先进后出的方式管理 Activity。</p>
<ul>
<li><strong>前台任务栈</strong>：<code>AMS</code>
通过任务栈的堆栈结构管理用户当前正在使用的应用（即前台任务），栈顶的
Activity 是用户当前正在交互的 Activity。</li>
<li><strong>后台任务栈</strong>：不在前台显示的 Activity
会被放置到后台任务栈，<code>AMS</code> 可以通过回收内存来释放这些后台
Activity 的资源。</li>
</ul>
<p>每次 <code>AMS</code> 启动新的 Activity
时，都会将其压入栈中，当用户按下返回键时，会从任务栈中弹出顶层的
Activity 并销毁它。</p>
<h4 id="进程管理">4. <strong>进程管理</strong></h4>
<p><code>AMS</code> 还负责管理应用的进程，包括：</p>
<ul>
<li><strong>进程启动</strong>：当某个应用首次启动时，如果该应用的进程还未运行，<code>AMS</code>
会通过 <code>Zygote</code> 启动一个新的应用进程。</li>
<li><strong>进程优先级调整</strong>：根据进程中 Activity
的状态，<code>AMS</code>
会调整应用进程的优先级。例如，前台进程优先级高，而后台进程优先级低。</li>
<li><strong>内存回收</strong>：当系统内存不足时，<code>AMS</code>
会终止优先级较低的后台进程来回收内存。</li>
</ul>
<h4 id="处理-activity-异常">5. <strong>处理 Activity 异常</strong></h4>
<p>当某个 Activity 出现异常（如 ANR 或崩溃）时，<code>AMS</code>
负责检测并处理这些异常。</p>
<ul>
<li><strong>ANR（Application Not Responding）</strong>：当某个 Activity
在主线程中执行时间过长且未响应时，<code>AMS</code> 会触发 ANR
对话框，并允许用户选择强制关闭应用。</li>
<li><strong>崩溃处理</strong>：当应用进程崩溃时，<code>AMS</code>
会记录崩溃信息，并销毁相关的 Activity 或服务。</li>
</ul>
<h3 id="ams-与-wms-协同工作">4. <strong>AMS 与 WMS
协同工作</strong></h3>
<p><code>AMS</code> 与 <code>WindowManagerService</code>（WMS）协同管理
Activity 的界面显示和窗口管理。当一个 Activity
被启动时，<code>AMS</code> 会通知 <code>WMS</code>
创建一个窗口（<code>Window</code>），并将 Activity
的视图显示在该窗口中。</p>
<h4 id="窗口创建">1. <strong>窗口创建</strong>：</h4>
<p>当 <code>AMS</code> 启动一个 Activity 时，会通过 <code>Binder</code>
向 <code>WMS</code> 发送请求，要求它创建一个窗口用于显示该 Activity
的界面。</p>
<h4 id="窗口显示">2. <strong>窗口显示</strong>：</h4>
<p><code>WMS</code> 接收到 <code>AMS</code>
的请求后，会创建一个窗口，并将该窗口的句柄返回给 Activity。Activity 通过
<code>setContentView()</code>
设置自己的布局后，窗口就会被渲染在屏幕上。</p>
<h4 id="窗口切换">3. <strong>窗口切换</strong>：</h4>
<p>当用户在不同 Activity 之间切换时，<code>WMS</code>
会负责管理窗口的隐藏和显示。<code>AMS</code> 通知 <code>WMS</code> 当前
Activity 的显示或隐藏，<code>WMS</code> 相应地更新界面显示。</p>
<h3 id="ams-的任务栈和任务栈管理">5. <strong>AMS
的任务栈和任务栈管理</strong></h3>
<p><code>AMS</code> 中的任务栈（Task Stack）用来管理不同应用和 Activity
的执行顺序。任务栈是一个栈结构，栈顶的 Activity 是当前正在运行的
Activity。当用户启动新任务时，<code>AMS</code>
会创建一个新的任务栈或者向现有的任务栈中添加
Activity。任务栈的管理方式包括：</p>
<ul>
<li><strong>启动模式</strong>：Activity 的启动模式（如
<code>standard</code>、<code>singleTop</code>、<code>singleTask</code>、<code>singleInstance</code>）决定了
Activity 如何被添加到任务栈中。</li>
<li><strong>返回栈</strong>：当用户按下返回键时，当前任务栈中的 Activity
会被依次弹出，并销毁。</li>
</ul>
<h3 id="总结-4">总结</h3>
<p><code>ActivityManagerService</code> 是 Android 系统中负责管理
Activity、应用进程和任务栈的核心组件。它通过与
<code>ActivityThread</code>、<code>WindowManagerService</code>、<code>PackageManagerService</code>
等其他系统服务协作，管理 Activity
的启动、生命周期、任务栈以及异常处理。<code>AMS</code> 在整个 Android
系统架构中起着至关重要的作用，它确保了应用程序能够按照</p>
<p>正确的生命周期顺序进行操作，同时有效地管理系统资源和进程调度。</p>
<h2 id="activitythread工作原理">ActivityThread工作原理</h2>
<p><code>ActivityThread</code> 是 Android
中的一个关键类，它位于应用程序的主线程（UI
线程）中，负责管理应用的生命周期以及处理系统和应用之间的通信。<code>ActivityThread</code>
的主要职责是与
<code>AMS</code>（ActivityManagerService）进行交互，处理来自
<code>AMS</code> 的消息并调度 Activity、Service、BroadcastReceiver
等组件的生命周期方法。它可以被看作是应用程序主线程的控制中心。</p>
<h3 id="activitythread-的基本概述">1. <strong>ActivityThread
的基本概述</strong></h3>
<p><code>ActivityThread</code> 是 Android
应用进程中的核心类。它负责启动和管理应用程序的主线程，并调度执行
<code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>
等组件的生命周期回调。同时，它通过 <code>Handler</code>
机制与系统服务（如
<code>AMS</code>）进行通信，将来自系统的消息调度到应用层的相应组件。</p>
<p>在 Android 系统启动应用程序时，<code>ActivityThread</code>
类会启动主线程，创建主 <code>Looper</code> 和
<code>MessageQueue</code>，并通过消息驱动应用的各个组件执行。</p>
<h3 id="activitythread-的核心组件">2. <strong>ActivityThread
的核心组件</strong></h3>
<ul>
<li><strong><code>Looper</code> 和
<code>MessageQueue</code></strong>：<code>ActivityThread</code>
运行在应用程序的主线程中，主线程的执行是基于消息循环机制的。<code>ActivityThread</code>
会创建一个 <code>Looper</code> 和一个
<code>MessageQueue</code>，用于处理来自系统和应用内部的消息。</li>
<li><strong><code>Handler</code></strong>：<code>ActivityThread</code>
使用 <code>Handler</code> 来分发和处理消息。每当系统通过
<code>Binder</code> 向应用发送请求（如启动一个
<code>Activity</code>），这些请求都会被封装成消息，通过
<code>Handler</code> 分发到主线程处理。</li>
<li><strong><code>ApplicationThread</code></strong>：这是
<code>ActivityThread</code> 与 <code>AMS</code> 交互的 Binder
接口。<code>AMS</code> 通过 <code>ApplicationThread</code>
发送消息给应用进程，<code>ApplicationThread</code> 作为
<code>ActivityThread</code>
的内部类，充当应用程序和系统服务之间的桥梁。</li>
<li><strong><code>ActivityClientRecord</code></strong>：<code>ActivityThread</code>
中使用 <code>ActivityClientRecord</code> 来记录每个 Activity
的状态，包括它的生命周期状态、相关的
<code>Intent</code>、<code>Token</code> 等。</li>
</ul>
<h3 id="activitythread-的工作流程">3. <strong>ActivityThread
的工作流程</strong></h3>
<h4 id="启动流程">1. <strong>启动流程</strong></h4>
<p><code>ActivityThread</code> 是在应用启动时由 Zygote
进程创建的。当用户启动应用时，<code>Zygote</code> 进程 fork
出一个新的进程，并在新进程中启动 <code>ActivityThread</code>
的主线程。启动流程可以概括如下：</p>
<ol type="1">
<li><p><strong>Zygote 启动应用进程</strong>：
当应用被启动时，<code>ActivityManagerService</code> 通过
<code>Zygote</code> 创建一个新的应用进程。<code>Zygote</code> 负责 fork
出新的进程，并调用 <code>ActivityThread.main()</code>
方法来启动应用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>);  <span class="comment">// 与 AMS 绑定</span></span><br><span class="line">    Looper.loop();  <span class="comment">// 开启消息循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>创建 <code>ActivityThread</code> 实例</strong>：
<code>main()</code> 方法中会创建一个 <code>ActivityThread</code>
实例，并通过 <code>attach()</code> 方法与
<code>ActivityManagerService</code> 进行绑定，告知 <code>AMS</code>
该进程已经启动。</p></li>
<li><p><strong>绑定 <code>ApplicationThread</code></strong>：
<code>ActivityThread.attach()</code> 会通过
<code>ApplicationThread</code> 将该进程与 <code>AMS</code>
绑定，<code>AMS</code> 会通过 Binder
机制向该进程发送生命周期相关的消息。</p></li>
<li><p><strong>启动消息循环</strong>：
<code>ActivityThread.main()</code> 调用了
<code>Looper.loop()</code>，从此开始应用进程的消息循环。应用进程会不断从
<code>MessageQueue</code> 中读取消息，并通过 <code>Handler</code>
处理这些消息。</p></li>
</ol>
<h4 id="消息处理机制">2. <strong>消息处理机制</strong></h4>
<p><code>ActivityThread</code> 通过 <code>Handler</code> 来处理从
<code>AMS</code> 和其他系统服务发送来的消息，这些消息主要涉及
<code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>
的启动和生命周期管理。</p>
<ol type="1">
<li><p><strong>Handler 处理消息</strong>： <code>ActivityThread</code>
使用 <code>H</code> 类（继承自
<code>Handler</code>）处理不同类型的消息。每个消息会通过
<code>H.handleMessage()</code> 方法分发，<code>H</code>
类会根据消息类型调用对应的处理方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LAUNCH_ACTIVITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAUSE_ACTIVITY</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP_ACTIVITY</span> <span class="operator">=</span> <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> LAUNCH_ACTIVITY:</span><br><span class="line">                handleLaunchActivity((ActivityClientRecord) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PAUSE_ACTIVITY:</span><br><span class="line">                handlePauseActivity((IBinder) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOP_ACTIVITY:</span><br><span class="line">                handleStopActivity((IBinder) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 其他消息处理...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>生命周期消息处理</strong>： 当应用需要启动一个
<code>Activity</code> 时，<code>AMS</code> 会通过
<code>ApplicationThread</code>
将启动请求发送给应用进程。<code>ActivityThread</code>
收到消息后，会调用对应的生命周期方法（如
<code>handleLaunchActivity()</code>），执行 Activity
的创建、启动和显示。</p></li>
</ol>
<h4 id="activity-启动过程">3. <strong>Activity 启动过程</strong></h4>
<p>当应用需要启动一个新的 <code>Activity</code>
时，<code>ActivityThread</code> 负责执行该 <code>Activity</code>
的启动过程。具体步骤如下：</p>
<ol type="1">
<li><p><strong>收到启动 Activity 的消息</strong>：
<code>ActivityThread</code> 收到 <code>AMS</code> 通过
<code>ApplicationThread</code> 发来的 <code>LAUNCH_ACTIVITY</code>
消息。</p></li>
<li><p><strong>创建 Activity 实例</strong>：
<code>ActivityThread.handleLaunchActivity()</code> 方法首先会调用
<code>Instrumentation.newActivity()</code> 来创建 <code>Activity</code>
实例。<code>Instrumentation</code>
是一个用于监控应用组件生命周期的类，负责实际的 <code>Activity</code>
创建和生命周期管理。</p></li>
<li><p><strong>调用 Activity 生命周期</strong>： 在
<code>ActivityThread.performLaunchActivity()</code>
中，<code>Activity</code> 实例被创建后，<code>Activity</code> 的
<code>attach()</code>
方法会被调用，完成与窗口和上下文的绑定。接着，会调用
<code>Activity</code> 的 <code>onCreate()</code> 方法，开始执行 Activity
的初始化逻辑。</p></li>
<li><p><strong>显示 Activity</strong>： <code>Activity</code>
创建完成后，<code>ActivityThread</code> 会通过
<code>WindowManager</code> 将 <code>Activity</code>
的界面显示到屏幕上。</p></li>
</ol>
<h4 id="activity-生命周期管理">4. <strong>Activity
生命周期管理</strong></h4>
<p><code>ActivityThread</code> 负责管理 <code>Activity</code>
的生命周期，当应用的 <code>Activity</code>
状态发生变化时，<code>AMS</code> 会通过 <code>ApplicationThread</code>
将相应的生命周期事件通知
<code>ActivityThread</code>，例如暂停、停止、销毁等操作。</p>
<ol type="1">
<li><p><strong>暂停 Activity</strong>： 当用户切换到其他
<code>Activity</code> 或应用时，<code>AMS</code> 会通知
<code>ActivityThread</code> 调用 <code>Activity</code> 的
<code>onPause()</code> 方法来暂停当前 <code>Activity</code>。</p></li>
<li><p><strong>停止 Activity</strong>： 当 <code>AMS</code> 认为某个
<code>Activity</code> 不再需要显示时，会通知 <code>ActivityThread</code>
调用 <code>Activity</code> 的 <code>onStop()</code> 方法，停止该
<code>Activity</code>。</p></li>
<li><p><strong>销毁 Activity</strong>： 当某个 <code>Activity</code>
被销毁时，<code>AMS</code> 会发送销毁命令给
<code>ActivityThread</code>，<code>ActivityThread</code> 调用
<code>Activity</code> 的 <code>onDestroy()</code> 方法，销毁该
<code>Activity</code>，释放资源。</p></li>
</ol>
<h3 id="与其他系统服务的协作">4.
<strong>与其他系统服务的协作</strong></h3>
<p><code>ActivityThread</code> 通过 <code>ApplicationThread</code> 与
<code>ActivityManagerService</code>（AMS） 进行通信，协调管理
<code>Activity</code>、<code>Service</code> 和其他组件的生命周期。</p>
<ul>
<li><p><strong>与 <code>AMS</code> 的交互</strong>：
<code>ActivityThread</code> 通过 <code>ApplicationThread</code>
作为客户端接口与 <code>AMS</code> 进行交互。<code>AMS</code>
负责调度应用进程的生命周期事件，<code>ActivityThread</code>
接收到这些事件后，通知应用中的相应组件执行对应的生命周期方法。</p></li>
<li><p><strong>与 <code>WMS</code> 的交互</strong>：
<code>ActivityThread</code> 通过 <code>WindowManager</code> 与
<code>WindowManagerService</code> (WMS)
进行交互，管理应用界面的窗口显示和调整。每次启动新的
<code>Activity</code> 时，<code>ActivityThread</code> 都会请求
<code>WMS</code> 创建一个新的窗口来显示 <code>Activity</code>
的内容。</p></li>
</ul>
<h3 id="activitythread-的主要方法">5. <strong>ActivityThread
的主要方法</strong></h3>
<ul>
<li><strong><code>main()</code></strong>：应用进程的入口，负责启动
<code>ActivityThread</code>，并初始化 <code>Looper</code>
和消息队列。</li>
<li><strong><code>attach()</code></strong>：将应用进程与
<code>AMS</code> 进行绑定，建立进程间通信的通道。</li>
<li><strong><code>handleLaunchActivity()</code></strong>：处理
<code>Activity</code> 的启动流程，包括创建 <code>Activity</code>
实例、调用生命周期方法等。</li>
<li><strong><code>performLaunchActivity()</code></strong>：执行
<code>Activity</code> 的启动，包括调用
<code>onCreate()</code>、<code>onStart()</code> 等生命周期方法。</li>
<li><strong><code>handlePauseActivity()</code></strong>：处理
<code>Activity</code> 的暂停操作，调用 <code>onPause()</code>
方法。</li>
<li><strong><code>handleStopActivity()</code></strong>：处理
<code>Activity</code> 的停止操作，调用 <code>onStop()</code> 方法。</li>
<li><strong><code>handleDestroyActivity()</code></strong>：处理
<code>Activity</code> 的销毁操作，调用 <code>onDestroy()</code>
方法。</li>
</ul>
<h3 id="总结-5">6. <strong>总结</strong></h3>
<p><code>ActivityThread</code> 是 Android</p>
<p>应用进程中的核心类，负责管理
<code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>
的生命周期和 UI 线程的消息循环。通过与 <code>AMS</code>
的交互，它能够有效地调度应用的生命周期回调，并处理用户界面的显示和切换。<code>ActivityThread</code>
利用 <code>Handler</code>
机制，在主线程中调度和处理系统消息，保证了应用的正常运行。</p>
<h2 id="内存抖动是什么">内存抖动是什么</h2>
<p>内存抖动（Memory Churn 或 Memory
Thrashing）指的是程序在短时间内频繁地进行内存的分配和释放，导致大量的临时对象被频繁创建和销毁，进而导致垃圾回收器（GC）频繁运行，从而影响程序的性能。这种现象通常会导致应用程序出现性能下降、卡顿等问题。</p>
<h3 id="内存抖动的表现">内存抖动的表现</h3>
<ul>
<li><strong>频繁分配和释放内存</strong>：程序中有大量的临时对象被创建，但这些对象很快就不再被使用，导致它们很快被垃圾回收。</li>
<li><strong>垃圾回收频率增加</strong>：由于频繁创建和销毁对象，垃圾回收器需要频繁运行来回收不再使用的内存，GC
的频繁运行会导致程序暂停，从而影响性能。</li>
<li><strong>CPU 使用率增高</strong>：频繁的内存分配和回收会增加 CPU
的负担，导致 CPU 占用率增加。</li>
<li><strong>应用卡顿或掉帧</strong>：在 Android 或其他 UI
密集型应用中，内存抖动会导致 UI 卡顿或者掉帧，影响用户体验。</li>
</ul>
<h3 id="内存抖动的常见原因">内存抖动的常见原因</h3>
<ol type="1">
<li><strong>频繁创建短生命周期的对象</strong>：某些情况下，程序中会频繁创建一些生命周期很短的对象，比如循环中每次迭代都会创建新的对象，而这些对象会很快变为垃圾。</li>
<li><strong>集合类的使用不当</strong>：在集合类（如
<code>ArrayList</code>、<code>HashMap</code>
等）中频繁添加和删除元素，可能会导致大量对象的分配和释放，进而引发内存抖动。</li>
<li><strong>字符串拼接</strong>：频繁进行字符串拼接会创建大量的临时字符串对象，特别是在
Java 中，字符串是不可变的，拼接操作会不断创建新的对象。</li>
<li><strong>重复创建对象而不是重用</strong>：在某些场景下，程序会重复创建一些对象而不是复用它们，这会导致不必要的内存分配。</li>
</ol>
<h3 id="如何避免内存抖动">如何避免内存抖动</h3>
<ol type="1">
<li><p><strong>避免不必要的对象创建</strong>：尽量避免在短时间内频繁创建临时对象，可以考虑对象池技术来重用对象。</p></li>
<li><p><strong>使用更高效的集合类</strong>：根据需求选择合适的集合类，例如，在频繁访问或修改时，可以使用带有优化策略的集合类来减少内存开销。</p></li>
<li><p><strong>优化字符串操作</strong>：在频繁拼接字符串时，使用
<code>StringBuilder</code> 或 <code>StringBuffer</code>
来替代直接的字符串拼接操作，减少不必要的对象分配。</p></li>
<li><p><strong>避免过度依赖自动装箱/拆箱</strong>：自动装箱（auto-boxing）和拆箱（auto-unboxing）会创建额外的对象，特别是在频繁操作基本数据类型时，应该尽量使用基本数据类型而不是包装类。</p></li>
<li><p><strong>优化算法</strong>：检查程序中的算法是否有优化的空间，避免不必要的对象创建和销毁。</p></li>
</ol>
<h3 id="内存抖动对性能的影响">内存抖动对性能的影响</h3>
<p>内存抖动可能导致应用程序的响应速度变慢，尤其是对于实时性要求较高的应用，如游戏或多媒体应用。频繁的垃圾回收不仅会消耗系统资源，还会导致程序在
GC 过程中暂停，造成应用的卡顿现象。</p>
<h3 id="内存抖动的检测">内存抖动的检测</h3>
<p>在 Android 和 Java
应用中，开发者可以使用各种性能分析工具来检测内存抖动，例如：</p>
<ul>
<li><strong>Android Studio
Profiler</strong>：可以帮助开发者监控内存分配情况，查看对象的创建和销毁频率，找到潜在的内存抖动问题。</li>
<li><strong>MAT (Memory Analyzer Tool)</strong>：可以用于分析 Java
应用的堆内存，检查内存使用情况，找到潜在的内存抖动源。</li>
</ul>
<p>通过这些工具，开发者可以识别程序中频繁创建的对象，优化代码以减少内存抖动。</p>
<h2 id="android系统启动流程是什么">Android系统启动流程是什么</h2>
<p>Android系统的启动流程可以分为以下几个主要阶段，从设备加电到启动应用的过程如下：</p>
<h3 id="bootloader阶段">1. <strong>Bootloader阶段</strong></h3>
<ul>
<li><strong>加电</strong>：当设备加电时，系统从固件（Bootloader）开始启动。Bootloader负责初始化硬件和加载内核，它是系统启动的第一步。</li>
<li><strong>Bootloader初始化</strong>：Bootloader会进行一些硬件初始化工作，例如内存、处理器、时钟等硬件资源的配置。然后，它会查找操作系统内核并将其加载到内存中。</li>
<li><strong>启动内核</strong>：一旦内核被加载，Bootloader会将控制权交给内核，开始执行内核代码。</li>
</ul>
<h3 id="linux内核启动阶段">2. <strong>Linux内核启动阶段</strong></h3>
<ul>
<li><strong>内核初始化</strong>：Android系统基于Linux内核。内核启动时，会初始化系统的核心组件，包括内存管理、进程管理、文件系统、网络等。在这一步中，内核会设置设备树（Device
Tree）并识别设备的硬件信息。</li>
<li><strong>启动init进程</strong>：内核完成基本的初始化之后，会启动第一个用户空间进程
<code>init</code>。<code>init</code> 是 Android
系统的第一个用户态进程，进程号为 1。</li>
</ul>
<h3 id="init进程启动阶段">3. <strong>Init进程启动阶段</strong></h3>
<ul>
<li><strong>解析init.rc文件</strong>：<code>init</code> 进程会根据
<code>init.rc</code>
文件的配置启动系统的服务和进程。<code>init.rc</code>
文件定义了系统的服务、文件系统挂载、属性设置等重要配置。</li>
<li><strong>启动Zygote进程</strong>：<code>init</code> 进程会启动 Zygote
进程，Zygote 是 Android 系统中非常重要的一个进程，它负责初始化 Java
虚拟机（JVM）并加载核心的 Android 类库。几乎所有的应用进程都是由 Zygote
派生出来的。</li>
</ul>
<h3 id="zygote和system-server启动阶段">4. <strong>Zygote和System
Server启动阶段</strong></h3>
<ul>
<li><strong>启动Zygote</strong>：Zygote
进程启动后，它会预加载一些系统常用的类和资源，并开始监听特定的
socket，等待启动新的应用进程。</li>
<li><strong>启动System Server</strong>：Zygote
还会启动一个非常重要的进程——<code>System Server</code>，它负责启动并管理
Android 的系统服务。System Server 会启动一些关键的系统服务，如 Activity
Manager、Package Manager、Window Manager 等。</li>
</ul>
<h3 id="启动android-runtime-art">5. <strong>启动Android Runtime
(ART)</strong></h3>
<ul>
<li><strong>ART初始化</strong>：Zygote 启动后，Android
Runtime（ART）环境会被初始化。ART 是 Android
用来执行和管理应用的运行时环境，负责字节码的转换和执行。</li>
</ul>
<h3 id="启动launcher和应用进程">6.
<strong>启动Launcher和应用进程</strong></h3>
<ul>
<li><strong>启动Launcher</strong>：在系统服务启动完成后，<code>Activity Manager</code>
会启动 Launcher
应用，这是用户界面的主屏幕，也是用户启动其他应用的入口。</li>
<li><strong>启动应用进程</strong>：当用户点击应用时，Launcher 会向
Zygote 发起请求，Zygote 会 fork
一个新的进程，生成应用进程。在这个新的进程中，ART
会加载应用的类并执行。</li>
</ul>
<h3 id="总结-6">总结：</h3>
<ol type="1">
<li><strong>Bootloader</strong>：初始化硬件，加载内核。</li>
<li><strong>内核</strong>：初始化系统资源，启动 init 进程。</li>
<li><strong>Init进程</strong>：解析配置，启动 Zygote 和 System
Server。</li>
<li><strong>Zygote</strong>：启动 Android Runtime (ART) 和 System
Server。</li>
<li><strong>Launcher</strong>：系统界面显示，用户可以启动应用。</li>
</ol>
<p>每一步都承担着不同的角色，最终目的是让 Android
系统能够顺利地加载并运行用户的应用。</p>
<h2 id="app启动流程">App启动流程</h2>
<p>Android应用程序（App）的启动过程可以分为多个阶段，从用户点击应用图标到应用界面显示的过程涉及多个组件。以下是Android应用启动流程的详细说明：</p>
<h3 id="用户点击应用图标">1. <strong>用户点击应用图标</strong></h3>
<p>当用户点击应用图标时，Launcher（启动器）应用会发起启动应用的请求。这个请求会通过
<strong>Activity Manager</strong> 传递到系统层，进入应用启动流程。</p>
<h3 id="launcher请求启动应用">2.
<strong>Launcher请求启动应用</strong></h3>
<ul>
<li><strong>向Activity
Manager发送Intent</strong>：当用户点击应用图标后，Launcher 向
<code>ActivityManagerService</code> (AMS) 发送一个带有应用启动信息的
<code>Intent</code>。这个 <code>Intent</code>
通常包含应用包名以及要启动的 <code>Activity</code> 信息。</li>
<li><strong>Activity Manager 检查应用状态</strong>：AMS
检查该应用是否已经运行。如果应用已经在后台运行，则直接将应用切换到前台；如果应用还没有启动，AMS
将会启动一个新的应用进程。</li>
</ul>
<h3 id="zygote进程派生应用进程">3.
<strong>Zygote进程派生应用进程</strong></h3>
<ul>
<li><strong>启动新的应用进程</strong>：如果应用还没有进程在运行，AMS
会通过与 <code>Zygote</code> 进程通信，请求 Zygote
fork（派生）一个新的进程。这是因为 Android 的所有应用进程都是由 Zygote
fork 出来的，这样可以共享系统的类库和资源，减少启动时间和内存占用。</li>
<li><strong>创建新进程</strong>：Zygote fork
新进程后，新进程会通过反射机制，启动应用的入口类（通常是
<code>ActivityThread</code>）。</li>
</ul>
<h3 id="activitythread启动">4. <strong>ActivityThread启动</strong></h3>
<ul>
<li><strong>ActivityThread的启动</strong>：新应用进程启动后，Zygote fork
出来的新进程会调用 <code>ActivityThread</code> 类的 <code>main()</code>
方法，开始初始化应用的主线程。<code>ActivityThread</code>
是应用进程的主类，它负责管理应用的主线程、处理 UI 操作、管理 Activity
的生命周期等。</li>
<li><strong>建立主线程Looper</strong>：<code>ActivityThread</code>
初始化时，会创建一个 <code>Looper</code>，它是 Android
的消息循环机制，主线程中的所有消息都会在这个 Looper 中处理。</li>
</ul>
<h3 id="activity的启动">5. <strong>Activity的启动</strong></h3>
<ul>
<li><strong>AMS通知启动Activity</strong>：AMS 在新进程准备好后，会通过
<code>Binder</code> 通信机制通知应用进程，要求启动具体的
<code>Activity</code>。AMS 会调用 <code>ApplicationThread</code> 的
<code>scheduleLaunchActivity()</code> 方法来完成通知工作。</li>
<li><strong>创建Activity实例</strong>：<code>ActivityThread</code>
收到启动 <code>Activity</code> 的消息后，会调用
<code>performLaunchActivity()</code> 方法，创建目标
<code>Activity</code> 的实例，并调用它的 <code>onCreate()</code>
方法。</li>
</ul>
<h3 id="activity生命周期方法调用">6.
<strong>Activity生命周期方法调用</strong></h3>
<ul>
<li><strong>onCreate()</strong>：<code>Activity</code>
的实例创建后，系统会首先调用 <code>onCreate()</code> 方法。这个方法是
<code>Activity</code>
生命周期的第一步，通常在这里完成界面布局的初始化、数据的加载以及组件的绑定等工作。</li>
<li><strong>onStart()</strong> 和
<strong>onResume()</strong>：<code>onCreate()</code>
方法执行完毕后，<code>Activity</code> 的 <code>onStart()</code> 和
<code>onResume()</code> 方法也会被依次调用。在 <code>onResume()</code>
中，<code>Activity</code> 将进入前台，并与用户开始交互。</li>
</ul>
<h3 id="view的渲染">7. <strong>View的渲染</strong></h3>
<ul>
<li><strong>View的绘制</strong>：在 <code>onCreate()</code>
方法中，<code>Activity</code> 通常会调用 <code>setContentView()</code>
方法加载布局资源（XML文件），创建界面上的视图层次结构。这个过程通过
<code>LayoutInflater</code> 将 XML 布局文件解析为相应的视图对象。</li>
<li><strong>SurfaceFlinger</strong>：当 <code>Activity</code>
的视图层次结构完成后，系统会通过 <code>WindowManager</code>
将这些视图提交给底层的 <code>SurfaceFlinger</code>
进行显示。<code>SurfaceFlinger</code> 是 Android
的图形渲染引擎，它负责将所有应用窗口的图像合成并显示在屏幕上。</li>
</ul>
<h3 id="用户界面显示">8. <strong>用户界面显示</strong></h3>
<ul>
<li><strong>最终显示</strong>：经过前面一系列的初始化和渲染过程，<code>Activity</code>
的界面会最终呈现给用户，此时应用进入可交互状态，用户可以开始操作应用的界面。</li>
</ul>
<h3 id="总结-7">总结：</h3>
<ol type="1">
<li><strong>用户点击图标</strong>：Launcher 向 AMS 发送启动请求。</li>
<li><strong>AMS
检查应用状态</strong>：决定是切换到前台还是启动新的进程。</li>
<li><strong>Zygote fork 新进程</strong>：通过 Zygote fork
创建应用进程。</li>
<li><strong>ActivityThread
初始化</strong>：启动主线程，准备消息循环。</li>
<li><strong>创建Activity</strong>：AMS 通知应用启动
<code>Activity</code>，调用生命周期方法。</li>
<li><strong>界面渲染</strong>：加载布局，View
被绘制，最终显示到屏幕。</li>
</ol>
<p>这个流程确保了 Android
应用的快速启动，同时保证了内存和资源的有效利用。</p>
<h2 id="wms是如何管理window的">WMS是如何管理Window的</h2>
<p>在Android系统中，<strong>WindowManagerService (WMS)</strong>
是一个非常重要的系统服务，负责管理所有应用和系统窗口的显示。它控制着应用窗口的创建、布局、显示、和删除等操作。以下是WMS管理Window的主要过程和机制：</p>
<h3 id="窗口的分类">1. <strong>窗口的分类</strong></h3>
<p>在Android中，窗口主要有以下几种类型：</p>
<ul>
<li><strong>应用窗口</strong>（Application
Window）：由普通应用创建的窗口，通常是由<code>Activity</code>通过<code>setContentView()</code>加载布局来创建。</li>
<li><strong>子窗口</strong>（Sub-Window）：依附于主窗口的窗口，比如<code>Dialog</code>。</li>
<li><strong>系统窗口</strong>（System
Window）：系统级别的窗口，比如状态栏、导航栏、输入法窗口等。</li>
</ul>
<h3 id="窗口的创建过程">2. <strong>窗口的创建过程</strong></h3>
<ul>
<li><p><strong>应用向WMS请求创建窗口</strong>：当应用启动并创建<code>Activity</code>时，<code>Activity</code>通过<code>WindowManager</code>来向
<code>WindowManagerService</code> (WMS)
请求创建一个窗口。这个请求实际上是通过<code>WindowManagerGlobal</code>的<code>addView()</code>方法提交的。</p></li>
<li><p><strong>WMS
接收并处理请求</strong>：<code>WindowManagerGlobal</code>
会通过Binder机制与<code>WindowManagerService</code>通信。WMS接收到创建窗口的请求后，验证窗口类型、权限等信息，接着为窗口分配一个<code>WindowToken</code>，并把窗口信息加入到WMS的管理列表中。</p></li>
<li><p><strong>Surface的创建</strong>：<code>WMS</code>
在接受窗口请求后，会为窗口创建一个对应的<code>Surface</code>，这是实际用于绘制内容的地方。<code>Surface</code>
是通过<code>SurfaceFlinger</code>来管理的，它负责最终的窗口显示和图形合成。</p></li>
<li><p><strong>窗口的添加和排列</strong>：WMS会将新的窗口添加到系统中的窗口列表中，并根据窗口类型、层级和Z-order（Z轴的顺序）来确定窗口的显示顺序。例如，状态栏窗口永远在最顶层，应用窗口在状态栏下面。</p></li>
</ul>
<h3 id="窗口的管理和布局">3. <strong>窗口的管理和布局</strong></h3>
<ul>
<li><p><strong>布局计算</strong>：WMS负责计算每个窗口在屏幕上的位置和大小。当窗口被添加或窗口尺寸发生变化时，WMS会重新计算窗口的布局。布局计算包括窗口的坐标、大小、显示的层级等。</p></li>
<li><p><strong>使用<code>WindowState</code>记录窗口状态</strong>：每个窗口在WMS中都有一个对应的<code>WindowState</code>对象。这个对象存储了窗口的各种状态信息，比如位置、大小、是否可见、是否需要重新绘制等。WMS通过维护所有<code>WindowState</code>对象来管理系统中的所有窗口。</p></li>
<li><p><strong>窗口层级的管理</strong>：Android窗口的层级管理基于Z-order，即不同类型的窗口有不同的层级。比如应用窗口的层级一般比系统窗口低，而对话框、输入法窗口等可能会显示在应用窗口的上方。WMS会根据窗口的类型和需求来调整窗口的层级顺序。</p></li>
</ul>
<h3 id="窗口的绘制和显示">4. <strong>窗口的绘制和显示</strong></h3>
<ul>
<li><p><strong>SurfaceFlinger负责窗口合成</strong>：WMS只是负责窗口的管理和布局，但实际的窗口绘制和图像合成是由<code>SurfaceFlinger</code>完成的。WMS在窗口布局完成后，会将窗口对应的<code>Surface</code>交给<code>SurfaceFlinger</code>，由它负责将各个窗口的内容合成为一张最终的图像并显示到屏幕上。</p></li>
<li><p><strong>刷新和重绘</strong>：当窗口的内容发生变化（比如界面更新，用户操作等），WMS会通知相应的<code>WindowState</code>，要求它重新绘制。在绘制完成后，<code>SurfaceFlinger</code>会接收到新的窗口内容，并重新进行图像合成，最终更新到屏幕上。</p></li>
</ul>
<h3 id="窗口的焦点管理">5. <strong>窗口的焦点管理</strong></h3>
<ul>
<li><p><strong>焦点窗口</strong>：WMS负责管理系统中焦点窗口的分配。焦点窗口是指当前接收用户输入的窗口，通常是用户正在与之交互的应用窗口。WMS会根据窗口的优先级、可见性和类型等条件决定哪个窗口可以获得焦点。</p></li>
<li><p><strong>焦点切换</strong>：当用户切换应用、弹出对话框或者窗口发生变化时，WMS会处理焦点切换，确保新的焦点窗口能够正确接收到输入事件。</p></li>
</ul>
<h3 id="窗口的移除">6. <strong>窗口的移除</strong></h3>
<ul>
<li><p><strong>应用请求关闭窗口</strong>：当应用不再需要一个窗口时，通常会调用<code>WindowManager</code>的<code>removeView()</code>方法来移除窗口。这个请求会通过Binder传递给WMS。</p></li>
<li><p><strong>WMS移除窗口</strong>：WMS接收到移除窗口的请求后，会将窗口从内部的管理列表中移除，并释放对应的资源（比如<code>Surface</code>和<code>WindowToken</code>）。如果这个窗口是焦点窗口，WMS还会重新分配焦点给其他窗口。</p></li>
</ul>
<h3 id="窗口动画">7. <strong>窗口动画</strong></h3>
<ul>
<li><strong>窗口的动画处理</strong>：WMS还负责处理窗口的显示、隐藏、缩放等动画效果。当窗口被添加、移除或改变大小时，WMS会触发窗口动画，以提供更平滑的用户体验。这些动画通常通过<code>Surface</code>的变换来实现，最终由<code>SurfaceFlinger</code>合成到屏幕上。</li>
</ul>
<h3 id="输入事件的分发">8. <strong>输入事件的分发</strong></h3>
<ul>
<li><p><strong>事件分发的管理</strong>：WMS还负责管理输入事件的分发。系统中的输入事件（如触摸、按键）首先会传递给WMS，然后WMS会根据窗口的焦点状态和区域来决定将事件分发给哪个窗口的应用。</p></li>
<li><p><strong>确保正确的窗口接收输入</strong>：当用户点击屏幕时，WMS会根据点击位置查找对应的窗口，并将点击事件分发给该窗口。如果窗口不在焦点上或被覆盖，事件不会被传递给它。</p></li>
</ul>
<h3 id="总结-8">总结：</h3>
<p>WMS 作为 Android 系统中的核心服务，主要通过以下几方面管理窗口：</p>
<ol type="1">
<li><strong>窗口创建与销毁</strong>：通过接收应用或系统请求创建、添加或移除窗口。</li>
<li><strong>窗口布局和层级管理</strong>：计算窗口的位置、大小，并确定它的显示顺序。</li>
<li><strong>窗口显示和绘制</strong>：通过与<code>SurfaceFlinger</code>协作来完成窗口内容的渲染。</li>
<li><strong>焦点管理</strong>：决定哪个窗口可以接收用户输入，并处理焦点的切换。</li>
<li><strong>事件分发</strong>：管理输入事件的分发，确保用户操作能够正确传递到窗口。</li>
</ol>
<p>通过这些机制，WMS确保了Android系统中多窗口的正常运行、显示和交互。</p>
<h2 id="rxjava的实现原理">RxJava的实现原理</h2>
<h3 id="rxjava概述">RxJava概述</h3>
<p><strong>RxJava</strong> 是一个基于 <strong>ReactiveX</strong>
的响应式编程库，它将异步和事件驱动编程抽象为基于流的操作，使用
<strong>Observable</strong>、<strong>Observer</strong>、<strong>Scheduler</strong>
和其他核心组件来管理数据流和事件流。它能够让程序员以更简洁的方式处理异步操作，避免回调地狱，提升代码的可读性和维护性。</p>
<p>RxJava 的核心是
<code>Observable</code>，它发射一系列的数据，<code>Observer</code> 订阅
<code>Observable</code>，以响应 <code>Observable</code>
发射的每个数据项。通过运算符，开发者可以轻松地对数据流进行转换、过滤、合并等操作。</p>
<h3 id="rxjava的核心组件">RxJava的核心组件</h3>
<ul>
<li><strong>Observable</strong>：数据源，它发射一系列数据，<code>Observable</code>
可以是有限的或无限的。</li>
<li><strong>Observer</strong>：观察者，接收由 <code>Observable</code>
发射的每一个数据。</li>
<li><strong>Scheduler</strong>：调度器，用于指定在哪个线程中执行
<code>Observable</code> 和 <code>Observer</code> 的工作。</li>
</ul>
<h3 id="rxjava-的实现基于以下关键思想">RxJava
的实现基于以下关键思想：</h3>
<h4 id="observable和observer模式">1.
<strong>Observable和Observer模式</strong></h4>
<p>RxJava 的基本机制是
<strong>观察者模式</strong>，<code>Observable</code> 是可观察的对象，而
<code>Observer</code> 是观察者。当 <code>Observable</code>
发射数据时，它会通知所有订阅它的
<code>Observer</code>，<code>Observer</code>
会做出相应的反应。基本流程如下：</p>
<ul>
<li><code>Observable</code> 发射数据。</li>
<li><code>Observer</code> 订阅 <code>Observable</code>，并通过
<code>onNext()</code> 接收数据，<code>onError()</code>
处理错误，<code>onComplete()</code> 处理完成事件。</li>
</ul>
<h4 id="链式操作符和装饰者模式">2.
<strong>链式操作符和装饰者模式</strong></h4>
<p>RxJava 中的操作符（如
<code>map()</code>、<code>flatMap()</code>、<code>filter()</code>
等）通常用于转换或过滤数据流。这些操作符通过链式调用组合在一起，每个操作符会返回一个新的
<code>Observable</code>，但并不会立刻执行，直到有 <code>Observer</code>
订阅了链条上的 <code>Observable</code>。</p>
<p>内部实现使用了
<strong>装饰者模式</strong>。每个操作符实际上都是在现有的
<code>Observable</code> 上添加一层装饰，创建一个新的
<code>Observable</code>，通过这种方式逐步处理数据流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">          .map(i -&gt; i * <span class="number">2</span>)</span><br><span class="line">          .filter(i -&gt; i &gt; <span class="number">2</span>)</span><br><span class="line">          .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，每个操作符创建一个新的 <code>Observable</code>
实例，直到调用 <code>subscribe()</code>
时，才会执行整个链条，<code>Observable</code>
会发射转换后的数据给订阅者。</p>
<h4 id="schedulers和线程控制">3.
<strong>Schedulers和线程控制</strong></h4>
<p>RxJava 中引入了 <strong>Schedulers</strong>
来管理多线程操作，它提供了灵活的方式去控制代码的执行线程。RxJava
提供了几种常见的 <code>Scheduler</code>：</p>
<ul>
<li><strong>Schedulers.io()</strong>：用于I/O操作，如网络请求、文件操作等，背后是一个线程池。</li>
<li><strong>Schedulers.computation()</strong>：用于计算密集型工作，背后也是线程池。</li>
<li><strong>Schedulers.newThread()</strong>：每次都会创建一个新线程。</li>
<li><strong>AndroidSchedulers.mainThread()</strong>：在 Android
环境下，确保代码在主线程执行。</li>
</ul>
<p>例如，通过 <code>subscribeOn()</code> 和 <code>observeOn()</code>
操作符，可以指定 <code>Observable</code> 的数据发射线程和
<code>Observer</code> 的数据处理线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">          .subscribeOn(Schedulers.io())</span><br><span class="line">          .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">          .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>subscribeOn(Schedulers.io())</code>：指定
<code>Observable</code> 在 I/O 线程中运行。</li>
<li><code>observeOn(AndroidSchedulers.mainThread())</code>：指定
<code>Observer</code> 在 Android 主线程中运行，确保 UI
更新在主线程进行。</li>
</ul>
<h2 id="背压问题及其解决方案">背压问题及其解决方案</h2>
<h3 id="什么是背压backpressure">1.
<strong>什么是背压（Backpressure）？</strong></h3>
<p><strong>背压</strong>
问题是指在异步流处理中，数据生产者（<code>Observable</code>）的生产速度快于数据消费者（<code>Observer</code>）的消费速度，导致事件堆积，内存压力增大，甚至可能导致系统崩溃。</p>
<p>RxJava 中的 <code>Observable</code>
是无限制地发射数据的，特别是当使用 <code>Observable.interval()</code> 或
<code>Observable.fromIterable()</code> 时，可能会快速产生大量数据。如果
<code>Observer</code> 处理速度较慢，而 <code>Observable</code>
发射数据过快，系统的缓冲区可能会被填满，造成背压问题。</p>
<h3 id="背压的应对方案">2. <strong>背压的应对方案</strong></h3>
<p>为了解决背压问题，RxJava 提供了两种类型的 <code>Observable</code>
来处理背压：<code>Observable</code> 和 <code>Flowable</code>。</p>
<ul>
<li><strong>Observable</strong>：不支持背压处理，如果使用它而生产速度过快会导致数据丢失或缓冲区溢出。</li>
<li><strong>Flowable</strong>：支持背压处理，可以根据消费能力控制数据的发射速率。<code>Flowable</code>
是基于 <code>Reactive Streams</code>
规范实现的，允许消费者向生产者请求一定数量的数据，从而避免生产者发射过多数据。</li>
</ul>
<h3 id="flowable-背压模式">3. <strong>Flowable 背压模式</strong></h3>
<p><code>Flowable</code> 支持多种背压策略，以应对不同的背压场景：</p>
<ol type="1">
<li><p><strong>BUFFER</strong>：无限制缓冲所有未被处理的数据，直到内存耗尽。用于数据量较小时的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .onBackpressureBuffer()</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>DROP</strong>：当消费者来不及处理时，丢弃后续产生的数据，直到消费者可以处理为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .onBackpressureDrop()</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>LATEST</strong>：只保留最新的一条数据，当消费者准备好时，只接收最后发射的数据，其他数据会被丢弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .onBackpressureLatest()</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>ERROR</strong>：当出现背压问题时抛出
<code>MissingBackpressureException</code>，这是最严格的模式，确保程序员能明确知道背压问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .onBackpressureError()</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="flowable请求数量管理">4.
<strong>Flowable请求数量管理</strong></h3>
<p><code>Flowable</code> 使用了一种 <strong>请求机制</strong>
来解决背压问题，消费者可以通过 <code>request()</code>
方法明确告诉生产者需要多少数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">                                      .onBackpressureDrop();</span><br><span class="line">flowable.subscribe(<span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line">        s.request(<span class="number">10</span>);  <span class="comment">// 请求 10 个数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received: &quot;</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Subscriber</code> 通过 <code>s.request(10)</code>
向 <code>Flowable</code> 请求10个数据，<code>Flowable</code>
会根据请求数量控制发射速率，从而避免背压问题。</p>
<h3 id="总结-9">总结</h3>
<ol type="1">
<li><p><strong>RxJava 实现原理</strong>：基于观察者模式，使用
<code>Observable</code> 发射数据，<code>Observer</code>
订阅并处理数据，操作符通过链式调用实现数据流的转换和处理。<code>Scheduler</code>
用于管理线程。</p></li>
<li><p><strong>背压问题</strong>：当数据生产者发射数据的速度快于消费者处理数据的速度时，会产生背压问题，可能导致内存溢出或数据丢失。</p></li>
<li><p><strong>背压解决方案</strong>：RxJava 提供了
<code>Flowable</code>
以及多种背压策略（BUFFER、DROP、LATEST、ERROR）来应对生产和消费速度不匹配的问题。</p></li>
</ol>
<h2 id="map-和-flatmap">map 和 flatMap</h2>
<p><code>RxJava</code>
是一种基于异步编程和事件驱动的响应式编程框架，广泛用于 Android 和 Java
开发中。在 <code>RxJava</code> 中，<code>map</code> 和
<code>flatMap</code>
是两个常见的操作符，用于对数据流进行转换，但它们的用途和功能略有不同。</p>
<h3 id="map-操作符">1. <code>map</code> 操作符</h3>
<p><strong><code>map</code></strong>
操作符用于将一个类型的流数据转换为另一种类型的流数据。它是一个一对一的转换操作符，即对于每个输入数据，<code>map</code>
生成一个对应的输出数据。</p>
<h4 id="工作原理">工作原理：</h4>
<ul>
<li><code>map</code> 操作符接收一个 <code>Function&lt;T, R&gt;</code>
函数，该函数接受一个类型 <code>T</code> 的输入，返回一个类型
<code>R</code> 的输出。</li>
<li>每当源 <code>Observable</code> 发出一个数据项时，<code>map</code>
就会应用这个函数，将数据项转换为新的数据类型，然后将转换后的数据项发射给下游。</li>
</ul>
<h4 id="示例">示例：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">observable.map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Number &quot;</span> + integer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number 1</span><br><span class="line">Number 2</span><br><span class="line">Number 3</span><br><span class="line">Number 4</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里，<code>map</code>
将整数转换为字符串，但依旧保持数据项的一对一对应关系。</li>
</ul>
<h3 id="flatmap-操作符">2. <code>flatMap</code> 操作符</h3>
<p><strong><code>flatMap</code></strong> 操作符与 <code>map</code>
类似，也用于将数据转换为另一种形式。但 <code>flatMap</code>
不再是一对一的转换，它可以将每个输入的元素转换为一个
<code>Observable</code>，并将所有这些 <code>Observable</code>
合并成一个单一的 <code>Observable</code> 流。</p>
<h4 id="工作原理-1">工作原理：</h4>
<ul>
<li><code>flatMap</code> 接收一个
<code>Function&lt;T, ObservableSource&lt;R&gt;&gt;</code>
函数，这个函数将输入的类型 <code>T</code> 转换为一个新的
<code>ObservableSource&lt;R&gt;</code>。</li>
<li><code>flatMap</code> 生成的多个 <code>Observable</code>
会被“扁平化”（flatten）成单一的流，所有这些 <code>Observable</code>
的数据会被合并并发射给下游。</li>
</ul>
<h4 id="示例-1">示例：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">observable.flatMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;String&gt; <span class="title function_">apply</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(<span class="string">&quot;Number &quot;</span> + integer, <span class="string">&quot;Square &quot;</span> + (integer * integer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number 1</span><br><span class="line">Square 1</span><br><span class="line">Number 2</span><br><span class="line">Square 4</span><br><span class="line">Number 3</span><br><span class="line">Square 9</span><br><span class="line">Number 4</span><br><span class="line">Square 16</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在这个例子中，<code>flatMap</code> 将每个整数转换为两个字符串的
<code>Observable</code>，并将它们扁平化合并为一个单一的流。</li>
</ul>
<h3 id="区别总结">3. 区别总结</h3>
<ul>
<li><strong>转换关系</strong>：
<ul>
<li><code>map</code>
是<strong>一对一</strong>的转换，每个源数据只生成一个输出数据。</li>
<li><code>flatMap</code>
是<strong>一对多</strong>或<strong>多对多</strong>的转换，每个源数据可以生成多个输出数据，并将这些数据合并成单一的流。</li>
</ul></li>
<li><strong>输出类型</strong>：
<ul>
<li><code>map</code> 将输入数据转换为单一的其他类型数据。</li>
<li><code>flatMap</code> 将输入数据转换为
<code>Observable</code>，然后合并多个 <code>Observable</code>
的输出。</li>
</ul></li>
<li><strong>合并方式</strong>：
<ul>
<li><code>map</code> 不会涉及合并，直接一对一地转换。</li>
<li><code>flatMap</code> 将多个 <code>Observable</code> 合并为一个
<code>Observable</code>，且通常是无序的。</li>
</ul></li>
<li><strong>使用场景</strong>：
<ul>
<li><code>map</code> 适用于简单的单一转换，比如数据格式的转换。</li>
<li><code>flatMap</code>
适用于嵌套的异步操作，比如当你需要根据一个结果发起一个新的异步请求，并将所有的请求结果合并。</li>
</ul></li>
</ul>
<h3 id="flatmap-和-concatmap-的对比">4. <code>flatMap</code> 和
<code>concatMap</code> 的对比</h3>
<ul>
<li><code>flatMap</code> 发出的 <code>Observable</code>
是<strong>无序</strong>的，数据项的顺序可能会打乱。</li>
<li>如果你需要保持发射顺序，可以使用
<code>concatMap</code>，它会按顺序将每个 <code>Observable</code>
合并。</li>
</ul>
<h4 id="concatmap-示例"><code>concatMap</code> 示例：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">observable.concatMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;String&gt; <span class="title function_">apply</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(<span class="string">&quot;Number &quot;</span> + integer, <span class="string">&quot;Square &quot;</span> + (integer * integer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number 1</span><br><span class="line">Square 1</span><br><span class="line">Number 2</span><br><span class="line">Square 4</span><br><span class="line">Number 3</span><br><span class="line">Square 9</span><br><span class="line">Number 4</span><br><span class="line">Square 16</span><br></pre></td></tr></table></figure></p>
<p>在这里，<code>concatMap</code> 保持了发射的顺序，而
<code>flatMap</code> 则可能导致顺序不一致。</p>
<h3 id="总结-10">总结</h3>
<ul>
<li><strong><code>map</code></strong>
适用于一对一转换，将每个输入数据转换为一个输出数据。</li>
<li><strong><code>flatMap</code></strong>
适用于将输入数据转换为多个数据流，并将这些数据流合并成一个单一的数据流。</li>
<li><code>flatMap</code> 适合处理异步操作，比如网络请求的嵌套调用，而
<code>map</code> 则适合简单的类型转换。</li>
</ul>
<h2 id="zip-操作符">zip 操作符</h2>
<p><code>zip</code> 操作符是 RxJava
中一个非常有用的组合操作符，用于将多个 <code>Observable</code> 或
<code>Flowable</code> 发出的数据项进行组合。它按顺序将每个源
<code>Observable</code>
发出的项组合成一个新项，直到其中一个源发出完毕。</p>
<h3 id="工作原理-2">工作原理</h3>
<ul>
<li><strong>输入</strong>：可以接受多个 <code>Observable</code>。</li>
<li><strong>输出</strong>：每当所有源 <code>Observable</code>
发出一个新项时，<code>zip</code> 就会将这些项组合成一个新项。</li>
<li><strong>顺序</strong>：组合项的顺序与输入源的顺序相对应。</li>
<li><strong>完成条件</strong>：当任意一个源 <code>Observable</code>
完成时，<code>zip</code> 将停止发出项。</li>
</ul>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;Integer&gt; source1 = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Observable&lt;String&gt; source2 = Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">Observable.zip(source1, source2, (num, letter) -&gt; num + letter)</span><br><span class="line">        .subscribe(result -&gt; System.out.println(result));</span><br></pre></td></tr></table></figure>
<h3 id="输出">输出</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1A</span><br><span class="line">2B</span><br><span class="line">3C</span><br></pre></td></tr></table></figure>
<h3 id="使用场景">使用场景</h3>
<ul>
<li>当你需要从多个数据源组合数据时，<code>zip</code>
是一个理想的选择，例如请求多个 API，然后将结果组合在一起。</li>
<li>它确保每个组合项都来自各个源 <code>Observable</code>
的同一“轮次”。</li>
</ul>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>如果输入的 <code>Observable</code> 数量不一样，<code>zip</code>
会在发出最短序列后完成。</li>
<li>你可以使用 <code>zip</code>
的重载版本来指定不同的合并函数，处理不同类型的数据。</li>
</ul>
<h2 id="aspectj-的实现原理">AspectJ 的实现原理</h2>
<p>AspectJ 是 Java
语言的一个扩展，用于实现面向方面编程（AOP，Aspect-Oriented
Programming）。AspectJ 的实现主要通过“切面”（Aspect）、“连接点”（Join
Point）、“切入点”（Pointcut）和“通知”（Advice）来完成。这些概念使得
AspectJ
可以在不修改源代码的前提下，对已有的代码功能进行扩展或修改。以下是
AspectJ 的主要实现原理：</p>
<h3 id="编译时织入compile-time-weaving">1. 编译时织入（Compile-Time
Weaving）</h3>
<p>在 AspectJ
中，织入（Weaving）是指将切面代码插入到主程序代码中的过程。AspectJ
支持多种织入方式，其中最常见的是编译时织入。它的原理是：</p>
<ul>
<li>在编译过程中，AspectJ 编译器（如 <code>ajc</code>）会分析 Java
代码和 AspectJ
代码，并根据定义的切入点，将相应的切面逻辑插入到匹配的连接点上。</li>
<li>最终生成的字节码已经包含了织入的切面逻辑，所以在运行时不需要额外的处理。</li>
</ul>
<p>编译时织入的优势在于生成的字节码已经包含了切面的逻辑，对运行时性能几乎没有影响。这种方式适用于在开发阶段已经确定好切面代码的场景。</p>
<h3 id="类加载时织入load-time-weavingltw">2. 类加载时织入（Load-Time
Weaving，LTW）</h3>
<p>类加载时织入是在运行时将切面织入到 Java
类中的方法。这种方式在类被加载到 JVM
中时，通过自定义的类加载器（ClassLoader）完成织入。具体实现原理为：</p>
<ul>
<li>JVM 加载类时，AspectJ 的 LTW 代理类加载器会拦截类的加载过程。</li>
<li>在加载类的字节码时，代理类加载器会将切面代码根据切入点织入到指定位置，生成新的字节码，再交由
JVM 加载。</li>
</ul>
<p>LTW
的优势在于动态性，可以根据运行时配置来织入切面代码，适合在复杂的应用中使用，例如
Spring 中的 AOP 支持。</p>
<h3 id="运行时代理">3. 运行时代理</h3>
<p>AspectJ 在 Spring AOP 中常见的动态代理模式下也可以实现 AOP。Spring
AOP 是基于代理的（proxy-based），而 AspectJ
是基于字节码级别的修改。在一些特殊情况下，AspectJ
也可以通过代理模式来实现动态织入，但通常会依赖于 Spring
框架中的代理机制。</p>
<h3 id="连接点切入点和通知的匹配机制">4.
连接点、切入点和通知的匹配机制</h3>
<p>AspectJ
的核心原理之一是通过切入点表达式来匹配连接点。具体流程如下：</p>
<ul>
<li><strong>连接点（Join
Point）</strong>：程序执行过程中可能插入切面代码的位置，包括方法调用、对象初始化等。</li>
<li><strong>切入点（Pointcut）</strong>：用于定义哪些连接点需要应用通知逻辑。切入点可以使用表达式来匹配方法或类。</li>
<li><strong>通知（Advice）</strong>：具体要在连接点执行的操作代码。在程序运行时，如果某个连接点匹配了切入点的定义，就会触发通知逻辑。</li>
</ul>
<h3 id="生成字节码并维护-aspectj-的执行流程">5. 生成字节码并维护 AspectJ
的执行流程</h3>
<p>AspectJ
生成的字节码在类的字节码中引入了切面逻辑。通过这个方式，编译后的类字节码会包含
AspectJ
定义的所有切面，并且在运行时确保切面能够在指定的连接点处执行。这种字节码生成和插入逻辑的实现是
AspectJ 的核心部分。</p>
<h3 id="总结-11">总结</h3>
<p>AspectJ
的实现原理主要依靠字节码插桩技术，无论是编译时、类加载时还是运行时，都围绕织入机制展开。它通过定义切入点和通知，将切面逻辑以各种方式织入到目标代码中，增强了代码的模块化和可维护性。</p>
<h2 id="okhttp的实现原理">OKHttp的实现原理</h2>
<p><strong>OKHttp</strong> 是一个高效的、支持 HTTP/2
的网络请求库，它被广泛用于 Android 和 Java 应用中。OKHttp 通过简洁的
API、灵活的连接池管理、对 HTTP
协议的完整支持，提供了强大的网络请求功能。下面我们深入了解 OKHttp
的实现原理及其关键机制。</p>
<h3 id="okhttp-核心组件和工作流程">OKHttp 核心组件和工作流程</h3>
<p>OKHttp 的网络请求机制由以下几个核心组件组成：</p>
<ul>
<li><strong>OkHttpClient</strong>：负责配置和管理网络请求的客户端。</li>
<li><strong>Request</strong>：封装 HTTP 请求的所有信息。</li>
<li><strong>Response</strong>：封装 HTTP 响应的所有信息。</li>
<li><strong>Call</strong>：表示一个具体的 HTTP 请求，<code>Call</code>
可以被执行或取消。</li>
<li><strong>Interceptor</strong>：拦截器，负责在请求和响应之间做中间处理。</li>
<li><strong>Dispatcher</strong>：负责管理异步请求的调度和执行。</li>
</ul>
<p>OKHttp 的请求流程通常包括以下几个步骤：</p>
<ol type="1">
<li>构建 <code>OkHttpClient</code> 客户端。</li>
<li>构建 <code>Request</code> 对象，指定请求的
URL、请求头和请求参数等。</li>
<li>通过 <code>OkHttpClient</code> 的 <code>newCall()</code> 方法创建
<code>Call</code> 对象。</li>
<li>执行 <code>Call</code>，通过同步或异步方式获取响应
<code>Response</code>。</li>
</ol>
<h3 id="okhttp-的工作流程">OKHttp 的工作流程</h3>
<ol type="1">
<li><p><strong>创建 OkHttpClient</strong> <code>OkHttpClient</code> 是
OKHttp 请求的核心类，负责管理连接池、缓存、拦截器等配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">        .writeTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>connectTimeout</code>：设置连接超时时间。</li>
<li><code>readTimeout</code>：设置读取超时时间。</li>
<li><code>writeTimeout</code>：设置写入超时时间。</li>
</ul></li>
<li><p><strong>创建 Request</strong> <code>Request</code> 对象封装了
HTTP 请求的信息，比如 URL、HTTP 方法、请求头和请求体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(<span class="string">&quot;https://example.com/api&quot;</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>创建 Call</strong> <code>Call</code> 对象是一次 HTTP
请求的封装，负责执行网络请求并获取响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> client.newCall(request);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>执行 Call</strong> 执行请求有两种方式：</p>
<ul>
<li><strong>同步请求</strong>：<code>execute()</code>，调用此方法会阻塞当前线程，直到请求完成。</li>
<li><strong>异步请求</strong>：<code>enqueue()</code>，调用此方法后，OKHttp
会在内部线程池中执行请求，并通过回调函数处理响应。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步请求</span></span><br><span class="line"><span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> call.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步请求</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 请求失败处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 请求成功处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="okhttp的实现细节">OKHttp的实现细节</h3>
<h4 id="拦截器interceptor机制">1.
<strong>拦截器（Interceptor）机制</strong></h4>
<p>拦截器是 OKHttp
中非常重要的一个概念，它允许在请求和响应的不同阶段进行拦截和处理。OKHttp
内部使用了 <strong>责任链模式</strong>
来处理网络请求，拦截器就是该模式中的核心环节。</p>
<p>拦截器主要分为两类：</p>
<ul>
<li><strong>应用拦截器（Application
Interceptor）</strong>：用于处理应用层的逻辑，如添加统一的请求头、修改请求或响应等。</li>
<li><strong>网络拦截器（Network
Interceptor）</strong>：用于处理底层网络请求，例如修改网络层数据、重新发起请求等。</li>
</ul>
<p>OKHttp 中内置了多个拦截器，如：</p>
<ul>
<li><strong>重试拦截器（RetryAndFollowUpInterceptor）</strong>：用于处理失败重试、重定向等操作。</li>
<li><strong>桥接拦截器（BridgeInterceptor）</strong>：负责处理应用层与网络层的桥接，例如设置请求头、响应头、Cookie
等。</li>
<li><strong>缓存拦截器（CacheInterceptor）</strong>：负责缓存逻辑的处理，判断请求是否可以使用缓存。</li>
<li><strong>连接拦截器（ConnectInterceptor）</strong>：负责管理连接池，处理连接的创建与复用。</li>
<li><strong>网络拦截器（NetworkInterceptor）</strong>：用于处理实际的网络
I/O 操作。</li>
</ul>
<p>拦截器通过链式调用的方式逐层传递请求和响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">    <span class="comment">// 修改请求</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> chain.proceed(request);</span><br><span class="line">    <span class="comment">// 修改响应</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个拦截器可以在 <code>chain.proceed(request)</code>
之前或之后对请求和响应进行处理。</p>
<h4 id="连接池connection-pool">2. <strong>连接池（Connection
Pool）</strong></h4>
<p>OKHttp 通过<strong>连接池</strong>来管理 HTTP
连接的复用，这大大提升了网络请求的性能，减少了不必要的 TCP
连接创建。OKHttp
默认会保持一组连接，当请求完成后，连接不会立即关闭，而是保留在连接池中，供后续请求复用。</p>
<ul>
<li><strong>连接复用</strong>：如果多个请求目标相同的主机（域名和端口相同），OKHttp
会复用已有的 TCP 连接，避免每次请求都建立新的连接。</li>
<li><strong>HTTP/2 支持</strong>：OKHttp 支持 HTTP/2 协议，允许在一个
TCP 连接上并行处理多个请求，从而进一步提升网络性能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .connectionPool(<span class="keyword">new</span> <span class="title class_">ConnectionPool</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>连接池的两个关键参数：</p>
<ul>
<li><strong>最大连接数</strong>：允许复用的最大连接数。</li>
<li><strong>连接空闲时间</strong>：当连接超过空闲时间后将被关闭。</li>
</ul>
<h4 id="缓存机制">3. <strong>缓存机制</strong></h4>
<p>OKHttp 提供了完整的 HTTP 缓存机制，遵循 HTTP 的缓存规则（如
<code>Cache-Control</code>、<code>ETag</code> 等），并允许本地缓存 GET
请求的响应。缓存拦截器通过判断缓存的有效性来决定是使用缓存还是发起新的网络请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>(cacheDirectory, cacheSize);</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .cache(cache)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>缓存目录</strong>：指定缓存文件存储的位置。</li>
<li><strong>缓存大小</strong>：限制缓存的大小。</li>
</ul>
<p>OKHttp
的缓存拦截器会根据缓存策略决定是否从缓存中读取数据或更新缓存。</p>
<h4 id="异步处理和线程池">4. <strong>异步处理和线程池</strong></h4>
<p>OKHttp 通过内部的 <strong>Dispatcher</strong>
类管理异步请求的执行。<code>Dispatcher</code>
是一个任务调度器，它使用线程池来执行异步请求，默认最多并行执行 64
个请求，并且对同一主机的请求最多并发 5 个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .dispatcher(<span class="keyword">new</span> <span class="title class_">Dispatcher</span>(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;())</span><br><span class="line">        ))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Dispatcher</strong>：控制请求的调度，管理队列中正在运行的异步请求以及等待的请求。</li>
<li><strong>线程池</strong>：用于执行异步任务，保证高效处理多个网络请求。</li>
</ul>
<h4 id="http2-和-websocket-支持">5. <strong>HTTP/2 和 WebSocket
支持</strong></h4>
<p>OKHttp 对 HTTP/2 的支持是其性能优化的一大亮点。通过
HTTP/2，多个请求可以在一个 TCP
连接上复用，减少了建立多个连接的开销。此外，OKHttp 还支持 WebSocket
协议，用于实现长连接的实时通讯。</p>
<ul>
<li><strong>HTTP/2
的好处</strong>：通过共享连接来处理多个请求，减少网络延迟和资源消耗。</li>
<li><strong>WebSocket 支持</strong>：OKHttp 提供了简单的 WebSocket
API，允许客户端与服务器之间保持长连接，并通过 WebSocket 传递数据。</li>
</ul>
<h3 id="okhttp的整体工作原理图">OKHttp的整体工作原理图</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+         +---------------------+</span><br><span class="line">|   OkHttpClient       |         |   Dispatcher         |</span><br><span class="line">+---------------------+         +---------------------+</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">|     Call             | &lt;---------------+</span><br><span class="line">+---------------------+                  |</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">|    Interceptor Chain |                  |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">|    RealConnection    | &lt;---------------+</span><br><span class="line">+---------------------+                  |</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">|   Connection Pool    |                  |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">+---------------------+         +---------------------+</span><br><span class="line">|   Network I/O        |         |   Response Cache    |</span><br><span class="line">+---------------------+         +---------------------+</span><br></pre></td></tr></table></figure>
<h3 id="总结-12">总结</h3>
<p>OKHttp 是通过
<strong>拦截器</strong>、<strong>连接池</strong>、<strong>异步调度器</strong>
等核心组件来高效管理 HTTP 请求的。其设计灵活，性能优化非常出色，特别是对
HTTP/2 的支持、连接复用和缓存机制，使得它成为 Android 和 Java
开发中非常流行的网络库。</p>
<ul>
<li><strong>拦截器链</strong>：使得请求和响应可以灵活地被拦截和修改。</li>
<li><strong>连接池</strong>：通过连接复用提升了网络请求的性能。</li>
<li><strong>缓存机制</strong>：提供了高效的 HTTP
缓存支持，避免不必要的网络请求。</li>
<li><strong>异步处理</strong>：通过 <code>Dispatcher</code>
和线程池管理异步请求的并发和调度。</li>
</ul>
<h2 id="glide-请求的生命周期">Glide 请求的生命周期</h2>
<p>Glide
的请求生命周期涉及多个阶段，从请求的创建到资源的加载和回收。理解这一生命周期有助于优化资源管理和提高应用性能。下面是一个典型的
Glide 请求生命周期：</p>
<ol type="1">
<li><strong>请求开始（Initialization）</strong>：
<ul>
<li>使用 <code>Glide.with(context)</code> 来创建一个
<code>RequestManager</code> 对象。<code>RequestManager</code>
负责管理请求的生命周期，并与 Android 的生命周期事件同步。</li>
</ul></li>
<li><strong>构建请求（Building the Request）</strong>：
<ul>
<li>通过链式调用，使用 <code>load()</code>
方法指定图像的来源（URL、文件、资源 ID 等）。</li>
<li>使用 <code>apply()</code> 方法可以应用
<code>RequestOptions</code>，配置图像的加载方式，例如占位符、错误图像、缩放类型等。</li>
</ul></li>
<li><strong>启动请求（Request Execution）</strong>：
<ul>
<li>调用 <code>into(target)</code> 方法来启动图像的加载过程，其中
<code>target</code> 通常是一个 <code>ImageView</code>。</li>
<li>Glide 会根据指定的 <code>RequestOptions</code> 和
<code>DiskCacheStrategy</code> 决定从缓存或网络加载资源。</li>
</ul></li>
<li><strong>资源加载（Resource Loading）</strong>：
<ul>
<li><strong>缓存检查</strong>：首先检查内存和磁盘缓存是否包含目标图像。</li>
<li><strong>网络请求或解码</strong>：如果缓存未命中，Glide
会请求网络资源或解码本地文件。</li>
<li><strong>Bitmap
Pooling</strong>：使用位图池复用机制以减少内存分配。</li>
</ul></li>
<li><strong>图像显示（Display）</strong>：
<ul>
<li>一旦资源准备好，图像将被显示在目标 <code>ImageView</code>
中。此过程也包括任何指定的 <code>Transformation</code>。</li>
</ul></li>
<li><strong>清理（Cleanup）</strong>：
<ul>
<li>当 <code>Activity</code> 或 <code>Fragment</code>
的生命周期变化（如销毁）时，Glide
会自动取消未完成的请求，释放内存资源。</li>
<li>可以手动调用例如 <code>Glide.with(context).clear(target)</code>
来取消加载或移除图像。</li>
</ul></li>
<li><strong>自动恢复（Automatic Lifecycle Integration）</strong>：
<ul>
<li><code>RequestManager</code> 和 <code>RequestBuilder</code>
会自动响应 Android 生命周期事件（如
<code>onPause</code>、<code>onResume</code>），以便在 UI
不可见时暂停图像加载，并在恢复时继续。</li>
</ul></li>
</ol>
<p>这种生命周期管理机制确保了高效的资源使用，防止内存泄漏，同时又能方便地集成到
Android 的组件生命周期中。</p>
<h2 id="handler-原理">Handler 原理</h2>
<p>Android 的 <code>Handler</code> 是 Android
系统中处理线程之间通信的一种机制。它允许你在一个线程中向其他线程发送和处理消息，最常见的场景是更新
UI。因为 Android 规定只能在主线程（UI 线程）中更新
UI，<code>Handler</code> 就成为了从工作线程与 UI
线程交互的重要工具。</p>
<h3 id="handler-原理概述">Handler 原理概述</h3>
<p><code>Handler</code>
是基于消息队列（MessageQueue）和消息循环（Looper）实现的。核心组件包括
<code>Handler</code>、<code>Message</code>、<code>Looper</code> 和
<code>MessageQueue</code>。以下是每个组件的角色：</p>
<ul>
<li><strong>Handler</strong>:
用于发送消息和处理消息。它向消息队列中发送消息，并在收到消息时执行相应的操作。</li>
<li><strong>Message</strong>: <code>Message</code> 是
<code>Handler</code>
处理的消息对象，包含了消息的内容，比如数据、标识符、目标 Handler
等。</li>
<li><strong>Looper</strong>:
负责管理线程中的消息循环。每个线程都可以通过 <code>Looper</code>
来关联一个消息队列。主线程默认有一个
<code>Looper</code>，工作线程需要手动创建。</li>
<li><strong>MessageQueue</strong>:
是一个消息队列，负责存储线程中的所有消息。<code>Looper</code> 会从
<code>MessageQueue</code> 中取出消息，然后分发给相应的
<code>Handler</code>。</li>
</ul>
<h3 id="工作原理-3">工作原理</h3>
<ol type="1">
<li><p><strong>Looper 准备</strong>: 每个线程可以通过
<code>Looper.prepare()</code> 方法来初始化一个 <code>Looper</code>
实例，并将其与当前线程关联。主线程的 <code>Looper</code>
是系统自动创建的，但子线程需要手动创建。</p></li>
<li><p><strong>消息发送</strong>: <code>Handler</code> 可以使用
<code>sendMessage()</code> 或 <code>post()</code> 方法将
<code>Message</code> 或 <code>Runnable</code> 发送到消息队列。每个
<code>Handler</code> 都与某个 <code>Looper</code>
关联，它们可以发送消息到这个 <code>Looper</code> 的
<code>MessageQueue</code> 中。</p></li>
<li><p><strong>消息存储</strong>: 发送的消息被存储在
<code>MessageQueue</code>
中。这个队列按时间顺序排列消息，先发送的消息先处理。</p></li>
<li><p><strong>消息处理</strong>: <code>Looper</code> 会不断地从
<code>MessageQueue</code> 中取出消息，并分发给相应的
<code>Handler</code>。每个 <code>Handler</code> 都有一个
<code>handleMessage()</code>
方法，当消息到达时，会调用这个方法来处理消息。</p></li>
<li><p><strong>Looper 轮询</strong>: 一旦 <code>Looper.loop()</code>
被调用，线程进入消息循环，<code>Looper</code> 就会不断地从
<code>MessageQueue</code> 中取消息，并将它们分发给关联的
<code>Handler</code>。</p></li>
</ol>
<h3 id="handler-工作流程图">Handler 工作流程图</h3>
<ol type="1">
<li>工作线程向主线程的 <code>Handler</code> 发送
<code>Message</code>。</li>
<li><code>MessageQueue</code> 接收到消息并入队。</li>
<li><code>Looper</code> 不断从 <code>MessageQueue</code> 取出消息。</li>
<li>取出消息后，<code>Looper</code> 分发给目标
<code>Handler</code>，调用 <code>Handler</code> 的
<code>handleMessage()</code> 进行处理。</li>
<li><code>Handler</code> 处理完消息后，循环继续，直到消息队列为空。</li>
</ol>
<h3 id="示例代码-1">示例代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程中创建 Handler</span></span><br><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 在主线程处理消息</span></span><br><span class="line">        textView.setText(<span class="string">&quot;Message received: &quot;</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程中发送消息</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.what = <span class="number">1</span>;</span><br><span class="line">        handler.sendMessage(msg); <span class="comment">// 发送消息到主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="注意事项-1">注意事项</h3>
<ul>
<li><strong>线程间通信</strong>: <code>Handler</code>
主要用于线程间的通信，工作线程可以通过 <code>Handler</code> 将消息发送到
UI 线程更新界面。</li>
<li><strong>避免内存泄漏</strong>: 当使用 <code>Handler</code>
时，特别是在活动或其他组件销毁时，如果没有妥善管理，可能会导致内存泄漏。建议使用
<code>WeakReference</code> 或者在 <code>onDestroy</code>
中移除所有的消息。</li>
<li><strong>主线程和子线程</strong>: <code>Handler</code>
的典型用法是在子线程进行耗时操作，然后通过 <code>Handler</code>
将结果发送到主线程更新 UI。</li>
</ul>
<p>总结来说，<code>Handler</code> 结合 <code>Looper</code> 和
<code>MessageQueue</code> 实现了 Android
中线程间的通信，主要用于处理子线程与主线程的消息交互。</p>
<h2 id="idlehandler">IdleHandler</h2>
<p>在 Android 中，<code>IdleHandler</code> 是用于处理
<code>MessageQueue</code>
在空闲时的任务的机制。它允许开发者在事件队列没有更多待处理消息时执行一些后台任务。这是通过
<code>Looper</code> 和 <code>MessageQueue</code> 框架实现的。以下是有关
<code>IdleHandler</code> 的详细信息：</p>
<h3 id="工作原理-4">工作原理</h3>
<ol type="1">
<li><strong>MessageQueue 和 Looper</strong>:
<ul>
<li>Android 的 <code>MessageQueue</code> 用于处理消息和可运行对象，它由
<code>Looper</code> 管理。</li>
<li>当 <code>MessageQueue</code> 中没有更多的消息时，可以触发
<code>IdleHandler</code>。</li>
</ul></li>
<li><strong>IdleHandler 接口</strong>:
<ul>
<li><code>IdleHandler</code> 是一个接口，其中包含一个
<code>queueIdle</code> 方法。</li>
<li>当 <code>Looper</code> 观察到消息队列空闲时，会调用此
<code>queueIdle</code> 方法。</li>
</ul></li>
<li><strong>注册 IdleHandler</strong>:
<ul>
<li>可以通过 <code>MessageQueue</code> 的 <code>addIdleHandler</code>
方法注册一个 <code>IdleHandler</code>。</li>
<li>多个 <code>IdleHandler</code> 可以同时添加到一个
<code>MessageQueue</code> 中。</li>
</ul></li>
</ol>
<h3 id="代码示例">代码示例</h3>
<p>以下是如何使用 <code>IdleHandler</code> 的一个基本示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> <span class="title class_">MessageQueue</span>.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行后台任务</span></span><br><span class="line">        Log.d(<span class="string">&quot;IdleHandler&quot;</span>, <span class="string">&quot;Queue is idle!&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 false 以在执行一次后移除此 IdleHandler</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-1">使用场景</h3>
<ul>
<li><strong>后台任务</strong>:
在不影响应用主线程的情况下，执行一些低优先级的背景任务，如日志记录或状态更新。</li>
<li><strong>资源清理</strong>:
空闲时释放不必要占用的资源，比如清理缓存。</li>
<li><strong>性能优化</strong>:
延迟不重要的工作以优化应用的性能，使得界面更流畅。</li>
</ul>
<h3 id="设计考量">设计考量</h3>
<ul>
<li><strong>任务性质</strong>: 由于 <code>IdleHandler</code>
执行在主线程，应确保任务对用户界面的影响最小。</li>
<li><strong>执行频率</strong>: 长时间任务应避免使用
<code>IdleHandler</code>，因为这可能影响到其他更高优先级的操作。</li>
<li><strong>返回值</strong>: <code>queueIdle</code> 方法返回
<code>true</code> 保留 <code>IdleHandler</code>，返回 <code>false</code>
表示处理完后从队列中移除，以避免反复执行。</li>
</ul>
<h3 id="注意事项-2">注意事项</h3>
<ul>
<li><strong>不能保证执行</strong>: 如果应用的 <code>MessageQueue</code>
经常忙于处理消息，<code>IdleHandler</code> 可能很少或不会被调用。</li>
<li><strong>避免阻塞</strong>: 确保 <code>queueIdle</code>
中的代码不会阻塞主线程，以免影响应用的响应速度。</li>
</ul>
<p><code>IdleHandler</code> 是一个有效的工具，
用于在不影响应用主线操作的情况下进行后台管理和优化。适当使用可以提升
Android 应用的性能和用户体验。</p>
<h2 id="handler-消息屏障">Handler 消息屏障</h2>
<p>Handler消息屏障（Message
Barrier）是Android消息处理机制中的一个概念，用于控制消息队列的处理顺序。它主要用于解决异步消息处理过程中优先级的问题。在常见的使用场景中，消息屏障允许某些重要的同步消息可以优先于异步消息来执行，提高应用的响应效率。</p>
<h3 id="handler-和-messagequeue">Handler 和 MessageQueue</h3>
<p>在 Android 中，<code>Handler</code> 和 <code>MessageQueue</code>
配合使用来管理消息的发送和处理。消息队列是一个有序的数据结构，通常会根据消息的到达时间顺序来看待处理。</p>
<h3 id="消息屏障的工作原理">消息屏障的工作原理</h3>
<ol type="1">
<li><strong>消息类型</strong>：
<ul>
<li><strong>同步消息</strong>：需要按照正常顺序处理的消息。</li>
<li><strong>异步消息</strong>：相对较不重要，允许可以稍后再处理。</li>
</ul></li>
<li><strong>屏障机制</strong>：
<ul>
<li>消息屏障会被插入消息队列中，从它插入的位置开始，所有同步消息会被暂时停止处理，但异步消息可以继续被处理。</li>
<li>当消息屏障插入队列后，随后的同步消息将被延迟处理，直到消息屏障被移除。</li>
</ul></li>
<li><strong>用法场景</strong>：
<ul>
<li>消息屏障通常被系统内部使用，通过设置它，可以让像动画或布局测量这样的耗时处理异步消息先行执行，优化UI的流畅性。</li>
<li>不是所有用户应用开发中直接去使用消息屏障，但理解其机制在性能调优中非常有帮助。</li>
</ul></li>
</ol>
<h3 id="实现方式">实现方式</h3>
<p>在 Android 源码中，<code>MessageQueue</code> 提供了
<code>postSyncBarrier</code>
方法用于插入一个消息屏障，其内部会生成一个特殊的 token 来标识屏障。</p>
<h3 id="示例-2">示例</h3>
<p>假设我们希望将某些动画消息优先于普通消息执行，可以通过插入消息屏障后再插入动画消息，动画消息以异步方式（Android
4.4开始支持）发送，这些消息会立即执行，后面的同步消息则会在屏障被移除后处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> messageQueue.postSyncBarrier();</span><br><span class="line"><span class="comment">// 发送异步消息</span></span><br><span class="line">messageQueue.sendMessage(…); <span class="comment">// 异步message setAsynchronous(true)</span></span><br><span class="line"><span class="comment">// 移除屏障</span></span><br><span class="line">messageQueue.removeSyncBarrier(token);</span><br></pre></td></tr></table></figure>
<h3 id="总结-13">总结</h3>
<p>使用消息屏障是一种高级性能优化策略，主要是帮助系统内部对不同优先级的消息进行合理调度。开发者在理解这类机制知识的同时，可以更好地设计那些需要高效响应的应用模块。</p>
<h2 id="android-图形框架">Android 图形框架</h2>
<p>参考：https://mp.weixin.qq.com/s/I0Hy03SkyYvNr-1v2oCTbA</p>
<p>Android
的图形渲染框架从底层硬件到顶层应用程序，是一套复杂而高效的架构。它涉及硬件抽象层（HAL）、图形驱动、图形引擎以及高级应用层
API。为了理解 Android
的图形渲染流程，可以将其划分为几个重要的层次，从最底层的硬件到最高层的应用绘制。以下是
Android 从底层到顶层的图形渲染框架的详细解析：</p>
<h3 id="硬件抽象层-hardware-abstraction-layer-hal">1. <strong>硬件抽象层
(Hardware Abstraction Layer, HAL)</strong></h3>
<p>Android 的底层图形框架直接与硬件交互，依赖于硬件抽象层 (HAL)
来统一访问不同的硬件组件。这一层是 Android
系统中的基础层，屏蔽了不同硬件平台的差异，使上层框架可以通过统一的接口来操作底层硬件。</p>
<ul>
<li><p><strong>SurfaceFlinger</strong>：SurfaceFlinger 是 Android
系统的核心组件之一，它负责将多个应用程序窗口的渲染结果合成到屏幕上。它与硬件抽象层交互，控制帧缓冲区
(Framebuffer)，并管理图形缓冲区的交换和显示。</p></li>
<li><p><strong>Gralloc (Graphics Allocation)</strong>：Gralloc
是图形内存分配器，它为图形帧缓冲区分配内存，用于存储各个应用程序渲染的图像。不同硬件平台的实现可能不同，Gralloc
负责跨平台的内存管理。</p></li>
<li><p><strong>硬件加速 (GPU)</strong>：Android 使用
GPU（图形处理单元）来加速图形渲染。GPU 通过 OpenGL ES 或 Vulkan
接口进行硬件加速渲染，从而大幅提升图形处理的效率。</p></li>
</ul>
<h3 id="图形驱动和接口">2. <strong>图形驱动和接口</strong></h3>
<p>在 HAL 之上，Android 通过 OpenGL ES、Vulkan 和 Skia 等图形 API
与底层的 GPU 交互。这些 API 使得应用程序可以高效地进行 2D 和 3D
图形的渲染。</p>
<ul>
<li><p><strong>OpenGL ES</strong>：OpenGL ES 是 OpenGL
的嵌入式版本，用于移动设备和嵌入式系统。它是 Android 系统中使用最广泛的
3D 图形 API，支持高效的 2D 和 3D 图形绘制。</p></li>
<li><p><strong>Vulkan</strong>：Vulkan 是一种现代的低开销、高性能的图形
API，特别适合于需要大量并发处理的高性能图形应用。它比 OpenGL ES
提供了更精细的控制和更高的性能，但复杂度也更高。</p></li>
<li><p><strong>Skia</strong>：Skia 是 Android 的 2D
图形库，它用于渲染所有的 2D 图形，包括文本、形状、位图等。Android
中的所有 View 组件最终都是通过 Skia 渲染的。</p></li>
<li><p><strong>EGL (Embedded-System Graphics Library)</strong>：EGL
是一个连接 OpenGL ES 和图形底层（如
Framebuffer、窗口系统）的接口，负责上下文管理、表面创建以及图形的缓冲交换。通过
EGL，应用程序可以创建和管理 OpenGL ES
的渲染上下文，并交换渲染结果。</p></li>
</ul>
<h3 id="surface-和-surfaceflinger">3. <strong>Surface 和
SurfaceFlinger</strong></h3>
<ul>
<li><p><strong>Surface</strong>：每个 Android 应用程序的窗口都与一个
<code>Surface</code> 对象相关联，<code>Surface</code>
是用于与系统共享图形缓冲区的抽象，它代表了一个可以绘制的画布。应用程序通过绘制到
<code>Surface</code> 来渲染内容，最终这些内容会被发送到
<code>SurfaceFlinger</code> 进行合成。</p></li>
<li><p><strong>SurfaceFlinger</strong>：作为 Android
的窗口合成器，<code>SurfaceFlinger</code> 负责将多个应用程序窗口的
<code>Surface</code> 进行合成，并最终显示在屏幕上。它接收来自不同应用的
<code>Surface</code>，并通过与硬件抽象层（HAL）和 Gralloc
的交互，将这些内容组合成一帧最终的图像，展示在屏幕上。</p></li>
</ul>
<h3 id="硬件加速和-vsync">4. <strong>硬件加速和 VSync</strong></h3>
<ul>
<li><p><strong>硬件加速</strong>：Android 系统在图形绘制过程中广泛使用了
GPU 硬件加速。所有 <code>View</code>
组件默认开启硬件加速，特别是在绘制复杂图形或动画时，硬件加速能极大提升性能。硬件加速通过
OpenGL ES 或 Vulkan 将图形渲染工作交给 GPU 执行，从而释放 CPU
资源。</p></li>
<li><p><strong>VSync (Vertical Sync)</strong>：VSync
是图形系统中的垂直同步机制，它控制图形帧的刷新频率。VSync
信号会同步图形缓冲区的交换与屏幕刷新，防止帧撕裂等问题。在 VSync
的控制下，系统以每秒 60
帧（或设备支持的其他刷新率）进行屏幕更新。</p></li>
</ul>
<h3 id="renderthread-和-choreographer">5. <strong>RenderThread 和
Choreographer</strong></h3>
<ul>
<li><p><strong>RenderThread</strong>：Android 中的
<code>RenderThread</code>
是一个独立的线程，用于处理界面渲染的任务。它负责管理硬件加速的绘制操作，将渲染任务提交给
GPU 以确保 UI 更新的高效性和响应性。</p></li>
<li><p><strong>Choreographer</strong>：<code>Choreographer</code> 是
Android 用于同步图形帧的系统，它负责协调应用程序的绘制周期和 VSync
信号。<code>Choreographer</code> 确保绘制、布局和动画更新与 VSync
同步，从而避免视觉上的不一致性和卡顿现象。</p></li>
</ul>
<h3 id="顶层的-android-ui-绘制系统">6. <strong>顶层的 Android UI
绘制系统</strong></h3>
<p>Android 的顶层图形渲染框架直接面向应用开发者，提供了丰富的绘制 API
和布局系统。主要包括以下几个核心部分：</p>
<h4 id="view-系统和绘制流程">View 系统和绘制流程：</h4>
<ol type="1">
<li><strong>View 和 ViewGroup</strong>：
<ul>
<li><code>View</code> 是 Android 中的基本 UI
单元，负责处理用户输入和界面显示。<code>ViewGroup</code> 是
<code>View</code> 的容器类，用来组织和管理子视图。</li>
<li>每个 <code>View</code> 都有一个 <code>draw()</code>
方法，通过它来实现自定义绘制逻辑，最终通过底层的 Skia
库进行实际绘制。</li>
</ul></li>
<li><strong>绘制流程</strong>：
<ul>
<li>Android 中的 UI
绘制是一个复杂的流程，从布局的测量、位置计算到最终的绘制，都是通过遍历
<code>View</code> 树来完成的。</li>
<li><strong>measure()</strong>、<strong>layout()</strong> 和
<strong>draw()</strong>
是绘制流程的三大核心步骤，负责布局、定位和绘制视图。</li>
</ul></li>
<li><strong>Canvas</strong> 和 <strong>Paint</strong>：
<ul>
<li><code>Canvas</code> 是 Android 的 2D
绘图类，代表了一个可绘制的表面。开发者可以在 <code>Canvas</code>
上绘制图形、文本和位图。</li>
<li><code>Paint</code>
是用来定义绘制风格的类，指定了颜色、线条宽度、文本大小等属性。</li>
</ul></li>
</ol>
<h4 id="硬件加速和-gpu-渲染">硬件加速和 GPU 渲染：</h4>
<ul>
<li>在 <code>View</code> 系统中，当开启硬件加速时，所有绘制操作会通过
OpenGL 渲染，<code>RenderThread</code> 会将 UI 绘制任务交给 GPU
处理。</li>
<li><strong>DisplayList</strong>：为了提高性能，Android 会将
<code>View</code> 的绘制操作记录在一个 DisplayList
中，类似于一个绘图的指令集。当内容需要重绘时，Android
可以快速重放这些指令而不需要重新计算所有内容。</li>
</ul>
<h3 id="动画系统">7. <strong>动画系统</strong></h3>
<p>Android 的动画系统也是图形框架的重要组成部分，它提供了多种动画 API
用于实现复杂的 UI 交互效果。</p>
<ul>
<li><p><strong>Property Animations</strong>：<code>ObjectAnimator</code>
和 <code>ValueAnimator</code> 是 Android
的属性动画系统，允许开发者以流畅的方式改变 <code>View</code>
的属性（如位置、透明度、缩放等），实现复杂的动画效果。</p></li>
<li><p><strong>硬件加速的动画</strong>：通过硬件加速，动画的每一帧可以在
GPU 上进行渲染，极大提升了动画的流畅度和性能。</p></li>
</ul>
<h3 id="触摸事件和输入系统">8. <strong>触摸事件和输入系统</strong></h3>
<p>Android
的触摸事件系统也是图形框架的一部分，负责处理用户输入，并将这些输入反馈到视图。</p>
<ul>
<li><p><strong>触摸事件分发</strong>：当用户在屏幕上触摸时，系统会生成触摸事件，并通过
<code>View</code> 的 <code>onTouchEvent()</code>
方法传递到各个视图中。<code>ViewGroup</code>
负责将事件分发给其子视图，直到目标视图处理该事件。</p></li>
<li><p><strong>多点触控</strong>：Android
支持多点触控，系统会为每个触控点生成唯一的
ID，允许开发者处理复杂的多点交互场景。</p></li>
</ul>
<h3 id="总结-14">总结</h3>
<p>Android
的图形渲染框架从底层到顶层，是一个层次分明、结构复杂的体系。底层通过硬件抽象层
(HAL) 和 GPU 来高效管理图形资源和渲染操作，中间层提供了 OpenGL ES、V</p>
<p>ulkan、Skia 等 API 来进行图形渲染，顶层则通过 <code>View</code>
系统、动画、触摸事件等接口为应用开发者提供了高效的 UI
绘制和交互工具。整个体系通过 VSync
和硬件加速技术，保证了图形渲染的高效性和流畅性。</p>
<h2 id="surfaceview-glsurfaceview-和-texturesurfaceview">SurfaceView,
GLSurfaceView 和 TextureSurfaceView</h2>
<p>参考：https://mp.weixin.qq.com/s/tzIKbtxQoVuwP6RmLj06Aw</p>
<p>在 Android 中，<code>SurfaceView</code>、<code>GLSurfaceView</code>
和 <code>TextureView</code>
是用于显示图形内容的三种常用控件，它们在实现方式、使用场景和性能特点上有所不同。以下是对它们的详细区别和应用场景的解析：</p>
<h3 id="surfaceview">1. <strong>SurfaceView</strong></h3>
<p><code>SurfaceView</code> 是 Android
中用于在独立线程上绘制内容的控件，通常用于处理高效的图形更新，比如视频播放、游戏渲染等场景。</p>
<h4 id="特点">特点：</h4>
<ul>
<li><p><strong>独立的 Surface</strong>：<code>SurfaceView</code>
的绘制是在一个独立的 <code>Surface</code> 上进行的，该
<code>Surface</code> 与主 UI
线程分离，意味着它可以在单独的渲染线程中进行绘制操作，不会影响主线程的性能。这样可以减少绘制时的卡顿。</p></li>
<li><p><strong>异步绘制</strong>：<code>SurfaceView</code>
的内容可以通过后台线程进行异步绘制，适合需要频繁更新内容的场景，比如视频流或实时渲染。</p></li>
<li><p><strong>透明问题</strong>：<code>SurfaceView</code>
的底层绘制是通过独立的 <code>Surface</code> 实现的，所以它不支持 View
层的叠加或透明效果。<code>SurfaceView</code>
显示的内容始终是在窗口最前面的部分，因此它的 <code>View</code>
层次较难与其他 UI 元素进行叠加。</p></li>
</ul>
<h4 id="使用场景-2">使用场景：</h4>
<ul>
<li>视频播放：例如使用 <code>MediaPlayer</code> 或
<code>ExoPlayer</code> 渲染视频内容。</li>
<li>游戏开发：使用单独的线程处理复杂的实时图形渲染。</li>
</ul>
<h4 id="示例-3">示例：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SurfaceView</span> <span class="variable">surfaceView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SurfaceView</span>(context);</span><br><span class="line"><span class="type">SurfaceHolder</span> <span class="variable">holder</span> <span class="operator">=</span> surfaceView.getHolder();</span><br><span class="line">holder.addCallback(<span class="keyword">new</span> <span class="title class_">SurfaceHolder</span>.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">        <span class="comment">// 在此处启动后台线程进行绘制操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="type">int</span> format, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 Surface 大小发生变化时调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">        <span class="comment">// 停止后台线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="glsurfaceview">2. <strong>GLSurfaceView</strong></h3>
<p><code>GLSurfaceView</code> 是一个专门用于 OpenGL 渲染的
<code>SurfaceView</code>，封装了 OpenGL ES 的绘制流程，简化了开发者的
OpenGL 渲染工作。它专为 2D 和 3D
图形渲染设计，特别适用于游戏和需要高性能图形渲染的应用场景。</p>
<h4 id="特点-1">特点：</h4>
<ul>
<li><p><strong>OpenGL ES 渲染支持</strong>：<code>GLSurfaceView</code>
封装了 OpenGL 的初始化、上下文管理、绘制回调等细节。开发者只需实现
<code>GLSurfaceView.Renderer</code> 接口来定义 OpenGL
渲染逻辑，而不需要手动管理 OpenGL 上下文和线程。</p></li>
<li><p><strong>独立线程渲染</strong>：<code>GLSurfaceView</code>
也通过后台线程来进行 OpenGL 绘制，与主线程分离，避免 UI 卡顿。</p></li>
<li><p><strong>双缓冲机制</strong>：它默认支持双缓冲机制，可以避免图像撕裂问题，确保渲染帧的流畅显示。</p></li>
<li><p><strong>EGL 管理</strong>：<code>GLSurfaceView</code> 自动管理
OpenGL 的 EGL 环境，处理 OpenGL
上下文、配置选择和窗口关联等操作，简化了开发者的工作。</p></li>
</ul>
<h4 id="使用场景-3">使用场景：</h4>
<ul>
<li>3D 图形渲染：如使用 OpenGL ES 绘制的 3D 游戏或数据可视化应用。</li>
<li>高性能 2D 图形渲染：如复杂的 2D 动画或自定义图形渲染。</li>
</ul>
<h4 id="示例-4">示例：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GLSurfaceView</span> <span class="variable">glSurfaceView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GLSurfaceView</span>(context);</span><br><span class="line"><span class="comment">// 设置OpenGL ES 版本，通常为2或3</span></span><br><span class="line">glSurfaceView.setEGLContextClientVersion(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Renderer</span></span><br><span class="line">glSurfaceView.setRenderer(<span class="keyword">new</span> <span class="title class_">GLSurfaceView</span>.Renderer() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化OpenGL资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawFrame</span><span class="params">(GL10 gl)</span> &#123;</span><br><span class="line">        <span class="comment">// 绘制每一帧的内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// 当Surface大小发生变化时调整视口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启渲染模式，默认是RENDERMODE_CONTINUOUSLY (连续渲染)</span></span><br><span class="line">glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);</span><br></pre></td></tr></table></figure>
<h3 id="textureview">3. <strong>TextureView</strong></h3>
<p><code>TextureView</code>
是一种更灵活的控件，允许应用程序直接控制渲染内容，并且可以像普通的
<code>View</code> 一样与其他 <code>View</code>
进行组合和叠加。它支持硬件加速，并且能够在应用层轻松管理。</p>
<h4 id="特点-2">特点：</h4>
<ul>
<li><p><strong>可叠加</strong>：<code>TextureView</code>
最大的优势是可以作为普通的 <code>View</code>
在视图层次中使用，这意味着它可以与其他 <code>View</code>
进行叠加、透明处理等复杂布局操作，克服了 <code>SurfaceView</code>
不支持叠加的问题。</p></li>
<li><p><strong>硬件加速</strong>：<code>TextureView</code>
支持硬件加速渲染，能够高效地处理复杂的图形内容。同时，它也支持在主线程上渲染，不像
<code>SurfaceView</code> 那样强制需要后台线程。</p></li>
<li><p><strong>灵活性</strong>：<code>TextureView</code> 通过
<code>SurfaceTexture</code>
提供了灵活的绘制接口，允许开发者使用自定义的渲染逻辑，例如结合 OpenGL 或
<code>Canvas</code> 绘制。</p></li>
<li><p><strong>更高的开销</strong>：虽然 <code>TextureView</code>
提供了更高的灵活性，但由于它在 <code>View</code>
层级中与其他视图一起渲染，性能开销比 <code>SurfaceView</code>
稍高，特别是在大规模或高频率的图形更新时。</p></li>
</ul>
<h4 id="使用场景-4">使用场景：</h4>
<ul>
<li>视频播放：与 <code>SurfaceView</code> 类似的场景，但允许在 UI
层级中进行透明和叠加处理。</li>
<li>自定义视图：如自定义控件中需要灵活的图形渲染。</li>
<li>动画和视频效果：需要叠加效果的动画或视频处理。</li>
</ul>
<h4 id="示例-5">示例：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TextureView</span> <span class="variable">textureView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextureView</span>(context);</span><br><span class="line">textureView.setSurfaceTextureListener(<span class="keyword">new</span> <span class="title class_">TextureView</span>.SurfaceTextureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceTextureAvailable</span><span class="params">(SurfaceTexture surface, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// SurfaceTexture 可用时进行初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// SurfaceTexture 尺寸变化时调整</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> &#123;</span><br><span class="line">        <span class="comment">// 当SurfaceTexture被销毁时进行清理操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceTextureUpdated</span><span class="params">(SurfaceTexture surface)</span> &#123;</span><br><span class="line">        <span class="comment">// SurfaceTexture 更新时调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="区别总结-1">4. <strong>区别总结</strong></h3>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 27%" />
<col style="width: 32%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>SurfaceView</th>
<th>GLSurfaceView</th>
<th>TextureView</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>绘制机制</strong></td>
<td>使用独立的 Surface，后台线程渲染</td>
<td>基于 OpenGL ES 渲染，后台线程渲染</td>
<td>在主线程或后台线程渲染</td>
</tr>
<tr class="even">
<td><strong>渲染场景</strong></td>
<td>常用于视频播放、2D 游戏等</td>
<td>用于 2D/3D 图形渲染，专为 OpenGL 设计</td>
<td>适用于需要叠加、透明效果的场景</td>
</tr>
<tr class="odd">
<td><strong>是否支持叠加</strong></td>
<td>不支持与其他 View 叠加</td>
<td>不支持与其他 View 叠加</td>
<td>支持与其他 View 叠加</td>
</tr>
<tr class="even">
<td><strong>OpenGL 支持</strong></td>
<td>需要手动集成 OpenGL 支持</td>
<td>内置 OpenGL 支持，自动管理 EGL 环境</td>
<td>可以手动集成 OpenGL</td>
</tr>
<tr class="odd">
<td><strong>使用场景</strong></td>
<td>视频播放、后台线程绘制</td>
<td>3D 游戏、复杂动画</td>
<td>视频播放、动画、需要叠加的场景</td>
</tr>
<tr class="even">
<td><strong>性能</strong></td>
<td>高效，适合频繁更新的图形</td>
<td>高效，专为 OpenGL 优化</td>
<td>性能较 <code>SurfaceView</code> 略低</td>
</tr>
</tbody>
</table>
<h3 id="选择建议">5. <strong>选择建议</strong></h3>
<ul>
<li>如果需要进行简单的视频播放或者通过后台线程渲染图像，<strong><code>SurfaceView</code></strong>
是一个不错的选择。</li>
<li>如果你的应用涉及到 2D 或 3D 的高性能图形渲染，且依赖于 OpenGL
ES，<strong><code>GLSurfaceView</code></strong> 是最佳选择，因为它简化了
OpenGL 的管理和使用。</li>
<li>如果你需要在 <code>View</code> 层级中进行复杂的 UI
叠加（如视频播放的同时显示 UI
元素）或处理透明视图，<strong><code>TextureView</code></strong>
提供了更灵活</li>
</ul>
<p>的选择，但需要注意它可能带来更多的性能开销。</p>
<p>总结来说，<code>SurfaceView</code>、<code>GLSurfaceView</code> 和
<code>TextureView</code>
各有其适用的场景和特点，选择合适的控件取决于你项目的需求、性能要求以及图形渲染的复杂程度。</p>
<h2 id="mvc-mvp-和-mvvm">MVC, MVP 和 MVVM</h2>
<p>在软件开发中，<strong>MVC</strong>（Model-View-Controller）、<strong>MVP</strong>（Model-View-Presenter）和
<strong>MVVM</strong>（Model-View-ViewModel）是三种常见的架构模式，它们用于分离代码中的业务逻辑、数据层和用户界面层。这些架构模式的核心目的是提高代码的可维护性、可测试性和扩展性。下面是对
MVC、MVP 和 MVVM 这三种架构模式的详细介绍及其区别。</p>
<hr />
<h3 id="mvcmodel-view-controller架构模式">1.
<strong>MVC（Model-View-Controller）架构模式</strong></h3>
<h4 id="概述-6">概述</h4>
<p>MVC 是最早被提出的架构模式之一，用于分离应用程序的逻辑和用户界面。MVC
的核心思想是将应用程序分成三层：<strong>Model</strong>、<strong>View</strong>
和
<strong>Controller</strong>。在这种架构模式中，每一层都有明确的职责。</p>
<h4 id="组件角色">组件角色</h4>
<ul>
<li><strong>Model（模型）</strong>：负责数据的获取和管理。它包括业务逻辑和数据操作，例如从数据库或网络获取数据，并处理这些数据。</li>
<li><strong>View（视图）</strong>：负责展示数据。<code>View</code>
直接与用户进行交互，显示 <code>Model</code>
中的数据，并接收用户的输入。</li>
<li><strong>Controller（控制器）</strong>：控制器是 <code>Model</code>
和 <code>View</code> 之间的桥梁。它负责处理用户的输入，并调用
<code>Model</code> 来获取或更新数据，然后将这些数据传递给
<code>View</code> 进行显示。</li>
</ul>
<h4 id="数据流和交互">数据流和交互</h4>
<ul>
<li>用户通过 <code>View</code> 与应用程序交互。</li>
<li>用户的输入被传递给 <code>Controller</code>，由
<code>Controller</code> 处理。</li>
<li><code>Controller</code> 与 <code>Model</code>
交互，获取或修改数据。</li>
<li><code>Model</code> 将处理后的数据返回给
<code>Controller</code>，然后 <code>Controller</code> 将数据传递给
<code>View</code> 来更新界面。</li>
</ul>
<h4 id="优点-7">优点</h4>
<ul>
<li>分离了数据层和表现层，降低了代码的耦合度。</li>
<li>适用于简单的应用场景，快速开发 UI 界面。</li>
</ul>
<h4 id="缺点-7">缺点</h4>
<ul>
<li><code>Controller</code>
在复杂应用中容易变得臃肿，因为它需要处理大量的逻辑。</li>
<li><code>View</code> 与 <code>Model</code>
的解耦较差，<code>View</code> 可能会直接依赖
<code>Model</code>，不利于单元测试。</li>
</ul>
<h4 id="图示">图示：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User &lt;--&gt; View &lt;--&gt; Controller &lt;--&gt; Model</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="mvpmodel-view-presenter架构模式">2.
<strong>MVP（Model-View-Presenter）架构模式</strong></h3>
<h4 id="概述-7">概述</h4>
<p>MVP 是对 MVC 的一种改进，主要解决了 MVC 中 <code>Controller</code>
容易臃肿的问题，并增强了 <code>View</code> 和 <code>Model</code>
的解耦。MVP 将控制逻辑移到 <strong>Presenter</strong> 中，使得
<code>View</code> 只负责渲染界面，而 <code>Presenter</code>
完全控制应用逻辑。</p>
<h4 id="组件角色-1">组件角色</h4>
<ul>
<li><strong>Model（模型）</strong>：与 MVC 中的 <code>Model</code>
类似，负责管理数据和业务逻辑。</li>
<li><strong>View（视图）</strong>：<code>View</code> 负责显示
<code>Presenter</code> 提供的数据，并将用户的输入传递给
<code>Presenter</code>。在 Android 中，<code>View</code> 通常是
Activity、Fragment 或 XML 布局。</li>
<li><strong>Presenter（展示者）</strong>：<code>Presenter</code> 是
<code>View</code> 和 <code>Model</code>
之间的桥梁。它接收用户输入，处理业务逻辑，调用 <code>Model</code>
获取数据，并将结果传递给 <code>View</code>
来更新界面。<code>Presenter</code> 不直接依赖 UI
框架，因此可以单独进行单元测试。</li>
</ul>
<h4 id="数据流和交互-1">数据流和交互</h4>
<ul>
<li>用户通过 <code>View</code> 与应用程序交互。</li>
<li><code>View</code> 将用户的输入传递给 <code>Presenter</code>，由
<code>Presenter</code> 处理业务逻辑。</li>
<li><code>Presenter</code> 通过 <code>Model</code> 获取或更新数据。</li>
<li><code>Presenter</code> 将处理后的数据返回给
<code>View</code>，<code>View</code> 根据数据更新界面。</li>
</ul>
<h4 id="优点-8">优点</h4>
<ul>
<li>更好的解耦：<code>View</code> 和 <code>Model</code>
之间完全解耦，<code>View</code> 只负责界面渲染，<code>Presenter</code>
负责业务逻辑。</li>
<li><code>Presenter</code> 不依赖具体的 UI
组件，可以单独测试业务逻辑。</li>
<li>更好的代码组织结构，适合中大型应用。</li>
</ul>
<h4 id="缺点-8">缺点</h4>
<ul>
<li>在复杂应用中，<code>Presenter</code>
也可能变得臃肿，特别是当它负责过多的界面逻辑时。</li>
<li>对于频繁交互的场景，<code>Presenter</code> 和 <code>View</code>
之间的通信可能会增多，导致代码较为繁琐。</li>
</ul>
<h4 id="图示-1">图示：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User &lt;--&gt; View &lt;--&gt; Presenter &lt;--&gt; Model</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="mvvmmodel-view-viewmodel架构模式">3.
<strong>MVVM（Model-View-ViewModel）架构模式</strong></h3>
<h4 id="概述-8">概述</h4>
<p>MVVM
是近年来流行的架构模式，特别是在数据绑定和响应式编程方面表现出色。MVVM
是对 MVP 的进一步演化，它引入了 <strong>ViewModel</strong> 来处理
<code>View</code> 的状态，并与 <code>View</code> 通过双向数据绑定（Data
Binding）进行交互，减少了手动更新 UI 的操作。</p>
<h4 id="组件角色-2">组件角色</h4>
<ul>
<li><strong>Model（模型）</strong>：与 MVC、MVP 中的 <code>Model</code>
一致，负责业务逻辑和数据处理。</li>
<li><strong>View（视图）</strong>：<code>View</code> 负责展示 UI，通常为
XML 布局文件或者 UI 组件。在 MVVM 中，<code>View</code> 通过数据绑定与
<code>ViewModel</code> 进行交互。</li>
<li><strong>ViewModel（视图模型）</strong>：<code>ViewModel</code> 是
<code>Model</code> 和 <code>View</code> 之间的桥梁，负责处理逻辑和维护
UI 状态。它不直接与 <code>View</code> 交互，而是通过
<code>Data Binding</code> 或者
<code>LiveData</code>、<code>Observable</code> 等方式向
<code>View</code> 提供数据。<code>ViewModel</code> 不依赖具体的
<code>View</code>，因此具有很好的可测试性。</li>
</ul>
<h4 id="数据流和交互-2">数据流和交互</h4>
<ul>
<li>用户与 <code>View</code> 交互，<code>View</code>
将用户的操作通过数据绑定机制传递给 <code>ViewModel</code>。</li>
<li><code>ViewModel</code> 处理业务逻辑，调用 <code>Model</code>
获取数据。</li>
<li><code>Model</code> 将数据返回给
<code>ViewModel</code>，<code>ViewModel</code> 通过数据绑定自动更新
<code>View</code>。</li>
</ul>
<h4 id="优点-9">优点</h4>
<ul>
<li><strong>双向数据绑定</strong>：<code>View</code> 和
<code>ViewModel</code> 通过数据绑定机制进行交互，减少了手动更新 UI
的代码量。UI 可以自动响应数据变化。</li>
<li><strong>更好的分离</strong>：<code>View</code> 和
<code>ViewModel</code> 之间完全解耦，<code>ViewModel</code> 不需要知道
<code>View</code> 的具体实现，使得 <code>ViewModel</code>
更容易测试。</li>
<li><strong>响应式编程</strong>：通过 <code>LiveData</code> 或
<code>Observable</code>，<code>View</code>
可以实时监听数据的变化，适合需要频繁更新 UI 的场景。</li>
</ul>
<h4 id="缺点-9">缺点</h4>
<ul>
<li>学习曲线较高，特别是在没有数据绑定框架的情况下，手动实现数据绑定较为复杂。</li>
<li>数据绑定可能导致调试和追踪问题，因为 UI
和逻辑的交互变得不那么直观。</li>
</ul>
<h4 id="图示-2">图示：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User &lt;--&gt; View &lt;--&gt; ViewModel &lt;--&gt; Model</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="mvcmvp-和-mvvm-的区别"><strong>MVC、MVP 和 MVVM
的区别</strong></h4>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 27%" />
<col style="width: 26%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>MVC</th>
<th>MVP</th>
<th>MVVM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>View 和 Model 的关系</strong></td>
<td>View 和 Model 之间可以直接交互</td>
<td>View 和 Model 之间完全解耦</td>
<td>View 和 Model 之间完全解耦</td>
</tr>
<tr class="even">
<td><strong>业务逻辑的放置位置</strong></td>
<td>Controller</td>
<td>Presenter</td>
<td>ViewModel</td>
</tr>
<tr class="odd">
<td><strong>数据绑定</strong></td>
<td>无</td>
<td>无</td>
<td>双向数据绑定（需要框架支持）</td>
</tr>
<tr class="even">
<td><strong>可测试性</strong></td>
<td>较差，Controller 中的逻辑难以测试</td>
<td>较好，Presenter 易于测试</td>
<td>最好，ViewModel 不依赖 UI，易测试</td>
</tr>
<tr class="odd">
<td><strong>代码复杂度</strong></td>
<td>适合简单应用，较低复杂度</td>
<td>中等，适合中型应用</td>
<td>较高，适合复杂应用</td>
</tr>
<tr class="even">
<td><strong>使用场景</strong></td>
<td>小型应用或快速开发</td>
<td>中型应用或需要业务逻辑分离的场景</td>
<td>大型应用或需要响应式界面的场景</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="总结-15">总结</h4>
<ul>
<li><strong>MVC</strong>：最基础的架构模式，适用于简单或较小的项目，但当项目变复杂时，<code>Controller</code>
会变得臃肿，难以维护。</li>
<li><strong>MVP</strong>：相比 MVC，MVP 的 <code>View</code> 和
<code>Model</code> 之间解耦更彻底，<code>Presenter</code>
负责所有的业务逻辑，适合中等复杂度的应用。<code>Presenter</code>
更容易测试和维护。</li>
<li><strong>MVVM</strong>：提供了更高级的双向数据绑定机制，使得
<code>View</code> 和 <code>ViewModel</code>
之间的交互更加自动化，特别适合需要频繁更新 UI
的复杂应用，但引入了更高的复杂性。</li>
</ul>
<h2 id="四大组件">四大组件</h2>
<p>Android 的四大组件（Four Major Components）是 Android
应用程序的基础构建模块，它们分别是
<strong>Activity</strong>、<strong>Service</strong>、<strong>BroadcastReceiver</strong>
和
<strong>ContentProvider</strong>。每一个组件都有其独特的功能和用途，用于构建功能丰富且高度交互的应用程序。下面是对这四个组件的详细介绍：</p>
<hr />
<h3 id="activity活动">1. <strong>Activity（活动）</strong></h3>
<h4 id="概述-9">概述</h4>
<p><strong>Activity</strong> 是 Android
应用程序的主要组件，用于展示用户界面并处理用户与应用程序的交互。每个
Activity
都代表应用的一个界面，是应用与用户之间交互的入口点。用户可以通过触摸屏幕、按键等操作与
Activity 进行交互，Activity 会响应这些操作并作出相应的反应。</p>
<h4 id="主要特点">主要特点：</h4>
<ul>
<li><strong>生命周期</strong>：<code>Activity</code> 的生命周期由
Android 系统管理。常见的生命周期方法包括
<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code>
和 <code>onDestroy()</code>。通过这些方法，开发者可以处理
<code>Activity</code> 的创建、显示、暂停、销毁等过程中的事件。</li>
<li><strong>UI 界面</strong>：每个 <code>Activity</code> 都包含一个 UI
界面，通常由 XML 布局文件描述，开发者可以在其中添加按钮、文本框、图像等
UI 元素。</li>
</ul>
<h4 id="使用场景-5">使用场景：</h4>
<ul>
<li>展示用户界面，如登录页面、主页、设置界面等。</li>
<li>处理用户交互，如点击按钮、输入数据等。</li>
</ul>
<h4 id="示例-6">示例：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="service服务">2. <strong>Service（服务）</strong></h3>
<h4 id="概述-10">概述</h4>
<p><strong>Service</strong> 是一个运行在后台的 Android
组件，用于执行长时间运行的操作，例如下载文件、播放音乐、处理网络请求等。与
<code>Activity</code> 不同，<code>Service</code>
没有用户界面。<code>Service</code>
可以在应用程序关闭后继续运行，并且它可以与其他组件（如
<code>Activity</code>）进行交互。</p>
<h4 id="主要特点-1">主要特点：</h4>
<ul>
<li><strong>后台运行</strong>：<code>Service</code>
可以在后台执行操作，而不会直接与用户交互。</li>
<li><strong>生命周期</strong>：<code>Service</code>
也有其自己的生命周期管理方法，包括
<code>onStartCommand()</code>、<code>onBind()</code>、<code>onCreate()</code>
和 <code>onDestroy()</code>。服务可以是<strong>启动服务</strong>（通过
<code>startService()</code> 启动）或<strong>绑定服务</strong>（通过
<code>bindService()</code> 启动）。</li>
<li><strong>前台服务</strong>：<code>Service</code>
可以作为<strong>前台服务</strong>运行，这意味着它会持续运行并在状态栏中显示通知，用户可以知道服务正在运行。典型的例子是音乐播放器或
GPS 导航服务。</li>
</ul>
<h4 id="使用场景-6">使用场景：</h4>
<ul>
<li>长时间的后台任务，如音乐播放、下载文件、数据同步等。</li>
<li>执行任务后不需要与用户直接交互的操作。</li>
</ul>
<h4 id="示例-7">示例：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行后台任务</span></span><br><span class="line">        <span class="keyword">return</span> START_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果不支持绑定，返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="broadcastreceiver广播接收器">3.
<strong>BroadcastReceiver（广播接收器）</strong></h3>
<h4 id="概述-11">概述</h4>
<p><strong>BroadcastReceiver</strong> 是一种 Android
组件，用于监听和接收广播消息。广播是一种应用程序间的消息传递机制，系统或应用程序可以发送广播，其他应用程序或组件可以通过
<code>BroadcastReceiver</code>
监听并响应这些广播。广播可以是系统广播（如网络连接状态变化、电量变化等）或自定义广播。</p>
<h4 id="主要特点-2">主要特点：</h4>
<ul>
<li><strong>广播消息</strong>：广播消息是一种全局通知，广播接收器可以监听这些通知并对其作出反应。系统广播如
“BOOT_COMPLETED” 或
“ACTION_BATTERY_LOW”，应用广播则是应用自定义的广播消息。</li>
<li><strong>无界面组件</strong>：<code>BroadcastReceiver</code>
没有用户界面，只是在接收到广播时执行相应的逻辑。</li>
<li><strong>动态和静态注册</strong>：广播接收器可以在
AndroidManifest.xml 中进行静态注册，或者在代码中动态注册（通常使用
<code>registerReceiver()</code> 和 <code>unregisterReceiver()</code>
方法）。</li>
</ul>
<h4 id="使用场景-7">使用场景：</h4>
<ul>
<li>监听系统广播（如网络状态变化、低电量通知等）。</li>
<li>在应用程序之间进行消息传递。</li>
<li>在特定事件发生时触发操作，如日历提醒、下载完成通知等。</li>
</ul>
<h4 id="示例-8">示例：</h4>
<p><strong>动态注册广播接收器：</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理广播</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action.equals(Intent.ACTION_BATTERY_LOW)) &#123;</span><br><span class="line">            <span class="comment">// 电量低时的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Activity中注册接收器</span></span><br><span class="line"><span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(Intent.ACTION_BATTERY_LOW);</span><br><span class="line"><span class="type">MyReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyReceiver</span>();</span><br><span class="line">registerReceiver(receiver, filter);</span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="contentprovider内容提供者">4.
<strong>ContentProvider（内容提供者）</strong></h3>
<h4 id="概述-12">概述</h4>
<p><strong>ContentProvider</strong> 是 Android
中用于在应用程序之间共享数据的组件。<code>ContentProvider</code>
通过标准化的接口为应用程序提供数据访问，可以管理文件、数据库、网络数据等。通过
<code>ContentProvider</code>，应用程序可以共享它们的数据，其他应用程序通过
<code>ContentResolver</code> 接口与 <code>ContentProvider</code>
进行通信。</p>
<h4 id="主要特点-3">主要特点：</h4>
<ul>
<li><strong>数据共享</strong>：<code>ContentProvider</code>
提供了跨应用的数据共享功能。它可以对 SQLite
数据库、文件或网络资源的数据进行操作。</li>
<li><strong>URI 访问数据</strong>：数据通过
URI（统一资源标识符）进行访问，<code>ContentProvider</code> 通过提供
CRUD 操作（创建、读取、更新、删除）来管理数据。</li>
<li><strong>安全性</strong>：<code>ContentProvider</code>
允许对共享的数据进行权限控制，开发者可以设置权限来限制其他应用对数据的访问。</li>
</ul>
<h4 id="使用场景-8">使用场景：</h4>
<ul>
<li>应用之间的数据共享，例如联系人、媒体、文件等。</li>
<li>实现应用与外部存储或其他应用的数据交互。</li>
<li>提供标准化的数据访问接口，例如 Android
系统的联系人、短信、媒体等数据访问。</li>
</ul>
<h4 id="示例-9">示例：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyContentProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase database;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化数据库</span></span><br><span class="line">        <span class="type">MyDatabaseHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDatabaseHelper</span>(getContext());</span><br><span class="line">        database = helper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询数据</span></span><br><span class="line">        <span class="keyword">return</span> database.query(<span class="string">&quot;my_table&quot;</span>, projection, selection, selectionArgs, <span class="literal">null</span>, <span class="literal">null</span>, sortOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span> &#123;</span><br><span class="line">        <span class="comment">// 插入数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> database.insert(<span class="string">&quot;my_table&quot;</span>, <span class="literal">null</span>, values);</span><br><span class="line">        <span class="keyword">return</span> Uri.withAppendedPath(uri, String.valueOf(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新数据</span></span><br><span class="line">        <span class="keyword">return</span> database.update(<span class="string">&quot;my_table&quot;</span>, values, selection, selectionArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> &#123;</span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        <span class="keyword">return</span> database.delete(<span class="string">&quot;my_table&quot;</span>, selection, selectionArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">(Uri uri)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回MIME类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.dir/vnd.example.my_table&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="四大组件的总结">四大组件的总结</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 15%" />
<col style="width: 31%" />
<col style="width: 42%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="header">
<th>组件</th>
<th>作用</th>
<th>典型使用场景</th>
<th>是否有用户界面</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Activity</strong></td>
<td>展示用户界面，处理用户交互</td>
<td>显示应用程序的界面，如主页、设置页面</td>
<td>有</td>
</tr>
<tr class="even">
<td><strong>Service</strong></td>
<td>执行后台任务，长时间运行操作</td>
<td>播放音乐、后台下载文件、数据同步等</td>
<td>无</td>
</tr>
<tr class="odd">
<td><strong>BroadcastReceiver</strong></td>
<td>监听并响应广播消息，进行全局事件处理</td>
<td>监听系统事件如网络变化、电量低等，或处理应用内的广播消息</td>
<td>无</td>
</tr>
<tr class="even">
<td><strong>ContentProvider</strong></td>
<td>在应用间共享数据，通过标准接口提供数据访问</td>
<td>共享联系人、文件、数据库等，或提供应用间的数据访问</td>
<td>无</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="四大组件的协作">四大组件的协作：</h4>
<ul>
<li>这些组件经常一起使用来构建复杂的 Android 应用程序。例如，一个应用的
<code>Activity</code> 可以启动 <code>Service</code>
来在后台处理任务，而当任务完成时通过广播通知
<code>BroadcastReceiver</code>，同时 <code>ContentProvider</code>
可以用于提供持久化的数据访问。</li>
</ul>
<p>掌握 Android 的四大组件是开发 Android
应用的基础，理解它们的生命周期、作用和交互</p>
<p>方式，可以帮助开发者设计和实现功能丰富且高效的应用程序。</p>
<h2 id="aidl">AIDL</h2>
<p><strong>AIDL</strong>（<strong>Android Interface Definition
Language</strong>，Android 接口定义语言）是 Android 提供的一种用于实现
<strong>进程间通信</strong>（Inter-Process Communication，简称
IPC）的机制。通过
AIDL，应用程序可以与运行在不同进程中的服务或组件进行通信，允许跨进程访问对象并调用远程方法。AIDL
是 Android
中强大且灵活的进程间通信工具之一，尤其适合在多进程环境中使用。</p>
<h3 id="为什么需要-aidl">为什么需要 AIDL？</h3>
<p>在 Android 中，默认情况下应用程序中的所有组件（如
<code>Activity</code>、<code>Service</code>
等）都是运行在同一个进程中的，可以直接通过引用对象来共享数据。但是，当组件运行在不同的进程时，它们之间是不能直接共享数据的，因为每个进程都有自己独立的内存空间。这时候就需要
AIDL 来进行进程间的数据传递和方法调用。</p>
<p>AIDL
的目标是允许你定义一个接口，让其他应用程序或服务可以调用你进程中的方法，就像调用本地方法一样。</p>
<h3 id="aidl-的工作原理">AIDL 的工作原理</h3>
<p>AIDL 的本质是利用 <strong>Binder</strong>
机制来实现不同进程之间的通信。在 Android
中，每个进程都有自己的内存空间，不能直接访问其他进程的数据。Binder 是
Android 的一种高效的 IPC 机制，AIDL 基于 Binder
来实现接口方法的跨进程调用。</p>
<p>AIDL 的工作流程如下：</p>
<ol type="1">
<li><strong>定义 AIDL 接口</strong>：创建一个 <code>.aidl</code>
文件，定义接口中可以被远程调用的方法。</li>
<li><strong>自动生成代码</strong>：Android SDK 工具会根据
<code>.aidl</code> 文件生成 <code>Stub</code> 和 <code>Proxy</code>
代码，<code>Stub</code> 负责接收远程调用，<code>Proxy</code>
负责在客户端执行远程调用。</li>
<li><strong>服务端实现接口</strong>：服务端实现 <code>Stub</code>
类中的方法，这些方法会在远程调用时被触发。</li>
<li><strong>客户端绑定服务</strong>：客户端通过
<code>bindService()</code> 绑定到远程服务，获取 <code>Proxy</code>
对象，并通过这个对象调用远程服务的方法。</li>
</ol>
<h3 id="aidl-的使用步骤">AIDL 的使用步骤</h3>
<h4 id="定义-aidl-接口">1. <strong>定义 AIDL 接口</strong></h4>
<p>首先，你需要定义一个 <code>.aidl</code>
文件，描述客户端和服务端共享的接口。AIDL
支持的基本数据类型包括：<code>int</code>、<code>long</code>、<code>boolean</code>、<code>float</code>、<code>double</code>、<code>String</code>
等，也支持数组、<code>List</code>、<code>Map</code> 和自定义
<code>Parcelable</code> 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// IMyAidlInterface.aidl</span><br><span class="line">package com.example.aidl;</span><br><span class="line"></span><br><span class="line">// 定义一个简单的接口，支持跨进程调用</span><br><span class="line">interface IMyAidlInterface &#123;</span><br><span class="line">    int add(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现-aidl-接口">2. <strong>实现 AIDL 接口</strong></h4>
<p>服务端需要实现这个接口。Android 会自动为这个接口生成一个
<code>Stub</code> 类，服务端需要继承这个 <code>Stub</code>
类并实现接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 AIDL 中定义的接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMyAidlInterface.<span class="type">Stub</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IMyAidlInterface</span>.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回 AIDL 的 Binder 对象</span></span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端绑定远程服务">3. <strong>客户端绑定远程服务</strong></h4>
<p>客户端通过 <code>bindService()</code> 方法来绑定远程服务，并获取
<code>Proxy</code> 对象。通过这个 <code>Proxy</code>
对象，客户端可以像调用本地方法一样调用远程服务中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IMyAidlInterface myAidlInterface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 ServiceConnection，处理与服务的连接和断开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 AIDL 接口的代理对象</span></span><br><span class="line">            myAidlInterface = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">            myAidlInterface = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        <span class="comment">// 绑定远程服务</span></span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 AIDL 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAddition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (myAidlInterface != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> myAidlInterface.add(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Result: &quot;</span> + result);  <span class="comment">// 输出结果：15</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在-androidmanifest.xml-中声明服务">4. <strong>在
<code>AndroidManifest.xml</code> 中声明服务</strong></h4>
<p>服务端的服务组件需要在 <code>AndroidManifest.xml</code>
中声明，并指定
<code>android:exported="true"</code>，以允许外部进程访问它。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MyService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.aidl.IMyAidlInterface&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="aidl-的数据类型支持">AIDL 的数据类型支持</h3>
<p>AIDL 支持以下几种数据类型：</p>
<ol type="1">
<li><strong>基本数据类型</strong>：如
<code>int</code>、<code>long</code>、<code>boolean</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>String</code>
等。</li>
<li><strong>集合类型</strong>：如 <code>List</code> 和
<code>Map</code>（<code>List</code> 可以是泛型
<code>List&lt;T&gt;</code>，T 必须是 AIDL 支持的类型）。</li>
<li><strong>自定义 <code>Parcelable</code>
对象</strong>：如果需要传递复杂的对象，可以实现 <code>Parcelable</code>
接口，并在 AIDL 文件中使用该类型。<code>Parcelable</code> 是 Android
中用于序列化对象的机制，它比 Java 的 <code>Serializable</code>
更高效。</li>
</ol>
<h3 id="aidl-的优缺点">AIDL 的优缺点</h3>
<h4 id="优点-10">优点：</h4>
<ol type="1">
<li><strong>跨进程通信</strong>：AIDL 是 Android 官方提供的 IPC
机制，支持跨进程调用远程服务中的方法。</li>
<li><strong>灵活性</strong>：通过
AIDL，可以灵活定义接口、数据类型以及不同进程间的调用方式。</li>
<li><strong>高效</strong>：AIDL 基于 Binder 机制，而 Binder 是 Android
特有的、非常高效的进程间通信方式。</li>
</ol>
<h4 id="缺点-10">缺点：</h4>
<ol type="1">
<li><strong>复杂性</strong>：AIDL
增加了开发复杂度，尤其是涉及到传递复杂对象时，需要手动实现
<code>Parcelable</code>。</li>
<li><strong>性能开销</strong>：虽然 AIDL 基于 Binder
是高效的，但频繁的跨进程通信仍然会带来一定的性能开销。一般情况下，应尽量减少进程间通信的频率和数据量。</li>
<li><strong>并发问题</strong>：AIDL 服务是多线程的，因此在实现 AIDL
接口时，开发者需要注意线程安全问题。</li>
</ol>
<h3 id="aidl-的典型使用场景">AIDL 的典型使用场景</h3>
<ol type="1">
<li><strong>音乐播放器</strong>：当音乐播放器的 UI
组件和后台播放服务运行在不同的进程中时，可以使用 AIDL 来让 UI
控制后台服务，比如播放、暂停、跳转等操作。</li>
<li><strong>远程数据处理</strong>：有些应用会在后台服务中进行繁重的计算任务或网络操作，而主应用进程可以通过
AIDL 调用这些任务并获取结果。</li>
<li><strong>跨应用通信</strong>：AIDL
可以用于不同应用间的通信。例如，应用 A 提供了一些服务，应用 B 可以通过
AIDL 访问这些服务。</li>
</ol>
<h3 id="总结-16">总结</h3>
<p>AIDL 是 Android 中用于实现进程间通信的强大工具，它基于 Binder
机制，允许不同进程的组件通过接口进行方法调用和数据传递。AIDL
主要用于需要在不同进程间进行复杂数据交互的场景，如后台服务、跨应用通信等。</p>
<p>开发者在使用 AIDL
时，需要了解进程间通信的特性，并注意线程安全和性能开销问题。虽然 AIDL
提供了极大的灵活性，但应在有必要的场景下使用，避免不必要的复杂度。</p>
<h2 id="性能优化">性能优化</h2>
<p>在 Android
应用开发中，性能优化是确保应用流畅运行、节省资源并提升用户体验的关键环节。常见的
Android 性能优化方法可以分为多种类型，如内存优化、UI
优化、电量优化、网络优化等。以下是一些常用的 Android 性能优化方法：</p>
<h3 id="内存优化">1. <strong>内存优化</strong></h3>
<p>参考：https://mp.weixin.qq.com/s/vuVZWsn9iGXTxvHQPfmKHQ</p>
<h4 id="减少内存泄漏">1.1 减少内存泄漏</h4>
<ul>
<li><strong>内存泄漏</strong>会导致应用在长时间运行后变得缓慢，甚至崩溃。</li>
<li>使用工具：Android Studio 的 <strong>LeakCanary</strong> 或
<strong>Memory Profiler</strong> 来检测内存泄漏。</li>
<li>避免持有对 <code>Context</code> 的长时间引用，尤其是
<code>Activity</code> 或 <code>Fragment</code>，避免使用静态变量持有
<code>Context</code>。</li>
<li>对于生命周期长的对象，如单例、线程等，应确保它们不会持有对短生命周期对象的引用。</li>
</ul>
<h4 id="使用合适的数据结构">1.2 使用合适的数据结构</h4>
<ul>
<li>使用轻量级的数据结构，比如在小数据量情况下使用
<code>ArrayList</code> 而不是 <code>HashMap</code>。</li>
<li>对于大数据或频繁操作的数据集，使用更高效的容器，比如
<code>SparseArray</code> 替代 <code>HashMap</code> 来节省内存。</li>
</ul>
<h4 id="使用合适的-bitmap-配置">1.3 使用合适的 Bitmap 配置</h4>
<ul>
<li>加载图片时使用 <code>BitmapFactory.Options</code> 的
<code>inSampleSize</code> 来缩放图片，防止加载过大的图片导致
<code>OutOfMemoryError</code>。</li>
<li>使用 <strong>LruCache</strong> 对图片进行缓存，避免重复加载。</li>
<li>在不需要图片时，及时调用 <code>Bitmap.recycle()</code>
来释放内存。</li>
</ul>
<h4 id="避免使用过多的-service">1.4 避免使用过多的
<code>Service</code></h4>
<ul>
<li><code>Service</code> 会常驻内存，占用资源。尽量使用
<strong>JobScheduler</strong> 或 <strong>WorkManager</strong>
来替代传统的 <code>Service</code>，尤其是后台任务的调度。</li>
</ul>
<h3 id="ui-优化">2. <strong>UI 优化</strong></h3>
<h4 id="避免-ui-卡顿anr">2.1 避免 UI 卡顿（ANR）</h4>
<ul>
<li>使用主线程（UI线程）处理复杂的逻辑或长时间的任务会导致
<strong>ANR（Application Not Responding）</strong>。</li>
<li>将耗时的操作（如网络请求、数据库查询、文件读写等）放在子线程中，使用
<strong>Handler</strong> 或 <strong>AsyncTask</strong>
进行异步处理。</li>
<li>对于频繁更新 UI 的场景，使用 <strong>RecyclerView</strong> 替代
<code>ListView</code>，并对 View 进行缓存和复用，减少创建和销毁
<code>View</code> 的次数。</li>
</ul>
<h4 id="优化布局">2.2 优化布局</h4>
<ul>
<li>减少布局层级，避免深层嵌套。</li>
<li>使用 <strong>ConstraintLayout</strong>，替代复杂的
<code>RelativeLayout</code> 和 <code>LinearLayout</code> 嵌套。</li>
<li>使用 <strong>Layout Inspector</strong>
工具分析布局层级，优化过于复杂的布局结构。</li>
<li>对于动态界面，使用 <strong>ViewStub</strong> 和
<strong>include</strong> 标签来优化布局加载，减少不必要的视图渲染。</li>
</ul>
<h4 id="避免频繁重绘">2.3 避免频繁重绘</h4>
<ul>
<li>避免频繁调用 <code>invalidate()</code>，尽量减少对 View
的重复绘制。</li>
<li>对于动画等频繁更新 UI 的场景，使用 <code>View.invalidate()</code>
时，只更新变化的区域而非整个视图。</li>
</ul>
<h3 id="电量优化">3. <strong>电量优化</strong></h3>
<h4 id="减少不必要的后台任务">3.1 减少不必要的后台任务</h4>
<ul>
<li>使用 <strong>JobScheduler</strong> 或 <strong>WorkManager</strong>
来调度任务，而不是使用 <code>Service</code> 或 <code>AlarmManager</code>
来频繁唤醒设备。</li>
<li>合理使用 <strong>Doze 模式</strong> 和 <strong>App
Standby</strong>，在应用进入后台时，尽量停止不必要的后台任务。</li>
<li>控制应用的唤醒频率，尽量减少 <code>WakeLock</code>
的使用，避免长时间占用 CPU。</li>
</ul>
<h4 id="优化传感器和-gps-使用">3.2 优化传感器和 GPS 使用</h4>
<ul>
<li>尽量减少传感器（如加速度计、陀螺仪）和 GPS 的高频次使用。</li>
<li>使用更节能的定位方式，如 <strong>Fused Location Provider
API</strong>，并根据需求调整定位精度，避免频繁的高精度 GPS 调用。</li>
</ul>
<h3 id="网络优化">4. <strong>网络优化</strong></h3>
<h4 id="减少不必要的网络请求">4.1 减少不必要的网络请求</h4>
<ul>
<li>合理使用网络请求，减少频繁的请求。</li>
<li>在需要重复请求的场景下，使用 <strong>缓存机制</strong>，例如 OkHttp
的缓存控制功能，避免每次都从服务器获取相同的数据。</li>
</ul>
<h4 id="压缩数据">4.2 压缩数据</h4>
<ul>
<li>尽量压缩网络请求的数据，使用 JSON 格式替代 XML
格式，减少数据包大小。</li>
<li>对图片等静态资源进行压缩，使用合适的图片格式和尺寸，减少带宽消耗。</li>
</ul>
<h4 id="批量处理网络请求">4.3 批量处理网络请求</h4>
<ul>
<li>使用 <strong>批量请求</strong>，例如合并多个请求或使用多路复用（如
HTTP/2 支持的多路复用）来减少网络交互的次数和延迟。</li>
<li>合理设计 API 接口，减少请求次数和数据传输量。</li>
</ul>
<h4 id="使用高效的网络库">4.4 使用高效的网络库</h4>
<ul>
<li>使用高效的网络库如
<strong>Retrofit</strong>、<strong>OkHttp</strong>，并配置合理的连接超时、读取超时等参数。</li>
<li>对于大文件下载，使用断点续传等技术减少网络资源浪费。</li>
</ul>
<h3 id="启动速度优化">5. <strong>启动速度优化</strong></h3>
<h4 id="减少启动时的初始化工作">5.1 减少启动时的初始化工作</h4>
<ul>
<li>在应用启动时，避免进行过多的初始化操作。将非必要的初始化延迟到用户实际需要时再进行。</li>
<li>使用 <strong>Lazy Initialization</strong>
技术，按需加载资源和模块。</li>
<li>通过 <strong>Profile GPU Rendering</strong>
工具检查启动时的绘制性能。</li>
</ul>
<h4 id="优化冷启动">5.2 优化冷启动</h4>
<ul>
<li>使用 <code>SplashActivity</code> 或空白的 <code>Theme</code>
来显示一个过渡界面，确保应用的冷启动时间尽可能短。</li>
<li>减少或推迟启动时的耗时操作，如数据库查询、网络请求等。</li>
</ul>
<h3 id="多线程优化">6. <strong>多线程优化</strong></h3>
<h4 id="合理使用线程池">6.1 合理使用线程池</h4>
<ul>
<li>避免创建过多的线程，尽量使用 <strong>线程池</strong>
来管理并发任务。</li>
<li>使用 <strong>AsyncTask</strong> 或 <strong>Executors</strong>
来处理异步任务，减少线程的开销和资源消耗。</li>
</ul>
<h4 id="避免线程竞争">6.2 避免线程竞争</h4>
<ul>
<li>合理管理多线程操作，避免多线程竞争资源导致的性能问题，例如使用锁机制时要避免锁粒度过大，影响性能。</li>
</ul>
<h3 id="数据库优化">7. <strong>数据库优化</strong></h3>
<h4 id="使用高效的数据库操作">7.1 使用高效的数据库操作</h4>
<ul>
<li>数据库操作应尽量在子线程中进行，避免阻塞主线程。</li>
<li>使用 <strong>批量插入/更新</strong>，减少频繁的数据库写入操作。</li>
<li>在查询时，尽量避免使用
<code>SELECT *</code>，而是只查询需要的字段，减少数据读取量。</li>
</ul>
<h4 id="使用索引优化查询">7.2 使用索引优化查询</h4>
<ul>
<li>对常用的查询字段建立索引，提高查询效率，但要避免在不必要的字段上建立过多的索引。</li>
</ul>
<h3 id="其他优化方法">8. <strong>其他优化方法</strong></h3>
<h4 id="使用-proguard-进行代码混淆与优化">8.1 使用 ProGuard
进行代码混淆与优化</h4>
<ul>
<li>开启 <strong>ProGuard</strong> 或 <strong>R8</strong>
来混淆代码、移除未使用的代码和资源，减小 APK
大小，并提升应用的安全性。</li>
</ul>
<h4 id="资源优化">8.2 资源优化</h4>
<ul>
<li>减少 APK 包大小，压缩图片、音频资源，删除不必要的资源文件。</li>
<li>使用 <strong>Android App Bundle</strong>，让 Google Play
根据用户设备生成最适合的 APK，减小下载包大小。</li>
</ul>
<h3 id="结论">结论：</h3>
<p>通过合理运用上述的性能优化策略，开发者可以显著提升 Android
应用的运行效率，减少内存消耗，避免 UI
卡顿和崩溃，提高电池续航，优化网络请求。性能优化是一个持续关注和调优的过程，借助
Android Studio 的工具（如 Profiler、Lint
等），可以更容易发现和解决潜在的性能瓶颈。</p>
<h2 id="mediacodec">MediaCodec</h2>
<p><code>MediaCodec</code> 是 Android 平台上的一个多媒体编解码器
API，允许应用程序高效地编码和解码音视频数据。它的主要作用是提供一个硬件加速的接口来处理媒体数据，能够在支持的设备上显著提高媒体处理的效率和性能。<code>MediaCodec</code>
通常与 <code>MediaExtractor</code>、<code>MediaMuxer</code>
等组件结合使用，以实现媒体的读取、解码、处理和重编码。下面是
<code>MediaCodec</code> 的工作原理及其基本流程：</p>
<h3 id="mediacodec-的工作原理"><code>MediaCodec</code> 的工作原理：</h3>
<p><code>MediaCodec</code>
使用缓冲区队列模型，在内部通过输入和输出缓冲区与编码器或解码器硬件进行交互。它的基本工作流程可以分为以下几个步骤：</p>
<ol type="1">
<li><strong>创建编码器或解码器</strong>：
<ul>
<li>应用程序需要根据需要使用的编解码器（如 H.264、AAC 等）来初始化一个
<code>MediaCodec</code> 实例。</li>
<li>通过 <code>MediaCodec.createDecoderByType()</code> 或
<code>MediaCodec.createEncoderByType()</code>
指定编码或解码的媒体格式类型。</li>
</ul></li>
<li><strong>配置 <code>MediaCodec</code></strong>：
<ul>
<li>使用 <code>configure()</code>
方法来设置编解码器的格式参数（例如帧率、码率、分辨率、采样率等），并且可以指定输入输出的
<code>Surface</code>（如果是视频数据）。</li>
<li>可以配置解码器将视频输出到屏幕或者输出到内存中进一步处理。</li>
</ul></li>
<li><strong>输入缓冲区处理（解码/编码）</strong>：
<ul>
<li><strong>填充输入缓冲区</strong>：<code>MediaCodec</code>
会分配一组输入缓冲区（input
buffers），应用程序需要获取这些缓冲区，然后将需要解码或编码的数据填充到缓冲区中。
<ul>
<li>通过 <code>dequeueInputBuffer()</code>
方法获取空闲的输入缓冲区。</li>
<li>应用程序将音视频数据填充到缓冲区后，再通过
<code>queueInputBuffer()</code> 提交给 <code>MediaCodec</code>
进行处理。</li>
</ul></li>
<li>对于视频解码，通常与 <code>MediaExtractor</code>
一起使用，先从媒体文件中提取帧数据，然后将数据送入输入缓冲区。</li>
</ul></li>
<li><strong>解码或编码过程</strong>：
<ul>
<li><code>MediaCodec</code>
内部硬件或软件会对输入缓冲区中的数据进行处理，解码或编码为指定的格式。</li>
<li>在解码的场景中，<code>MediaCodec</code> 将压缩的数据（如
H.264）解码为原始帧数据。在编码的场景中，<code>MediaCodec</code>
将原始数据（如 YUV）编码为压缩格式。</li>
</ul></li>
<li><strong>输出缓冲区处理</strong>：
<ul>
<li><code>MediaCodec</code>
将解码或编码后的数据放入输出缓冲区，应用程序可以通过
<code>dequeueOutputBuffer()</code> 获取这些缓冲区。</li>
<li>获取输出缓冲区后，应用程序可以对解码后的原始帧进行显示、保存，或者对编码后的数据进行封装存储等操作。</li>
<li>对于视频解码，可以直接将数据呈现到 <code>Surface</code>
上，避免数据从 GPU 到 CPU 再到 GPU 的拷贝，提升效率。</li>
</ul></li>
<li><strong>释放和重置</strong>：
<ul>
<li>完成编解码操作后，应用程序可以调用 <code>release()</code> 方法释放
<code>MediaCodec</code> 实例。</li>
<li>也可以通过 <code>flush()</code> 方法重置
<code>MediaCodec</code>，在不改变配置的前提下，清空所有缓冲区，适用于流式媒体解码场景。</li>
</ul></li>
</ol>
<h3 id="基本工作流程图">基本工作流程图：</h3>
<ol type="1">
<li><p><strong>创建 <code>MediaCodec</code> 并配置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MediaCodec codec = MediaCodec.createDecoderByType(&quot;video/avc&quot;);</span><br><span class="line">codec.configure(format, surface, null, 0);</span><br><span class="line">codec.start();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>解码数据</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (decoding) &#123;</span><br><span class="line">    // 获取输入缓冲区并填充数据</span><br><span class="line">    int inputBufferIndex = codec.dequeueInputBuffer(TIMEOUT_US);</span><br><span class="line">    if (inputBufferIndex &gt;= 0) &#123;</span><br><span class="line">        ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferIndex);</span><br><span class="line">        inputBuffer.clear();</span><br><span class="line">        // 从数据源读取数据并填充到缓冲区中</span><br><span class="line">        int sampleSize = extractor.readSampleData(inputBuffer, 0);</span><br><span class="line">        if (sampleSize &lt; 0) &#123;</span><br><span class="line">            // No more data</span><br><span class="line">            codec.queueInputBuffer(inputBufferIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);</span><br><span class="line">            decoding = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long presentationTimeUs = extractor.getSampleTime();</span><br><span class="line">            codec.queueInputBuffer(inputBufferIndex, 0, sampleSize, presentationTimeUs, 0);</span><br><span class="line">            extractor.advance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取解码后的输出缓冲区</span><br><span class="line">    MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();</span><br><span class="line">    int outputBufferIndex = codec.dequeueOutputBuffer(bufferInfo, TIMEOUT_US);</span><br><span class="line">    if (outputBufferIndex &gt;= 0) &#123;</span><br><span class="line">        // 处理解码后的数据</span><br><span class="line">        codec.releaseOutputBuffer(outputBufferIndex, true);  // true 表示渲染到 Surface</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>释放 <code>MediaCodec</code></strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codec.stop();</span><br><span class="line">codec.release();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="mediacodec-的特点"><code>MediaCodec</code> 的特点：</h3>
<ul>
<li><strong>硬件加速</strong>：<code>MediaCodec</code> 通过设备硬件（如
GPU、DSP
等）加速解码和编码操作，比纯软件编解码效率更高，特别适合高分辨率视频处理。</li>
<li><strong>低延迟</strong>：由于直接操作缓冲区队列并结合硬件加速，能够提供低延迟的编解码，适合实时媒体处理，如视频会议、直播。</li>
<li><strong>灵活性</strong>：支持视频和音频的多种格式（如
H.264、H.265、VP8、AAC、MP3 等），可适应多种应用场景。</li>
</ul>
<p>总结来说，<code>MediaCodec</code>
提供了一个高效、灵活的多媒体编解码接口，通过硬件加速的方式让应用程序能够处理复杂的音视频数据，同时降低了对系统资源的消耗。</p>
<h3 id="参考">参考</h3>
<p><a
href="https://juejin.cn/post/6844903573306916878">安卓解码器MediaCodec解析</a></p>
<h2 id="camera-和-camera2-的区别">Camera 和 Camera2 的区别</h2>
<p><code>Android Camera</code> API 和 <code>Camera2</code> API 是
Android 平台上用于开发摄像头功能的两个主要 API。<code>Camera2</code> API
是为了替代早期的 <code>Camera</code> API
而推出的，提供了更强大的功能和更灵活的控制方式。以下是这两个 API
的主要区别：</p>
<h3 id="api-的推出时间">1. <strong>API 的推出时间</strong></h3>
<ul>
<li><strong>Camera API</strong>：这是 Android 1.0
版本引入的较早的摄像头接口，它在 Android
5.0（Lollipop）之后逐渐被弃用。</li>
<li><strong>Camera2 API</strong>：在 Android
5.0（Lollipop）中引入，用于提供更精细的摄像头控制和硬件功能支持。</li>
</ul>
<h3 id="api-设计和复杂性">2. <strong>API 设计和复杂性</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li><strong>简单易用</strong>：<code>Camera API</code>
比较简单易用，适合快速开发一些基本的摄像头功能。</li>
<li><strong>功能有限</strong>：它的设计目标是提供基本的拍照和录制视频功能，无法直接访问摄像头硬件的高级特性。</li>
<li><strong>同步模式</strong>：操作大多是同步的，容易出现卡顿或性能瓶颈的问题，尤其在高性能需求场景下。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li><strong>高度灵活且复杂</strong>：<code>Camera2</code>
采用了全新的设计模式，基于管道（pipeline）机制。开发者可以非常灵活地控制图像捕捉流程，包括对曝光、对焦、ISO
等参数进行精细的调整。</li>
<li><strong>异步模式</strong>：<code>Camera2</code>
使用异步的回调机制，通过 <code>Handler</code>
来处理图像数据流，支持多线程和更好的性能优化。</li>
<li><strong>更高的学习曲线</strong>：与 <code>Camera API</code>
相比，<code>Camera2</code>
的使用更为复杂，需要对相机特性有更深入的了解。</li>
</ul></li>
</ul>
<h3 id="硬件能力的访问">3. <strong>硬件能力的访问</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li>只能进行非常有限的设置，例如分辨率和缩放。无法很好地访问和利用摄像头的高级功能。</li>
<li>不支持手动控制 ISO、快门速度、白平衡、对焦等参数。</li>
<li>无法使用 RAW 格式拍摄，只能获取压缩格式（如 JPEG）的图片。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li>提供对摄像头硬件的细粒度控制，允许开发者通过
<code>CaptureRequest</code>
自定义曝光时间、ISO、对焦距离、快门速度等参数。</li>
<li>支持高级模式，比如全手动模式、自动对焦/自动曝光/自动白平衡锁定等。</li>
<li>支持拍摄 RAW 格式图像，便于开发者在后期处理时有更大的灵活度。</li>
<li>允许开发者访问双摄像头功能，以及处理高帧率视频和慢动作视频。</li>
</ul></li>
</ul>
<h3 id="图像处理与数据流">4. <strong>图像处理与数据流</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li>图像处理和捕捉流程是比较固定的，开发者难以自定义数据流。</li>
<li>通过预览界面获取图像数据，无法获得预览与拍摄的分离控制。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li><code>Camera2</code> 提供了一个基于 <strong>管道（Capture
Pipeline）</strong>
的图像捕捉流程，可以同时处理多个数据流，比如同时预览、拍照、录像等。</li>
<li>可以处理多个输出目标（如
<code>Surface</code>、<code>ImageReader</code>），支持多线程并发处理数据。</li>
<li>支持并行预览、拍照和录像，且能够更好地控制帧率和分辨率。</li>
</ul></li>
</ul>
<h3 id="性能与帧率控制">5. <strong>性能与帧率控制</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li>性能相对较低，主要适用于低帧率的预览和拍摄。</li>
<li>对高帧率视频录制和高性能图像处理支持有限。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li>提供更高效的图像处理流程，支持高帧率视频录制和慢动作视频。</li>
<li>可以通过手动调节帧率和分辨率来优化性能，适合高性能场景。</li>
</ul></li>
</ul>
<h3 id="开发者工具与兼容性">6. <strong>开发者工具与兼容性</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li>由于 Camera API 较为简单，适合快速开发入门级的摄像头应用。</li>
<li>但是它的功能有限，且在 Android 5.0 之后逐渐被 Camera2
取代，因此并不适合现代高需求的应用场景。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li>虽然复杂度较高，但适合开发需要高度自定义、专业级别的应用，如专业相机应用、AR/VR
应用等。</li>
<li>Camera2 API 兼容 Android 5.0
及更高版本的设备，某些设备可能没有完全支持 Camera2 API
的所有特性（如完全手动控制），这取决于设备硬件支持。</li>
</ul></li>
</ul>
<h3 id="扩展和进化">7. <strong>扩展和进化</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li>基本没有进一步的发展，功能已经很有限，主要用于向后兼容性。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li>是 Android 未来摄像头开发的主流 API，不断得到改进和扩展。随着
Android
版本的升级，新特性不断加入（如多摄像头的同步控制、深度图等）。</li>
</ul></li>
</ul>
<h3 id="示例代码差异">8. <strong>示例代码差异</strong></h3>
<p><strong>Camera API 示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> Camera.open();</span><br><span class="line">Camera.<span class="type">Parameters</span> <span class="variable">params</span> <span class="operator">=</span> camera.getParameters();</span><br><span class="line">camera.setPreviewDisplay(surfaceHolder);</span><br><span class="line">camera.startPreview();</span><br></pre></td></tr></table></figure>
<p><strong>Camera2 API 示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CameraManager</span> <span class="variable">manager</span> <span class="operator">=</span> (CameraManager) getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">CameraDevice.<span class="type">StateCallback</span> <span class="variable">stateCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraDevice</span>.StateCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpened</span><span class="params">(CameraDevice cameraDevice)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动相机预览</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDisconnected</span><span class="params">(CameraDevice cameraDevice)</span> &#123; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(CameraDevice cameraDevice, <span class="type">int</span> error)</span> &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">manager.openCamera(cameraId, stateCallback, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="总结-17">总结：</h3>
<ul>
<li><strong>Camera API</strong>
更简单，适合基础的拍照和视频录制应用，但功能和性能有限，已逐步被淘汰。</li>
<li><strong>Camera2 API</strong>
提供了更强大、更灵活的摄像头控制，适合对性能和高级功能有较高要求的应用开发，但其复杂性较高，需要开发者更深入的掌握相关概念和技术。</li>
</ul>
<p>目前，开发复杂或高性能摄像头应用时，<code>Camera2 API</code>
是首选。</p>
<h2 id="bufferqueue">BufferQueue</h2>
<p><code>BufferQueue</code> 是 Android
图形子系统中一个非常核心的组件，它负责管理生产者和消费者之间的缓冲区交换，通常用于处理图像和视频流数据。<code>BufferQueue</code>
是构建图像渲染管道的基础部分，应用于窗口管理器（SurfaceFlinger）、相机、视频播放器等与图像显示相关的系统组件中。</p>
<h3 id="bufferqueue-的工作机制"><code>BufferQueue</code> 的工作机制</h3>
<p><code>BufferQueue</code>
是一个<strong>生产者/消费者模式</strong>的实现，包含两个主要部分： -
<strong>生产者（Producer）</strong>：向缓冲区队列提交图像数据。 -
<strong>消费者（Consumer）</strong>：从缓冲区队列读取并处理图像数据。</p>
<p>生产者和消费者可以在不同的线程或进程中运行，<code>BufferQueue</code>
负责在它们之间传递缓冲区。</p>
<h4 id="主要组件">主要组件</h4>
<ol type="1">
<li><p><strong><code>GraphicBuffer</code></strong>：<code>BufferQueue</code>
中传递的实际缓冲区，是承载图像数据的内存块。生产者将数据填充到
<code>GraphicBuffer</code>
中，消费者从中读取图像并进行处理或显示。</p></li>
<li><p><strong><code>BufferSlot</code></strong>：<code>BufferQueue</code>
中的每个缓冲区被称为一个 <code>BufferSlot</code>，通常
<code>BufferQueue</code> 维护一个固定数量的
<code>BufferSlot</code>。生产者和消费者通过 <code>BufferSlot</code>
来交换数据。</p></li>
<li><p><strong><code>Surface</code> 和
<code>SurfaceTexture</code></strong>：</p>
<ul>
<li><strong><code>Surface</code></strong>：生产者通过
<code>Surface</code> 向 <code>BufferQueue</code>
提交数据，常用于图像渲染。例如，当一个应用想要在屏幕上绘制图像时，它会通过
<code>Surface</code> 向 <code>BufferQueue</code> 发送图像。</li>
<li><strong><code>SurfaceTexture</code></strong>：消费者通过
<code>SurfaceTexture</code> 从 <code>BufferQueue</code>
获取数据，通常用于纹理渲染（如 OpenGL 中的渲染）。</li>
</ul></li>
</ol>
<h4 id="流程">流程</h4>
<ol type="1">
<li><strong>生产者提交数据</strong>：
<ul>
<li>生产者通过 <code>Surface</code> 或其他接口向
<code>BufferQueue</code> 提交新的 <code>GraphicBuffer</code>。</li>
<li>生产者调用 <code>dequeueBuffer()</code> 从 <code>BufferQueue</code>
请求一个空闲的缓冲区
<code>BufferSlot</code>，生产者可以向这个缓冲区中填充图像数据。</li>
<li>填充完数据后，生产者调用 <code>queueBuffer()</code>
将这个缓冲区返回给
<code>BufferQueue</code>，表示该缓冲区现在包含了新的一帧图像数据。</li>
</ul></li>
<li><strong>消费者读取数据</strong>：
<ul>
<li>消费者会调用 <code>acquireBuffer()</code> 来从
<code>BufferQueue</code> 中获取已填充的
<code>BufferSlot</code>，并从中读取图像数据。</li>
<li>一旦消费者完成了对图像的处理或显示，它会调用
<code>releaseBuffer()</code>，将缓冲区返回给
<code>BufferQueue</code>，以便生产者再次使用。</li>
</ul></li>
</ol>
<h3 id="bufferqueue-的主要作用"><code>BufferQueue</code> 的主要作用</h3>
<ol type="1">
<li><p><strong>异步图像处理</strong>： <code>BufferQueue</code>
实现了生产者和消费者的异步通信。生产者和消费者可以在不同的线程或进程中独立运行，<code>BufferQueue</code>
通过缓冲区管理确保数据交换的高效和流畅。生产者可以持续生成数据而不用等待消费者处理完成。</p></li>
<li><p><strong>双缓冲或多缓冲机制</strong>： <code>BufferQueue</code>
支持多缓冲机制（通常是双缓冲或三缓冲），确保在高帧率的图像处理过程中避免撕裂现象。生产者可以生成下一帧数据，而消费者正在处理或显示上一帧的数据。</p></li>
<li><p><strong>图形显示和纹理渲染的桥梁</strong>： 在 Android
中，应用通过 <code>Surface</code> 提交图像数据，这些数据被消费者（如
<code>SurfaceFlinger</code> 或 GPU）从 <code>BufferQueue</code>
中读取，用于最终的图形显示或作为 OpenGL 纹理使用。</p></li>
</ol>
<h3 id="bufferqueue-的工作示例"><code>BufferQueue</code> 的工作示例</h3>
<p><strong>图形渲染流程</strong>： 在一个典型的 Android
图形渲染场景中，应用程序通过 <code>SurfaceView</code>
绘制图像，背后实际涉及 <code>BufferQueue</code> 的运作： - 应用通过
<code>Surface</code> 提交绘制数据（例如，游戏中的帧）。 -
<code>BufferQueue</code> 在后台处理缓冲区队列。 -
<code>SurfaceFlinger</code> 作为消费者，从 <code>BufferQueue</code>
获取缓冲区并将其合成到最终的显示屏幕上。</p>
<h4 id="示例流程">示例流程：</h4>
<ol type="1">
<li>应用程序向 <code>Surface</code> 请求一个缓冲区。</li>
<li><code>BufferQueue</code>
分配一个空闲的缓冲区（<code>BufferSlot</code>）并返回给应用程序。</li>
<li>应用程序将图像数据写入缓冲区，并将其放回
<code>BufferQueue</code>。</li>
<li><code>SurfaceFlinger</code> 从 <code>BufferQueue</code>
获取这个缓冲区，并将其显示在屏幕上。</li>
<li>一旦显示完成，缓冲区会被标记为空闲状态，并且可供生产者再次使用。</li>
</ol>
<h3 id="bufferqueue-的实际应用场景">BufferQueue 的实际应用场景</h3>
<h4 id="camera-api">1. <strong>Camera API</strong></h4>
<p>在 Camera 应用程序中，<code>BufferQueue</code>
被用于管理相机的预览帧流。相机硬件作为生产者不断地将预览帧（图像数据）发送到
<code>BufferQueue</code> 中，而应用程序或 <code>SurfaceFlinger</code>
作为消费者，从 <code>BufferQueue</code> 中获取并处理或显示这些帧。</p>
<h4 id="视频播放">2. <strong>视频播放</strong></h4>
<p>在视频播放过程中，视频解码器解码后的图像帧通过
<code>BufferQueue</code>
发送给显示器。解码器是生产者，播放器是消费者。视频播放器通过
<code>SurfaceView</code> 或 <code>TextureView</code>
处理解码后的图像，并呈现在用户界面上。</p>
<h4 id="opengl-纹理渲染">3. <strong>OpenGL 纹理渲染</strong></h4>
<p><code>SurfaceTexture</code> 使用 <code>BufferQueue</code>
来管理将图像数据传递给 GPU 的过程。应用程序可以通过
<code>SurfaceTexture</code> 从摄像头或其他数据源获取图像，并将其作为
OpenGL 纹理进行渲染。</p>
<h3 id="bufferqueue-的优化点">BufferQueue 的优化点</h3>
<ul>
<li><p><strong>锁定与并发</strong>：<code>BufferQueue</code>
使用了同步机制来确保生产者和消费者的并发访问安全。在高性能场景下，对锁的优化非常关键。Android
内部对 <code>BufferQueue</code>
的锁机制进行了深度优化，避免了不必要的阻塞和性能开销。</p></li>
<li><p><strong>多缓冲区模式</strong>：通过支持双缓冲、三缓冲等机制，<code>BufferQueue</code>
能够有效减少生产者和消费者之间的等待时间，提高图像处理的流畅度。</p></li>
<li><p><strong>硬件加速</strong>：<code>BufferQueue</code>
直接与硬件加速进行协作，生产者和消费者可以使用
<code>GraphicBuffer</code> 来减少数据拷贝的开销，直接在 GPU
中操作，提高效率。</p></li>
</ul>
<h3 id="总结-18">总结</h3>
<p><code>BufferQueue</code> 是 Android
图形系统的核心机制，用于协调生产者（例如应用、相机、视频解码器等）和消费者（如
<code>SurfaceFlinger</code>、OpenGL
渲染器等）之间的缓冲区传递。它通过异步处理和多缓冲区机制，确保图像数据高效传输，并避免卡顿、撕裂等现象。在实际的
Android 开发中，理解 <code>BufferQueue</code>
的工作原理对于优化图像显示性能非常重要。</p>
<h2 id="组件化">组件化</h2>
<p>Android
组件化是一种将应用程序的不同功能模块分离成独立组件的开发架构模式。这些组件可以单独开发、测试、调试和维护，并且通过某种机制进行集成，最终构成一个完整的应用程序。组件化的目的是提升代码的可维护性、复用性和灵活性，尤其在大型团队开发中显得尤为重要。</p>
<h3 id="为什么需要组件化">为什么需要组件化？</h3>
<ol type="1">
<li><p><strong>降低复杂度</strong>：随着应用功能越来越复杂，代码变得难以维护和扩展。通过将不同功能划分成模块，可以降低整体代码的复杂性。</p></li>
<li><p><strong>并行开发</strong>：团队成员可以同时开发不同的模块，减少相互依赖，提高开发效率。</p></li>
<li><p><strong>复用性</strong>：组件可以在不同项目中复用，降低代码冗余，提升开发效率。</p></li>
<li><p><strong>独立性</strong>：组件可以独立开发、调试和测试，不依赖于整个应用程序的运行，减少开发调试的时间。</p></li>
<li><p><strong>降低耦合</strong>：通过组件化，模块间的依赖性降低，模块之间的通信可以通过接口或依赖注入实现，从而降低耦合度。</p></li>
</ol>
<h3 id="组件化的基本概念">组件化的基本概念</h3>
<ol type="1">
<li><strong>组件（Component）</strong>：
<ul>
<li>每个组件是一个相对独立的功能模块，比如登录模块、用户模块、支付模块等。</li>
<li>组件可以是可执行的 Android 模块（如
<code>Activity</code>、<code>Service</code>），也可以是非可执行的业务逻辑模块（如数据处理、工具库等）。</li>
</ul></li>
<li><strong>模块化（Modularization）</strong>：
<ul>
<li>组件化的实现通常是通过模块化来完成的，Android 中通过 Gradle
的多模块构建实现模块化开发。</li>
<li>每个模块可以有自己的独立的代码、资源和配置，模块之间可以通过接口进行交互。</li>
</ul></li>
<li><strong>公共库（Common Library）</strong>：
<ul>
<li>在组件化架构中，公共库是存放通用代码（如工具类、网络请求、日志处理等）的模块，其他业务模块可以依赖它。</li>
</ul></li>
<li><strong>主应用（App Shell）</strong>：
<ul>
<li>主应用是最终集成所有模块的入口。各个组件开发完成后，最终都会通过某种机制集成到主应用中，主应用通常只负责整体调度和框架集成，而不包含具体的业务逻辑。</li>
</ul></li>
<li><strong>组件通信（Component Communication）</strong>：
<ul>
<li>不同组件之间通常通过接口（Interface）、事件总线（Event
Bus）或依赖注入（Dependency Injection）等方式进行通信。</li>
</ul></li>
</ol>
<h3 id="组件化的架构层次">组件化的架构层次</h3>
<p>组件化架构一般分为几个层次，每个层次都有其独立的职责和功能：</p>
<ol type="1">
<li><strong>基础层（Base Layer）</strong>：
<ul>
<li>包含一些通用的基础库和工具库，提供网络请求、数据库操作、日志管理等功能。</li>
<li>例如 <code>common</code> 模块，通常包含 Android
应用开发过程中用到的工具类、常用函数和常量等。</li>
</ul></li>
<li><strong>业务层（Business Layer）</strong>：
<ul>
<li>包含具体的业务功能，每个功能模块封装在一个独立的组件中，比如登录模块、用户管理模块、支付模块等。</li>
<li>这些模块通常不直接相互依赖，而是通过公共接口来进行通信。</li>
</ul></li>
<li><strong>接口层（Interface Layer）</strong>：
<ul>
<li>定义模块之间的交互接口，确保模块之间解耦。通过接口和服务的方式，其他模块能够调用业务逻辑而无需知道其具体实现。</li>
<li>例如，使用 <code>Router</code> 作为组件之间导航的工具，或者通过
<code>EventBus</code> 发送事件来进行模块间通信。</li>
</ul></li>
<li><strong>主应用层（App Shell Layer）</strong>：
<ul>
<li>主应用层负责集成各个业务模块，将所有模块组合成一个完整的应用程序。</li>
<li>在开发阶段，主应用可以是一个轻量的壳应用，主要用于调度和启动业务模块。</li>
</ul></li>
</ol>
<h3 id="组件化的实现方式">组件化的实现方式</h3>
<p>Android 组件化有多种实现方式，常见的方式包括使用 <code>Gradle</code>
的多模块构建、使用路由（Router）进行模块间通信、通过服务接口定义模块交互、以及通过依赖注入框架实现模块的动态加载。</p>
<h4 id="gradle-多模块化构建">1. <strong>Gradle
多模块化构建</strong></h4>
<p>在 Android 中，使用 <code>Gradle</code>
可以轻松实现模块化构建。每个业务模块可以通过 <code>Gradle</code>
定义成一个独立的 Android Library 或 Android Module。通过配置
<code>settings.gradle</code> 和
<code>build.gradle</code>，可以将这些模块组合到主应用中。</p>
<ul>
<li><p><strong>模块划分</strong>：一个应用被拆分成多个 Gradle
模块，每个模块可以是 <code>Android Library</code> 或
<code>Java Library</code>，也可以是可执行的 Android 模块。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line">include <span class="string">&#x27;:app&#x27;</span></span><br><span class="line">include <span class="string">&#x27;:login&#x27;</span></span><br><span class="line">include <span class="string">&#x27;:user&#x27;</span></span><br><span class="line">include <span class="string">&#x27;:payment&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app/build.gradle</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(<span class="string">&#x27;:login&#x27;</span>)</span><br><span class="line">    implementation project(<span class="string">&#x27;:user&#x27;</span>)</span><br><span class="line">    implementation project(<span class="string">&#x27;:payment&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，模块之间的依赖是明确的，编译时 <code>Gradle</code>
能自动解析模块间的依赖关系。</p>
<h4 id="组件间通信方式">2. <strong>组件间通信方式</strong></h4>
<h5
id="接口通信interface-communication">（1）<strong>接口通信（Interface
Communication）</strong></h5>
<ul>
<li><p>模块之间通过接口（Interface）来实现通信和解耦。接口可以定义在公共模块中，各个业务模块通过实现这些接口来完成具体的业务逻辑。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公共模块中的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录模块实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 具体的登录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="路由通信router-communication">（2）<strong>路由通信（Router
Communication）</strong></h5>
<ul>
<li><p>路由器（Router）是一种常见的组件间通信方式，它允许模块通过
URI（统一资源标识符）进行导航或调用彼此的功能。常用的路由库如
<strong>ARouter</strong>。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在登录模块中定义路由路径</span></span><br><span class="line"><span class="meta">@Route(path = &quot;/login/main&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="comment">// 具体业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在用户模块中通过路由跳转到登录模块</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">&quot;/login/main&quot;</span>).navigation();</span><br></pre></td></tr></table></figure></p>
<h5 id="事件总线event-bus">（3）<strong>事件总线（Event
Bus）</strong></h5>
<ul>
<li><p>使用事件总线（如
<code>EventBus</code>、<code>RxBus</code>）在不同模块之间发送事件通知，实现模块之间的解耦和通信。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送事件</span></span><br><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> <span class="title class_">LoginEvent</span>(<span class="string">&quot;User logged in&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收事件</span></span><br><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoginEvent</span><span class="params">(LoginEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理登录事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="依赖注入dependency-injection">（4）<strong>依赖注入（Dependency
Injection）</strong></h5>
<ul>
<li>使用依赖注入框架（如 <strong>Dagger</strong> 或
<strong>Hilt</strong>）可以实现动态加载组件，进一步解耦模块之间的依赖。</li>
</ul>
<h4 id="动态化加载">3. <strong>动态化加载</strong></h4>
<p>在某些场景下，组件可能不需要随着应用一起打包，而是需要在运行时动态加载。例如在插件化框架（如
<strong>RePlugin</strong>、<strong>Small</strong>）中，组件可以作为插件单独打包和发布，主应用可以在运行时动态加载这些插件。</p>
<h3 id="组件化的开发模式">组件化的开发模式</h3>
<ol type="1">
<li><strong>单一组件模式（Single Component Mode）</strong>：
<ul>
<li>在组件开发的早期阶段，每个组件通常独立开发和测试。开发者可以通过单一组件的模式，将某个模块设置为一个独立的应用进行调试。</li>
</ul></li>
<li><strong>集成模式（Integration Mode）</strong>：
<ul>
<li>当所有组件开发完成后，它们会集成到主应用中，组成一个完整的应用程序。此时可以通过配置
<code>Gradle</code> 构建文件来控制每个模块的集成状态。</li>
</ul></li>
</ol>
<h3 id="组件化的优缺点">组件化的优缺点</h3>
<h4 id="优点-11">优点：</h4>
<ol type="1">
<li><strong>开发效率提升</strong>：模块化拆分后，不同功能模块可以并行开发、测试、调试，提高开发效率。</li>
<li><strong>代码可维护性提升</strong>：代码拆分成小的模块后，每个模块都更加独立，维护和扩展变得更加容易。</li>
<li><strong>模块复用</strong>：业务模块可以复用到其他项目中，减少重复开发的工作量。</li>
<li><strong>灵活的应用架构</strong>：可以通过增加或减少模块来灵活调整应用的功能，而无需对整个应用进行大的改动。</li>
</ol>
<h4 id="缺点-11">缺点：</h4>
<ol type="1">
<li><strong>初期成本较高</strong>：组件化架构的搭建和维护需要一定的技术门槛，初期设计和实施的成本较高。</li>
<li><strong>复杂的依赖管理</strong>：组件化会导致依赖管理变得复杂，特别是在有大量公共库和模块之间存在复杂依赖关系的情况下。</li>
<li></li>
</ol>
<p><strong>性能开销</strong>：如果模块之间的通信频繁，或者路由、依赖注入的使用不当，可能会带来一定的性能开销。</p>
<h3 id="总结-19">总结</h3>
<p>Android
组件化是一种非常有效的架构模式，尤其适用于大型项目或多人协作开发的项目。通过合理的模块划分、解耦的通信方式和灵活的依赖管理，组件化能够提升项目的可维护性和扩展性，同时也能提高开发效率。不过，组件化的实施需要根据项目规模、团队需求和性能考虑权衡进行。</p>
<h2 id="插件化">插件化</h2>
<p>Android
插件化是一种将应用程序的功能模块化，并且在运行时动态加载模块的方法。与组件化不同，插件化的目标是使应用程序的某些功能可以在应用发布后动态添加、更新或移除，而无需重新打包整个应用。通过插件化，开发者可以灵活地更新或扩展应用程序的功能，提升应用的可扩展性和灵活性。</p>
<h3 id="为什么需要插件化">为什么需要插件化？</h3>
<ol type="1">
<li><p><strong>动态扩展</strong>：应用程序的功能可以在运行时动态加载，无需重新打包发布整个应用。例如，可以在应用中实现动态更新某些模块（如业务功能、界面等）。</p></li>
<li><p><strong>减少 APK
大小</strong>：将一些次要或不常用的功能以插件的形式分离出去，用户可以在需要时才下载和加载这些功能，减少初始安装包的体积。</p></li>
<li><p><strong>灵活更新</strong>：通过插件化，可以局部更新应用中的某些功能模块，而无需发布完整的更新包，从而减少用户的更新成本和开发者的发布压力。</p></li>
<li><p><strong>多团队并行开发</strong>：不同功能模块可以作为插件独立开发和测试，团队之间的耦合降低，提升开发效率。</p></li>
<li><p><strong>实现业务隔离</strong>：通过插件化架构，不同业务模块可以相对独立地实现和部署，避免功能模块之间的代码耦合，提升代码的可维护性。</p></li>
</ol>
<h3 id="android-插件化的基本概念">Android 插件化的基本概念</h3>
<ol type="1">
<li><strong>宿主（Host App）</strong>：
<ul>
<li>宿主是插件化系统的核心部分，它负责加载和运行插件，同时管理插件与宿主的交互。</li>
<li>宿主提供了基本的应用框架和资源，插件运行时依赖于宿主提供的环境。</li>
</ul></li>
<li><strong>插件（Plugin）</strong>：
<ul>
<li>插件是一个独立的功能模块，可以被宿主动态加载和运行。插件通常包含自己的代码、资源和配置。</li>
<li>插件可以是一个完整的模块（如登录模块、支付模块），也可以是某个具体的功能（如一个新界面、一个新工具等）。</li>
</ul></li>
<li><strong>插件框架（Plugin Framework）</strong>：
<ul>
<li>插件框架是插件化的基础，它负责管理插件的加载、卸载、资源访问和类的调用等功能。</li>
<li>常见的插件框架有
<strong>RePlugin</strong>、<strong>Small</strong>、<strong>DynamicLoadApk</strong>、<strong>DroidPlugin</strong>
等。</li>
</ul></li>
<li><strong>资源管理（Resource Management）</strong>：
<ul>
<li>插件的资源（如图片、布局文件等）需要与宿主应用的资源隔离开来，插件框架负责解决插件和宿主之间的资源访问问题。</li>
</ul></li>
<li><strong>ClassLoader</strong>：
<ul>
<li>Android 插件化的一个关键技术点是
<strong>ClassLoader</strong>，它用于动态加载插件的类文件，使插件能够在宿主环境中执行。</li>
<li>插件框架通常会通过自定义的 <code>ClassLoader</code>
来实现插件的动态加载和隔离。</li>
</ul></li>
<li><strong>插件生命周期管理</strong>：
<ul>
<li>插件中的 <code>Activity</code>、<code>Service</code>
等组件的生命周期需要通过插件框架进行管理，插件框架会负责将插件中的组件映射到宿主的上下文环境中执行。</li>
</ul></li>
</ol>
<h3 id="插件化的工作原理">插件化的工作原理</h3>
<h4 id="动态加载插件">1. <strong>动态加载插件</strong></h4>
<p>Android 插件化的核心原理是
<strong>动态加载</strong>，即在应用运行时，通过某种机制将插件的代码和资源加载到宿主的内存中，并运行这些代码。其基本流程如下：</p>
<ol type="1">
<li><p><strong>插件打包</strong>：插件通常被打包成 APK
格式，但它不是一个独立运行的应用程序。插件的代码、资源和配置文件（如
<code>AndroidManifest.xml</code>）打包在一起。</p></li>
<li><p><strong>插件的加载</strong>：宿主应用通过插件框架使用
<code>DexClassLoader</code> 或 <code>PathClassLoader</code>
动态加载插件中的代码和资源。这个过程通常需要解决类的查找、资源加载和
<code>AndroidManifest.xml</code> 文件的解析等问题。</p></li>
<li><p><strong>插件组件的运行</strong>：插件的
<code>Activity</code>、<code>Service</code>
等组件不能直接注册到系统中，而是通过插件框架模拟这些组件的生命周期。宿主会将插件的组件映射到宿主环境中运行。</p></li>
</ol>
<h4 id="classloader-动态加载机制">2. <strong>ClassLoader
动态加载机制</strong></h4>
<p>Android 插件化的一个关键点是通过 <strong>ClassLoader</strong>
实现插件的动态加载。插件框架通常使用 <code>DexClassLoader</code>
或自定义 <code>ClassLoader</code> 来加载插件的 <code>.dex</code>
文件（即插件的字节码），从而使插件的代码在宿主中运行。</p>
<ul>
<li><p><strong><code>DexClassLoader</code></strong>：Android
提供的一个类加载器，用于加载外部存储或网络下载的 <code>.dex</code>
文件。插件框架会利用这个类加载器将插件的代码动态加载到内存中。</p></li>
<li><p><strong>类的加载顺序</strong>：插件加载时，ClassLoader
会首先从宿主的类路径中查找需要的类，如果没有找到，则会从插件的
<code>.dex</code>
文件中查找类。这样可以实现插件与宿主之间的类隔离。</p></li>
</ul>
<h4 id="资源管理">3. <strong>资源管理</strong></h4>
<p>插件化的一个重要挑战是 <strong>资源的管理</strong>，因为 Android
的资源（如图片、布局文件等）是通过 <code>R</code>
文件生成的静态引用，而插件的资源和宿主的资源需要分开管理，不能冲突。</p>
<ul>
<li>插件框架通常会通过 <code>AssetManager</code>
动态加载插件的资源包，并将插件的资源加入宿主的资源管理系统中。</li>
<li>宿主和插件的资源 ID 可能会发生冲突，插件框架需要通过
<code>Resources</code> 动态解析插件资源，避免 ID 冲突。</li>
</ul>
<h4 id="activity-的生命周期管理-1">4. <strong>Activity
的生命周期管理</strong></h4>
<p>插件化中，插件的 <code>Activity</code> 不能直接注册到系统的
<code>AndroidManifest.xml</code> 中，因此插件框架需要模拟
<code>Activity</code> 的生命周期，并将插件的 <code>Activity</code>
与宿主的 <code>Activity</code> 进行映射。</p>
<ul>
<li>插件框架会在宿主的 <code>AndroidManifest.xml</code> 中注册一个占位的
<code>Activity</code>（称为代理 <code>Activity</code>），当插件的
<code>Activity</code> 需要启动时，宿主会启动代理
<code>Activity</code>，然后通过反射将插件的 <code>Activity</code>
的生命周期方法映射到代理 <code>Activity</code> 上执行。</li>
</ul>
<h3 id="插件化框架的常见实现">插件化框架的常见实现</h3>
<h4 id="replugin">1. <strong>RePlugin</strong></h4>
<p><strong>RePlugin</strong> 是一个由 360 公司开发的开源 Android
插件化框架，目标是解决复杂的插件化场景，包括插件的动态加载、卸载、资源管理和生命周期管理。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li>支持插件的动态加载和卸载。</li>
<li>插件可以动态更新，且更新过程无需重启宿主应用。</li>
<li>插件和宿主的资源可以独立管理，避免冲突。</li>
<li>支持插件的独立调试，开发体验较好。</li>
</ul></li>
<li><strong>实现原理</strong>：
<ul>
<li>使用自定义的 <code>ClassLoader</code> 来实现插件的动态加载。</li>
<li>通过代理 <code>Activity</code> 来处理插件的组件生命周期问题。</li>
<li>使用 <code>Resources</code> 和 <code>AssetManager</code>
动态管理插件的资源。</li>
</ul></li>
</ul>
<h4 id="small">2. <strong>Small</strong></h4>
<p><strong>Small</strong>
是一个轻量级的插件化框架，适合那些只需要简单插件化场景的应用。它的设计目标是让开发者尽可能少地修改现有项目代码，同时实现应用的插件化。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li>插件轻量化，依赖少，集成简单。</li>
<li>支持资源管理、类加载、Activity 生命周期管理。</li>
<li>支持插件动态加载。</li>
</ul></li>
<li><strong>实现原理</strong>：
<ul>
<li>Small 使用 <code>PathClassLoader</code> 来加载插件的代码。</li>
<li>插件的资源通过 <code>AssetManager</code>
动态加入宿主的资源系统中，保证宿主和插件之间的资源隔离。</li>
</ul></li>
</ul>
<h4 id="droidplugin">3. <strong>DroidPlugin</strong></h4>
<p><strong>DroidPlugin</strong> 是 360
安全团队开发的另一个开源插件化框架，专注于通过插件化实现应用多进程、热更新和动态功能扩展。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li>支持插件的动态安装、卸载、升级。</li>
<li>支持插件的多进程运行。</li>
<li>插件可以访问宿主提供的服务，能够进行复杂的业务逻辑实现。</li>
</ul></li>
<li><strong>实现原理</strong>：
<ul>
<li>DroidPlugin 使用代理机制来启动和管理插件的
<code>Activity</code>、<code>Service</code> 和
<code>BroadcastReceiver</code>。</li>
<li>通过自定义的 <code>ClassLoader</code> 来动态加载插件的代码。</li>
</ul></li>
</ul>
<h4 id="dynamicloadapk">4. <strong>DynamicLoadApk</strong></h4>
<p><strong>DynamicLoadApk</strong> 是另一个简单的插件化框架，主要通过
<code>DexClassLoader</code> 动态加载插件的代码，并通过代理
<code>Activity</code> 来实现插件 <code>Activity</code>
的生命周期管理。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li>插件通过 APK 文件形式加载，插件的代码和宿主隔离。</li>
<li>支持插件 <code>Activity</code> 的生命周期管理。</li>
<li>框架简单易用，适合简单插件化场景。</li>
</ul></li>
</ul>
<h3 id="插件化的实现步骤">插件化的实现步骤</h3>
<ol type="1">
<li><strong>创建宿主应用</strong>：宿主应用是插件化系统的核心，负责加载和管理插件。首先，需要在宿主应用</li>
</ol>
<p>中配置插件框架，并为插件的加载提供接口。</p>
<ol start="2" type="1">
<li><p><strong>创建插件应用</strong>：插件是宿主应用的功能扩展，插件通常打包为
APK 格式，并通过插件框架加载到宿主中运行。</p></li>
<li><p><strong>使用插件框架</strong>：选择合适的插件框架（如
RePlugin、Small、DroidPlugin），并在宿主应用中集成框架代码，处理插件的加载、资源管理和生命周期管理。</p></li>
<li><p><strong>处理组件和资源</strong>：插件中的组件（如
Activity、Service）和资源（如图片、布局文件）需要通过插件框架进行加载和管理，确保插件和宿主的资源和组件能够正确工作。</p></li>
</ol>
<h3 id="插件化的挑战">插件化的挑战</h3>
<ol type="1">
<li><p><strong>性能问题</strong>：插件化框架在加载和卸载插件时，会涉及到大量的反射操作、资源加载等，可能会影响性能。特别是在低端设备上，插件的加载速度可能较慢。</p></li>
<li><p><strong>资源冲突</strong>：插件和宿主的资源可能会发生冲突，特别是资源
ID 重复的问题。插件框架需要解决资源的隔离和冲突问题。</p></li>
<li><p><strong>兼容性问题</strong>：不同的 Android
版本和设备在处理插件加载和资源管理时，可能会表现出不同的行为，这需要插件框架进行兼容性处理。</p></li>
<li><p><strong>调试难度</strong>：插件的动态加载和运行增加了调试的难度，开发者需要使用特定的工具和框架来调试插件中的问题。</p></li>
</ol>
<h3 id="总结-20">总结</h3>
<p>Android
插件化是一种强大的架构模式，它允许应用程序在运行时动态加载和卸载功能模块，提升应用的灵活性和扩展性。插件化的核心原理是通过
<code>ClassLoader</code>
动态加载插件的代码，并通过插件框架处理插件的资源和组件生命周期管理。常见的插件化框架如
RePlugin、Small、DroidPlugin
等，能够帮助开发者快速实现应用的插件化。</p>
<p>插件化的实施可以解决应用程序动态更新、功能扩展、模块化开发等问题，但同时也带来了性能、资源冲突和兼容性等挑战。开发者在使用插件化时需要根据具体需求权衡利弊，并选择合适的框架和实现方案。</p>
<h2 id="热更新">热更新</h2>
<p><strong>Android
热更新</strong>（Hotfix）是一种在应用程序无需重新安装或从应用商店下载新版本的情况下，动态修复代码或资源错误的技术。通过热更新技术，开发者可以在不经过
Google Play 等应用商店重新发布应用的情况下修复应用中的
Bug，甚至在某些情况下动态更新应用中的某些业务逻辑。</p>
<h3 id="为什么需要热更新">为什么需要热更新？</h3>
<ol type="1">
<li><p><strong>快速修复
Bug</strong>：应用发布后，可能会出现一些紧急问题或
Bug，传统的方式需要重新打包、发布、等待用户更新，这个过程可能会导致修复延迟，影响用户体验。热更新可以立即修复这些问题。</p></li>
<li><p><strong>减少发布成本</strong>：每次发布新版本的应用都需要经过打包、测试、上架等一系列复杂流程，热更新能够节省开发和发布的时间成本。</p></li>
<li><p><strong>增强灵活性</strong>：热更新可以动态修改应用中的某些逻辑或资源，提升应用的灵活性。</p></li>
<li><p><strong>减少应用重新发布的频率</strong>：通过热更新技术，可以减少应用频繁上架应用市场的次数，减少对用户造成的打扰。</p></li>
</ol>
<h3 id="热更新的基本原理">热更新的基本原理</h3>
<p>Android
热更新的基本原理是通过动态加载机制，替换应用程序中的部分代码或资源，使应用在运行时能够使用新的代码或资源，而无需重新安装或重启应用。其主要实现方式有以下几种：</p>
<ol type="1">
<li><p><strong>类替换（Class
Replacement）</strong>：在应用运行时，通过修改类加载器（<code>ClassLoader</code>）的加载逻辑，将有问题的类替换为修复后的类。</p></li>
<li><p><strong>方法替换（Method
Hooking）</strong>：通过字节码修改技术，将应用中的某些方法替换为新的方法，这样可以在不改变整个类的情况下修复部分方法。</p></li>
<li><p><strong>资源替换（Resource
Replacement）</strong>：通过动态加载外部资源包的方式，替换应用中的图片、布局、字符串等资源。</p></li>
</ol>
<h3 id="热更新的实现方式">热更新的实现方式</h3>
<p>目前，Android 热更新技术主要通过以下几种方式实现：</p>
<h4 id="dex-文件替换">1. <strong>Dex 文件替换</strong></h4>
<p>Dex 文件是 Android
中的可执行文件格式，它包含了应用程序的字节码。通过热更新技术，可以在应用运行时动态加载新的
Dex 文件，替换掉原来的有问题的类。</p>
<ul>
<li><strong>关键技术</strong>：
<ul>
<li>使用 <code>DexClassLoader</code> 或 <code>PathClassLoader</code>
动态加载新的 Dex 文件。</li>
<li>通过修改 <code>ClassLoader</code> 的父加载器，将新 Dex
中的类优先加载，覆盖掉原应用中的类。</li>
</ul></li>
<li><strong>示例流程</strong>：
<ol type="1">
<li>应用运行时，发现某个类存在问题。</li>
<li>从服务器下载修复后的 Dex 文件。</li>
<li>使用 <code>DexClassLoader</code> 动态加载这个 Dex
文件，并替换有问题的类。</li>
</ol></li>
<li><strong>优点</strong>：可以灵活地替换整个类，适用于修复逻辑错误。</li>
<li><strong>缺点</strong>：修改的是整个类，粒度相对较大，且存在兼容性问题。</li>
</ul>
<h4 id="方法替换hook-技术">2. <strong>方法替换（Hook
技术）</strong></h4>
<p>方法替换是一种更加精细的热更新技术。通过 Hook
技术，可以在不替换整个类的情况下，仅替换有问题的方法。这种方式使用了字节码操作技术，通过修改运行时方法的字节码来实现方法级别的替换。</p>
<ul>
<li><strong>关键技术</strong>：
<ul>
<li>使用字节码操作框架，如 <strong>ASM</strong> 或
<strong>JavaAssist</strong>，在运行时动态修改方法的字节码。</li>
<li>Hook Android 的类加载器，拦截方法的调用，并替换为修复后的逻辑。</li>
</ul></li>
<li><strong>示例流程</strong>：
<ol type="1">
<li>应用运行时发现某个方法存在 Bug。</li>
<li>从服务器下载包含新方法的字节码。</li>
<li>使用字节码修改工具，将旧方法替换为新方法。</li>
</ol></li>
<li><strong>优点</strong>：可以只替换有问题的方法，避免对整个类的替换，修复粒度更细。</li>
<li><strong>缺点</strong>：实现复杂，尤其是在不同版本的 Android
系统上存在兼容性问题。</li>
</ul>
<h4 id="资源替换">3. <strong>资源替换</strong></h4>
<p>热更新不仅限于代码的修复，某些情况下，应用中的资源文件（如图片、布局、字符串等）也可能需要动态更新。通过资源替换技术，可以在不重启应用的情况下，动态更新应用的资源。</p>
<ul>
<li><strong>关键技术</strong>：
<ul>
<li>动态加载资源包（APK、AAR 或其他格式）。</li>
<li>使用反射或 <code>AssetManager</code>
将外部资源与应用的资源系统整合。</li>
</ul></li>
<li><strong>示例流程</strong>：
<ol type="1">
<li>应用发现某个资源有问题。</li>
<li>从服务器下载新的资源文件（如 APK 包中的资源）。</li>
<li>使用 <code>AssetManager</code> 加载新资源，替换旧资源。</li>
</ol></li>
<li><strong>优点</strong>：可以动态更新应用的图片、布局等静态资源，不需要重新安装应用。</li>
<li><strong>缺点</strong>：资源的替换相对简单，但可能需要与代码的热更新结合使用。</li>
</ul>
<h3 id="热更新的常用框架">热更新的常用框架</h3>
<h4 id="tinker微信开源">1. <strong>Tinker（微信开源）</strong></h4>
<p><strong>Tinker</strong>
是腾讯微信团队开源的一个热修复框架，支持类、So
库、资源等多种类型的修复。Tinker 是目前最流行的 Android
热修复框架之一，广泛应用于大多数 Android 应用中。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>支持 Dex 修复：可以动态替换应用中的代码。</li>
<li>支持资源修复：可以动态加载新的图片、布局等资源。</li>
<li>支持 So 库修复：可以修复应用中的本地库文件。</li>
</ul></li>
<li><p><strong>原理</strong>： Tinker 通过生成一个 Patch
文件（补丁包），这个补丁包包含需要修复的 Dex 文件、资源或 So
文件。应用运行时加载这个补丁包，并通过反射和 <code>ClassLoader</code>
动态替换原有的代码和资源。</p></li>
<li><p><strong>Tinker 工作流程</strong>：</p>
<ol type="1">
<li>构建补丁包：开发者通过 Tinker
工具生成一个补丁包，包含需要修复的代码和资源。</li>
<li>应用加载补丁包：应用启动时，通过 Tinker 框架加载补丁包。</li>
<li>动态替换：Tinker 框架通过自定义的 <code>ClassLoader</code> 和
<code>AssetManager</code> 将补丁包中的内容替换到原有的应用中。</li>
</ol></li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>支持多种修复类型，功能强大。</li>
<li>已在多个大型应用中验证，稳定性好。</li>
</ul></li>
<li><p><strong>劣势</strong>：</p>
<ul>
<li>实现相对复杂，集成门槛较高。</li>
<li>对于大版本更新，热修复的效果有限。</li>
</ul></li>
</ul>
<h4 id="andfix阿里巴巴开源">2.
<strong>AndFix（阿里巴巴开源）</strong></h4>
<p><strong>AndFix</strong>
是阿里巴巴开源的一个轻量级的热修复框架，专注于方法级别的替换，适合快速修复线上
Bug。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>修复粒度小：AndFix
通过修改方法字节码实现热修复，不需要替换整个类。</li>
<li>使用方便：无需重新打包应用，可以通过补丁文件直接修复 Bug。</li>
</ul></li>
<li><p><strong>原理</strong>： AndFix 利用 <code>JNI</code>
技术修改方法的字节码，从而在运行时替换掉有问题的方法。修复的补丁是基于方法级别的字节码修改，而不是替换整个
Dex 文件。</p></li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>修复粒度小，效率高。</li>
<li>实现简单，开发者容易上手。</li>
</ul></li>
<li><p><strong>劣势</strong>：</p>
<ul>
<li>只支持方法级别的修复，适用场景有限。</li>
<li>由于底层依赖于 <code>JNI</code> 和
<code>ASM</code>，可能会存在一定的兼容性问题。</li>
</ul></li>
</ul>
<h4 id="robust美团点评开源">3.
<strong>Robust（美团点评开源）</strong></h4>
<p><strong>Robust</strong>
是美团点评开源的另一个热修复框架，专注于解决类、方法的修复问题。Robust
提供了不同的修复方案，适用于不同的业务场景。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>支持类和方法的替换，修复粒度灵活。</li>
<li>提供了不同的模式（如全量模式和增量模式）来满足不同的业务需求。</li>
</ul></li>
<li><p><strong>原理</strong>： 通过代理机制，Robust
在运行时创建一个类的代理对象，并将代理对象的方法指向修复后的方法实现。通过这种方式，Robust
可以在不修改原始类的情况下，修复其中的 Bug。</p></li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>提供多种修复模式，适用场景广泛。</li>
<li>不依赖 <code>JNI</code>，兼容性较好。</li>
</ul></li>
<li><p><strong>劣势</strong>：</p>
<ul>
<li>修复效率相对较低。</li>
<li>实现相对复杂。</li>
</ul></li>
</ul>
<h4 id="nuwa">4. <strong>Nuwa</strong></h4>
<p><strong>Nuwa</strong> 是另一个早期的 Android 热修复框架，Nuwa
采用了类似 Tinker 的实现方式，但更加轻</p>
<p>量，专注于 Dex 文件的修复。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li>支持 Dex 修复，重点是修复逻辑错误。</li>
<li>较为简单，适合快速集成和使用。</li>
</ul></li>
<li><strong>优势</strong>：
<ul>
<li>实现简单，轻量级。</li>
<li>不依赖过多的外部框架。</li>
</ul></li>
<li><strong>劣势</strong>：
<ul>
<li>不支持资源和 So 文件的修复。</li>
<li>功能相对较为单一。</li>
</ul></li>
</ul>
<h3 id="热更新技术的挑战">热更新技术的挑战</h3>
<p>尽管热更新可以极大地提高开发和发布效率，但实现热更新时仍然面临着一些技术挑战：</p>
<ol type="1">
<li><p><strong>兼容性问题</strong>：不同版本的 Android
系统中，<code>ClassLoader</code>
和资源管理机制有所不同，可能导致热更新在某些设备上不兼容或无法正常工作。尤其是在
Android 5.0 及以上，ART 虚拟机引入了新的机制，使得 Dex
文件的修改更加困难。</p></li>
<li><p><strong>安全性问题</strong>：热更新的补丁文件通常需要通过网络下载，这会带来一定的安全风险。如果补丁文件没有做好安全校验，可能被恶意攻击者利用，篡改补丁内容。热更新框架需要对补丁进行严格的签名和校验。</p></li>
<li><p><strong>性能问题</strong>：由于热更新涉及到类加载器的修改、字节码的替换等操作，可能会带来一定的性能开销。过多或频繁的热更新可能导致应用启动变慢或运行时的性能下降。</p></li>
<li><p><strong>系统限制</strong>：Google 从 Android 7.0 开始对动态加载的
APK 进行了限制，增加了对 <code>Dex</code>
文件的验证和优化，某些热更新框架在新的 Android 版本上可能失效。</p></li>
</ol>
<h3 id="总结-21">总结</h3>
<p>Android 热更新技术为开发者提供了一种在应用运行时动态修复 Bug
或更新代码的能力。通过 Dex
文件替换、方法级别修复、资源替换等方式，开发者可以在不重新打包应用的情况下快速修复问题或更新功能。</p>
<p>常见的热更新框架如
<strong>Tinker</strong>、<strong>AndFix</strong>、<strong>Robust</strong>
等，为开发者提供了不同的解决方案。每种框架都有其独特的实现方式和适用场景，开发者可以根据自己的需求选择合适的框架。</p>
<p>尽管热更新具有显著的优点，但在实际应用中也面临兼容性、安全性和性能方面的挑战。开发者在使用热更新技术时需要权衡利弊，确保应用的稳定性和用户体验。</p>
<h2 id="线程间通信">线程间通信</h2>
<p>在 Android
开发中，线程间通信是一项非常重要的任务，尤其是在处理多线程操作时，比如在后台线程中执行耗时任务，然后将结果返回到主线程更新
UI。由于 Android 的 UI
操作只能在主线程中执行，线程间的通信机制变得尤为关键。以下是几种常见的
Android 线程间通信方式：</p>
<h3 id="handler">1. <strong>Handler</strong></h3>
<p><code>Handler</code> 是 Android
中最常用的线程间通信工具。它主要用于将消息从后台线程传递到主线程，从而更新
UI。<code>Handler</code>
工作机制是将消息放入一个线程的消息队列中，Looper
再循环处理这些消息。</p>
<ul>
<li><strong>工作原理</strong>：
<ol type="1">
<li><code>Looper</code> 负责轮询消息队列。</li>
<li><code>Handler</code> 用于发送消息。</li>
<li><code>Message</code> 是传递的数据载体。</li>
</ol></li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在子线程中进行耗时操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> performTask();</span><br><span class="line">        <span class="comment">// 将结果传递给主线程</span></span><br><span class="line">        handler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 更新 UI</span></span><br><span class="line">                textView.setText(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="asynctask已废弃使用替代方案">2.
<strong>AsyncTask</strong>（已废弃，使用替代方案）</h3>
<p><code>AsyncTask</code>
过去用于在后台线程执行任务并在主线程中返回结果。由于存在内存泄漏风险和并发控制不佳的缺陷，从
Android API 30 开始已经被废弃。</p>
<p>建议使用 <code>ExecutorService</code> 和 <code>Handler</code>
组合来替代 <code>AsyncTask</code>。</p>
<h3 id="executor-future-callable">3. <strong>Executor + Future +
Callable</strong></h3>
<p><code>ExecutorService</code> 是一种管理线程池的方式，可以用来替代
<code>AsyncTask</code> 执行异步任务。通过 <code>Future</code>
可以获取任务的执行结果，使用 <code>Callable</code> 来返回结果。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 执行后台任务</span></span><br><span class="line">        <span class="keyword">return</span> performTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();  <span class="comment">// 获取任务结果</span></span><br><span class="line">            handler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 更新 UI</span></span><br><span class="line">                    textView.setText(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="handlerthread">4. <strong>HandlerThread</strong></h3>
<p><code>HandlerThread</code> 是一个带有 <code>Looper</code>
的线程。通过 <code>HandlerThread</code> 可以轻松地创建后台线程，并且利用
<code>Handler</code> 来处理它的消息队列。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HandlerThread</span> <span class="variable">handlerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;MyHandlerThread&quot;</span>);</span><br><span class="line">handlerThread.start();</span><br><span class="line"><span class="type">Handler</span> <span class="variable">backgroundHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(handlerThread.getLooper());</span><br><span class="line"></span><br><span class="line">backgroundHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行后台任务</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> performTask();</span><br><span class="line">        <span class="comment">// 使用主线程的 handler 更新 UI</span></span><br><span class="line">        handler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                textView.setText(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="broadcastreceiver-1">5. <strong>BroadcastReceiver</strong></h3>
<p><code>BroadcastReceiver</code> 主要用于不同组件（Activity、Service
等）之间的通信。它也可以用于线程间通信，尤其在多个线程之间需要广播事件时。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<ol type="1">
<li><p>发送广播： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.UPDATE_UI&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;Hello from background&quot;</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></p></li>
<li><p>接收广播： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BroadcastReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        textView.setText(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">registerReceiver(receiver, <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(<span class="string">&quot;com.example.UPDATE_UI&quot;</span>));</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="eventbus">6. <strong>EventBus</strong></h3>
<p><code>EventBus</code>
是一个第三方库，它简化了线程间的通信流程。通过发布-订阅模式，可以轻松地在后台线程发布事件，并在主线程订阅和处理这些事件。</p>
<ul>
<li><strong>基本步骤</strong>：
<ol type="1">
<li>在后台线程发布事件。</li>
<li>在主线程订阅该事件并处理。</li>
</ol></li>
</ul>
<p><strong>总结</strong>： Android
提供了多种线程间通信的机制。最常用的方案是基于 <code>Handler</code>
的方法，因为它与 Android
的消息队列机制紧密集成。对于一些复杂的场景，诸如
<code>ExecutorService</code> 和 <code>HandlerThread</code>
也能提供更灵活的多线程处理能力。</p>
<h2 id="android-的四种启动模式及实践场景">Android
的四种启动模式及实践场景</h2>
<p>在 Android 开发中，Activity 的四种启动模式（Launch Mode）是指在
AndroidManifest.xml 中通过 <code>android:launchMode</code>
属性或在代码中通过 Intent 的标志位来控制 Activity
的启动行为。这四种启动模式分别是
<code>standard</code>、<code>singleTop</code>、<code>singleTask</code>
和
<code>singleInstance</code>，每种模式适用于不同的实践场景。以下是对它们的详细说明及其应用场景：</p>
<h3 id="standard标准模式">1. <strong>standard（标准模式）</strong></h3>
<ul>
<li><strong>描述</strong>：这是默认的启动模式。每次启动一个
Activity，都会创建一个新的实例并将其压入任务栈中，无论该 Activity
是否已经存在。</li>
<li><strong>行为</strong>：每次调用
<code>startActivity()</code>，都会生成一个新的实例，即使栈中已经存在相同的
Activity。</li>
<li><strong>实践场景</strong>：
<ul>
<li>适用于大多数普通的页面跳转场景，例如从列表页进入详情页。</li>
<li>示例：一个新闻应用中，用户从新闻列表点击进入不同的新闻详情页面，每次点击都会创建一个新的详情页实例。</li>
</ul></li>
<li><strong>注意</strong>：如果不指定 <code>launchMode</code>，Activity
默认使用此模式。</li>
</ul>
<hr />
<h3 id="singletop栈顶复用模式">2.
<strong>singleTop（栈顶复用模式）</strong></h3>
<ul>
<li><strong>描述</strong>：如果目标 Activity
已经位于任务栈的栈顶，则不会创建新实例，而是复用栈顶的现有实例，并调用其
<code>onNewIntent()</code> 方法传递新的 Intent
数据；如果不在栈顶，则会创建新实例。</li>
<li><strong>行为</strong>：避免在栈顶重复创建相同的 Activity。</li>
<li><strong>实践场景</strong>：
<ul>
<li>适用于需要避免重复打开相同页面的场景，例如搜索页面。</li>
<li>示例：一个搜索应用中，用户在搜索结果页再次点击“搜索”按钮，不希望创建新的搜索结果页，而是更新当前页面的内容。</li>
</ul></li>
<li><strong>注意</strong>：如果栈顶不是目标 Activity，则行为与
<code>standard</code> 相同。</li>
</ul>
<hr />
<h3 id="singletask栈内复用模式">3.
<strong>singleTask（栈内复用模式）</strong></h3>
<ul>
<li><strong>描述</strong>：在任务栈中只允许存在一个该 Activity
的实例。如果栈中不存在该
Activity，则创建新实例并压入栈中；如果栈中已存在，则清除其上方的所有
Activity，并调用已有实例的 <code>onNewIntent()</code> 方法。</li>
<li><strong>行为</strong>：确保任务栈中只有一个实例，适合作为应用的“根”或“主”页面。</li>
<li><strong>实践场景</strong>：
<ul>
<li>适用于应用的首页或核心功能页面，避免重复创建。</li>
<li>示例：一个社交应用的主界面（如微信的聊天列表），无论从通知栏还是其他页面返回，都只复用现有的主界面实例，并清理其上方的栈。</li>
</ul></li>
<li><strong>注意</strong>：这种模式会影响任务栈的结构，需谨慎使用。</li>
</ul>
<hr />
<h3 id="singleinstance单实例模式">4.
<strong>singleInstance（单实例模式）</strong></h3>
<ul>
<li><strong>描述</strong>：该模式会为 Activity
创建一个独立的任务栈，且该栈中只允许存在这一个 Activity 实例。其他
Activity 无法进入该任务栈。</li>
<li><strong>行为</strong>：完全独立于其他任务栈，适合完全隔离的
Activity。</li>
<li><strong>实践场景</strong>：
<ul>
<li>适用于与主应用逻辑完全分离的功能，例如拨号界面或第三方授权登录页面。</li>
<li>示例：一个应用中调用系统拨号界面，拨号界面运行在独立的任务栈中，完成后返回原应用。</li>
</ul></li>
<li><strong>注意</strong>：这种模式会创建新的任务栈，通常用于跨应用的交互场景。</li>
</ul>
<hr />
<h3 id="代码示例-1"><strong>代码示例</strong></h3>
<p>在 AndroidManifest.xml 中配置启动模式： <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>通过 Intent 动态设置启动模式： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MainActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="总结对比"><strong>总结对比</strong></h3>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 16%" />
<col style="width: 36%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>启动模式</th>
<th>实例数量</th>
<th>任务栈行为</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>standard</td>
<td>多个实例</td>
<td>每次创建新实例压栈</td>
<td>普通页面跳转</td>
</tr>
<tr class="even">
<td>singleTop</td>
<td>栈顶复用</td>
<td>栈顶复用，其他情况新建</td>
<td>搜索结果页</td>
</tr>
<tr class="odd">
<td>singleTask</td>
<td>栈内单实例</td>
<td>栈内复用，清栈至该实例</td>
<td>应用主界面</td>
</tr>
<tr class="even">
<td>singleInstance</td>
<td>全局单实例</td>
<td>独立任务栈，仅一个实例</td>
<td>拨号或授权页面</td>
</tr>
</tbody>
</table>
<p>根据实际需求选择合适的启动模式，可以优化应用的导航体验和资源使用效率。</p>
<h1 id="java">Java</h1>
<h2 id="hashmap的实现原理">HashMap的实现原理</h2>
<p><code>HashMap</code> 是 Java
集合框架中的一个常用数据结构，基于哈希表（Hash
Table）实现，用于存储键值对（key-value）数据。<code>HashMap</code>
的核心思想是通过哈希函数快速定位键的位置，进而实现高效的查找、插入和删除操作。以下是
<code>HashMap</code> 的实现原理及其主要特性。</p>
<h3 id="基本结构">1. <strong>基本结构</strong></h3>
<p><code>HashMap</code>
主要基于<strong>数组</strong>和<strong>链表</strong>（JDK 1.8
之前）或<strong>红黑树</strong>（JDK 1.8
及之后）的数据结构来实现。它的核心结构如下：</p>
<ul>
<li><p><strong>数组（Node[] table）</strong>：哈希表的核心部分是一个
<code>Node</code> 数组，数组中的每个元素是一个链表的头节点（JDK 1.8
之前）或红黑树的根节点（JDK 1.8 之后）。</p></li>
<li><p><strong>链表或红黑树</strong>：当多个键的哈希值相同时，会发生哈希冲突。在
JDK 1.8 之前，冲突的键值对会以链表的形式存储在数组的同一个位置上；而在
JDK 1.8 之后，当冲突的链表长度超过一定阈值（默认是
8）时，链表会转化为红黑树以提高性能。</p></li>
</ul>
<h3 id="存储单元node">2. <strong>存储单元：Node</strong></h3>
<p>每个键值对都封装在一个 <code>Node</code> 对象中，<code>Node</code> 是
<code>HashMap</code> 中的内部类。<code>Node</code> 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;      <span class="comment">// 哈希值</span></span><br><span class="line">    <span class="keyword">final</span> K key;         <span class="comment">// 键</span></span><br><span class="line">    V value;             <span class="comment">// 值</span></span><br><span class="line">    Node&lt;K,V&gt; next;      <span class="comment">// 指向下一个节点的指针 (用于链表)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hash</code>：键的哈希值。</li>
<li><code>key</code>：存储的键。</li>
<li><code>value</code>：存储的值。</li>
<li><code>next</code>：用于指向下一个节点（当发生哈希冲突时，形成链表）。</li>
</ul>
<h3 id="哈希函数">3. <strong>哈希函数</strong></h3>
<p><code>HashMap</code>
通过哈希函数将键映射到数组的索引位置。哈希函数的目的是通过键计算出一个整数（即哈希值），然后通过取模运算将哈希值映射到数组中的一个具体位置。</p>
<ul>
<li><p><strong>哈希值的计算</strong>： <code>HashMap</code> 使用键的
<code>hashCode()</code>
方法来计算哈希值。为了减少哈希冲突并提高分布的均匀性，<code>HashMap</code>
会进一步处理 <code>hashCode()</code> 返回的哈希值。JDK 1.8
中的实现将高位的哈希值与低位异或（XOR）运算以减少冲突：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>数组索引计算</strong>： <code>HashMap</code> 使用
<code>哈希值 % 数组长度</code>
的方式将哈希值映射到数组的某个索引位置（实际上是通过
<code>hash &amp; (table.length - 1)</code>
位运算来计算索引，这比取模运算效率更高）。</p></li>
</ul>
<h3 id="处理哈希冲突">4. <strong>处理哈希冲突</strong></h3>
<p>哈希冲突发生在多个键具有相同的哈希值并映射到数组的同一位置时。<code>HashMap</code>
通过以下两种方式处理哈希冲突：</p>
<h4 id="链地址法链表">1. <strong>链地址法（链表）</strong>：</h4>
<p>在 JDK 1.8 之前，<code>HashMap</code>
处理冲突时使用的是链地址法。多个哈希值相同的元素会被存储在同一个数组位置（即
<code>Node</code>），形成一个链表。新的元素会插入到链表的末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入新节点</span></span><br><span class="line">Node&lt;K,V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 将新节点挂在原链表的末尾</span></span><br><span class="line">lastNode.next = newNode;</span><br></pre></td></tr></table></figure>
<h4 id="红黑树树化">2. <strong>红黑树（树化）</strong>：</h4>
<p>在 JDK 1.8 之后，当链表长度超过 8
时，链表会转化为红黑树。红黑树的查找、插入和删除的时间复杂度为 O(log
n)，相比链表的 O(n) 效率更高。</p>
<ul>
<li>当链表的长度超过阈值（8）时，<code>HashMap</code>
会自动将链表转换为红黑树。</li>
<li>如果红黑树的节点数量减少到 6
以下，树会被重新转换回链表，以节省内存开销。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// TREEIFY_THRESHOLD is 8</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>
<h3 id="扩容机制">5. <strong>扩容机制</strong></h3>
<p><code>HashMap</code>
的底层数组有容量限制，当数组的元素过多时，发生哈希冲突的概率增大，因此需要动态扩容来保持较低的冲突率。<code>HashMap</code>
的扩容机制如下：</p>
<ul>
<li><p><strong>触发条件</strong>：当哈希表中的元素数量超过数组容量与负载因子（<code>load factor</code>）的乘积时，会触发扩容操作。默认负载因子是
0.75。</p>
<ul>
<li>计算公式：<code>元素数量 &gt; 数组容量 * 负载因子</code></li>
</ul></li>
<li><p><strong>扩容过程</strong>：扩容时，<code>HashMap</code>
将数组的容量扩大为原来的两倍，并将旧数组中的所有元素重新哈希并放入新的数组中。这一过程称为<strong>rehash</strong>。</p></li>
<li><p><strong>rehash
的计算</strong>：重新计算所有键的哈希值并将它们放入新数组，键的位置可能会改变（因为数组容量变大了）。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> table.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCap</span> <span class="operator">=</span> oldCap * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 创建一个更大的新数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTable = <span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">// 将旧数组中的元素重新映射到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex</span> <span class="operator">=</span> e.hash &amp; (newCap - <span class="number">1</span>);</span><br><span class="line">            e.next = newTable[newIndex];</span><br><span class="line">            newTable[newIndex] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找过程">6. <strong>查找过程</strong></h3>
<p>查找操作通过键来查找相应的值，基本流程如下：</p>
<ol type="1">
<li>通过哈希函数计算出键的哈希值。</li>
<li>通过哈希值计算出数组中的索引位置。</li>
<li>在对应位置，如果是链表，遍历链表查找对应键；如果是红黑树，通过树的查找逻辑查找相应键。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 通过哈希值计算数组下标并查找</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 检查首节点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123; <span class="comment">// 检查链表或树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除操作">7. <strong>删除操作</strong></h3>
<p>删除操作的过程和查找类似，首先根据键计算哈希值，再通过索引找到对应的链表或树结构，找到后将其从链表中删除或从树中移除。</p>
<h3 id="hashmap-的性能">8. <strong><code>HashMap</code>
的性能</strong></h3>
<ul>
<li><strong>时间复杂度</strong>：在理想情况下，<code>HashMap</code>
的查找、插入和删除操作的时间复杂度是
O(1)。这是因为哈希表的设计使得每次操作都能快速通过哈希值定位到元素。
<ul>
<li>如果发生哈希冲突并且链表很长，时间复杂度可能退化为 O(n)，但在 JDK
1.8 之后，通过红黑树的引入，最坏情况下时间复杂度也只是 O(log n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：<code>HashMap</code>
的空间复杂度主要取决于其底层数组和存储的元素数量。当哈希冲</li>
</ul>
<p>突严重时，链表和树会占用额外的空间。</p>
<h3 id="总结-22">总结</h3>
<ul>
<li><code>HashMap</code>
是一种基于哈希表的数据结构，使用了哈希函数来实现快速的键值对存取。</li>
<li>它通过数组、链表和红黑树相结合的方式处理哈希冲突，提高查找和插入的效率。</li>
<li>它支持动态扩容，通过重新计算哈希值将元素分布到更大的数组中，以保持哈希表的性能。</li>
</ul>
<h2 id="jni中java如何调c">JNI中Java如何调C++</h2>
<p>在JNI（Java Native Interface）中，Java 调用 C++
代码的过程需要通过定义 Native 方法并进行 JNI
函数调用。以下是Java调用C++代码的详细步骤和机制：</p>
<h3 id="声明-native-方法">1. <strong>声明 Native 方法</strong></h3>
<p>在 Java 中，使用 <code>native</code>
关键字声明一个原生方法，这个方法的实现会在 C/C++ 代码中。Java
代码并不实现这个方法，而是依赖 JNI 来调用 C/C++ 代码。</p>
<p>例如，Java类中可以这样声明一个 Native 方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个本地(native)方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载本地库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>); <span class="comment">// 加载名为 native-lib 的库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>nativeMethod()</strong>：这是在 Java 中声明的原生方法。</li>
<li><strong>System.loadLibrary(“native-lib”)</strong>：这个方法会加载名为
<code>native-lib</code> 的本地库，确保 C/C++ 代码可以被调用。</li>
</ul>
<h3 id="生成-cc-头文件">2. <strong>生成 C/C++ 头文件</strong></h3>
<p>使用 <code>javac</code> 编译 Java 文件，然后使用 <code>javah</code>
工具生成对应的 C/C++ 头文件（<code>.h</code>
文件）。这个文件会为本地方法生成一个对应的函数声明。</p>
<p>例如：</p>
<p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">javac NativeExample.java   <span class="comment"># 编译 Java 文件</span></span><br><span class="line">javah NativeExample        <span class="comment"># 生成 JNI 头文件</span></span><br></pre></td></tr></table></figure></p>
<p><code>javah</code> 工具会生成一个头文件
<code>NativeExample.h</code>，其中包含对应的 C/C++ 函数声明，例如：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Header for class NativeExample */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Included_NativeExample</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Included_NativeExample</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     NativeExample</span></span><br><span class="line"><span class="comment"> * Method:    nativeMethod</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_NativeExample_nativeMethod</span><span class="params">(JNIEnv *, jobject)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>Java_NativeExample_nativeMethod</code>: 这是由
<code>javah</code> 根据 Java 类名和方法名自动生成的 C 函数名。</li>
<li><code>JNIEnv *</code>: 这是 JNI 环境指针，提供了大量可以在 C/C++
中调用 Java API 的函数。</li>
<li><code>jobject</code>: 代表的是 Java 中调用这个方法的实例对象。</li>
</ul>
<h3 id="实现-native-方法-cc-实现">3. <strong>实现 Native 方法 (C/C++
实现)</strong></h3>
<p>在生成的头文件基础上，开发者需要实现这个 C/C++ 函数。</p>
<p>例如，可以在 <code>native-lib.cpp</code> 中实现这个函数：</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现 nativeMethod 函数</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_NativeExample_nativeMethod</span><span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from C++!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键点：</p>
<ul>
<li><strong>JNIEXPORT</strong> 和 <strong>JNICALL</strong>
是修饰符，确保函数可以被 JNI 机制正确调用。</li>
<li><strong>JNIEnv</strong> 提供了丰富的接口，可以在 C/C++ 中操作 Java
对象或调用 Java 方法。</li>
<li><strong>jobject</strong> 是对 Java 对象的引用，通过它可以访问调用该
Native 方法的 Java 对象。</li>
</ul>
<h3 id="编译-cc-代码并生成库">4. <strong>编译 C/C++
代码并生成库</strong></h3>
<p>将 C/C++ 代码编译成动态库。这个库的名字需要与 Java 中通过
<code>System.loadLibrary()</code> 加载的库名一致。</p>
<p>在 Linux 中，可以这样编译 C++ 代码：</p>
<p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ -shared -fPIC -o libnative-lib.so native-lib.cpp -I<span class="variable">$&#123;JAVA_HOME&#125;</span>/include -I<span class="variable">$&#123;JAVA_HOME&#125;</span>/include/linux</span><br></pre></td></tr></table></figure></p>
<p>关键参数：</p>
<ul>
<li><code>-shared</code>: 编译为共享库（即 <code>.so</code>
文件）。</li>
<li><code>-fPIC</code>:
生成与位置无关的代码，以便可以用于动态加载。</li>
<li><code>-o libnative-lib.so</code>: 指定输出文件为共享库
<code>libnative-lib.so</code>，Java 将加载此库。</li>
<li><code>-I</code>: 指定包含 JNI 头文件的路径。</li>
</ul>
<h3 id="运行-java-代码">5. <strong>运行 Java 代码</strong></h3>
<p>在 Java 中，通过 <code>System.loadLibrary("native-lib")</code>
加载编译后的共享库，然后可以直接调用定义的 <code>nativeMethod()</code>
方法。</p>
<p>例如，Java 类 <code>NativeExample</code> 可以这样调用：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NativeExample</span>().nativeMethod(); <span class="comment">// 调用C++实现的 nativeMethod</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序时，Java 将通过 JNI 调用 <code>native-lib</code> 中的
<code>nativeMethod()</code> 实现，最终执行 C/C++ 代码并输出结果。</p>
<h3 id="jni-调用机制的关键概念">6. <strong>JNI
调用机制的关键概念</strong></h3>
<ul>
<li><p><strong>JNIEnv</strong>：这是 JNI 环境的指针，JNI
提供了很多函数供 C/C++ 代码调用，例如，调用 Java 方法、访问 Java
对象、操作字符串等。通过 <code>JNIEnv</code>，可以实现很多 Java 和 C/C++
的交互。</p></li>
<li><p><strong>jobject</strong>：这是 Java 对象的引用，C/C++
可以通过这个对象调用 Java 中的成员方法或属性。</p></li>
<li><p><strong>类型映射</strong>：Java 和 C/C++
之间的数据类型不完全一致，JNI 提供了一些特定的数据类型，例如：</p>
<ul>
<li><code>jint</code> 对应于 Java 的 <code>int</code></li>
<li><code>jboolean</code> 对应于 Java 的 <code>boolean</code></li>
<li><code>jstring</code> 对应于 Java 的 <code>String</code></li>
</ul></li>
</ul>
<h3 id="调用java方法和访问字段">7.
<strong>调用Java方法和访问字段</strong></h3>
<p>在 C/C++ 中，不仅可以实现 Native 方法，还可以通过 JNI 机制调用 Java
对象的方法，或访问 Java 对象的字段。常用的函数包括：</p>
<ul>
<li><p><strong>调用Java方法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jclass clazz = env-&gt;<span class="built_in">GetObjectClass</span>(obj);</span><br><span class="line">jmethodID methodID = env-&gt;<span class="built_in">GetMethodID</span>(clazz, <span class="string">&quot;methodName&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">env-&gt;<span class="built_in">CallVoidMethod</span>(obj, methodID);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>访问Java字段</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jfieldID fieldID = env-&gt;<span class="built_in">GetFieldID</span>(clazz, <span class="string">&quot;fieldName&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">jint fieldValue = env-&gt;<span class="built_in">GetIntField</span>(obj, fieldID);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-23">总结：</h3>
<p>Java 调用 C/C++ 代码的流程可以总结为以下步骤：</p>
<ol type="1">
<li>在 Java 中声明 <code>native</code> 方法。</li>
<li>通过 <code>javah</code> 工具生成 C/C++ 头文件。</li>
<li>在 C/C++ 中实现这些头文件声明的函数。</li>
<li>编译 C/C++ 代码为动态库，并在 Java 中加载这个库。</li>
<li>通过 JNI 环境（<code>JNIEnv</code>）在 C/C++ 中调用 Java
方法、访问字段或进行对象交互。</li>
</ol>
<h2 id="jni中c如何调java">JNI中C++如何调Java</h2>
<p>在JNI（Java Native Interface）中，C++ 调用 Java
方法的过程称为”从Native代码调用Java代码”。这种调用通常发生在C++代码需要通知Java端事件，或使用Java提供的某些功能时。以下是C++调用Java代码的详细步骤和机制：</p>
<h3 id="获取jni环境指针-jnienv">1. <strong>获取JNI环境指针
(<code>JNIEnv</code>)</strong></h3>
<p>每个Native方法中，JNI环境指针<code>JNIEnv *</code>是一个非常重要的参数，它提供了调用Java方法的所有接口。在任何一个Native方法中，<code>JNIEnv *</code>都是自动提供的。可以通过它调用Java中的方法、访问类、对象等。</p>
<h3 id="获取java类">2. <strong>获取Java类</strong></h3>
<p>在调用Java方法之前，C++代码首先需要通过<code>JNIEnv</code>获取到相应的Java类。可以通过以下方式获取Java类的引用：</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jclass clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/example/YourJavaClass&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>com/example/YourJavaClass</code>
是Java类的完全限定名（包名+类名）。此时，<code>clazz</code>
是对该Java类的引用。</p>
<h3 id="获取java方法id">3. <strong>获取Java方法ID</strong></h3>
<p>为了调用Java方法，C++代码需要通过<code>JNIEnv</code>获取方法的标识符（<code>jmethodID</code>）。调用Java的方法可能是实例方法（对象方法）或静态方法。</p>
<ul>
<li><p><strong>获取实例方法ID</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jmethodID methodID = env-&gt;<span class="built_in">GetMethodID</span>(clazz, <span class="string">&quot;methodName&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>methodName</code>: 要调用的Java方法的名称。</li>
<li><code>"(I)V"</code>:
方法的签名，其中<code>(I)</code>表示方法参数为一个<code>int</code>类型，<code>V</code>表示返回类型为<code>void</code>。</li>
</ul></li>
<li><p><strong>获取静态方法ID</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jmethodID staticMethodID = env-&gt;<span class="built_in">GetStaticMethodID</span>(clazz, <span class="string">&quot;staticMethodName&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>GetStaticMethodID</code> 用于获取静态方法的ID。</li>
<li><code>"(Ljava/lang/String;)V"</code>
是方法签名，表示参数为一个<code>String</code>类型，返回类型为<code>void</code>。</li>
</ul></li>
</ul>
<p>Java方法的签名格式：</p>
<ul>
<li>基本类型：
<ul>
<li><code>Z</code>：<code>boolean</code></li>
<li><code>B</code>：<code>byte</code></li>
<li><code>C</code>：<code>char</code></li>
<li><code>S</code>：<code>short</code></li>
<li><code>I</code>：<code>int</code></li>
<li><code>J</code>：<code>long</code></li>
<li><code>F</code>：<code>float</code></li>
<li><code>D</code>：<code>double</code></li>
<li><code>V</code>：<code>void</code></li>
</ul></li>
<li>引用类型（对象）使用全路径的形式表示，例如<code>Ljava/lang/String;</code>
表示<code>java.lang.String</code>。</li>
</ul>
<h3 id="调用java方法">4. <strong>调用Java方法</strong></h3>
<p>获取了Java类和方法ID后，C++代码可以调用该Java方法。具体方法取决于你调用的是实例方法还是静态方法。</p>
<ul>
<li><p><strong>调用实例方法</strong>：</p>
<ul>
<li>首先需要一个Java对象实例（<code>jobject</code>），可以通过传入的参数或者构造方法创建一个对象。</li>
<li>然后调用实例方法：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jobject obj = <span class="comment">// 已有的Java对象或通过构造方法创建;</span></span><br><span class="line">env-&gt;<span class="built_in">CallVoidMethod</span>(obj, methodID, <span class="number">42</span>);  <span class="comment">// 传入参数42，调用Java方法</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>CallVoidMethod</code>
是用于调用返回类型为<code>void</code>的方法。类似地，有：</p>
<ul>
<li><code>CallIntMethod()</code>：调用返回<code>int</code>的方法</li>
<li><code>CallObjectMethod()</code>：调用返回Java对象的方法</li>
<li><code>CallBooleanMethod()</code> 等其他类型的方法调用函数。</li>
</ul></li>
<li><p><strong>调用静态方法</strong>：
如果调用的是静态方法，就不需要<code>jobject</code>，而是通过类的引用调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">env-&gt;<span class="built_in">CallStaticVoidMethod</span>(clazz, staticMethodID, env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello from C++&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建java对象实例">5. <strong>创建Java对象实例</strong></h3>
<p>如果需要在C++中创建一个Java对象，C++可以通过调用Java类的构造方法来实例化Java对象。过程如下：</p>
<ul>
<li><p><strong>获取构造方法ID</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jmethodID constructorID = env-&gt;<span class="built_in">GetMethodID</span>(clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里<code>"&lt;init&gt;"</code>表示构造方法，<code>(Ljava/lang/String;)V</code>
表示构造方法的签名，即参数是<code>String</code>，返回值为<code>void</code>。</p></li>
<li><p><strong>创建对象</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jobject obj = env-&gt;<span class="built_in">NewObject</span>(clazz, constructorID, env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>上述代码会创建一个新实例，并调用Java类的构造函数。</p></li>
</ul>
<h3 id="访问java字段">6. <strong>访问Java字段</strong></h3>
<p>除了调用Java方法，C++代码还可以访问Java对象的成员字段（包括静态字段和实例字段）。</p>
<ul>
<li><p><strong>获取实例字段ID</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jfieldID fieldID = env-&gt;<span class="built_in">GetFieldID</span>(clazz, <span class="string">&quot;fieldName&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>fieldName</code>是Java中的字段名，<code>"I"</code>表示该字段是<code>int</code>类型。</p></li>
<li><p><strong>读取字段值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jint fieldValue = env-&gt;<span class="built_in">GetIntField</span>(obj, fieldID);</span><br></pre></td></tr></table></figure>
<p>使用 <code>Get&lt;Type&gt;Field()</code> 来获取字段值，这里的
<code>&lt;Type&gt;</code>
是字段的类型，如<code>Int</code>、<code>Boolean</code>、<code>Object</code>等。</p></li>
<li><p><strong>设置字段值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">env-&gt;<span class="built_in">SetIntField</span>(obj, fieldID, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>Set&lt;Type&gt;Field()</code> 设置字段值。</p></li>
</ul>
<h3 id="完整示例c-调用-java-方法">7. <strong>完整示例：C++ 调用 Java
方法</strong></h3>
<p>假设我们在 Java 类 <code>JavaExample</code> 中有如下代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance method called with value: &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method called with message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C++中，可以如下调用这个Java类的方法：</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT <span class="type">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_MyNativeClass_nativeMethod</span><span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 Java 类</span></span><br><span class="line">    jclass javaClass = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/example/JavaExample&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用实例方法</span></span><br><span class="line">    jmethodID instanceMethodID = env-&gt;<span class="built_in">GetMethodID</span>(javaClass, <span class="string">&quot;instanceMethod&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    jobject javaObj = env-&gt;<span class="built_in">NewObject</span>(javaClass, env-&gt;<span class="built_in">GetMethodID</span>(javaClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>));</span><br><span class="line">    env-&gt;<span class="built_in">CallVoidMethod</span>(javaObj, instanceMethodID, <span class="number">42</span>);  <span class="comment">// 传入42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用静态方法</span></span><br><span class="line">    jmethodID staticMethodID = env-&gt;<span class="built_in">GetStaticMethodID</span>(javaClass, <span class="string">&quot;staticMethod&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    jstring message = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello from C++&quot;</span>);</span><br><span class="line">    env-&gt;<span class="built_in">CallStaticVoidMethod</span>(javaClass, staticMethodID, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异常处理">8. <strong>异常处理</strong></h3>
<p>在使用 JNI 调用 Java 方法时，C++ 代码应该处理可能出现的 Java
异常。可以通过以下方法检查是否有异常抛出：</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (env-&gt;<span class="built_in">ExceptionCheck</span>()) &#123;</span><br><span class="line">    env-&gt;<span class="built_in">ExceptionDescribe</span>();  <span class="comment">// 打印异常信息</span></span><br><span class="line">    env-&gt;<span class="built_in">ExceptionClear</span>();     <span class="comment">// 清除异常状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结-24">总结：</h3>
<p>C++ 调用 Java 方法的流程大致如下：</p>
<ol type="1">
<li><strong>获取JNI环境指针</strong>：使用<code>JNIEnv</code>来调用Java代码。</li>
<li><strong>获取Java类引用</strong>：通过<code>FindClass</code>获取Java类。</li>
<li><strong>获取方法ID</strong>：使用<code>GetMethodID</code>或<code>GetStaticMethodID</code>获取实例方法或静态方法的ID。</li>
<li><strong>调用方法</strong>：使用<code>Call&lt;Type&gt;Method</code>或<code>CallStatic&lt;Type&gt;Method</code>来调用实例方法或静态方法。</li>
<li><strong>访问Java字段</strong>：使用<code>GetFieldID</code>获取字段ID，然后通过<code>Get&lt;Type&gt;Field</code>或<code>Set&lt;Type&gt;Field</code>访问或修改字段值。</li>
</ol>
<p>通过这些步骤，C++代码可以灵活地与Java代码进行交互。</p>
<h2 id="内存模型">内存模型</h2>
<p>JVM（Java Virtual Machine，Java 虚拟机）的内存模型定义了 Java
程序运行时内存的管理方式，包括内存区域的划分、数据的存储方式以及垃圾回收机制等。JVM
内存模型可以划分为多个区域，这些区域用于存储不同类型的数据，并且各区域的生命周期和作用也有所不同。</p>
<h3 id="jvm-内存模型主要分为以下几个部分">JVM
内存模型主要分为以下几个部分：</h3>
<ol type="1">
<li><strong>程序计数器 (Program Counter Register)</strong>：
<ul>
<li>这是一块很小的内存区域，用来存储每个线程当前执行的字节码指令的地址。因为
JVM
是多线程的，每个线程都有一个独立的程序计数器，用于记录当前线程所执行的字节码指令的地址。</li>
<li>如果线程正在执行的是一个本地方法（native
method），程序计数器为空（undefined）。</li>
</ul></li>
<li><strong>Java 虚拟机栈 (Java Virtual Machine Stack)</strong>：
<ul>
<li>每个线程都有一个独立的 Java
虚拟机栈，栈中存放着每个方法调用的栈帧（Stack
Frame），包括局部变量、操作数栈、动态链接和方法的返回地址。</li>
<li><strong>局部变量表</strong> 存放方法的局部变量，包括基本数据类型（如
<code>int</code>, <code>long</code>, <code>float</code>,
<code>double</code>）和对象的引用。</li>
<li>每个方法被调用时，都会在虚拟机栈中创建一个栈帧，方法执行完毕后，栈帧出栈。</li>
<li>栈的大小可以通过启动参数 <code>-Xss</code> 来设置。</li>
</ul></li>
<li><strong>本地方法栈 (Native Method Stack)</strong>：
<ul>
<li>与 Java
虚拟机栈类似，但本地方法栈用于存储本地方法调用时的信息，本地方法是指使用
JNI（Java Native Interface）调用的非 Java 方法，如 C 或 C++ 代码。</li>
<li>这一部分内存区域是与平台相关的，主要用于处理平台相关的原生代码。</li>
</ul></li>
<li><strong>堆 (Heap)</strong>：
<ul>
<li>堆是 JVM
内存中最大的一块区域，几乎所有对象都存储在堆中，垃圾回收器主要关注的也是这个区域。</li>
<li>堆在 JVM
启动时创建，所有线程共享这一块内存，任何线程都可以访问堆中的对象。</li>
<li><strong>堆的结构</strong>：
<ul>
<li><strong>新生代 (Young Generation)</strong>:
新生代是对象最先创建的区域，分为三个部分：一个 “Eden” 区和两个
“Survivor” 区（S0 和 S1）。
<ul>
<li>当一个对象首次被创建时，会被分配到 Eden 区，当 Eden
区满时，存活下来的对象会被移到 Survivor 区。</li>
<li>在新生代经过几次垃圾回收依然存活的对象，会被晋升到老年代。</li>
</ul></li>
<li><strong>老年代 (Old Generation)</strong>:
老年代存储生命周期较长的对象，即从新生代中晋升过来的对象。老年代垃圾回收频率较低，但回收时耗时较长。</li>
</ul></li>
<li>堆内存的大小可以通过 <code>-Xms</code> 和 <code>-Xmx</code>
参数来设置。</li>
</ul></li>
<li><strong>方法区 (Method Area)</strong>：
<ul>
<li>方法区是所有线程共享的，用于存储类的元数据（Class
Metadata）、常量、静态变量、即时编译器编译后的代码（JIT 代码）等。</li>
<li>方法区可以看作是堆的逻辑部分，但它专门用于存储与类相关的结构数据。</li>
<li>在 HotSpot JVM 中，方法区是由 <strong>元空间 (Metaspace)</strong>
实现的。在 Java 8 之前，方法区也被称为永久代（PermGen），从 Java 8
开始，永久代被元空间取代。
<ul>
<li>元空间的内存空间是由系统的本地内存而非 JVM
堆来管理，因此相比之前版本的永久代，减少了 OutOfMemoryError
的问题。</li>
</ul></li>
</ul></li>
<li><strong>运行时常量池 (Runtime Constant Pool)</strong>：
<ul>
<li>运行时常量池是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。比如，字符串常量、数字常量、方法引用等。</li>
<li>它不仅包括 Java
源代码中的常量，还包含运行时才能确定的动态常量。</li>
</ul></li>
</ol>
<h3 id="jvm-内存模型的内存区域图示">JVM 内存模型的内存区域图示：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------------------------+</span><br><span class="line">|       Method Area (Metaspace)      |</span><br><span class="line">|    - Class Metadata                |</span><br><span class="line">|    - Constant Pool                 |</span><br><span class="line">|    - Static Variables              |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|           Heap (Heap Space)        |</span><br><span class="line">|    - Young Generation              |</span><br><span class="line">|    - Old Generation                |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|    Java Virtual Machine Stack      |</span><br><span class="line">|    - Stack Frames                  |</span><br><span class="line">|    - Local Variables               |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|       Native Method Stack          |</span><br><span class="line">|    - Native Method Information     |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|      Program Counter Register      |</span><br><span class="line">+------------------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收-garbage-collection">垃圾回收 (Garbage Collection)</h3>
<p>JVM
提供了自动的垃圾回收机制，用来释放不再使用的对象。垃圾回收的主要目标是堆内存，特别是新生代和老年代。常用的垃圾回收算法有：</p>
<ol type="1">
<li><strong>标记-清除算法 (Mark and Sweep)</strong>：
<ul>
<li>垃圾回收器会首先遍历对象图，标记所有存活的对象。然后，它会清除未被标记的对象，回收相应的内存空间。</li>
</ul></li>
<li><strong>复制算法 (Copying)</strong>：
<ul>
<li>主要用于新生代。它将对象分配到 Eden 区和 Survivor
区之间，并在垃圾回收时将存活的对象复制到空的 Survivor
区，释放其他空间。</li>
</ul></li>
<li><strong>标记-压缩算法 (Mark-Compact)</strong>：
<ul>
<li>主要用于老年代。标记存活对象后，将存活对象压缩到堆的一端，释放连续的内存空间。</li>
</ul></li>
</ol>
<h3 id="总结-25">总结</h3>
<p>JVM
的内存模型通过堆、方法区、栈、程序计数器等多个区域的划分和管理，来保证
Java
程序的高效运行，同时通过垃圾回收机制实现内存自动管理。理解这些内存区域的工作原理有助于优化
Java 程序的性能和内存使用。</p>
<h2 id="垃圾回收">垃圾回收</h2>
<p>Java 的垃圾回收机制（Garbage Collection，简称 GC）是 Java
语言的一大优势之一，它自动管理内存分配和释放，程序员无需手动处理内存释放，减少了内存泄漏和程序崩溃的可能性。垃圾回收机制通过追踪对象的生命周期，回收不再被引用的对象所占用的内存。</p>
<h3 id="垃圾回收的基本原理">垃圾回收的基本原理</h3>
<p>垃圾回收的核心任务是找到并删除不再被程序使用的对象。JVM
使用<strong>根可达性算法</strong>（Reachability
Analysis）来判断对象是否可以被回收。该算法通过判断对象是否可以从<strong>GC
Root</strong>到达（即是否有引用链可达），如果一个对象从 GC Root
不可达，那么该对象就被认为是垃圾，可以被回收。</p>
<h4 id="gc-roots-常见的有">GC Roots 常见的有：</h4>
<ul>
<li>当前线程栈中的局部变量。</li>
<li>方法区中静态变量。</li>
<li>方法区中的常量。</li>
<li>JNI 引用的对象（Native 方法中的引用）。</li>
</ul>
<h3 id="垃圾回收的主要算法">垃圾回收的主要算法</h3>
<p>Java 的垃圾回收机制主要依赖以下几种算法：</p>
<ol type="1">
<li><strong>标记-清除算法 (Mark-Sweep)</strong>：
<ul>
<li><strong>过程</strong>：
<ul>
<li><strong>标记阶段</strong>：从 GC Root
开始，遍历所有的引用对象，标记活跃对象。</li>
<li><strong>清除阶段</strong>：遍历整个堆，回收未被标记的对象。</li>
</ul></li>
<li><strong>优点</strong>：不需要额外空间来存储对象。</li>
<li><strong>缺点</strong>：容易产生内存碎片，导致较大的对象无法分配连续的内存空间。</li>
</ul></li>
<li><strong>复制算法 (Copying)</strong>：
<ul>
<li><strong>过程</strong>：
<ul>
<li>将内存分为两块区域，每次只使用其中的一块。当一块内存空间用完时，将存活的对象复制到另一块空间，然后清空当前的内存空间。</li>
</ul></li>
<li><strong>优点</strong>：不产生内存碎片，分配内存效率较高。</li>
<li><strong>缺点</strong>：需要额外的内存空间（通常是将新生代内存分为
Eden 和两个 Survivor 区）。</li>
<li><strong>应用场景</strong>：主要用于 Java 堆中的新生代。</li>
</ul></li>
<li><strong>标记-整理算法 (Mark-Compact)</strong>：
<ul>
<li><strong>过程</strong>：
<ul>
<li>首先标记所有的活跃对象，之后将所有的存活对象压缩到内存的一端，保持内存的连续性，最后清除端边界外的空间。</li>
</ul></li>
<li><strong>优点</strong>：避免了内存碎片问题。</li>
<li><strong>缺点</strong>：整理过程需要移动对象，开销较大。</li>
<li><strong>应用场景</strong>：主要用于老年代。</li>
</ul></li>
<li><strong>分代收集算法</strong>：
<ul>
<li><strong>基本思想</strong>：Java
中的对象按其生命周期长短被分为不同的代，垃圾回收器采用不同的算法来管理不同区域的内存。</li>
<li><strong>分代结构</strong>：
<ul>
<li><strong>新生代 (Young
Generation)</strong>：新创建的对象会首先分配到新生代。新生代中的对象通常“朝生夕死”，垃圾回收频繁，回收速度较快。
<ul>
<li><strong>Eden 区</strong>：大多数新对象在这里分配。</li>
<li><strong>Survivor 区</strong>：包含两个区 (S0, S1)，存活的对象会从
Eden 区复制到其中一个 Survivor 区，当该 Survivor
区满时，活跃对象会复制到另一个 Survivor 区或进入老年代。</li>
</ul></li>
<li><strong>老年代 (Old
Generation)</strong>：存活时间较长、生命周期较长的对象会被晋升到老年代，老年代的垃圾回收频率较低，但耗时较长。</li>
<li><strong>永久代/元空间 (Permanent
Generation/Metaspace)</strong>：存储类的元数据（在 Java 8
之后，永久代被元空间取代）。</li>
</ul></li>
</ul></li>
</ol>
<h3 id="java-垃圾回收器">Java 垃圾回收器</h3>
<p>JVM 中有多种不同的垃圾回收器，适合不同的应用场景，常见的有：</p>
<ol type="1">
<li><strong>Serial GC</strong>：
<ul>
<li>单线程的垃圾回收器，适用于小型应用程序。</li>
<li>优点：简单、低内存开销。</li>
<li>缺点：GC 时会暂停所有应用线程（即所谓的“Stop the
World”），效率较低。</li>
</ul></li>
<li><strong>Parallel GC</strong>（也叫做 “吞吐量优先垃圾回收器”）：
<ul>
<li>多线程垃圾回收器，适合高吞吐量的应用程序。</li>
<li>优点：并行执行 GC，能够处理大量的对象分配。</li>
<li>缺点：在高响应需求的应用中，可能不够快速。</li>
</ul></li>
<li><strong>CMS GC (Concurrent Mark-Sweep Garbage Collector)</strong>：
<ul>
<li>低延迟的垃圾回收器，适用于需要低停顿时间的应用程序。</li>
<li>优点：标记和清除过程是并发执行的，减少了长时间的停顿。</li>
<li>缺点：会产生内存碎片，并且在高并发下，垃圾回收线程与应用线程可能会争抢资源。</li>
</ul></li>
<li><strong>G1 GC (Garbage First Garbage Collector)</strong>：
<ul>
<li>Java 7 引入的一种新的垃圾回收器，设计用于取代 CMS。</li>
<li><strong>分区收集</strong>：将堆划分为多个相同大小的区域，根据区域内的垃圾回收优先级进行回收，优先清理垃圾最多的区域。</li>
<li><strong>优点</strong>：能够提供更可预测的停顿时间，适合大内存、多处理器的系统，降低了大规模老年代
GC 的延迟。</li>
<li><strong>缺点</strong>：比 CMS 更复杂。</li>
</ul></li>
<li><strong>ZGC (Z Garbage Collector)</strong>：
<ul>
<li>在 Java 11
引入的一种超低延迟垃圾回收器，设计用于处理超大堆内存。</li>
<li><strong>优点</strong>：能处理 TB 级别的堆，并且 GC
停顿时间非常短（通常在 10 毫秒以下）。</li>
<li><strong>缺点</strong>：实现复杂，并且相比传统 GC
可能会占用更多的内存。</li>
</ul></li>
</ol>
<h3 id="垃圾回收的触发机制">垃圾回收的触发机制</h3>
<p>垃圾回收不是随时都可以发生的，通常会在以下情况下触发： 1.
当堆内存中的<strong>新生代</strong>（Eden
区）空间耗尽时，会触发<strong>Minor GC</strong>，它只清理新生代。 2.
当堆内存中的<strong>老年代</strong>空间耗尽时，会触发<strong>Major
GC</strong> 或 <strong>Full
GC</strong>，它会清理整个堆，包括新生代和老年代。Full GC
的代价较高，通常伴随长时间的暂停。</p>
<h3 id="垃圾回收的调优">垃圾回收的调优</h3>
<p>为了提高应用的性能，开发者可以根据实际需求调整垃圾回收器的策略。调优时可以根据以下参数进行设置：
- <strong>-Xms</strong> 和
<strong>-Xmx</strong>：设置堆的初始大小和最大大小。 -
<strong>-XX:NewSize</strong> 和
<strong>-XX:MaxNewSize</strong>：设置新生代的大小。 -
<strong>-XX:SurvivorRatio</strong>：设置 Eden 区与 Survivor 区的比例。 -
<strong>-XX:+UseG1GC</strong>：启用 G1 垃圾回收器。 -
<strong>-XX:+UseZGC</strong>：启用 ZGC 垃圾回收器。</p>
<h3 id="总结-26">总结</h3>
<p>Java
的垃圾回收机制通过自动回收不再使用的对象，简化了内存管理，同时不同的垃圾回收器和算法适应不同类型的应用场景。在高性能应用中，理解和调优垃圾回收机制是提升应用性能的重要手段。</p>
<h2 id="常用设计模式">常用设计模式</h2>
<p>设计模式是软件开发中的一种通用解决方案，用于解决某类常见的设计问题。设计模式并不是具体的代码，而是经过总结的、可复用的解决方案，可以帮助开发者编写高效、可维护和可扩展的代码。设计模式分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。以下是常用的设计模式及其解释和应用场景。</p>
<hr />
<h3 id="创建型模式">1. <strong>创建型模式</strong></h3>
<p>创建型模式关注对象的创建方式，目的是将对象的创建过程与其使用分离，以提高系统的灵活性和可扩展性。</p>
<h4 id="单例模式-singleton-pattern">1.1 <strong>单例模式 (Singleton
Pattern)</strong></h4>
<p><strong>意图</strong>：保证一个类只有一个实例，并提供一个全局访问点。</p>
<ul>
<li><strong>应用场景</strong>：用于需要一个类有且仅有一个实例的情况，比如全局配置对象、日志系统、线程池等。</li>
<li><strong>实现</strong>：通过私有化构造函数、提供一个静态方法来获取唯一的实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="工厂方法模式-factory-method-pattern">1.2 <strong>工厂方法模式
(Factory Method Pattern)</strong></h4>
<p><strong>意图</strong>：定义一个创建对象的接口，但让子类决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p>
<ul>
<li><strong>应用场景</strong>：需要根据不同的条件创建不同类型的对象时，可以使用工厂方法模式。</li>
<li><strong>实现</strong>：通过定义一个抽象工厂类，子类根据需要创建具体对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Product A created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Product B created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactoryA</span> <span class="keyword">extends</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象工厂模式-abstract-factory-pattern">1.3 <strong>抽象工厂模式
(Abstract Factory Pattern)</strong></h4>
<p><strong>意图</strong>：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体的类。</p>
<ul>
<li><strong>应用场景</strong>：当需要创建多个相关联的对象时，使用抽象工厂模式。</li>
<li><strong>实现</strong>：定义多个工厂接口，分别用于创建相关的产品族。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    Checkbox <span class="title function_">createCheckbox</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WinFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Checkbox <span class="title function_">createCheckbox</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinCheckbox</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Checkbox <span class="title function_">createCheckbox</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacCheckbox</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="建造者模式-builder-pattern">1.4 <strong>建造者模式 (Builder
Pattern)</strong></h4>
<p><strong>意图</strong>：将对象的创建与表示分离，使得相同的创建过程可以构建不同的对象。</p>
<ul>
<li><strong>应用场景</strong>：用于创建复杂对象，特别是当构建过程复杂时，如创建包含多个步骤的对象时。</li>
<li><strong>实现</strong>：通过一个 <code>Builder</code>
类逐步构造复杂对象，最后返回完整对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartA</span><span class="params">(String partA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartB</span><span class="params">(String partB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProductBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProductBuilder <span class="title function_">buildPartA</span><span class="params">(String partA)</span> &#123;</span><br><span class="line">        product.setPartA(partA);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProductBuilder <span class="title function_">buildPartB</span><span class="params">(String partB)</span> &#123;</span><br><span class="line">        product.setPartB(partB);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="结构型模式">2. <strong>结构型模式</strong></h3>
<p>结构型模式关注类和对象的组合，帮助我们更好地组织代码结构，特别是在类继承和对象组合方面提供更灵活的解决方案。</p>
<h4 id="适配器模式-adapter-pattern">2.1 <strong>适配器模式 (Adapter
Pattern)</strong></h4>
<p><strong>意图</strong>：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。</p>
<ul>
<li><strong>应用场景</strong>：当你需要使用一个已有的类，但它的接口与其他代码不兼容时，使用适配器模式。</li>
<li><strong>实现</strong>：通过创建一个适配器类，桥接客户类和需要适配的类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Specific Request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="装饰器模式-decorator-pattern">2.2 <strong>装饰器模式 (Decorator
Pattern)</strong></h4>
<p><strong>意图</strong>：动态地给对象添加额外的职责，而不是通过继承来扩展功能。</p>
<ul>
<li><strong>应用场景</strong>：用于需要动态地为对象添加功能的时候，例如对核心功能进行增强。</li>
<li><strong>实现</strong>：通过装饰器类包装原始对象，并在装饰器类中添加新功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Concrete Component operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;Additional functionality in decorator&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代理模式-proxy-pattern">2.3 <strong>代理模式 (Proxy
Pattern)</strong></h4>
<p><strong>意图</strong>：为其他对象提供一个代理，以控制对该对象的访问。</p>
<ul>
<li><strong>应用场景</strong>：用于延迟加载、控制访问权限、在访问对象时添加额外的逻辑等场景。</li>
<li><strong>实现</strong>：代理类实现目标接口，并控制对目标对象的访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Real Service Request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealService realService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realService == <span class="literal">null</span>) &#123;</span><br><span class="line">            realService = <span class="keyword">new</span> <span class="title class_">RealService</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Proxy Service Request&quot;</span>);</span><br><span class="line">        realService.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="行为型模式">3. <strong>行为型模式</strong></h3>
<p>行为型模式关注对象之间的交互及职责的划分，定义了对象之间如何通信和协作。</p>
<h4 id="观察者模式-observer-pattern">3.1 <strong>观察者模式 (Observer
Pattern)</strong></h4>
<p><strong>意图</strong>：定义对象间的一对多依赖，当一个对象的状态发生改变时，所有依赖于它的对象都会自动收到通知。</p>
<ul>
<li><strong>应用场景</strong>：用于事件处理机制，发布-订阅系统，典型的应用是
GUI 事件处理和消息系统。</li>
<li><strong>实现</strong>：通过维护观察者列表，在被观察者状态变化时通知所有观察者。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteObserver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; received message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="策略模式-strategy-pattern">3.2 <strong>策略模式 (Strategy
Pattern)</strong></h4>
<p><strong>意图</strong>：定义一系列算法，将每个算法封装起来，并使它们可以相互替换。策略模式使得算法的变化不会影响使用算法的客户。</p>
<ul>
<li><strong>应用场景</strong>：用于需要动态选择算法或行为的场景，例如支付方式的选择、排序算法的切换等。</li>
<li><strong>实现</strong>：将不同的算法实现封装到具体的策略类中，通过统一接口调用不同的策略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing Strategy A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing Strategy B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命令模式-command-pattern">3.3 <strong>命令模式 (Command
Pattern)</strong></h4>
<p><strong>意图</strong>：将请求封装成一个对象，从而可以用不同的请求对客户进行参数化，以及对请求排队或记录请求日志。</p>
<ul>
<li><strong>应用场景</strong>：用于执行请求操作的场景，如按钮点击、撤销操作等。</li>
<li><strong>实现</strong>：通过将请求封装为命令对象，然后在需要的时候调用这些命令对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOnCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressButton</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结-27">总结</h3>
<ul>
<li><strong>创建型模式</strong>
解决对象创建问题，确保系统中的对象创建过程灵活可控（如单例、工厂、建造者等）。</li>
<li><strong>结构型模式</strong>
解决类或对象的组合问题，确保系统的不同部分能灵活、有效地协作（如适配器、代理、装饰器等）。</li>
<li><strong>行为型模式</strong>
解决对象之间的交互问题，确保对象之间的职责分配合理且合作顺畅（如观察者、策略、命令等）。</li>
</ul>
<p>不同的设计模式有助于解决软件开发中的常见问题，通过合理选择合适的设计模式，可以提高代码的可维护性、可复用性和可扩展性。</p>
<h2 id="并发编程">并发编程</h2>
<p><strong>Java
并发编程</strong>是指在多线程环境下，协调多个线程并发执行任务的编程技术。并发编程是
Java
语言中的一个重要特性，它允许程序在多核处理器上充分利用计算资源，提高程序的运行效率。然而，并发编程也带来了线程同步、数据共享和竞态条件等挑战。Java
提供了一整套工具和类库来帮助开发者编写高效且安全的并发程序。</p>
<h3 id="为什么需要并发编程">为什么需要并发编程？</h3>
<ol type="1">
<li><strong>提高性能</strong>：在多核处理器上，通过并发编程可以让多个任务同时执行，提高程序的效率。</li>
<li><strong>优化资源使用</strong>：并发编程允许程序在 I/O
操作（如网络请求、文件读写）或其他阻塞操作期间执行其他任务，从而更好地利用系统资源。</li>
<li><strong>响应性</strong>：在 GUI
程序中，使用并发编程可以让主线程负责界面渲染，而后台线程执行耗时任务，避免用户界面卡顿。</li>
</ol>
<hr />
<h3 id="java-并发编程的基本概念">Java 并发编程的基本概念</h3>
<h4 id="线程">1. <strong>线程</strong></h4>
<p>线程是 Java
并发编程的基本单位。每个线程代表程序中的一个执行路径。Java 提供了
<code>Thread</code> 类和 <code>Runnable</code>
接口来创建和管理线程。</p>
<ul>
<li><strong>创建线程</strong>：
<ul>
<li>通过继承 <code>Thread</code> 类： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">thread.start();  <span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure></li>
<li>通过实现 <code>Runnable</code> 接口： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="线程的生命周期">2. <strong>线程的生命周期</strong></h4>
<p>Java 线程的生命周期通常包括以下几个阶段： -
<strong>新建（New）</strong>：线程被创建，但还没有启动。 -
<strong>就绪（Runnable）</strong>：线程已经准备好，并等待 CPU
资源进行执行。 - <strong>运行（Running）</strong>：线程正在执行中。 -
<strong>阻塞（Blocked）</strong>：线程在等待某个条件（如锁、I/O）时进入阻塞状态。
-
<strong>死亡（Terminated）</strong>：线程的任务完成，或因异常退出，线程进入终止状态。</p>
<hr />
<h3 id="线程同步与共享资源">线程同步与共享资源</h3>
<p>当多个线程共享同一个资源时，可能会发生<strong>竞态条件</strong>（Race
Condition），导致程序出现错误。Java
提供了多种机制来实现线程同步，以确保多个线程能够安全地访问共享资源。</p>
<h4 id="synchronized-关键字">1. <strong>synchronized
关键字</strong></h4>
<p><code>synchronized</code> 是 Java
中最基础的同步机制，它用于锁定某个对象，使得同一时间只有一个线程能够访问被锁定的代码块或方法。</p>
<ul>
<li><strong>同步方法</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 同步代码，确保同一时间只有一个线程执行此方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>同步代码块</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当线程进入 <code>synchronized</code>
方法或代码块时，会自动获取对象的锁，一旦线程完成执行或抛出异常，锁会被自动释放。</p>
<h4 id="volatile-关键字">2. <strong>volatile 关键字</strong></h4>
<p><code>volatile</code>
关键字用于标记变量，使其在多个线程间可见。它确保了变量的修改会立即被写入主内存，并且每次读取时都从主内存读取。</p>
<ul>
<li><strong>使用场景</strong>：适用于简单的共享变量（如状态标志）的场景，但不适合复杂的同步逻辑。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="lock-接口">3. <strong>Lock 接口</strong></h4>
<p><code>Lock</code> 是一种更灵活的锁机制，相比
<code>synchronized</code>，它提供了更多的控制和功能。例如，<code>Lock</code>
可以在获取不到锁时等待，也可以尝试非阻塞地获取锁。</p>
<ul>
<li><strong>ReentrantLock</strong>：常用的 <code>Lock</code>
实现类，支持可重入锁。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();   <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="线程间通信-1">线程间通信</h3>
<p>线程之间需要通过某种方式进行通信，以协调它们的执行顺序。Java
提供了多种线程间通信的机制。</p>
<h4 id="wait-notify-notifyall">1. <strong>wait() / notify() /
notifyAll()</strong></h4>
<p><code>wait()</code>、<code>notify()</code> 和
<code>notifyAll()</code> 是 Java
提供的原始线程通信方法，它们必须在同步块或同步方法中使用。</p>
<ul>
<li><code>wait()</code>：使当前线程进入等待状态，直到另一个线程调用
<code>notify()</code> 或 <code>notifyAll()</code>。</li>
<li><code>notify()</code>：唤醒等待该对象锁的某一个线程。</li>
<li><code>notifyAll()</code>：唤醒等待该对象锁的所有线程。</li>
</ul>
<p>示例： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForCondition</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            wait();  <span class="comment">// 等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">changeCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        notify();  <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="condition-接口">2. <strong>Condition 接口</strong></h4>
<p><code>Condition</code> 是与 <code>Lock</code>
配合使用的线程通信机制，它提供了类似 <code>wait()</code> 和
<code>notify()</code> 的功能，但更为灵活。每个 <code>Lock</code>
对象可以创建多个 <code>Condition</code>
实例，实现更精细的线程通信控制。</p>
<ul>
<li>使用 <code>Condition</code>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    condition.await();  <span class="comment">// 当前线程等待</span></span><br><span class="line">    condition.signal(); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="java-并发工具类">Java 并发工具类</h3>
<p>Java 的 <code>java.util.concurrent</code>
包提供了许多用于并发编程的工具类，简化了线程的管理和调度。</p>
<h4 id="executor-框架">1. <strong>Executor 框架</strong></h4>
<p><code>Executor</code>
框架提供了一种更高级的管理线程池的方法，避免了直接操作线程。<code>ExecutorService</code>
是 <code>Executor</code>
的子接口，提供了更多的方法来管理线程池中的任务。</p>
<ul>
<li><p><strong>创建线程池</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);  <span class="comment">// 创建固定大小的线程池</span></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Task is running&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown();  <span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>常见线程池类型</strong>：</p>
<ul>
<li><code>newFixedThreadPool(int nThreads)</code>：固定大小的线程池。</li>
<li><code>newCachedThreadPool()</code>：根据需要创建新线程的线程池，但会重用先前的线程。</li>
<li><code>newSingleThreadExecutor()</code>：单线程池，确保所有任务按顺序执行。</li>
</ul></li>
</ul>
<h4 id="future-和-callable">2. <strong>Future 和 Callable</strong></h4>
<p><code>Callable</code> 是 <code>Runnable</code>
的增强版本，允许任务有返回值。<code>Future</code> 是
<code>Callable</code> 的返回值，表示一个异步计算的结果。</p>
<ul>
<li><strong>Callable</strong> 使用示例： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();  <span class="comment">// 阻塞等待任务完成并获取结果</span></span><br><span class="line">    System.out.println(result);  <span class="comment">// 输出 123</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="countdownlatch">3. <strong>CountDownLatch</strong></h4>
<p><code>CountDownLatch</code>
是一种同步工具，允许一个或多个线程等待其他线程完成某些操作。它使用一个计数器，线程调用
<code>countDown()</code>
递减计数器，直到计数器归零，等待的线程才会被唤醒。</p>
<ul>
<li><strong>示例</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finished.&quot;</span>);</span><br><span class="line">        latch.countDown();  <span class="comment">// 计数器减一</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">latch.await();  <span class="comment">// 等待计数器归零</span></span><br><span class="line">System.out.println(<span class="string">&quot;All threads finished.&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="cyclicbarrier">4. <strong>CyclicBarrier</strong></h4>
<p><code>CyclicBarrier</code>
是一种允许一组线程彼此等待到达某个公共屏障点的同步工具。</p>
<ul>
<li><p><strong>使用场景</strong>：适用于多线程任务需要在某个时间点共同执行的场景。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; is waiting.&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              barrier.await();  <span class="comment">// 所有线程都等待，直到屏障被释放</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; is released.&quot;</span>);</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line"></span><br><span class="line">Java 并发编程是构建高效、多线程应用的核心技术。通过线程的创建、同步、通信和 `java.util.concurrent` 工具包，Java 提供了一个强大的并发编程框架。使用线程池、锁、并发集合、同步机制等工具，可以帮助开发者编写高效、安全的并发程序。开发者需要注意线程的生命周期、同步问题、死锁、并发性能等问题，以确保程序的稳定性和性能。</span><br><span class="line"></span><br><span class="line">## 常用的锁</span><br><span class="line"></span><br><span class="line">在并发编程中，锁是用于协调多个线程对共享资源的访问，防止线程间的竞态条件和数据不一致问题。Java 提供了多种锁的实现，每种锁适用于不同的场景，具有各自的特性和用法。下面是 Java 中常用的几种锁及其详细介绍。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### <span class="number">1.</span> **<span class="keyword">synchronized</span> 关键字**</span><br><span class="line"></span><br><span class="line">`<span class="keyword">synchronized</span>` 是 Java 中最基本的内置锁（也叫**监视器锁**），它可以修饰方法或代码块，用于确保同一时间只有一个线程能够执行该方法或代码块，保证线程安全。</span><br><span class="line"></span><br><span class="line">#### 特点：</span><br><span class="line">- **可重入**：`<span class="keyword">synchronized</span>` 是可重入锁，意味着同一个线程可以多次获得同一把锁，而不会发生死锁。</span><br><span class="line">- **内置锁**：`<span class="keyword">synchronized</span>` 是 JVM 层面提供的机制，不需要手动管理锁的获取和释放，JVM 会自动处理。</span><br><span class="line">- **效率较低**：在高并发场景下，`<span class="keyword">synchronized</span>` 的性能相对较低，尤其是在锁竞争激烈时，可能导致线程的频繁阻塞和唤醒。</span><br><span class="line"></span><br><span class="line">#### 用法：</span><br><span class="line">- 修饰实例方法：</span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 线程安全的代码</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>修饰代码块： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 线程安全的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h3 id="reentrantlock">2. <strong>ReentrantLock</strong></h3>
<p><code>ReentrantLock</code> 是 <code>Lock</code>
接口的常用实现类，它是一个<strong>可重入锁</strong>，类似于
<code>synchronized</code>，但它提供了更多的控制和功能。</p>
<h4 id="特点-3">特点：</h4>
<ul>
<li><strong>手动加锁与解锁</strong>：与 <code>synchronized</code>
不同，<code>ReentrantLock</code> 需要手动调用 <code>lock()</code>
获取锁，使用完后需要手动调用 <code>unlock()</code> 释放锁。</li>
<li><strong>可重入性</strong>：与 <code>synchronized</code>
类似，<code>ReentrantLock</code> 允许同一线程多次获取同一把锁。</li>
<li><strong>可中断性</strong>：在获取锁时，线程可以选择响应中断，这意味着线程可以被中断，从而避免永久等待锁。</li>
<li><strong>公平锁与非公平锁</strong>：<code>ReentrantLock</code>
支持公平锁和非公平锁，公平锁按照线程请求锁的顺序来分配锁，非公平锁则允许插队。</li>
</ul>
<h4 id="用法">用法：</h4>
<ul>
<li><p>非公平锁： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();  <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>公平锁： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);  <span class="comment">// 公平锁</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h3 id="reentrantreadwritelock">3.
<strong>ReentrantReadWriteLock</strong></h3>
<p><code>ReentrantReadWriteLock</code>
是一种读写锁，允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁设计的目的是提高并发读的性能，因为读操作不会互相阻塞。</p>
<h4 id="特点-4">特点：</h4>
<ul>
<li><strong>读锁和写锁分离</strong>：<code>ReentrantReadWriteLock</code>
提供了两种锁：<code>readLock()</code> 和
<code>writeLock()</code>。多个线程可以同时获取读锁，但只有一个线程可以获取写锁，并且写锁与读锁互斥。</li>
<li><strong>可重入性</strong>：读锁和写锁都是可重入的，意味着同一个线程可以多次获取读锁或写锁。</li>
<li><strong>写锁优先</strong>：默认情况下，写锁的优先级高于读锁，意味着写锁会在等待时阻止其他线程获取读锁。</li>
</ul>
<h4 id="用法-1">用法：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作</span></span><br><span class="line">readLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读操作，多个线程可同时执行</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    readLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写操作</span></span><br><span class="line">writeLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写操作，只有一个线程可以执行</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="stampedlock">4. <strong>StampedLock</strong></h3>
<p><code>StampedLock</code> 是 Java 8
引入的一种改进的读写锁。它提供了类似 <code>ReentrantReadWriteLock</code>
的读写锁功能，但在某些场景下提供了更高效的并发控制。<code>StampedLock</code>
通过使用时间戳（stamp）来管理锁状态。</p>
<h4 id="特点-5">特点：</h4>
<ul>
<li><strong>不可重入</strong>：与 <code>ReentrantReadWriteLock</code>
不同，<code>StampedLock</code>
是不可重入的，意味着线程在同一锁上不能重复加锁。</li>
<li><strong>乐观读锁</strong>：<code>StampedLock</code>
提供了一种乐观读锁机制，允许在没有加锁的情况下进行读取操作，但在执行完读取操作后需要确认锁的有效性。乐观读锁可以提高并发读的性能。</li>
<li><strong>传统读写锁</strong>：<code>StampedLock</code>
也提供传统的读锁和写锁。</li>
</ul>
<h4 id="用法-2">用法：</h4>
<ul>
<li><p><strong>乐观读锁</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行读取操作</span></span><br><span class="line"><span class="comment">// 验证锁的有效性</span></span><br><span class="line"><span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123;</span><br><span class="line">    <span class="comment">// 如果锁在读取过程中被修改，重新获取锁</span></span><br><span class="line">    stamp = stampedLock.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stampedLock.unlockRead(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>写锁</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    stampedLock.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h3 id="countdownlatch-1">5. <strong>CountDownLatch</strong></h3>
<p><code>CountDownLatch</code>
是一种用于线程同步的工具类，它允许一个或多个线程等待其他线程完成某些操作。<code>CountDownLatch</code>
通过一个计数器来控制线程的执行，当计数器减为零时，所有等待的线程将继续执行。</p>
<h4 id="特点-6">特点：</h4>
<ul>
<li><strong>一次性使用</strong>：<code>CountDownLatch</code>
是一次性的，计数器减为零后无法重置。</li>
<li><strong>线程等待</strong>：一个线程或多个线程可以调用
<code>await()</code> 方法等待，其他线程完成任务后调用
<code>countDown()</code> 减少计数器。</li>
</ul>
<h4 id="用法-3">用法：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        latch.countDown();  <span class="comment">// 任务完成，计数器减一</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">latch.await();  <span class="comment">// 等待所有任务完成</span></span><br><span class="line">System.out.println(<span class="string">&quot;所有任务完成&quot;</span>);</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="cyclicbarrier-1">6. <strong>CyclicBarrier</strong></h3>
<p><code>CyclicBarrier</code>
是另一种用于线程同步的工具类，允许一组线程相互等待，直到所有线程都到达某个屏障点。与
<code>CountDownLatch</code> 不同的是，<code>CyclicBarrier</code>
可以多次使用。</p>
<h4 id="特点-7">特点：</h4>
<ul>
<li><strong>可重复使用</strong>：<code>CyclicBarrier</code>
可以在所有线程到达屏障后重复使用，适用于需要多轮同步操作的场景。</li>
<li><strong>可执行回调</strong>：当所有线程到达屏障时，可以执行一个可选的回调操作。</li>
</ul>
<h4 id="用法-4">用法：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;所有线程已到达屏障，执行回调操作&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="semaphore">7. <strong>Semaphore</strong></h3>
<p><code>Semaphore</code>
是一种计数信号量，用于控制同时访问某个资源的线程数。它可以用于实现限流，限制同时访问共享资源的线程数量。</p>
<h4 id="特点-8">特点：</h4>
<ul>
<li><strong>控制访问数量</strong>：<code>Semaphore</code>
通过一个计数器来控制可用的资源数量，线程调用 <code>acquire()</code>
获取资源，调用 <code>release()</code> 释放资源。</li>
<li><strong>多线程访问控制</strong>：适用于限制多个线程同时访问共享资源的场景，如数据库连接池等。</li>
</ul>
<h4 id="用法-5">用法：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);  <span class="comment">// 允许同时有三个线程访问资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();  <span class="comment">// 获取资源</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在访问资源&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟资源访问</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();  <span class="comment">// 释放资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="readwritelock">8. <strong>ReadWriteLock</strong></h3>
<p><code>ReadWriteLock</code> 是一种特殊类型的锁，允许</p>
<p>多个读线程同时执行，但只允许一个写线程执行。适用于读多写少的场景，提高并发性能。</p>
<h4 id="特点-9">特点：</h4>
<ul>
<li><strong>读锁可共享</strong>：多个线程可以同时获取读锁。</li>
<li><strong>写锁独占</strong>：写锁只能被一个线程持有，且与读锁互斥。</li>
</ul>
<h4 id="用法-6">用法：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line">readLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行读操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    readLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line">writeLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行写操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结-28">总结</h3>
<p>Java 提供了多种并发编程中的锁和同步机制，以满足不同场景下的需求：</p>
<ul>
<li><strong><code>synchronized</code></strong>：最简单的同步机制，用于基本的互斥访问。</li>
<li><strong><code>ReentrantLock</code></strong>：提供了更多控制和功能的可重入锁。</li>
<li><strong><code>ReentrantReadWriteLock</code></strong> 和
<strong><code>StampedLock</code></strong>：适用于读多写少的场景，提供了读写分离的锁机制。</li>
<li><strong><code>CountDownLatch</code></strong> 和
<strong><code>CyclicBarrier</code></strong>：用于线程同步，前者是一次性使用，后者可重复使用。</li>
<li><strong><code>Semaphore</code></strong>：用于控制同时访问某个资源的线程数。</li>
<li><strong><code>ReadWriteLock</code></strong>：允许多个线程同时读取，但只允许一个线程写入。</li>
</ul>
<p>根据具体的应用场景，选择合适的锁机制可以有效提高并发程序的性能和可靠性。</p>
<h2 id="四种引用">四种引用</h2>
<p>在Java中，有四种引用类型：强引用、软引用、弱引用和虚引用。</p>
<ol type="1">
<li><p><strong>强引用</strong>：最常见的引用方式，Java垃圾回收器不会回收被强引用的对象。只要强引用存在，对象就会一直存在。</p></li>
<li><p><strong>软引用</strong>：主要用于缓存，当系统内存不足时，垃圾回收器会回收这些对象。适合用来实现内存敏感的缓存。</p></li>
<li><p><strong>弱引用</strong>：比软引用更弱，垃圾回收器在下一次回收时会回收所有只被弱引用的对象。这适用于描述一些非强依赖的对象。</p></li>
<li><p><strong>虚引用</strong>：也称为幽灵引用，不会影响对象的生命周期，只能用来跟踪对象被垃圾回收器回收的状态。通常和
<code>ReferenceQueue</code> 一起使用。 ## 线程间通信</p></li>
</ol>
<p>在 Java
中，线程间通信是一项关键技术，用于在多线程环境中协同处理数据和任务。Java
提供了多种线程间通信的方式，常见的方式如下：</p>
<h3 id="使用-waitnotify-和-notifyall">1. <strong>使用
<code>wait()</code>、<code>notify()</code> 和
<code>notifyAll()</code></strong></h3>
<p>这是 Java
中经典的线程间通信方式，基于对象的监视器锁（Monitor）。<code>wait()</code>、<code>notify()</code>
和 <code>notifyAll()</code> 是 <code>Object</code>
类中的方法，用于在线程间进行协调与通信。</p>
<ul>
<li><p><strong><code>wait()</code></strong>：当前线程进入等待状态，并释放持有的对象锁，直到另一个线程调用
<code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒它。</p></li>
<li><p><strong><code>notify()</code></strong>：唤醒在该对象监视器上等待的某一个线程。</p></li>
<li><p><strong><code>notifyAll()</code></strong>：唤醒在该对象监视器上等待的所有线程。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForResource</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!available) &#123;</span><br><span class="line">            wait();  <span class="comment">// 线程等待，直到被唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">        available = <span class="literal">false</span>;  <span class="comment">// 资源已被使用，重新设置为不可用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">releaseResource</span><span class="params">()</span> &#123;</span><br><span class="line">        available = <span class="literal">true</span>;</span><br><span class="line">        notify();  <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(SharedResource resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resource.waitForResource();  <span class="comment">// 等待资源</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Thread A acquired resource.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadB</span><span class="params">(SharedResource resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        resource.releaseResource();  <span class="comment">// 释放资源</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread B released resource.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，<code>ThreadA</code> 将等待资源的释放，而
<code>ThreadB</code> 负责释放资源。</p>
<h3 id="使用-synchronized-关键字">2. <strong>使用
<code>synchronized</code> 关键字</strong></h3>
<p><code>sychronized</code> 是 Java
中用于线程同步的关键字，它可以保证同一时间只有一个线程能访问被
<code>synchronized</code>
修饰的代码块或方法，从而避免线程间的竞争问题。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(Counter counter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            counter.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>increment()</code> 和 <code>getCount()</code>
方法是同步的，确保同一时刻只有一个线程能修改 <code>count</code>
的值，从而避免数据竞争。</p>
<h3 id="使用-lock-和-condition从-java.util.concurrent-包">3.
<strong>使用 <code>Lock</code> 和 <code>Condition</code>（从
<code>java.util.concurrent</code> 包）</strong></h3>
<p><code>Lock</code> 和 <code>Condition</code> 提供了比
<code>synchronized</code> 更灵活的线程同步机制。<code>Lock</code>
类允许手动获取和释放锁，而 <code>Condition</code> 类则类似于
<code>wait()</code> 和 <code>notify()</code>，但具有更大的灵活性。</p>
<ul>
<li><p><strong>Lock</strong>：提供显式的锁定和解锁操作，支持更复杂的同步控制。</p></li>
<li><p><strong>Condition</strong>：可以让线程等待某个条件满足，再继续执行，类似于
<code>Object.wait()</code> 和 <code>Object.notify()</code>。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitForResource</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!available) &#123;</span><br><span class="line">                condition.await();  <span class="comment">// 等待条件满足</span></span><br><span class="line">            &#125;</span><br><span class="line">            available = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseResource</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            available = <span class="literal">true</span>;</span><br><span class="line">            condition.signal();  <span class="comment">// 唤醒一个等待线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-blockingqueue">4. <strong>使用
<code>BlockingQueue</code></strong></h3>
<p><code>BlockingQueue</code> 是 Java
的并发包中的一种线程安全的队列，它提供了用于生产者-消费者模式的通信机制。多个线程可以安全地将元素放入或取出队列，<code>BlockingQueue</code>
会自动处理线程之间的同步问题。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                queue.put(i);  <span class="comment">// 放入队列</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">item</span> <span class="operator">=</span> queue.take();  <span class="comment">// 从队列中取出</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumed: &quot;</span> + item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(queue).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-semaphore">5. <strong>使用
<code>Semaphore</code></strong></h3>
<p><code>Semaphore</code>
是一种计数信号量，用于控制同时访问特定资源的线程数量。它可以用于限制某些资源的访问，例如限制一个文件同时只能被最多
3 个线程访问。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">access</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        semaphore.acquire();  <span class="comment">// 获取一个许可</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is accessing resource.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();  <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(SharedResource resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resource.access();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-exchanger">6. <strong>使用
<code>Exchanger</code></strong></h3>
<p><code>Exchanger</code> 用于两个线程之间交换数据。一个线程调用
<code>exchange()</code>
方法将数据传给另一个线程，同时接收对方的数据。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExchangerExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> exchanger.exchange(<span class="string">&quot;Data from Thread 1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 received: &quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> exchanger.exchange(<span class="string">&quot;Data from Thread 2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 received: &quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-29"><strong>总结</strong></h3>
<p>Java 提供了多种线程间通信的机制，每种方式适合不同的场景： -
<code>wait()</code> / <code>notify()</code>
适合简单的生产者-消费者模型。 - <code>Lock</code> 和
<code>Condition</code> 提供了更加灵活的同步控制。 -
<code>BlockingQueue</code> 和 <code>Semaphore</code>
适用于并发资源管理。 - <code>Exchanger</code>
适合两个线程之间的数据交换。</p>
<p>选择适合的线程通信方式需要根据实际的应用场景和需求。</p>
<h2 id="jvm-中-java-对象的创建过程">JVM 中 Java 对象的创建过程</h2>
<p>在 JVM 中，Java
对象的创建是一个复杂且精细的过程，涉及多个步骤。以下是 Java
对象创建的主要流程：</p>
<h3 id="类加载检查">1. <strong>类加载检查</strong></h3>
<ul>
<li>在创建一个对象之前，JVM
会首先检查该对象所属的类是否已经被加载、解析和初始化。如果类还没有被加载，JVM
会触发类加载过程（包括加载、链接和初始化）。</li>
<li>类加载是通过类加载器（ClassLoader）完成的。这个过程确保了所有必要的类信息都已准备就绪，包含字段和方法等定义。</li>
</ul>
<h3 id="内存分配">2. <strong>内存分配</strong></h3>
<ul>
<li>在类加载完成后，JVM
会为新对象分配内存。对象的内存分配通常是在堆中进行的。具体分配内存的位置取决于堆的结构和垃圾收集器的实现。</li>
<li>JVM
会根据对象的大小，从堆中划分一块空间用于存储对象的实例变量、元数据等信息。一般来说，对象的内存大小由类中的字段（包括继承的字段）和对象头（Object
Header）共同决定。</li>
<li>JVM 中的内存分配方式有两种：
<ul>
<li><strong>指针碰撞</strong>：如果堆中的内存是规整的，没有被垃圾回收器整理过，那么
JVM 可以直接通过移动指针来分配内存。</li>
<li><strong>空闲列表</strong>：如果堆中内存不规整，有分散的空闲区域，JVM
会通过一个空闲列表来找到一块合适的内存区域分配给新对象。</li>
</ul></li>
</ul>
<h3 id="内存区域初始化为零值">3.
<strong>内存区域初始化为零值</strong></h3>
<ul>
<li>为了保证对象的安全性，JVM
会将新分配的内存空间初始化为零值。这意味着对象实例变量（包括基本类型和引用类型）在分配后默认为零或
<code>null</code>
值。这一过程确保了对象的默认值在构造方法之前被初始化。</li>
</ul>
<h3 id="设置对象头">4. <strong>设置对象头</strong></h3>
<ul>
<li>JVM 在对象内存中分配了一个对象头（Object
Header），用于存储对象的元数据。</li>
<li>对象头通常包括以下信息：
<ul>
<li><strong>Mark Word</strong>：包含对象的哈希码、GC
信息、锁状态等。</li>
<li><strong>类指针（Class
Pointer）</strong>：指向对象所属的类的元数据，表示该对象是哪个类的实例。</li>
</ul></li>
<li>如果是数组对象，JVM 还会在对象头中存储数组的长度信息。</li>
</ul>
<h3 id="执行构造方法-方法">5. <strong>执行构造方法（<init>
方法）</strong></h3>
<ul>
<li>JVM 完成对象的内存分配和初始化后，会调用对象的构造方法（即
<code>new</code> 语句后自动调用的 <code>&lt;init&gt;</code>
方法）。</li>
<li>构造方法用于进行对象的进一步初始化，可能包括显式赋值和其他逻辑操作。</li>
<li>构造方法调用结束后，JVM 完成了整个对象创建过程。</li>
</ul>
<h3 id="返回对象的引用">6. <strong>返回对象的引用</strong></h3>
<ul>
<li>构造方法执行完成后，对象的创建过程就结束了。JVM
返回对象的引用地址（或指针），并将其存储到变量中，从而可以在程序中访问和使用该对象。</li>
</ul>
<h3 id="补充锁与同步"><strong>补充：锁与同步</strong></h3>
<ul>
<li>对象创建完成后，JVM 会确保对象头中的锁状态处于“无锁”状态。</li>
<li>当对象用于同步操作（例如 <code>synchronized</code>
关键字）时，对象头中的 Mark Word 将被更新，以存储锁的信息。</li>
</ul>
<h3 id="总结-30"><strong>总结</strong></h3>
<p>Java
对象的创建过程涉及从类加载到内存分配，再到初始化和构造的多个步骤。这些步骤确保每个对象都是从其所属的类定义中产生的，并且初始值是安全的。这种流程体现了
JVM 对对象管理的精确控制和优化。</p>
<h2 id="动态代理">动态代理</h2>
<p>动态代理是一种在程序运行时动态创建代理对象的技术，主要用于拦截方法调用，以在不修改原始代码的情况下对方法调用进行增强或修改。Java
提供了两种主要的动态代理实现方式：<strong>JDK 动态代理</strong>和
<strong>CGLIB 动态代理</strong>。</p>
<h3 id="jdk-动态代理">1. <strong>JDK 动态代理</strong></h3>
<p>JDK 动态代理是 Java
内置的一种动态代理实现方式。它基于接口来生成代理对象，因此只适用于代理实现了接口的类。核心类是
<code>java.lang.reflect.Proxy</code> 和 <code>InvocationHandler</code>
接口。</p>
<h4 id="实现步骤">实现步骤</h4>
<ul>
<li><strong>定义接口</strong>：目标对象需要实现一个或多个接口，以便 JDK
动态代理能够基于接口生成代理对象。</li>
<li><strong>实现 InvocationHandler</strong>：创建一个类实现
<code>InvocationHandler</code> 接口，重写 <code>invoke</code>
方法。这个方法会在代理对象的方法被调用时触发，在 <code>invoke</code>
方法中可以添加增强逻辑。</li>
<li><strong>生成代理对象</strong>：使用
<code>Proxy.newProxyInstance</code>
方法生成代理对象。此方法需要提供类加载器、接口列表和
<code>InvocationHandler</code> 实例。</li>
</ul>
<h4 id="示例代码-2">示例代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Performing task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Service target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceInvocationHandler</span><span class="params">(Service target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理</span></span><br><span class="line"><span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl</span>();</span><br><span class="line"><span class="type">Service</span> <span class="variable">proxyService</span> <span class="operator">=</span> (Service) Proxy.newProxyInstance(</span><br><span class="line">        service.getClass().getClassLoader(),</span><br><span class="line">        service.getClass().getInterfaces(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServiceInvocationHandler</span>(service)</span><br><span class="line">);</span><br><span class="line">proxyService.performTask();</span><br></pre></td></tr></table></figure>
<h4 id="特点-10">特点</h4>
<ul>
<li><strong>基于接口</strong>：JDK
动态代理要求目标对象必须实现接口。</li>
<li><strong>性能较高</strong>：由于代理是基于接口实现的，通常运行速度较快。</li>
<li><strong>代理方法范围</strong>：只能代理实现了接口的方法，无法直接代理类中的具体方法。</li>
</ul>
<h3 id="cglib-动态代理">2. <strong>CGLIB 动态代理</strong></h3>
<p>CGLIB（Code Generation
Library）是一个第三方库，通过生成字节码的方式实现代理，它基于继承生成代理类，因此可以代理不实现接口的类。CGLIB
是通过继承目标类并重写其方法来实现代理的，这种方式使用了 ASM
字节码生成框架。</p>
<h4 id="实现步骤-1">实现步骤</h4>
<ul>
<li><strong>引入 CGLIB 库</strong>：CGLIB 不是 JDK
自带的库，需要手动添加依赖。</li>
<li><strong>实现 MethodInterceptor</strong>：创建一个实现
<code>MethodInterceptor</code> 接口的类，重写 <code>intercept</code>
方法。这个方法会在代理对象的方法被调用时执行，可以在此方法中添加增强逻辑。</li>
<li><strong>生成代理对象</strong>：使用 <code>Enhancer</code>
类生成代理对象。<code>Enhancer</code> 可以创建任何类的代理，除非该类是
<code>final</code> 类（因为 <code>final</code> 类不能被继承）。</li>
</ul>
<h4 id="示例代码-3">示例代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Performing task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 CGLIB 代理</span></span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(Service.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">ServiceMethodInterceptor</span>());</span><br><span class="line"><span class="type">Service</span> <span class="variable">proxyService</span> <span class="operator">=</span> (Service) enhancer.create();</span><br><span class="line">proxyService.performTask();</span><br></pre></td></tr></table></figure>
<h4 id="特点-11">特点</h4>
<ul>
<li><strong>基于继承</strong>：CGLIB
是通过继承目标类来实现代理的，因此可以代理不实现接口的类。</li>
<li><strong>性能相对较低</strong>：CGLIB 代理性能略低于 JDK
动态代理，但适用于无接口的情况。</li>
<li><strong>限制性</strong>：不能代理 <code>final</code> 类，因为 CGLIB
需要通过继承来实现动态代理。</li>
</ul>
<h3 id="动态代理的应用场景">3. <strong>动态代理的应用场景</strong></h3>
<p>动态代理在许多框架中广泛应用，尤其是
AOP（面向切面编程）和拦截器模式。常见的应用场景包括：</p>
<ul>
<li><strong>权限检查</strong>：在方法调用之前检查调用方是否具有相应权限。</li>
<li><strong>日志记录</strong>：在方法调用之前或之后添加日志记录逻辑。</li>
<li><strong>事务管理</strong>：在方法调用开始和结束时分别开启和关闭事务。</li>
<li><strong>远程调用代理</strong>：在客户端调用服务端的远程方法时，通过代理封装调用细节。</li>
<li><strong>缓存处理</strong>：在方法执行前后进行缓存查询或缓存更新，以提高效率。</li>
</ul>
<h3 id="jdk-动态代理和-cglib-代理的选择">4. <strong>JDK 动态代理和 CGLIB
代理的选择</strong></h3>
<ul>
<li><strong>JDK 动态代理</strong>：适用于代理实现了接口的对象，通常比
CGLIB 代理速度更快，且不需要额外依赖。</li>
<li><strong>CGLIB
动态代理</strong>：适用于没有接口的类代理，但代理创建速度相对较慢，且生成的代理对象较重。CGLIB
是通过字节码生成实现的，因此比 JDK 动态代理更灵活。</li>
</ul>
<p>在 Spring AOP 中，默认情况下会优先使用 JDK
动态代理，如果目标类没有实现接口，则会退而使用 CGLIB 动态代理。</p>
<h3 id="总结-31">总结</h3>
<p>动态代理为程序提供了强大的灵活性和可扩展性，特别适合需要对方法调用进行拦截和增强的场景。通过动态代理，开发者可以在运行时创建代理对象，实现如权限校验、日志、事务等切面功能，极大地提高了代码的解耦性和可维护性。</p>
<h1 id="c">C++</h1>
<h2 id="智能指针的类型">智能指针的类型</h2>
<p>C++
的智能指针是为了解决传统指针的内存管理问题而引入的，它们能够自动管理动态分配的内存，避免内存泄漏和悬挂指针问题。C++11
标准引入了三种主要的智能指针类型：<code>std::unique_ptr</code>、<code>std::shared_ptr</code>
和 <code>std::weak_ptr</code>，它们分别适用于不同的内存管理场景。</p>
<h3 id="stdunique_ptr">1.
<strong><code>std::unique_ptr</code></strong></h3>
<h4 id="概述-13">概述：</h4>
<p><code>std::unique_ptr</code>
是一种独占所有权的智能指针，即一个对象只能被一个 <code>unique_ptr</code>
拥有。当 <code>unique_ptr</code>
被销毁时，它所管理的对象也会自动销毁。<code>unique_ptr</code>
不允许复制，但可以通过移动语义将所有权转移给另一个
<code>unique_ptr</code>。</p>
<h4 id="主要特点-4">主要特点：</h4>
<ul>
<li><strong>独占所有权</strong>：一个对象只能被一个
<code>unique_ptr</code> 拥有，不能共享。</li>
<li><strong>移动语义支持</strong>：可以通过 <code>std::move</code> 将
<code>unique_ptr</code> 转移到另一个 <code>unique_ptr</code>。</li>
<li><strong>自动销毁</strong>：当 <code>unique_ptr</code>
退出作用域或被销毁时，自动调用 <code>delete</code> 来释放内存。</li>
</ul>
<h4 id="示例-10">示例：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有权转移给 ptr2</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="keyword">if</span> (!ptr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 is null after move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; *ptr2 &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 ptr2 离开作用域时，内存会被自动释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景-9">使用场景：</h4>
<ul>
<li>独占资源的场景，比如文件句柄、网络连接、动态分配的内存等。</li>
<li>当不希望多个指针共享同一个对象时，使用 <code>unique_ptr</code>
来确保对象的唯一所有权。</li>
</ul>
<h3 id="stdshared_ptr">2.
<strong><code>std::shared_ptr</code></strong></h3>
<h4 id="概述-14">概述：</h4>
<p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，多个
<code>shared_ptr</code>
可以同时指向同一个对象，并通过引用计数来管理对象的生命周期。只有当最后一个
<code>shared_ptr</code> 被销毁时，所管理的对象才会被释放。</p>
<h4 id="主要特点-5">主要特点：</h4>
<ul>
<li><strong>共享所有权</strong>：多个 <code>shared_ptr</code>
可以共享同一个对象，每个 <code>shared_ptr</code> 都增加引用计数。</li>
<li><strong>引用计数</strong>：每次复制
<code>shared_ptr</code>，引用计数会增加，销毁时引用计数会减少，当引用计数降为
0 时，对象会被释放。</li>
<li><strong>线程安全</strong>：引用计数的增加和减少是线程安全的，但对象本身的操作并不是线程安全的。</li>
</ul>
<h4 id="示例-11">示例：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use count: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 共享 ptr1 的所有权</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 use count: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 use count: &quot;</span> &lt;&lt; ptr<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">    &#125; <span class="comment">// ptr2 离开作用域，引用计数减少</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use count: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br><span class="line">    <span class="comment">// 当 ptr1 离开作用域时，内存会被释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景-10">使用场景：</h4>
<ul>
<li>当需要多个对象共享同一个资源时，比如在图结构、树结构中，多个节点可以共享相同的子节点。</li>
<li>适合动态分配的资源需要在多个对象之间共享，且不确定资源何时释放的场景。</li>
</ul>
<h3 id="stdweak_ptr">3. <strong><code>std::weak_ptr</code></strong></h3>
<h4 id="概述-15">概述：</h4>
<p><code>std::weak_ptr</code> 是一种不参与引用计数的智能指针，用于解决
<code>std::shared_ptr</code> 循环引用的问题。<code>weak_ptr</code>
不会影响引用计数，它提供了一种弱引用的机制，允许访问对象但不会控制对象的生命周期。<code>weak_ptr</code>
必须通过 <code>lock()</code> 方法提升为 <code>shared_ptr</code>
才能访问对象。</p>
<h4 id="主要特点-6">主要特点：</h4>
<ul>
<li><strong>不增加引用计数</strong>：<code>weak_ptr</code> 只是对
<code>shared_ptr</code> 的弱引用，不会增加对象的引用计数。</li>
<li><strong>解决循环引用问题</strong>：在 <code>shared_ptr</code>
循环引用的场景中，使用 <code>weak_ptr</code> 可以打破循环引用。</li>
<li><strong>检查对象是否仍然存在</strong>：通过 <code>expired()</code>
方法可以判断对象是否已经被释放。</li>
</ul>
<h4 id="示例-12">示例：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 weak_ptr 指向 shared_ptr</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wptr = sptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 weak_ptr 是否仍然指向有效对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> tmp = wptr.<span class="built_in">lock</span>()) &#123;  <span class="comment">// lock() 提升为 shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shared object is still alive, value: &quot;</span> &lt;&lt; *tmp &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shared object has been destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sptr.<span class="built_in">reset</span>(); <span class="comment">// 手动销毁 shared_ptr 管理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查 weak_ptr 是否指向有效对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> tmp = wptr.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shared object is still alive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shared object has been destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景-11">使用场景：</h4>
<ul>
<li>解决 <code>shared_ptr</code>
的循环引用问题，例如双向链表或父子对象之间的引用。</li>
<li>当需要观察一个对象的生命周期但不希望参与其管理时，可以使用
<code>weak_ptr</code>。</li>
</ul>
<h3 id="stdauto_ptr已废弃">4.
<strong><code>std::auto_ptr</code>（已废弃）</strong></h3>
<p><code>std::auto_ptr</code> 是 C++98
引入的一种早期智能指针类型，但由于它的所有权语义不清晰（复制时所有权会转移）和不支持
C++11 的现代功能（如移动语义），已在 C++11 中被废弃，并由
<code>unique_ptr</code> 取而代之。现代 C++ 应避免使用
<code>auto_ptr</code>，转而使用 <code>unique_ptr</code>。</p>
<h3 id="各类智能指针对比">各类智能指针对比</h3>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 8%" />
<col style="width: 21%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>智能指针类型</th>
<th>所有权</th>
<th>引用计数</th>
<th>线程安全</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>unique_ptr</code></td>
<td>独占所有权</td>
<td>不支持</td>
<td>不支持</td>
<td>适合独占的资源管理，不需要多个指针共享对象</td>
</tr>
<tr class="even">
<td><code>shared_ptr</code></td>
<td>共享所有权</td>
<td>支持</td>
<td>增减计数是线程安全的</td>
<td>适合需要多个指针共享同一个对象的场景</td>
</tr>
<tr class="odd">
<td><code>weak_ptr</code></td>
<td>无所有权</td>
<td>不支持</td>
<td>不支持</td>
<td>解决 <code>shared_ptr</code> 的循环引用问题，弱引用对象</td>
</tr>
</tbody>
</table>
<h3 id="总结-32">总结</h3>
<p>C++
提供了多种智能指针来管理动态内存，它们各有不同的应用场景和使用特点：</p>
<ul>
<li><strong><code>std::unique_ptr</code></strong>：独占所有权，适用于不需要共享的资源管理。</li>
<li><strong><code>std::shared_ptr</code></strong>：共享所有权，适用于需要多个对象共享同一资源的场景。</li>
<li><strong><code>std::weak_ptr</code></strong>：弱引用，用于解决循环引用问题或需要观察对象但不参与管理的场景。</li>
</ul>
<p>通过智能指针的合理使用，可以有效地避免手动内存管理中的常见错误，如内存泄漏、悬挂指针等问题。</p>
<h1 id="kotlin">Kotlin</h1>
<h2
id="协程为什么在io操作上优于线程池">协程为什么在IO操作上优于线程池</h2>
<p>协程优于线程的关键在于它的调度算法使得它在IO操作下对于线程资源的利用更充分更饱和，没有阻塞，同时切换成本更低（因为挂起恢复时可能在同一个线程上）。</p>
<p>是的，你的总结非常到位！协程相较于线程的关键优势确实可以归纳为<strong>调度算法的优化</strong>、<strong>线程资源的高效利用</strong>以及<strong>切换成本的降低</strong>，尤其在
I/O
操作场景下表现尤为突出。让我进一步梳理和确认你的理解，同时补充一些细节，确保这个概念更清晰。</p>
<hr />
<h3 id="调度算法的优化">1. 调度算法的优化</h3>
<h4 id="协程的调度机制">协程的调度机制</h4>
<ul>
<li><strong>用户态调度</strong>: 协程的调度由
<code>kotlinx.coroutines</code>
库控制，而不是依赖操作系统的线程调度器。这种用户态调度让协程能够根据任务状态（运行、挂起、恢复）灵活分配线程。</li>
<li><strong>挂起与恢复</strong>: 协程遇到 I/O 操作时（如
<code>delay</code>
或异步网络请求），会挂起并释放当前线程，调度器立即将线程分配给其他就绪的协程。这种协作式调度避免了线程空闲等待。</li>
</ul>
<h4 id="对比线程池">对比线程池</h4>
<ul>
<li><strong>线程池的调度</strong>: 线程池（如 Java 的
<code>ExecutorService</code>）依赖操作系统和 JVM
的线程管理。任务分配到线程后，如果遇到 I/O
阻塞，线程会停下来等待，无法动态调整。</li>
<li><strong>资源利用不足</strong>:
阻塞的线程无法处理其他任务，导致线程池中的线程利用率低下，尤其在 I/O
密集型场景（如 100 个网络请求）。</li>
</ul>
<h4 id="为什么更饱和">为什么更饱和？</h4>
<ul>
<li>协程通过挂起机制，确保线程在等待 I/O
时不会闲置，而是立即执行其他协程。例如，在 <code>Dispatchers.IO</code>
上，64 个线程可以服务于数百甚至数千个协程，线程利用率接近 100%。</li>
<li>线程池则受限于线程数，阻塞时资源浪费严重。</li>
</ul>
<hr />
<h3 id="线程资源的充分利用">2. 线程资源的充分利用</h3>
<h4 id="协程的高效利用">协程的高效利用</h4>
<ul>
<li><strong>线程复用</strong>:
协程在挂起时释放线程，调度器将线程分配给其他协程。同一线程可以顺序执行多个协程的任务，最大化线程的“忙碌时间”。</li>
<li><strong>高并发支持</strong>: 因为协程是轻量级的（内存占用仅几
KB），可以在有限线程上运行大量协程（比如 100、1000
个），而无需创建等量的线程。</li>
</ul>
<h4 id="io-操作下的体现">I/O 操作下的体现</h4>
<ul>
<li><strong>无阻塞</strong>: 在 I/O 场景中，协程通过挂起函数（如
Retrofit 的 <code>suspend</code> 请求）与异步 I/O
框架配合，发起请求后挂起，线程不等待响应，而是去处理其他任务。</li>
<li><strong>饱和度</strong>: 假设 100 个协程发起网络请求，每个请求耗时 1
秒，线程池的 64
个线程可以并发处理所有请求，挂起期间线程持续工作，整体效率远高于线程阻塞。</li>
</ul>
<h4 id="示例对比">示例对比</h4>
<ul>
<li><strong>线程池</strong>: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    executor.submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 阻塞 I/O</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4 个线程处理 100 个任务，每线程阻塞 1 秒，总耗时约 25
秒，线程利用率低。</li>
</ul></li>
<li><strong>协程</strong>: <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">    repeat(<span class="number">100</span>) &#123;</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>) <span class="comment">// 挂起 I/O</span></span><br><span class="line">            println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>64 个线程处理 100 个协程，挂起时线程复用，总耗时约 1-2
秒，线程利用率高。</li>
</ul></li>
</ul>
<hr />
<h3 id="切换成本更低">3. 切换成本更低</h3>
<h4 id="协程的切换机制">协程的切换机制</h4>
<ul>
<li><strong>用户态切换</strong>: 协程的挂起和恢复由协程库管理，保存的是
Continuation（协程状态），开销仅为函数调用级别（纳秒级）。</li>
<li><strong>同一线程内</strong>:
如果挂起和恢复发生在同一线程（常见于单线程调度器如
<code>Dispatchers.Main</code>
或线程池中的复用），完全没有操作系统级别的上下文切换。</li>
<li><strong>跨线程切换</strong>: 即使恢复时切换线程（比如从
<code>Dispatchers.IO</code> 到
<code>Dispatchers.Main</code>），也只是线程池内的调度，频率和开销远低于线程池中大量线程的竞争。</li>
</ul>
<h4 id="对比线程切换">对比线程切换</h4>
<ul>
<li><strong>操作系统调度</strong>:
线程切换涉及保存寄存器、栈指针等，开销在微秒级，且受系统负载影响。</li>
<li><strong>阻塞浪费</strong>:
线程池中的线程如果阻塞，操作系统可能频繁切换到其他线程，增加上下文切换成本。</li>
</ul>
<h4 id="io-操作下的优势">I/O 操作下的优势</h4>
<ul>
<li>在 I/O
场景中，协程挂起时线程不阻塞，恢复时可能仍在原线程（取决于调度器和任务状态），避免了不必要的切换。</li>
<li>即使跨线程，协程数量远超线程，调度器优化了分配，切换次数远少于线程池。</li>
</ul>
<hr />
<h3 id="关键在于-io-操作的特性">4. 关键在于 I/O 操作的特性</h3>
<h4 id="io-操作的等待特性">I/O 操作的等待特性</h4>
<ul>
<li>I/O
操作（如网络请求、数据库查询）大部分时间在等待外部资源（如服务器响应、磁盘读取），实际计算时间很少。</li>
<li>线程池中，阻塞等待浪费线程资源；协程中，挂起释放线程，等待期间线程处理其他任务。</li>
</ul>
<h4 id="协程的适配性">协程的适配性</h4>
<ul>
<li><strong>异步 I/O 集成</strong>:
协程与现代异步框架（Retrofit、OkHttp）配合，I/O
操作天然非阻塞，挂起机制完美契合。</li>
<li><strong>无阻塞</strong>:
挂起函数将等待时间“隐藏”，线程始终处于活跃状态，资源利用更饱和。</li>
</ul>
<hr />
<h3 id="你的总结的准确性">5. 你的总结的准确性</h3>
<p>你提到： &gt; 协程优于线程的关键在于它的调度算法使得它在 I/O
操作下对于线程资源的利用更充分更饱和，没有阻塞，同时切换成本更低（因为挂起恢复时可能在同一个线程上）。</p>
<ul>
<li><strong>完全正确</strong>，并可以进一步概括为：
<ol type="1">
<li><strong>调度算法</strong>: 用户态调度 +
挂起机制，优化了线程分配。</li>
<li><strong>资源利用饱和</strong>:
挂起释放线程，复用率高，无阻塞浪费。</li>
<li><strong>切换成本低</strong>:
用户态切换（纳秒级）远低于线程切换（微秒级），同一线程内无切换成本。</li>
</ol></li>
</ul>
<h4 id="补充细节">补充细节</h4>
<ul>
<li><strong>“可能在同一个线程上”</strong>:
是的，同一线程内的挂起/恢复是常见情况，尤其在单线程调度器（如
<code>Dispatchers.Main</code>）或线程池复用时。但在
<code>Dispatchers.IO</code>
上，恢复可能发生在不同线程，不过调度器优化确保成本最低。</li>
<li><strong>I/O 的前提</strong>: 协程的优势在 I/O
密集型任务中更明显，因为挂起机制与等待特性契合。CPU
密集型任务则可能更依赖线程并行。</li>
</ul>
<hr />
<h3 id="直观示例android-中的-io">6. 直观示例：Android 中的 I/O</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    repeat(<span class="number">100</span>) &#123;</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = apiService.getData() <span class="comment">// 异步网络请求</span></span><br><span class="line">            withContext(Dispatchers.Main) &#123;</span><br><span class="line">                textView.text = <span class="string">&quot;Task <span class="variable">$it</span>: <span class="variable">$data</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>调度</strong>: 100 个协程在 <code>Dispatchers.IO</code> 的
64 个线程上运行。</li>
<li><strong>协作</strong>:
每个协程发起请求后挂起，线程复用，等待响应时处理其他协程。</li>
<li><strong>成本</strong>:
挂起/恢复成本低，线程利用饱和，总耗时接近单个请求时间。</li>
</ul>
<hr />
<h3 id="结论-1">7. 结论</h3>
<p>协程优于线程的关键确实在于： - <strong>调度算法</strong>:
用户态控制，挂起释放线程，优化分配。 - <strong>线程利用更饱和</strong>:
无阻塞，复用率高，适合 I/O 等待。 - <strong>切换成本低</strong>:
同一线程内无切换，跨线程时调度优化。</p>
<p>在 I/O
操作下，这些特性让协程能以更少的线程高效处理更多任务，避免了线程池的阻塞浪费和频繁切换。这正是协程在
Android
中处理网络请求、数据库操作等场景的核心优势！如果还有细节想深挖（比如调度器源码），随时告诉我！</p>
<h1 id="音视频">音视频</h1>
<h2 id="视频播放器的实现原理">视频播放器的实现原理</h2>
<p>视频播放器的基本实现原理包括了音视频文件的解码、同步播放、显示和用户交互等过程。一个完整的视频播放器通常由多个模块协作完成，从读取媒体数据到音视频的同步输出。以下是视频播放器的基本实现原理和关键模块：</p>
<h3 id="媒体文件的读取和解封装">1. 媒体文件的读取和解封装</h3>
<h4 id="容器格式和封装格式">容器格式和封装格式：</h4>
<p>视频文件通常包含视频流、音频流和其他数据，如字幕等，这些数据被封装在容器格式中（如
MP4、AVI、MKV、FLV
等）。播放器的第一步就是将这些封装格式打开，提取出音频、视频和其他流。</p>
<ul>
<li><strong>解封装
(Demuxing)</strong>：解封装是指将多媒体容器文件中的不同流（视频流、音频流等）分离出来。这个过程依赖于容器的解析器（Demuxer）。常见的库有
FFmpeg，它可以处理多种封装格式。</li>
<li><strong>流的分离</strong>：解封装后，视频和音频流会被分别提取，用于后续的解码操作。</li>
</ul>
<h3 id="音视频的解码">2. 音视频的解码</h3>
<h4 id="编码格式">编码格式：</h4>
<p>音频和视频流通常是压缩的，以节省存储空间和带宽。视频通常使用
H.264、H.265（HEVC）等编码格式，音频则可能使用 AAC、MP3
等。播放器需要对这些压缩的音视频流进行解码。</p>
<ul>
<li><strong>视频解码器</strong>：解码器（Codec）将压缩的视频流解码为原始的帧数据（如
YUV 格式的图像帧）。</li>
<li><strong>音频解码器</strong>：解码音频流，将压缩的音频数据解码为可播放的音频采样数据（如
PCM 格式）。</li>
</ul>
<p>解码的复杂性取决于视频和音频的编码格式，现代播放器通常使用第三方库（如
FFmpeg）来支持多种解码方式。解码过程的性能需求较高，解码速度必须足够快才能保证实时播放。</p>
<h3 id="音视频同步">3. 音视频同步</h3>
<h4 id="时间戳-ptsdts">时间戳 (PTS/DTS)：</h4>
<p>为了确保音频和视频同步播放，每个音频帧和视频帧都带有时间戳。播放器根据这些时间戳进行音视频同步。
- <strong>PTS (Presentation Time
Stamp)</strong>：表示该帧需要在什么时候进行播放。 - <strong>DTS
(Decoding Time
Stamp)</strong>：表示该帧需要在什么时候进行解码。对于一些编解码格式，DTS
和 PTS 可能不一样。</p>
<h4 id="音视频同步算法">音视频同步算法：</h4>
<p>通常，播放器会以音频播放为基准，通过音频输出的时间来控制视频帧的显示。如果发现音频和视频不同步，播放器会调整视频帧的播放时间，或丢弃/重复某些视频帧，以确保播放的流畅性和同步性。</p>
<h3 id="渲染和播放">4. 渲染和播放</h3>
<h4 id="视频渲染">视频渲染：</h4>
<ul>
<li><strong>视频帧的显示</strong>：视频帧数据通常是 YUV 格式，需要转换为
RGB
格式，然后交由显示设备（如屏幕）渲染。转换和渲染过程依赖于图形处理单元
(GPU)，现代视频播放器通常会使用硬件加速技术（如 OpenGL、DirectX 或
Vulkan）来提高渲染效率。</li>
<li><strong>显示刷新率匹配</strong>：为了确保播放平滑，播放器需要将视频的帧率与显示器的刷新率进行匹配。例如，如果视频是
24fps，而显示器是 60Hz，播放器需要适当插入或重复帧，保证播放平滑。</li>
</ul>
<h4 id="音频播放">音频播放：</h4>
<ul>
<li><strong>音频输出</strong>：解码后的音频数据（通常是 PCM
格式）需要送到音频设备进行播放。常用的音频输出接口有
OpenAL、ALSA、DirectSound 等。</li>
<li><strong>音频缓冲</strong>：音频播放通常需要使用缓冲区来存储待播放的音频数据。播放器会将解码好的音频数据填充到缓冲区，音频硬件则从缓冲区中取出数据进行播放。音频缓冲的大小需要合适，如果过大，会导致音画不同步，过小则可能导致音频播放卡顿。</li>
</ul>
<h3 id="控制逻辑和用户交互">5. 控制逻辑和用户交互</h3>
<p>播放器还需要处理用户输入的各种控制指令，例如： -
<strong>播放</strong>、<strong>暂停</strong>、<strong>停止</strong>：播放器需要在解码和渲染时对这些命令做出响应，控制音视频的解码和输出过程。
-
<strong>快进</strong>、<strong>快退</strong>：播放器需要快速跳过未播放的部分，重新读取和解码目标位置的音视频帧。
-
<strong>音量控制</strong>、<strong>静音</strong>：控制音频播放时的音量。
-
<strong>字幕显示</strong>：如果视频文件带有字幕，播放器需要将字幕文件解析出来，并在适当的时间同步显示在视频画面上。</p>
<h3 id="缓冲和网络播放">6. 缓冲和网络播放</h3>
<p>对于在线视频播放器，还需要处理网络延迟和不稳定性。网络播放器会预先从网络缓冲一定量的数据，以保证播放流畅性。
-
<strong>缓冲机制</strong>：在网络播放中，播放器需要下载并缓存音视频数据。缓冲的大小和策略可以根据网络带宽和视频编码的特性来调整。
- <strong>自适应码率
(ABR)</strong>：对于流媒体播放，播放器需要根据网络状况调整播放视频的码率，以便在网络状况恶化时能维持流畅的播放。</p>
<h3 id="硬件加速">7. 硬件加速</h3>
<p>现代视频播放器通常使用硬件加速来提升性能，特别是在处理高分辨率视频（如
4K、8K）时。硬件加速的常见形式包括： - <strong>硬件解码</strong>：通过
GPU 或专用解码芯片进行视频解码，减轻 CPU 负担。 -
<strong>硬件渲染</strong>：使用 GPU
渲染视频帧，提升渲染效率和显示效果。</p>
<p>常见的硬件解码接口包括： - <strong>VDPAU</strong>：适用于 Linux
平台的硬件加速解码接口。 - <strong>DXVA</strong>：用于 Windows
的硬件解码接口。 - <strong>MediaCodec</strong>：Android
平台的硬件解码接口。</p>
<h3 id="视频播放器实现流程总结">视频播放器实现流程总结</h3>
<ol type="1">
<li><strong>读取和解析文件</strong>：播放器打开媒体文件，解封装得到音视频流。</li>
<li><strong>音视频解码</strong>：通过解码器解码音视频流，得到可用的音频采样和视频帧数据。</li>
<li><strong>音视频同步</strong>：根据音频和视频的时间戳，保持音视频同步播放。</li>
<li><strong>视频渲染</strong>：将解码的原始视频帧渲染到屏幕上，通常使用
GPU 进行加速渲染。</li>
<li><strong>音频播放</strong>：将解码后的音频数据送到音频设备进行播放。</li>
<li><strong>用户交互</strong>：响应用户的播放、暂停、快进、音量调节等操作。</li>
<li><strong>流媒体支持</strong>：通过网络缓冲和自适应码率调整，确保在线播放的流畅性。</li>
</ol>
<h3 id="总结-33">总结</h3>
<p>一个视频播放器的基本实现原理主要包括媒体数据的解封装、解码、音视频同步、渲染和播放。为了保证播放的流畅性和性能，现代播放器通常依赖硬件加速、优化的解码算法和用户友好的交互设计。对于在线视频，播放器还需要处理网络延迟、码率调整等问题。</p>
<h2 id="视频直播的实现原理">视频直播的实现原理</h2>
<p>视频直播是一种实时将视频数据从一个或多个源传输到远程观众的技术。它的实现涉及多个关键步骤，包括视频采集、编码、传输、解码和播放，依赖于多个技术协议和优化手段来确保低延迟和高质量的实时视频体验。以下是视频直播的基本实现原理和关键技术。</p>
<h3 id="视频直播的基本流程">视频直播的基本流程</h3>
<ol type="1">
<li><strong>视频采集</strong>
<ul>
<li>视频直播从采集视频和音频数据开始。数据可以来自摄像头、麦克风或其他音视频设备。</li>
<li>采集设备会将原始的视频和音频数据传送给直播服务器或直播软件进行处理。</li>
<li>视频采集通常以帧为单位进行，常见的帧率有 24fps、30fps 或
60fps。</li>
</ul></li>
<li><strong>视频编码</strong>
<ul>
<li>原始视频数据通常体积庞大，未经压缩的音视频数据直接传输会占用大量带宽。为了减少传输带宽，视频采集后需要进行压缩处理，这就是<strong>视频编码</strong>。</li>
<li>常见的视频编码格式包括
H.264、H.265（HEVC），而音频编码格式则常见的有 AAC、MP3 等。</li>
<li><strong>编码的目的是</strong>：在保证视频质量的前提下，压缩视频数据大小，使其可以在网络上实时传输。</li>
<li><strong>实时编码</strong>需要考虑延迟问题，因此通常选择具备快速编码能力的编解码器。</li>
</ul></li>
<li><strong>封装</strong>
<ul>
<li>编码后的音视频数据会被封装成特定格式的流文件，用于网络传输。</li>
<li>封装协议决定了音视频如何打包以及数据的传输顺序。常见的封装格式有
FLV、MP4 等。</li>
<li><strong>FLV</strong>
是视频直播中最常见的封装格式之一，因为它支持流媒体播放，适合直播应用。</li>
</ul></li>
<li><strong>推流</strong>
<ul>
<li>视频编码和封装后，数据通过网络传输到直播服务器，称为<strong>推流</strong>（Publishing
Stream）。</li>
<li>常见的推流协议有：
<ul>
<li><strong>RTMP (Real-Time Messaging
Protocol)</strong>：最常用的直播推流协议，低延迟，广泛支持。</li>
<li><strong>HLS (HTTP Live
Streaming)</strong>：适用于跨平台播放，延迟较高，但兼容性好，适合点播和直播。</li>
<li><strong>SRT (Secure Reliable
Transport)</strong>：低延迟，高可靠性，适合在不稳定网络下传输。</li>
<li><strong>WebRTC (Web Real-Time
Communication)</strong>：用于实现浏览器端的实时音视频通信，延迟极低。</li>
</ul></li>
</ul></li>
<li><strong>直播服务器和分发</strong>
<ul>
<li><strong>直播服务器</strong>：接收推流并进行处理（如转码、多码率处理、流的分发等）。直播服务器还会维护与观众的连接，并将流数据分发到观众端。</li>
<li><strong>内容分发网络
(CDN)</strong>：为了解决大量用户同时观看时的带宽和负载问题，直播流通常通过
CDN 分发。CDN
在全球各地部署服务器，通过缓存和负载均衡来加速直播内容的分发，减少延迟并提高可用性。</li>
<li><strong>转码</strong>：为了适应不同网络条件和设备，直播服务器通常会对原始视频流进行多码率转码。不同质量的流可以满足用户的不同带宽和设备条件。</li>
</ul></li>
<li><strong>拉流和播放</strong>
<ul>
<li><strong>拉流</strong>（Pulling
Stream）：观众端的播放器通过特定的协议向直播服务器请求视频流，称为拉流。</li>
<li>播放器根据接收到的视频流数据进行解码和播放。</li>
<li>播放器需要支持直播使用的协议，如 RTMP、HLS 或
WebRTC。通常播放器内部实现了缓冲机制，确保即使网络有波动，也能提供连续的播放体验。</li>
</ul></li>
</ol>
<h3 id="关键技术和优化">关键技术和优化</h3>
<h4 id="编码优化">1. <strong>编码优化</strong></h4>
<ul>
<li>在直播中，编码器的选择至关重要，既要确保较高的压缩效率，又要控制延迟。</li>
<li><strong>硬件加速</strong>：为了减少编码的延迟，现代直播系统往往使用硬件加速编码器（如
GPU 加速）来提高编码效率，减少编码延迟。</li>
<li><strong>自适应码率</strong>：视频直播系统通常支持自适应码率（ABR），根据用户当前的网络状况，自动调整视频流的质量，以保证播放的流畅性和低延迟。</li>
</ul>
<h4 id="传输协议的选择">2. <strong>传输协议的选择</strong></h4>
<ul>
<li><strong>RTMP</strong>：低延迟的实时传输协议，支持推流到服务器并在观众端实时播放，延迟通常在
1-3 秒范围内。</li>
<li><strong>HLS</strong>：基于 HTTP
的直播协议，兼容性好但延迟较高（通常在 6-30 秒）。HLS
通过将视频分割成若干小的 TS 文件进行传输。</li>
<li><strong>SRT</strong>：提供更好的传输可靠性和抗网络抖动能力，适合复杂网络条件下的低延迟传输。</li>
<li><strong>WebRTC</strong>：浏览器端实时音视频通信协议，延迟通常在毫秒级，非常适合对延迟敏感的场景（如互动直播、视频会议等）。</li>
</ul>
<h4 id="cdn-和边缘节点优化">3. <strong>CDN 和边缘节点优化</strong></h4>
<ul>
<li>CDN
通过在全球多个节点部署缓存服务器，将直播内容分发到离观众最近的服务器节点，减少网络延迟和带宽压力。</li>
<li><strong>边缘计算</strong>：某些直播服务在 CDN
的边缘节点上进行实时处理和转码，减少直播服务器的负载，并提高分发效率。</li>
</ul>
<h4 id="延迟控制">4. <strong>延迟控制</strong></h4>
<ul>
<li>低延迟是直播技术的一个重要目标，尤其是在互动性较强的场景中（如在线游戏直播、体育赛事、在线教育等）。通过以下手段可以减少直播的延迟：
<ul>
<li><strong>减少编码延迟</strong>：使用快速编码器或硬件加速。</li>
<li><strong>减少传输延迟</strong>：使用低延迟传输协议，如 WebRTC、SRT
或低延迟 RTMP。</li>
<li><strong>减少播放器的缓冲</strong>：尽量减少播放器端的缓冲时间，虽然这可能会增加播放过程中的卡顿风险，但可以显著降低延迟。</li>
</ul></li>
</ul>
<h4 id="网络抖动与丢包处理">5. <strong>网络抖动与丢包处理</strong></h4>
<ul>
<li>在网络不稳定的环境下（如移动网络），直播系统需要应对网络抖动和丢包问题。</li>
<li><strong>FEC (Forward Error
Correction)</strong>：通过在传输数据中增加冗余信息来修复丢失的数据包。</li>
<li><strong>ARQ (Automatic Repeat
reQuest)</strong>：当检测到数据包丢失时，接收端请求发送端重新发送丢失的数据包。</li>
<li><strong>自适应传输机制</strong>：根据网络带宽的变化，自动调整视频流的码率，确保流畅性。</li>
</ul>
<h3 id="实现原理的示例流程">实现原理的示例流程</h3>
<p>假设有一个主播使用 RTMP 协议推流至直播平台，观众通过 HLS
协议观看的典型流程：</p>
<ol type="1">
<li>主播通过摄像头和麦克风采集音视频数据。</li>
<li>音视频数据经过编码（H.264 视频编码，AAC 音频编码），并封装成 FLV
格式，通过 RTMP 协议推送到直播平台服务器。</li>
<li>直播平台服务器接收流后，可能对流进行转码，生成不同清晰度的版本，以适应不同网络状况的观众。</li>
<li>转码后的流通过 CDN
分发到各个边缘节点，离观众最近的节点提供服务。</li>
<li>观众使用支持 HLS 的播放器向 CDN 请求视频流，并按顺序播放收到的 HLS
切片文件（.ts 文件）。</li>
<li>播放器对视频流进行解码，将解码后的画面和音频同步输出，实现直播观看。</li>
</ol>
<h3 id="总结-34">总结</h3>
<p>视频直播的实现涉及多个环节，从视频采集到推流、服务器处理、内容分发和最终播放，每个环节都影响着直播的质量和延迟。选择合适的编码方式、传输协议以及内容分发策略对于实现高质量、低延迟的直播体验至关重要。</p>
<h2 id="网速差如何保证流畅">网速差如何保证流畅</h2>
<p>在网络状况不理想时，直播画面可能会卡顿或画质下降。为了保证在网络条件差的情况下仍然能够提供流畅的观看体验，可以采取多种技术手段进行优化。以下是一些常用的策略：</p>
<h3 id="自适应码率流-adaptive-bitrate-streaming-abr">1. 自适应码率流
(Adaptive Bitrate Streaming, ABR)</h3>
<p>自适应码率技术是目前直播系统最常用的优化手段。它根据用户的网络状况动态调整视频流的码率，以保证观看流畅性。</p>
<ul>
<li><strong>原理</strong>：直播平台通常会将同一个直播视频流生成多种不同清晰度的版本（不同的分辨率和码率），如
480p、720p、1080p
等。当网络带宽变差时，播放器会自动切换到低清晰度、低码率的流，从而减少带宽占用，确保视频播放流畅。</li>
<li><strong>技术实现</strong>：
<ul>
<li>对于 HLS 或 DASH
等协议，播放器端可以自动选择适合当前带宽的流进行播放。</li>
<li>CDN
或服务器端在推送视频流时，会根据带宽监控情况为用户推送合适码率的视频。</li>
</ul></li>
</ul>
<h3 id="降低视频分辨率和帧率">2. 降低视频分辨率和帧率</h3>
<p>当网络条件变差时，适当降低视频的分辨率和帧率可以减少需要传输的数据量，从而提高流畅性。</p>
<ul>
<li><strong>降低分辨率</strong>：比如从 1080p 降低到 720p 或
480p。低分辨率视频所需的带宽更少，可以在较差的网络环境中流畅播放。</li>
<li><strong>降低帧率</strong>：通过减少每秒传输的帧数（例如从 60fps
降低到 30fps 或
15fps），可以大幅减少需要传输的数据量。虽然帧率降低会影响视频的细节流畅度，但在网络条件极差时，降低帧率是非常有效的手段。</li>
</ul>
<h3 id="视频编码器优化">3. 视频编码器优化</h3>
<p>选择合适的编码器和优化编码参数，能够在较低码率下保持较高的视频质量。</p>
<ul>
<li><strong>H.265 (HEVC)</strong> 或 <strong>VP9</strong>：相比
H.264，H.265 和 VP9
编解码器在同等画质下具有更高的压缩效率，适合在低带宽环境下使用。</li>
<li><strong>动态码率调整</strong>：实时编码时，编码器可以根据当前场景复杂度动态调整码率。例如，视频中变化较少的静态场景可以使用较低的码率，而运动较多的场景可以使用较高码率。</li>
<li><strong>编码参数调整</strong>：减少关键帧频率（如 I
帧间隔）等编码设置，能够减少需要传输的关键帧数量，从而减少带宽占用。</li>
</ul>
<h3 id="提高缓冲策略">4. 提高缓冲策略</h3>
<p>适当增加播放器的缓冲区大小，使其在网络波动时仍能继续播放缓存中的视频数据，减少卡顿。</p>
<ul>
<li><strong>增大缓冲区</strong>：在网络抖动较大时，适当增加缓冲区的大小（如将几秒的缓冲时间增加到
10
秒），可以让播放器预加载更多的视频数据，从而应对网络的暂时中断或抖动问题。</li>
<li><strong>逐步加载策略</strong>：在缓冲区不足时，播放器可以动态调整加载策略，首先下载关键帧和低质量数据，确保视频不会卡顿。</li>
</ul>
<h3 id="使用低延迟传输协议">5. 使用低延迟传输协议</h3>
<p>选择合适的低延迟传输协议来减少视频传输时的延迟，尤其是在网络条件不稳定时，可以使用以下协议：</p>
<ul>
<li><strong>SRT (Secure Reliable Transport)</strong>：SRT
协议具有抗网络抖动和丢包的功能，能够在低带宽和高延迟的环境下提供更稳定的流传输效果。</li>
<li><strong>WebRTC</strong>：WebRTC
是一种超低延迟传输协议，适合需要极低延迟的直播场景。WebRTC
能够在不稳定的网络环境下通过自适应码率、拥塞控制等机制保持较流畅的视频体验。</li>
<li><strong>低延迟 HLS</strong>：低延迟 HLS
通过减少切片的大小和缓存时间，使直播延迟缩短，同时保持一定流畅性。</li>
</ul>
<h3 id="网络丢包与错误修正">6. 网络丢包与错误修正</h3>
<p>在差网络环境下，网络丢包是常见问题，通过一些错误修正和丢包重传机制可以提升传输效果。</p>
<ul>
<li><strong>FEC (Forward Error
Correction)</strong>：前向纠错技术会在数据传输中加入冗余数据，以便在一定程度上修复丢失的包，而无需重传，减少由于网络丢包导致的卡顿。</li>
<li><strong>ARQ (Automatic Repeat
Request)</strong>：当传输过程中数据包丢失时，通过 ARQ
机制请求重新发送丢失的数据包，确保数据的完整性。</li>
</ul>
<h3 id="优化直播的网络环境">7. 优化直播的网络环境</h3>
<p>虽然技术手段可以在一定程度上提高流畅性，但优化网络环境也是至关重要的手段。</p>
<ul>
<li><strong>选择合适的 CDN</strong>：通过全球分布的内容分发网络
(CDN)，直播流可以通过就近的服务器节点传输到用户端，减少网络延迟。</li>
<li><strong>网络带宽管理</strong>：对于移动设备，建议使用 4G 或 5G
网络，避免使用 Wi-Fi
网络不稳定的环境。在宽带不高的网络条件下，可以通过限制其他应用程序的网络使用，确保直播有足够的带宽。</li>
</ul>
<h3 id="使用预加载和智能缓存">8. 使用预加载和智能缓存</h3>
<ul>
<li><strong>智能缓存机制</strong>：通过智能分析用户的带宽情况和当前的视频播放进度，提前加载未来几秒的视频流数据。即使网络突然波动，用户仍能利用缓存的数据，继续播放视频，避免卡顿。</li>
<li><strong>渐进式加载</strong>：在加载视频时，优先加载低分辨率的内容并逐渐切换到高分辨率。这种方式能确保即使网络不稳定，用户也能快速开始观看直播。</li>
</ul>
<h3 id="降低非必要开销">9. 降低非必要开销</h3>
<ul>
<li><strong>去除非关键数据流</strong>：在网络条件差时，可以暂停或去掉非关键的数据流，例如关闭不必要的字幕、统计信息等，减少带宽占用。</li>
<li><strong>优化交互逻辑</strong>：在一些互动性较强的直播场景中，降低实时互动频率，减少数据的往返传输，可以保证视频和音频的流畅性。</li>
</ul>
<h3 id="总结-35">总结</h3>
<p>为了在网络条件较差的情况下保持视频直播的流畅性，可以通过自适应码率流、降低分辨率和帧率、优化编码器、提高缓冲、使用低延迟协议、网络丢包处理等技术手段来优化直播体验。同时，选择合适的网络传输架构（如
CDN）和改善本地网络环境也非常重要。</p>
<h2 id="常用流媒体协议">常用流媒体协议</h2>
<p>流媒体协议是指在网络上传输音频、视频等多媒体内容的协议，它们定义了如何在不同设备和网络条件下高效地传输数据。常见的流媒体协议有多个，每个协议都有其独特的特点和应用场景，主要用于视频点播、直播、实时通信等领域。下面是常用的几种流媒体协议的详细介绍：</p>
<hr />
<h3 id="rtmpreal-time-messaging-protocol">1. <strong>RTMP（Real-Time
Messaging Protocol）</strong></h3>
<h4 id="概述-16">概述</h4>
<p>RTMP 是 Adobe 公司开发的一种用于音视频数据传输的流媒体协议，最初用于
Flash 播放器。虽然 Flash 已经逐渐被淘汰，但 RTMP
仍然在视频直播中得到广泛应用，特别是在推流和传输中。</p>
<h4 id="特点-12">特点：</h4>
<ul>
<li><strong>低延迟</strong>：RTMP
提供了较低的传输延迟，通常用于实时直播场景。</li>
<li><strong>TCP 协议</strong>：RTMP 基于 TCP
协议，提供可靠的数据传输，保证数据的完整性。</li>
<li><strong>适用于推流</strong>：RTMP
常用于从客户端推送视频流到服务器，或者从服务器向播放器分发直播视频。</li>
<li><strong>逐渐被 HLS 替代</strong>：随着 HLS 等协议的普及，RTMP
的应用正在逐渐减少，特别是在终端播放器上，但它仍广泛应用于服务器端的推流过程。</li>
</ul>
<h4 id="使用场景-12">使用场景：</h4>
<ul>
<li>视频直播推流：RTMP 常用于客户端（如 OBS）向服务器推送直播流。</li>
<li>视频点播：一些旧的 Flash 视频点播系统仍然使用 RTMP。</li>
</ul>
<h4 id="架构示例">架构示例：</h4>
<ul>
<li><strong>推流</strong>：客户端（如摄像头或编码器）通过 RTMP
协议将音视频数据推送到流媒体服务器（如 Wowza、NGINX-RTMP）。</li>
<li><strong>拉流</strong>：观众设备通过 RTMP
拉取音视频流，实现低延迟观看。</li>
</ul>
<hr />
<h3 id="hlshttp-live-streaming">2. <strong>HLS（HTTP Live
Streaming）</strong></h3>
<h4 id="概述-17">概述</h4>
<p>HLS 是由苹果公司开发的一种基于 HTTP
的流媒体传输协议。它通过将媒体流分割成若干小的文件（TS
切片），并通过标准 HTTP 协议进行传输。这种方式使得 HLS 可以在任意支持
HTTP 的平台上工作，且具备良好的兼容性。</p>
<h4 id="特点-13">特点：</h4>
<ul>
<li><strong>广泛支持</strong>：HLS
是移动设备上最常用的流媒体协议，iOS、macOS 原生支持 HLS。</li>
<li><strong>基于 HTTP 传输</strong>：HLS 通过 HTTP
进行传输，具备很好的兼容性，可以利用现有的 HTTP 服务器和
CDN（内容分发网络）进行分发。</li>
<li><strong>适应性流媒体</strong>：HLS
支持自适应比特率流（ABR），可以根据网络条件动态切换视频质量，保证在不同带宽下的流畅播放。</li>
<li><strong>高延迟</strong>：HLS 的一个主要缺点是延迟较高，通常在 10-30
秒，主要是由于每个切片的时长（通常为 2-6 秒）和缓冲机制所致。</li>
</ul>
<h4 id="使用场景-13">使用场景：</h4>
<ul>
<li>视频点播（VOD）：HLS 常用于视频点播服务，如 Netflix 和
YouTube。</li>
<li>直播流媒体：HLS
也用于实时直播，但在一些对低延迟要求较高的场景（如在线教育、游戏直播）中效果不佳。</li>
</ul>
<h4 id="工作原理-5">工作原理：</h4>
<ul>
<li><strong>切片</strong>：将视频文件切分为多个 TS 小文件，并生成一个
<code>.m3u8</code> 文件来索引这些切片。</li>
<li><strong>传输</strong>：客户端根据 <code>.m3u8</code> 文件，通过 HTTP
协议逐个下载 TS 切片并进行播放。</li>
<li><strong>自适应</strong>：客户端根据网络带宽和播放情况动态选择合适的切片质量。</li>
</ul>
<hr />
<h3 id="dashdynamic-adaptive-streaming-over-http">3.
<strong>DASH（Dynamic Adaptive Streaming over HTTP）</strong></h3>
<h4 id="概述-18">概述</h4>
<p>DASH 是一种与 HLS 类似的流媒体传输协议，也基于 HTTP 传输。它是由 MPEG
组织开发的标准协议，旨在提供自适应的流媒体传输。</p>
<h4 id="特点-14">特点：</h4>
<ul>
<li><strong>跨平台支持</strong>：DASH 是开放标准，相较于 HLS
在苹果平台的主导地位，DASH 在 Android 和 Windows
等平台上也有广泛支持。</li>
<li><strong>自适应比特率流</strong>：与 HLS 类似，DASH
支持自适应比特率流，可以根据网络带宽切换不同清晰度的流。</li>
<li><strong>基于 HTTP</strong>：DASH 通过 HTTP 进行传输，兼容 HTTP
服务器和 CDN。</li>
<li><strong>更灵活的编码支持</strong>：DASH 支持多种编码格式，如
H.264、H.265、VP9 等，具有更高的灵活性。</li>
</ul>
<h4 id="使用场景-14">使用场景：</h4>
<ul>
<li>视频点播：DASH 常用于高清视频点播服务，支持 4K、HDR
等高质量视频内容。</li>
<li>实时流媒体：DASH 支持实时流媒体，但与 HLS 一样，延迟通常较高。</li>
</ul>
<h4 id="工作原理-6">工作原理：</h4>
<ul>
<li><strong>切片与索引文件</strong>：DASH 将视频切片为若干小段，并通过
MPD（Media Presentation Description）文件进行索引，类似于 HLS 的
<code>.m3u8</code> 文件。</li>
<li><strong>动态适应</strong>：客户端根据网络状况选择不同质量的切片，进行动态适应，提供最佳播放体验。</li>
</ul>
<hr />
<h3 id="rtspreal-time-streaming-protocol">4. <strong>RTSP（Real-Time
Streaming Protocol）</strong></h3>
<h4 id="概述-19">概述</h4>
<p>RTSP 是一种用于控制多媒体流的网络协议，它与 RTP
协议配合使用，用于流媒体播放控制。RTSP
定义了如何在客户端和服务器之间建立和管理流媒体会话，但实际的数据传输通常通过
RTP 进行。</p>
<h4 id="特点-15">特点：</h4>
<ul>
<li><strong>实时流媒体传输</strong>：RTSP
常用于实时视频传输场景，尤其是在视频监控、IP 摄像机中广泛应用。</li>
<li><strong>基于 RTP</strong>：RTSP 本身不传输数据，数据传输由
RTP（Real-Time Transport Protocol）完成。RTP 使用 UDP
进行传输，具备低延迟的优势。</li>
<li><strong>复杂的控制功能</strong>：RTSP
提供了丰富的控制功能，如播放、暂停、快进、倒退等操作。</li>
<li><strong>灵活性</strong>：RTSP
非常灵活，适用于实时媒体流的传输和控制。</li>
</ul>
<h4 id="使用场景-15">使用场景：</h4>
<ul>
<li>视频监控：RTSP 是许多 IP 摄像机、监控系统中传输视频的主要协议。</li>
<li>视频会议：RTSP 被广泛应用于视频会议系统中，提供实时音视频传输。</li>
</ul>
<h4 id="工作原理-7">工作原理：</h4>
<ul>
<li><strong>会话管理</strong>：RTSP 定义了会话控制命令，如
<code>PLAY</code>、<code>PAUSE</code>、<code>SETUP</code>
等，用于控制媒体流的播放。</li>
<li><strong>数据传输</strong>：RTSP 通过 RTP 协议传输音视频数据。RTP
通常基于 UDP 传输，能够实现低延迟的视频播放。</li>
</ul>
<hr />
<h3 id="webrtcweb-real-time-communication">5. <strong>WebRTC（Web
Real-Time Communication）</strong></h3>
<h4 id="概述-20">概述</h4>
<p>WebRTC
是一种用于实时音视频通信的开源协议，支持点对点的低延迟音视频传输。它主要用于实时通信场景，例如视频聊天、视频会议和直播互动。</p>
<h4 id="特点-16">特点：</h4>
<ul>
<li><strong>超低延迟</strong>：WebRTC
的延迟通常在毫秒级，非常适合实时通信场景。</li>
<li><strong>点对点通信</strong>：WebRTC 支持通过
P2P（点对点）进行音视频传输，可以减少服务器的压力，并提供更快的传输速度。</li>
<li><strong>跨平台支持</strong>：WebRTC 在现代浏览器中得到了广泛支持，如
Chrome、Firefox 等。</li>
<li><strong>安全性</strong>：WebRTC 默认使用加密传输（DTLS 和
SRTP），确保数据的安全性。</li>
</ul>
<h4 id="使用场景-16">使用场景：</h4>
<ul>
<li>视频聊天和会议：例如 Google Meet、Zoom 等视频会议工具使用 WebRTC
实现点对点通信。</li>
<li>实时直播：WebRTC
也用于超低延迟的互动直播场景，特别是在需要观众和主播实时互动的场景中。</li>
<li>游戏直播与多人互动：如需要极低延迟的场景，例如多人游戏直播和在线协作应用。</li>
</ul>
<h4 id="工作原理-8">工作原理：</h4>
<ul>
<li><strong>信令交换</strong>：在建立 WebRTC
连接之前，客户端通过信令交换（如通过
WebSocket）传递会话描述信息（SDP），确定媒体格式和传输方式。</li>
<li><strong>点对点通信</strong>：一旦连接建立，音视频数据通过 P2P
进行传输，减少中转服务器的负载和延迟。</li>
</ul>
<hr />
<h3 id="srtsecure-reliable-transport">6. <strong>SRT（Secure Reliable
Transport）</strong></h3>
<h4 id="概述-21">概述</h4>
<p>SRT
是一种开源的传输协议，专为在不稳定网络条件下进行安全和低延迟的音视频传输设计。SRT
具有抗丢包、抗抖动的特性，适合在复杂网络环境下的直播流媒体传输。</p>
<h4 id="特点-17">特点：</h4>
<ul>
<li><strong>低延迟</strong>：SRT 专为低延迟传输设计，适合高质量</li>
</ul>
<p>直播。 - <strong>安全性</strong>：SRT
提供了端到端的加密，确保数据传输的安全性。 -
<strong>抗丢包与抖动</strong>：SRT
内置了丢包重传机制和网络抖动缓冲，能够在网络状况不佳的情况下保证音视频流的完整性和质量。
- <strong>基于 UDP</strong>：SRT 基于 UDP
协议，但通过丢包重传等机制，实现了可靠的数据传输。</p>
<h4 id="使用场景-17">使用场景：</h4>
<ul>
<li>远程直播：SRT
适合用于跨国直播、远程摄像机传输等需要高质量和低延迟的视频传输场景。</li>
<li>复杂网络环境下的直播：在丢包率较高的网络中，SRT
能够提供较好的传输性能。</li>
</ul>
<h4 id="工作原理-9">工作原理：</h4>
<ul>
<li><strong>丢包重传</strong>：SRT 使用 NACK
反馈机制检测丢包，并重新传输丢失的数据包。</li>
<li><strong>加密传输</strong>：SRT 提供 AES
加密，确保传输过程中的数据安全。</li>
</ul>
<hr />
<h3 id="总结-36">总结</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 22%" />
<col style="width: 5%" />
<col style="width: 8%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>协议</th>
<th>传输方式</th>
<th>延迟</th>
<th>安全性</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>RTMP</strong></td>
<td>基于 TCP</td>
<td>低</td>
<td>无</td>
<td>直播推流、低延迟视频传输</td>
</tr>
<tr class="even">
<td><strong>HLS</strong></td>
<td>基于 HTTP</td>
<td>高</td>
<td>支持</td>
<td>视频点播、直播（延迟容忍度较高）</td>
</tr>
<tr class="odd">
<td><strong>DASH</strong></td>
<td>基于 HTTP</td>
<td>中等</td>
<td>支持</td>
<td>高清视频点播、自适应流传输</td>
</tr>
<tr class="even">
<td><strong>RTSP</strong></td>
<td>基于 UDP（RTP）</td>
<td>低</td>
<td>无</td>
<td>视频监控、视频会议</td>
</tr>
<tr class="odd">
<td><strong>WebRTC</strong></td>
<td>基于 P2P/UDP</td>
<td>超低</td>
<td>支持</td>
<td>视频聊天、视频会议、互动直播</td>
</tr>
<tr class="even">
<td><strong>SRT</strong></td>
<td>基于 UDP</td>
<td>低</td>
<td>支持</td>
<td>跨国直播、远程视频传输</td>
</tr>
</tbody>
</table>
<p>不同的流媒体协议有各自的优缺点，开发者需要根据具体的应用场景（如延迟需求、网络环境、传输稳定性等）选择合适的协议。</p>
<h2 id="dts-和-pts-有什么区别">DTS 和 PTS 有什么区别</h2>
<p>DTS（Decoding Time Stamp，解码时间戳）和 PTS（Presentation Time
Stamp，显示时间戳）是视频和音频流中两个重要的时间戳概念，通常用于多媒体容器格式如
MPEG、MKV
等，目的是同步音视频的播放。它们的区别主要体现在解码和播放的时序上：</p>
<ol type="1">
<li><strong>DTS（解码时间戳）</strong>：
<ul>
<li>作用：告诉解码器什么时候开始解码某一帧的数据。</li>
<li>含义：当视频流中的某一帧可能需要提前解码（例如在有 B
帧的情况下），解码器会根据 DTS 值进行解码，但不一定立刻显示。</li>
<li>应用：在包含帧重排序的视频编码（如 H.264）中，DTS
代表该帧应当被解码的时刻。</li>
</ul></li>
<li><strong>PTS（显示时间戳）</strong>：
<ul>
<li>作用：告诉播放器什么时候把解码后的帧显示到屏幕上。</li>
<li>含义：PTS 决定了解码后的帧何时被呈现给观众或播放出来。PTS
通常和播放的时间轴直接相关。</li>
<li>应用：PTS
用于确保帧按照正确的顺序和时间展示，尤其是对于具有复杂帧类型（如 I 帧、P
帧和 B 帧）的流。</li>
</ul></li>
</ol>
<h3 id="总结-37">总结：</h3>
<ul>
<li><strong>DTS</strong> 控制解码时间，<strong>PTS</strong>
控制显示时间。</li>
<li>DTS 不一定总是存在，特别是在没有帧重排序的流中。</li>
<li>PTS 是多媒体流中最常见的时间戳，用于保持音视频同步。</li>
</ul>
<p>对于大多数视频播放场景，播放器会优先使用 PTS 确保音视频的同步播放，而
DTS 则更多地在视频解码过程中起作用。</p>
<h1 id="数据结构和算法">数据结构和算法</h1>
<p>数据结构和算法是计算机科学的核心，它们帮助我们以有效的方式存储、组织和处理数据。掌握常用的数据结构和算法对编写高效程序至关重要。下面将介绍一些常用的数据结构和算法，并提供相应的示例代码。</p>
<hr />
<h2 id="常用数据结构">1. <strong>常用数据结构</strong></h2>
<h3 id="数组-array">1.1 <strong>数组 (Array)</strong></h3>
<p><strong>数组</strong>是一种固定大小的线性数据结构，存储相同类型的元素。它支持通过索引快速访问元素，但由于大小固定，插入和删除操作相对复杂。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>访问元素：O(1)</li>
<li>插入/删除元素：O(n) （最坏情况下，需要移动元素）</li>
</ul></li>
</ul>
<h4 id="示例java">示例（Java）：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);  <span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure>
<h3 id="链表-linked-list">1.2 <strong>链表 (Linked List)</strong></h3>
<p><strong>链表</strong>是一种动态的数据结构，由节点组成，每个节点包含数据部分和指向下一个节点的指针。链表分为单链表和双链表。与数组不同，链表支持动态扩展，插入和删除操作高效，但随机访问性能较差。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>访问元素：O(n)</li>
<li>插入/删除元素：O(1)（当给定节点位置时）</li>
</ul></li>
</ul>
<h4 id="示例java-单链表">示例（Java 单链表）：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> data) &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">    Node head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(current.data + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈-stack">1.3 <strong>栈 (Stack)</strong></h3>
<p><strong>栈</strong>是一种后进先出（LIFO）的数据结构。栈支持在栈顶进行插入和删除操作，常用于递归、括号匹配等问题。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>压栈/出栈：O(1)</li>
<li>访问元素：O(n)</li>
</ul></li>
</ul>
<h4 id="示例java-使用栈">示例（Java 使用栈）：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="number">1</span>);  <span class="comment">// 压入元素</span></span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">System.out.println(stack.pop());  <span class="comment">// 弹出元素，输出：2</span></span><br><span class="line">System.out.println(stack.peek()); <span class="comment">// 查看栈顶元素，输出：1</span></span><br></pre></td></tr></table></figure>
<h3 id="队列-queue">1.4 <strong>队列 (Queue)</strong></h3>
<p><strong>队列</strong>是一种先进先出（FIFO）的数据结构，常用于排队处理任务。队列支持在队尾插入数据，并在队首删除数据。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>入队/出队：O(1)</li>
<li>访问元素：O(n)</li>
</ul></li>
</ul>
<h4 id="示例java-使用队列">示例（Java 使用队列）：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="number">1</span>);  <span class="comment">// 入队</span></span><br><span class="line">queue.offer(<span class="number">2</span>);</span><br><span class="line">System.out.println(queue.poll());  <span class="comment">// 出队，输出：1</span></span><br><span class="line">System.out.println(queue.peek());  <span class="comment">// 查看队首元素，输出：2</span></span><br></pre></td></tr></table></figure>
<h3 id="哈希表-hash-table">1.5 <strong>哈希表 (Hash Table)</strong></h3>
<p><strong>哈希表</strong>是一种基于哈希函数的数据结构，用于快速查找、插入和删除数据。哈希表通过将键映射到特定的存储位置，能够实现接近
O(1) 时间复杂度的查找。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>查找/插入/删除：平均 O(1)，最坏 O(n)</li>
</ul></li>
</ul>
<h4 id="示例java-使用哈希表">示例（Java 使用哈希表）：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">map.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;Alice&quot;</span>));  <span class="comment">// 输出：25</span></span><br><span class="line">map.remove(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">System.out.println(map.containsKey(<span class="string">&quot;Bob&quot;</span>));  <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure>
<h3 id="树-tree">1.6 <strong>树 (Tree)</strong></h3>
<p><strong>树</strong>是一种层次结构的非线性数据结构，包含节点，每个节点有一个父节点和若干子节点。<strong>二叉树</strong>是树的特殊形式，每个节点最多有两个子节点。<strong>二叉搜索树（BST）</strong>是一种特殊的二叉树，其中每个节点的左子节点都小于该节点，右子节点都大于该节点。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>查找/插入/删除：O(log n)（在平衡二叉树中）</li>
</ul></li>
</ul>
<h4 id="示例二叉树的遍历">示例（二叉树的遍历）：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        left = right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="常用算法">2. <strong>常用算法</strong></h2>
<h3 id="排序算法">2.1 <strong>排序算法</strong></h3>
<h4 id="快速排序-quick-sort">2.1.1 <strong>快速排序 (Quick
Sort)</strong></h4>
<p><strong>思想</strong>：快速排序是基于分治思想的排序算法，通过选择一个基准元素，将数组分成两部分，使得基准元素左边的元素都小于它，右边的元素都大于它，然后递归地对两部分进行排序。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>最优/平均情况：O(n log n)</li>
<li>最坏情况：O(n²)</li>
</ul></li>
</ul>
<h4 id="示例java-快速排序">示例（Java 快速排序）：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pi</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">        arr[high] = temp;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));  <span class="comment">// 输出排序后的数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找算法">2.2 <strong>查找算法</strong></h3>
<h4 id="二分查找-binary-search">2.2.1 <strong>二分查找 (Binary
Search)</strong></h4>
<p><strong>思想</strong>：二分查找用于在有序数组中查找元素，通过不断将查找范围减半，直到找到目标元素或范围为空。</p>
<ul>
<li><strong>时间复杂度</strong>：O(log n)</li>
</ul>
<h4 id="示例java-二分查找">示例（Java 二分查找）：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(arr, <span class="number">4</span>);</span><br><span class="line">        System.out.println(index);  <span class="comment">// 输出：3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="贪心算法-greedy-algorithm">2.3 <strong>贪心算法 (Greedy
Algorithm)</strong></h3>
<p><strong>思想</strong>：贪心算法通过每一步选择当前最优解来构建全局最优解，常用于解决优化问题，如背包问题、最小生成树等。</p>
<ul>
<li><strong>时间复杂度</strong>：取决于具体问题</li>
</ul>
<h4 id="示例java-找零问题">示例（Java 找零问题）：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreedyChange</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">makeChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        Arrays.sort(coins);  <span class="comment">// 从小到大排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coins.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (amount &gt;= coins[i]) &#123;</span><br><span class="line">               </span><br><span class="line"></span><br><span class="line"> amount -= coins[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        System.out.println(makeChange(coins, <span class="number">63</span>));  <span class="comment">// 输出：6（25 + 25 + 10 + 1 + 1 + 1）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划-dynamic-programming">2.4 <strong>动态规划 (Dynamic
Programming)</strong></h3>
<p><strong>思想</strong>：动态规划通过将复杂问题分解为更小的子问题来解决，每个子问题的结果都会被保存，以便后续重用，避免重复计算。</p>
<ul>
<li><strong>时间复杂度</strong>：取决于问题的规模和状态数</li>
</ul>
<h4 id="示例java-求解斐波那契数列">示例（Java 求解斐波那契数列）：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fib(<span class="number">10</span>));  <span class="comment">// 输出：55</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结-38">总结</h3>
<ul>
<li><strong>数据结构</strong>提供了组织和存储数据的方式，如数组、链表、栈、队列、树、哈希表等。</li>
<li><strong>算法</strong>提供了解决问题的步骤或过程，如排序（快速排序）、查找（二分查找）、贪心算法和动态规划等。</li>
</ul>
<p>通过选择合适的数据结构和算法，可以显著提高程序的性能和可扩展性。</p>
<h2 id="链表常用算法">链表常用算法</h2>
<p>好的！链表（Linked
List）是一种基础且重要的数据结构，在算法和数据处理中有着广泛应用。相比数组，链表的优势在于动态性和插入/删除的效率，但也带来了一些挑战，比如查找和反转的复杂性。以下我将详细讲解链表的主要算法，包括<strong>遍历、反转、合并、检测环、删除节点</strong>等，针对每种算法提供原理、Java
代码示例和分析。这些算法涵盖了常见的链表操作，适用于算法学习和面试准备。</p>
<hr />
<h3 id="定义链表节点">1. 定义链表节点</h3>
<p>首先定义一个单向链表节点类，作为示例的基础： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;         <span class="comment">// 数据域</span></span><br><span class="line">    ListNode next;   <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表的辅助方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(curr.val + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="主要算法及实现">2. 主要算法及实现</h3>
<h4 id="遍历链表">2.1 遍历链表</h4>
<h5 id="原理">原理</h5>
<ul>
<li>从头节点开始，沿 <code>next</code> 指针依次访问每个节点，直到遇到
<code>null</code>。</li>
<li>用于统计长度、查找节点或打印链表。</li>
</ul>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Length: &quot;</span> + getLength(head)); <span class="comment">// 输出: 3</span></span><br><span class="line">        ListNode.printList(head); <span class="comment">// 输出: 1 -&gt; 2 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度">复杂度</h5>
<ul>
<li><strong>时间复杂度</strong>: O(n)，n 是链表长度。</li>
<li><strong>空间复杂度</strong>: O(1)，只用一个指针。</li>
</ul>
<hr />
<h4 id="反转链表">2.2 反转链表</h4>
<h5 id="原理-1">原理</h5>
<ul>
<li>使用三个指针（<code>prev</code>、<code>curr</code>、<code>next</code>）迭代反转每个节点的
<code>next</code> 指针。</li>
<li>核心思想：逐步调整指针方向，原地完成反转。</li>
</ul>
<h5 id="代码-1">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;  <span class="comment">// 保存下一个节点</span></span><br><span class="line">            curr.next = prev;           <span class="comment">// 反转指针</span></span><br><span class="line">            prev = curr;                <span class="comment">// 前移 prev</span></span><br><span class="line">            curr = next;                <span class="comment">// 前移 curr</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;                    <span class="comment">// 新头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reversed</span> <span class="operator">=</span> reverseList(head);</span><br><span class="line">        ListNode.printList(reversed); <span class="comment">// 输出: 3 -&gt; 2 -&gt; 1 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-1">复杂度</h5>
<ul>
<li><strong>时间复杂度</strong>: O(n)，一次遍历。</li>
<li><strong>空间复杂度</strong>: O(1)，原地操作。</li>
</ul>
<hr />
<h4 id="合并两个有序链表">2.3 合并两个有序链表</h4>
<h5 id="原理-2">原理</h5>
<ul>
<li>类似归并排序的合并过程，比较两个链表的节点值，逐步构建新链表。</li>
<li>使用哑节点（dummy node）简化边界处理。</li>
</ul>
<h5 id="代码-2">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 哑节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理剩余节点</span></span><br><span class="line">        curr.next = (l1 != <span class="literal">null</span>) ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        l1.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        l1.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        l2.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        l2.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> mergeTwoLists(l1, l2);</span><br><span class="line">        ListNode.printList(merged); <span class="comment">// 输出: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-2">复杂度</h5>
<ul>
<li><strong>时间复杂度</strong>: O(n + m)，n 和 m 是两个链表长度。</li>
<li><strong>空间复杂度</strong>: O(1)，仅用哑节点，不计输出空间。</li>
</ul>
<hr />
<h4 id="检测链表中的环">2.4 检测链表中的环</h4>
<h5 id="原理-3">原理</h5>
<ul>
<li>使用<strong>快慢指针法</strong>（Floyd 判圈算法）：
<ul>
<li>慢指针每次走 1 步，快指针每次走 2 步。</li>
<li>若有环，快慢指针会在环内相遇；若无环，快指针先到
<code>null</code>。</li>
</ul></li>
</ul>
<h5 id="代码-3">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;         <span class="comment">// 慢指针走 1 步</span></span><br><span class="line">            fast = fast.next.next;    <span class="comment">// 快指针走 2 步</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 相遇说明有环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = head.next; <span class="comment">// 创建环: 1 -&gt; 2 -&gt; 3 -&gt; 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hasCycle(head)); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-3">复杂度</h5>
<ul>
<li><strong>时间复杂度</strong>: O(n)，快指针最多跑完环的长度。</li>
<li><strong>空间复杂度</strong>: O(1)，只用两个指针。</li>
</ul>
<hr />
<h4 id="删除链表中的节点">2.5 删除链表中的节点</h4>
<h5 id="原理-4">原理</h5>
<ul>
<li><strong>普通删除</strong>:
找到目标节点的前驱，调整指针跳过目标。</li>
<li><strong>特殊情况</strong>:
如果只给定要删除的节点（无前驱引用），将其值替换为下个节点的值，再删除下个节点。</li>
</ul>
<h5 id="代码-4">代码</h5>
<h6 id="删除指定值的节点">删除指定值的节点</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 哑节点处理头节点删除</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next; <span class="comment">// 跳过目标节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> deleteNode(head, <span class="number">2</span>);</span><br><span class="line">        ListNode.printList(result); <span class="comment">// 输出: 1 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="只给定节点删除无前驱">只给定节点删除（无前驱）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设 node 是要删除的节点，且不是尾节点</span></span><br><span class="line">        node.val = node.next.val;    <span class="comment">// 复制下个节点的值</span></span><br><span class="line">        node.next = node.next.next;  <span class="comment">// 跳过下个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeToDelete</span> <span class="operator">=</span> head.next; <span class="comment">// 删除 2</span></span><br><span class="line"></span><br><span class="line">        deleteNode(nodeToDelete);</span><br><span class="line">        ListNode.printList(head); <span class="comment">// 输出: 1 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-4">复杂度</h5>
<ul>
<li><strong>普通删除</strong>: O(n) 时间，O(1) 空间。</li>
<li><strong>给定节点删除</strong>: O(1) 时间，O(1) 空间。</li>
</ul>
<hr />
<h4 id="查找中间节点">2.6 查找中间节点</h4>
<h5 id="原理-5">原理</h5>
<ul>
<li>使用快慢指针：快指针走 2 步，慢指针走 1
步，快指针到尾时，慢指针在中间。</li>
</ul>
<h5 id="代码-5">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">middle</span> <span class="operator">=</span> middleNode(head);</span><br><span class="line">        System.out.println(middle.val); <span class="comment">// 输出: 3 (偶数长度取后半中间)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-5">复杂度</h5>
<ul>
<li><strong>时间复杂度</strong>: O(n)。</li>
<li><strong>空间复杂度</strong>: O(1)。</li>
</ul>
<hr />
<h3 id="复杂度总结">3. 复杂度总结</h3>
<table>
<thead>
<tr class="header">
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>关键技术</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
<td>指针移动</td>
</tr>
<tr class="even">
<td>反转</td>
<td>O(n)</td>
<td>O(1)</td>
<td>三指针迭代</td>
</tr>
<tr class="odd">
<td>合并有序链表</td>
<td>O(n + m)</td>
<td>O(1)</td>
<td>哑节点、双指针</td>
</tr>
<tr class="even">
<td>检测环</td>
<td>O(n)</td>
<td>O(1)</td>
<td>快慢指针</td>
</tr>
<tr class="odd">
<td>删除节点</td>
<td>O(n) / O(1)</td>
<td>O(1)</td>
<td>前驱指针 / 值替换</td>
</tr>
<tr class="even">
<td>查找中间节点</td>
<td>O(n)</td>
<td>O(1)</td>
<td>快慢指针</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="算法应用场景">4. 算法应用场景</h3>
<ul>
<li><strong>遍历</strong>: 统计、搜索基础操作。</li>
<li><strong>反转</strong>: 翻转数据顺序（如打印倒序）。</li>
<li><strong>合并</strong>: 归并排序、合并数据流。</li>
<li><strong>检测环</strong>: 检查循环依赖、死循环。</li>
<li><strong>删除</strong>: 数据清理、动态调整。</li>
<li><strong>中间节点</strong>: 分治法、分段处理。</li>
</ul>
<hr />
<h3 id="总结-39">5. 总结</h3>
<p>链表的主要算法围绕指针操作展开，核心是<strong>指针的移动与调整</strong>。通过快慢指针、三指针、哑节点等技巧，可以高效解决常见问题。Java
实现中要注意： - <strong>边界条件</strong>: 处理空链表或单节点。 -
<strong>内存管理</strong>: 确保不留悬空引用（Java
垃圾回收会处理，但逻辑需清晰）。</p>
<p>如果想深入某个算法（比如递归反转、双向链表操作）或有具体问题（比如链表排序），告诉我，我可以进一步展开！有什么想问的吗？</p>
<h1 id="网络">网络</h1>
<h2 id="https-进行连接的过程">Https 进行连接的过程</h2>
<p>我来详细讲解 HTTPS 的连接过程，用简洁的语言梳理清楚它的步骤。HTTPS 是
HTTP 的安全版本，通过在 HTTP 和 TCP 之间加入 TLS/SSL
层来实现加密通信。整个过程主要分为 <strong>TCP 连接建立</strong> 和
<strong>TLS 握手</strong> 两个阶段。下面是逐步拆解：</p>
<hr />
<h3 id="tcp-三次握手">1. TCP 三次握手</h3>
<p>HTTPS 基于 TCP，所以先要建立一个可靠的 TCP
连接。这通过三次握手完成：</p>
<ul>
<li><strong>客户端发送 SYN</strong>：<br />
客户端向服务器发送一个 SYN（同步）包，带一个随机序列号（如
<code>Seq = x</code>），表示想建立连接。</li>
<li><strong>服务器回复 SYN-ACK</strong>：<br />
服务器收到后，回应一个 SYN-ACK（同步-确认）包，包含自己的序列号（如
<code>Seq = y</code>）和对客户端的确认（<code>Ack = x + 1</code>）。</li>
<li><strong>客户端发送 ACK</strong>：<br />
客户端再回一个
ACK（确认）包，确认服务器的序列号（<code>Ack = y + 1</code>）。这时，TCP
连接就建好了，双向通信通道准备就绪。</li>
</ul>
<hr />
<h3 id="tls-握手">2. TLS 握手</h3>
<p>TCP 连接建立后，开始 TLS
握手，目的是协商加密参数、验证身份并建立安全通道。过程如下：</p>
<ul>
<li><strong>步骤 1：Client Hello</strong><br />
客户端发起握手，发送 “Client Hello” 消息，包含：
<ul>
<li>支持的 TLS 版本（如 TLS 1.2 或 1.3）。</li>
<li>支持的加密算法组合（比如 AES_256_GCM + SHA256）。</li>
<li>一个随机数（Client Random），用于后续密钥生成。</li>
</ul></li>
<li><strong>步骤 2：Server Hello</strong><br />
服务器回应 “Server Hello” 消息，包含：
<ul>
<li>选定的 TLS 版本和加密算法。</li>
<li>另一个随机数（Server Random）。</li>
<li>服务器的数字证书（包含公钥，由权威机构 CA 签名）。</li>
</ul></li>
<li><strong>步骤 3：证书验证</strong><br />
客户端拿到证书后：
<ul>
<li>检查证书是否可信（验证 CA 签名、证书有效期、域名匹配）。</li>
<li>如果通过，提取服务器公钥。</li>
</ul></li>
<li><strong>步骤 4：密钥交换</strong>
<ul>
<li>客户端生成一个随机值（Pre-Master Secret）。</li>
<li>用服务器公钥加密这个值，发给服务器。</li>
<li>双方用 Client Random、Server Random 和 Pre-Master Secret
计算出对称密钥（Master Secret）。<br />
（注：TLS 1.3 用更安全的 Diffie-Hellman
密钥交换替代这个方式，但目标一致：生成对称密钥。）</li>
</ul></li>
<li><strong>步骤 5：完成握手</strong>
<ul>
<li>客户端发送 “Finished”
消息，用刚生成的对称密钥加密，证明握手成功。</li>
<li>服务器也发送 “Finished” 消息，同样加密，确认双方密钥一致。</li>
<li>TLS 握手结束，安全通道建立。</li>
</ul></li>
</ul>
<hr />
<h3 id="加密通信">3. 加密通信</h3>
<p>握手完成后，客户端和服务器用协商好的对称密钥（比如 AES）加密所有 HTTP
数据，包括请求和响应，确保通信内容不被窃听或篡改。</p>
<hr />
<h3 id="流程图-2">流程图</h3>
<pre><code class="highlight mermaid">sequenceDiagram
    participant C as 客户端
    participant S as 服务器

    %% TCP 三次握手
    C-&gt;&gt;S: SYN (Seq = x)
    S--&gt;&gt;C: SYN-ACK (Seq = y, Ack = x + 1)
    C-&gt;&gt;S: ACK (Ack = y + 1)
    Note right of S: TCP 连接建立

    %% TLS 握手
    C-&gt;&gt;S: Client Hello&lt;br&gt;(版本、算法、Client Random)
    S--&gt;&gt;C: Server Hello&lt;br&gt;(版本、算法、Server Random、证书)
    C-&gt;&gt;C: 验证证书
    C-&gt;&gt;S: Pre-Master Secret&lt;br&gt;(用公钥加密)
    Note over C,S: 双方计算对称密钥
    C-&gt;&gt;S: Finished&lt;br&gt;(加密)
    S--&gt;&gt;C: Finished&lt;br&gt;(加密)
    Note right of S: TLS 握手完成

    %% 加密通信
    C-&gt;&gt;S: HTTP 请求 (加密)
    S--&gt;&gt;C: HTTP 响应 (加密)</code></pre>
<h3 id="完整流程总结">完整流程总结</h3>
<ol type="1">
<li><strong>TCP 三次握手</strong>：建立底层连接（SYN → SYN-ACK →
ACK）。</li>
<li><strong>TLS 握手</strong>：
<ul>
<li>协商版本和算法（Client Hello ↔︎ Server Hello）。</li>
<li>验证服务器身份（证书）。</li>
<li>交换密钥材料并生成对称密钥。</li>
<li>双方确认握手完成（Finished）。</li>
</ul></li>
<li><strong>加密通信</strong>：用对称密钥保护后续 HTTP 数据。</li>
</ol>
<hr />
<h3 id="为什么这么设计">为什么这么设计？</h3>
<ul>
<li><strong>安全性</strong>：证书验证防中间人攻击，加密保护数据隐私。</li>
<li><strong>效率</strong>：对称加密（通信阶段）比非对称加密（握手阶段）快，结合使用兼顾安全和性能。</li>
<li><strong>灵活性</strong>：支持多种算法和版本，适应不同场景。</li>
</ul>
<hr />
<h2 id="https-连接过程中使用对称和非对称加密的场景">Https
连接过程中使用对称和非对称加密的场景</h2>
<p>在 HTTPS
的连接过程中，对称加密和非对称加密各司其职，用在不同的阶段。下面我详细说明
HTTPS（包括 TCP 握手和 TLS 握手）中这两类加密的用途和具体位置：</p>
<hr />
<h3 id="对称加密和非对称加密的定义">对称加密和非对称加密的定义</h3>
<ul>
<li><strong>对称加密</strong>：加密和解密用同一个密钥（如
AES、ChaCha20），速度快，适合大数据量加密。</li>
<li><strong>非对称加密</strong>：使用一对密钥（公钥加密，私钥解密，或反之），如
RSA、ECC，速度慢但安全，用于密钥交换或身份验证。</li>
</ul>
<hr />
<h3 id="https-连接过程中加密的使用">HTTPS 连接过程中加密的使用</h3>
<h4 id="tcp-三次握手-1">1. TCP 三次握手</h4>
<ul>
<li><strong>加密使用</strong>：无<br />
TCP 三次握手（SYN → SYN-ACK →
ACK）只是建立连接，不涉及任何加密。对称和非对称加密都不在这里使用，数据是明文传输的。</li>
</ul>
<h4 id="tls-握手-1">2. TLS 握手</h4>
<p>TLS 握手是 HTTPS 的核心，这里会用到 <strong>非对称加密</strong> 和
<strong>对称加密的准备工作</strong>：</p>
<ul>
<li><strong>步骤 1：Client Hello</strong>
<ul>
<li><strong>加密使用</strong>：无<br />
客户端发送支持的版本、算法和 Client
Random，这些是明文传输的，没有加密。</li>
</ul></li>
<li><strong>步骤 2：Server Hello</strong>
<ul>
<li><strong>加密使用</strong>：无<br />
服务器返回版本、算法、Server Random
和证书，同样是明文。证书包含公钥，但此时还没用它加密数据。</li>
</ul></li>
<li><strong>步骤 3：证书验证</strong>
<ul>
<li><strong>加密使用</strong>：无（但涉及非对称加密的验证）<br />
客户端验证证书时，检查 CA 的数字签名。签名是用 CA
的私钥对证书内容加密生成的，客户端用 CA
的公钥解密验证。这是非对称加密的应用，但属于证书本身的验证过程，不是客户端和服务器之间的通信加密。</li>
</ul></li>
<li><strong>步骤 4：密钥交换</strong>
<ul>
<li><strong>非对称加密</strong>：这里是主要使用场景
<ul>
<li>客户端生成 Pre-Master
Secret，用服务器证书中的公钥（非对称加密算法，如
RSA）加密后发送给服务器。</li>
<li>服务器用自己的私钥解密，拿到 Pre-Master Secret。</li>
<li>双方用 Client Random、Server Random 和 Pre-Master Secret
通过密钥派生函数（如 HMAC）生成对称密钥（Master Secret）。</li>
<li>（注：如果是 TLS 1.3，使用 Diffie-Hellman 密钥交换，不直接用 RSA
加密 Pre-Master
Secret，但仍是非对称加密的一种变体，确保密钥安全交换。）</li>
</ul></li>
<li><strong>作用</strong>：非对称加密保护 Pre-Master Secret
的传输，避免被窃听。对称密钥还未使用。</li>
</ul></li>
<li><strong>步骤 5：完成握手</strong>
<ul>
<li><strong>对称加密</strong>：首次使用
<ul>
<li>客户端发送 “Finished” 消息，用刚刚生成的对称密钥（如
AES）加密，包含握手数据的校验值。</li>
<li>服务器收到后用相同的对称密钥解密，验证一致性。</li>
<li>服务器也发送 “Finished” 消息，同样用对称密钥加密。</li>
</ul></li>
<li><strong>作用</strong>：对称加密确认双方密钥一致，并保护握手结束消息。这是
TLS 握手中对称加密的起点。</li>
</ul></li>
</ul>
<h4 id="加密通信-1">3. 加密通信</h4>
<ul>
<li><strong>对称加密</strong>：主要使用场景
<ul>
<li>TLS 握手完成后，客户端和服务器用协商好的对称密钥（如
AES_256_GCM）加密所有 HTTP 请求和响应数据。</li>
<li>比如，客户端发送 <code>GET /index.html</code>，服务器返回 HTML
内容，全程用对称密钥加密和解密。</li>
</ul></li>
<li><strong>作用</strong>：对称加密速度快，适合大数据量传输，确保通信内容保密。</li>
</ul>
<hr />
<h3 id="对称加密和非对称加密的分工">对称加密和非对称加密的分工</h3>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 34%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>阶段</th>
<th>对称加密</th>
<th>非对称加密</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>TCP 三次握手</strong></td>
<td>无</td>
<td>无</td>
</tr>
<tr class="even">
<td><strong>Client Hello</strong></td>
<td>无</td>
<td>无</td>
</tr>
<tr class="odd">
<td><strong>Server Hello</strong></td>
<td>无</td>
<td>无（证书签名验证用非对称，但不算通信）</td>
</tr>
<tr class="even">
<td><strong>证书验证</strong></td>
<td>无</td>
<td>用于验证 CA 签名</td>
</tr>
<tr class="odd">
<td><strong>密钥交换</strong></td>
<td>生成对称密钥，但尚未使用</td>
<td>用于加密 Pre-Master Secret</td>
</tr>
<tr class="even">
<td><strong>完成握手</strong></td>
<td>用对称密钥加密 Finished 消息</td>
<td>无</td>
</tr>
<tr class="odd">
<td><strong>加密通信</strong></td>
<td>用对称密钥加密所有 HTTP 数据</td>
<td>无</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="为什么这样分工">为什么这样分工？</h3>
<ol type="1">
<li><strong>非对称加密</strong>：
<ul>
<li><strong>用处</strong>：密钥交换和身份验证（证书）。</li>
<li><strong>原因</strong>：非对称加密安全但慢，只用来传输少量数据（如
Pre-Master Secret，几十字节），避免直接暴露对称密钥。</li>
</ul></li>
<li><strong>对称加密</strong>：
<ul>
<li><strong>用处</strong>：保护握手完成消息和后续通信。</li>
<li><strong>原因</strong>：对称加密快，适合加密大量数据（如网页内容、视频流），但需要先安全交换密钥。</li>
</ul></li>
</ol>
<hr />
<h2 id="浏览器输入-url-后发生了什么">浏览器输入 Url 后发生了什么</h2>
<p>当你在浏览器输入一个 URL（比如
<code>https://www.example.com</code>）并按下回车后，浏览器会触发一系列复杂的步骤，从解析
URL
到最终渲染页面。以下是详细的过程，我会尽量清晰地分解每个环节，包括网络通信、DNS
解析、HTTPS 连接、页面加载和渲染等。</p>
<hr />
<h3 id="url-解析">1. URL 解析</h3>
<ul>
<li><strong>输入处理</strong>：<br />
浏览器首先检查你输入的 URL 是否合法。如果缺少协议（如
<code>www.example.com</code>），浏览器会默认补全为
<code>https://</code>（现代浏览器优先 HTTPS）。</li>
<li><strong>分解 URL</strong>：<br />
URL 被拆成几个部分：
<ul>
<li>协议：<code>https</code></li>
<li>域名：<code>www.example.com</code></li>
<li>路径：默认 <code>/</code>（如果没指定）</li>
<li>参数/锚点：如 <code>?id=123</code> 或
<code>#section1</code>（可选）</li>
</ul></li>
</ul>
<hr />
<h3 id="dns-解析">2. DNS 解析</h3>
<ul>
<li><strong>检查缓存</strong>：<br />
浏览器先查看本地缓存（浏览器缓存、操作系统缓存）是否有
<code>www.example.com</code> 的 IP 地址记录。如果有，直接使用。</li>
<li><strong>发起 DNS 请求</strong>：<br />
如果缓存没找到：
<ol type="1">
<li>浏览器向操作系统的 DNS 客户端（通常通过 <code>getaddrinfo</code>
调用）请求解析。</li>
<li>系统检查 hosts 文件（如 <code>/etc/hosts</code>）。</li>
<li>如果没有，系统向配置的 DNS 服务器（通常是路由器或 ISP
提供的）发送查询。</li>
</ol></li>
<li><strong>递归解析</strong>：<br />
DNS 服务器执行递归查询：
<ul>
<li>查询根域名服务器（<code>.</code>），获取 <code>.com</code>
的顶级域名服务器地址。</li>
<li>查询 <code>.com</code> 服务器，获取 <code>example.com</code>
的权威服务器地址。</li>
<li>查询 <code>example.com</code> 服务器，获取
<code>www.example.com</code> 的 IP 地址（如
<code>93.184.216.34</code>）。</li>
</ul></li>
<li><strong>返回 IP</strong>：<br />
DNS 服务器将 IP 返回给浏览器，通常还会附带
TTL（生存时间），供缓存使用。</li>
</ul>
<hr />
<h3 id="建立-tcp-连接">3. 建立 TCP 连接</h3>
<ul>
<li><strong>目标</strong>：浏览器拿到 IP
后，向服务器（<code>93.184.216.34</code>）的 443 端口（HTTPS
默认端口）发起连接。</li>
<li><strong>三次握手</strong>：
<ol type="1">
<li>客户端发送 SYN 包（<code>Seq = x</code>）。</li>
<li>服务器回复 SYN-ACK（<code>Seq = y, Ack = x + 1</code>）。</li>
<li>客户端发送 ACK（<code>Ack = y + 1</code>）。</li>
</ol>
<ul>
<li>完成后，TCP 连接建立，双向通信通道就绪。</li>
</ul></li>
</ul>
<hr />
<h3 id="tls-握手https-特有">4. TLS 握手（HTTPS 特有）</h3>
<p>因为是 <code>https://</code>，需要建立加密通道： - <strong>Client
Hello</strong>：<br />
客户端发送支持的 TLS 版本（如 TLS 1.3）、加密算法和随机数（Client
Random）。 - <strong>Server Hello</strong>：<br />
服务器返回选定的版本、算法、随机数（Server Random）和证书（含公钥）。 -
<strong>证书验证</strong>：<br />
客户端用 CA 公钥验证证书，确保服务器身份可信。 -
<strong>密钥交换</strong>：<br />
- 客户端生成 Pre-Master Secret，用服务器公钥加密后发送。 -
双方计算对称密钥（Master Secret）。 - <strong>完成握手</strong>：<br />
- 双方用对称密钥发送 “Finished” 消息，确认握手成功。 -
<strong>结果</strong>：安全通道建立，通信加密。</p>
<hr />
<h3 id="发送-http-请求">5. 发送 HTTP 请求</h3>
<ul>
<li><strong>构造请求</strong>：<br />
浏览器生成 HTTP 请求： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 ...</span><br><span class="line">Accept: text/html, ...</span><br></pre></td></tr></table></figure></li>
<li><strong>加密发送</strong>：<br />
请求用 TLS 对称密钥（如 AES）加密，通过 TCP 发送到服务器。</li>
</ul>
<hr />
<h3 id="服务器处理请求">6. 服务器处理请求</h3>
<ul>
<li><strong>接收和解密</strong>：<br />
服务器用对称密钥解密请求。</li>
<li><strong>处理逻辑</strong>：
<ul>
<li>Web 服务器（如 Nginx、Apache）解析请求。</li>
<li>如果是动态页面，可能调用后端代码（如 PHP、Java）生成响应。</li>
<li>如果是静态文件，直接读取（如 <code>index.html</code>）。</li>
</ul></li>
<li><strong>生成响应</strong>：<br />
服务器返回 HTTP 响应： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1234</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="接收和解析-http-响应">7. 接收和解析 HTTP 响应</h3>
<ul>
<li><strong>接收数据</strong>：<br />
浏览器通过 TCP 接收加密响应，用对称密钥解密。</li>
<li><strong>检查状态码</strong>：
<ul>
<li><code>200 OK</code>：正常，继续处理。</li>
<li><code>301/302</code>：重定向，跳转到新 URL。</li>
<li><code>404</code>：页面不存在，显示错误。</li>
</ul></li>
<li><strong>解析 HTML</strong>：
<ul>
<li>浏览器将 HTML 交给渲染引擎（如 WebKit、Blink），构建 DOM
树（Document Object Model）。</li>
</ul></li>
</ul>
<hr />
<h3 id="资源加载">8. 资源加载</h3>
<ul>
<li><strong>发现资源</strong>：<br />
解析 HTML 时，遇到
<code>&lt;link&gt;</code>（CSS）、<code>&lt;script&gt;</code>（JS）、<code>&lt;img&gt;</code>（图片）等标签，触发额外请求。</li>
<li><strong>并行请求</strong>：<br />
浏览器为每个资源重复步骤
3-7（DNS、TCP、TLS、HTTP），通常并行处理（现代浏览器支持 6-8
个并发连接）。</li>
<li><strong>缓存检查</strong>：<br />
如果资源有缓存（如通过 <code>Cache-Control</code> 或
<code>ETag</code>），可能直接使用本地副本。</li>
</ul>
<hr />
<h3 id="页面渲染">9. 页面渲染</h3>
<ul>
<li><strong>构建 DOM 和 CSSOM</strong>：
<ul>
<li>DOM 树：从 HTML 解析出节点树。</li>
<li>CSSOM 树：从 CSS 解析出样式树。</li>
</ul></li>
<li><strong>合并渲染树</strong>：<br />
将 DOM 和 CSSOM 结合，生成渲染树（只包含可见元素）。</li>
<li><strong>布局（Layout）</strong>：<br />
计算每个元素的位置和大小（Reflow）。</li>
<li><strong>绘制（Paint）</strong>：<br />
将渲染树转为像素，生成图层。</li>
<li><strong>合成（Composite）</strong>：<br />
将图层组合，交给 GPU 显示到屏幕。</li>
</ul>
<hr />
<h3 id="执行-javascript">10. 执行 JavaScript</h3>
<ul>
<li><strong>加载 JS</strong>：<br />
<code>&lt;script&gt;</code> 执行时，可能修改 DOM 或 CSSOM。</li>
<li><strong>重新渲染</strong>：<br />
JS 动态更改会导致重布局或重绘制。</li>
<li><strong>事件监听</strong>：<br />
绑定交互逻辑（如点击事件），等待用户操作。</li>
</ul>
<hr />
<h3 id="完整流程总结-1">完整流程总结</h3>
<ol type="1">
<li><strong>URL 解析</strong>：分解协议、域名、路径。</li>
<li><strong>DNS 解析</strong>：域名 → IP。</li>
<li><strong>TCP 连接</strong>：三次握手。</li>
<li><strong>TLS 握手</strong>：建立 HTTPS 安全通道。</li>
<li><strong>HTTP 请求</strong>：发送请求。</li>
<li><strong>服务器响应</strong>：处理并返回数据。</li>
<li><strong>解析响应</strong>：解密并构建 DOM。</li>
<li><strong>资源加载</strong>：下载 CSS、JS、图片。</li>
<li><strong>渲染页面</strong>：布局、绘制、合成。</li>
<li><strong>执行 JS</strong>：动态交互。</li>
</ol>
<hr />
]]></content>
      <categories>
        <category>Android</category>
        <category>应用开发</category>
      </categories>
  </entry>
  <entry>
    <title>NDK</title>
    <url>/Android/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/NDK.html</url>
    <content><![CDATA[<h1 id="一什么是-ndk">一、什么是 NDK？</h1>
<p>NDK 是 <strong>Native Development Kit</strong> 的缩写，是 Android
官方提供的一套工具，可以使用 C/C++ 编写一部分 Android
应用代码，并将其编译为本地机器码以提高性能或复用已有的 C/C++ 库。</p>
<h2 id="使用-ndk-的常见场景">使用 NDK 的常见场景：</h2>
<ul>
<li>需要更高性能的计算，如图像处理、音视频编解码、游戏引擎等。</li>
<li>调用已有的 C/C++ 库（如 FFmpeg、OpenCV、libcurl）。</li>
<li>实现底层安全逻辑（尽管这并不能完全防止反编译）。</li>
</ul>
<hr />
<h1 id="二ndk-的基本组成">二、NDK 的基本组成</h1>
<ul>
<li><code>.cpp/.c</code>：C/C++ 源文件</li>
<li><code>Android.mk</code> / <code>CMakeLists.txt</code>：构建脚本</li>
<li><code>jniLibs/</code>：存放编译好的 <code>.so</code> 文件</li>
<li><code>ndk-build</code> / CMake：构建工具</li>
<li><code>gradle</code>：集成到 Android 工程</li>
</ul>
<hr />
<h1 id="三ndk-的配置方法">三、NDK 的配置方法</h1>
<h2 id="步骤-1安装-ndk-和-cmake">✅ 步骤 1：安装 NDK 和 CMake</h2>
<p>在 Android Studio 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File -&gt; Settings -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Android SDK -&gt; SDK Tools</span><br></pre></td></tr></table></figure>
<p>勾选：</p>
<ul>
<li><strong>NDK (Side by side)</strong></li>
<li><strong>CMake</strong></li>
<li><strong>LLDB（可选）</strong></li>
</ul>
<hr />
<h2 id="步骤-2配置-gradle">✅ 步骤 2：配置 Gradle</h2>
<p>假设我们使用的是 <strong>CMake</strong>。</p>
<h3 id="在-build.gradle-app-中添加">在 <code>build.gradle (app)</code>
中添加：</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定 .so 支持的架构</span></span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters <span class="string">&quot;armeabi-v7a&quot;</span>, <span class="string">&quot;arm64-v8a&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果使用 CMake，则指定 CMake 构建文件路径</span></span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags <span class="string">&quot;-std=c++11&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定 CMakeLists.txt 路径</span></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path <span class="string">&quot;src/main/cpp/CMakeLists.txt&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="步骤-3添加-native-代码和-cmake-文件">✅ 步骤 3：添加 native
代码和 CMake 文件</h2>
<h3 id="文件结构">文件结构：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app/</span><br><span class="line">└── src/</span><br><span class="line">    └── main/</span><br><span class="line">        ├── cpp/</span><br><span class="line">        │   ├── native-lib.cpp</span><br><span class="line">        │   └── CMakeLists.txt</span><br><span class="line">        └── java/</span><br><span class="line">            └── com/example/ndkdemo/</span><br><span class="line">                └── MainActivity.java</span><br></pre></td></tr></table></figure>
<h3 id="native-lib.cpp-示例"><code>native-lib.cpp</code> 示例：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_ndkdemo_MainActivity_stringFromJNI</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;</span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="cmakelists.txt-示例"><code>CMakeLists.txt</code> 示例：</h3>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>( <span class="comment"># 名称</span></span><br><span class="line">             native-lib</span><br><span class="line"></span><br><span class="line">             <span class="comment"># 类型</span></span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             <span class="comment"># 源文件</span></span><br><span class="line">             native-lib.cpp )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>( <span class="comment"># log 库</span></span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># 目标库</span></span><br><span class="line">                       native-lib</span><br><span class="line"></span><br><span class="line">                       <span class="comment"># 依赖的系统库</span></span><br><span class="line">                       <span class="variable">$&#123;log-lib&#125;</span> )</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="步骤-4在-javakotlin-中调用-native-方法">✅ 步骤 4：在
Java/Kotlin 中调用 native 方法</h2>
<h3 id="kotlin-示例">Kotlin 示例：</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">()</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(<span class="string">&quot;NDK&quot;</span>, stringFromJNI())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="四多模块项目如何组织-ndk">四、多模块项目如何组织 NDK？</h1>
<p>每个 module 都可以有自己的 <code>CMakeLists.txt</code>，在其对应的
<code>build.gradle</code> 中分别指定。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:app -&gt; 引用模块</span><br><span class="line">:nativecore -&gt; 存放 C/C++ 源码和 native 接口</span><br></pre></td></tr></table></figure>
<h3
id="nativecorebuild.gradle"><code>nativecore/build.gradle</code>：</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        path <span class="string">&quot;src/main/cpp/CMakeLists.txt&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>app</code> 模块中调用该模块中的 native 方法（通过 AAR
依赖或 <code>System.loadLibrary</code>）。</p>
<hr />
<h1 id="五小结">五、小结</h1>
<table>
<thead>
<tr class="header">
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>使用场景</td>
<td>性能优化/调用现有C库</td>
</tr>
<tr class="even">
<td>构建系统</td>
<td><code>CMake</code>（推荐） 或 ndk-build</td>
</tr>
<tr class="odd">
<td>配置方式</td>
<td><code>build.gradle + CMakeLists.txt</code></td>
</tr>
<tr class="even">
<td>编写语言</td>
<td>C 或 C++（推荐 C++11）</td>
</tr>
<tr class="odd">
<td>调用方式</td>
<td>JNI</td>
</tr>
</tbody>
</table>
<hr />
<p>如果你需要我提供使用 <code>ndk-build</code>（使用
<code>Android.mk</code>）的示例或者在多模块项目中精细拆分 NDK
的高级配置，我也可以继续讲。需要吗？</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>应用开发</category>
      </categories>
  </entry>
  <entry>
    <title>现代 Android 开发需要掌握哪些技能</title>
    <url>/Android/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E7%8E%B0%E4%BB%A3-Android-%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E5%93%AA%E4%BA%9B%E6%8A%80%E8%83%BD.html</url>
    <content><![CDATA[<h3 id="语言基础">语言基础</h3>
<p>优先使用 Kotlin 语言，掌握其核心特性，如扩展函数、Lambda
表达式、数据类、协程等。Kotlin 是 Android
官方推荐的语言，具有更简洁的语法和更强大的功能。</p>
<p>Java 仍然是 Android 开发的基础语言，了解 Java
的面向对象编程（OOP）思想、集合框架、异常处理等。Android 的许多底层 API
仍然是用 Java 编写的，因此了解 Java 对于理解 Android
系统架构非常重要。</p>
<p>C++ 语言在 Android
开发中主要用于编写跨平台库或者性能敏感的部分，如游戏开发或需要与底层系统交互的场景。掌握
JNI（Java Native Interface）以便在 Kotlin/Java 中调用 C++ 代码。同时 C++
库的反编译难度较大，可以加固 APK 防止逆向工程。</p>
<h3 id="ui-开发">UI 开发</h3>
<p>使用现代 UI 框架 Jetpack Compose，熟练掌握Composable
函数、状态管理、SideEffect
APIs、动画、主题、自定义组件、Navigation-Compose 路由导航。</p>
<p>对于传统 UI 开发，熟悉 View System，包括
ConstraintLayout、RecyclerView、ViewPager2、自定义 View、动画系统，XML
布局与 DataBinding/ViewBinding。</p>
<h3 id="架构模式">架构模式</h3>
<p>MVVM（Model-View-ViewModel）是现代 Android
开发的主流架构，强调视图与业务逻辑的分离。通常结合使用
ViewModel、LiveData 或 StateFlow 来管理 UI 状态和生命周期。</p>
<p>MVI（Model-View-Intent）在 Jetpack Compose
中也越来越流行，适用于响应式编程和单向数据流。</p>
<p>数据管理通常使用 Repository 模式，结合单一数据源（Single source of
truth）来管理数据状态。数据源可以是网络、数据库或本地缓存。</p>
<p>组件之间的依赖管理通常使用依赖注入框架，如 Hilt 或
Dagger，来管理组件之间的依赖关系，简化代码结构。</p>
<h3 id="异步编程">异步编程</h3>
<p>使用 Kotlin 协程和 Flow
进行异步编程，掌握协程的启动、取消、异常处理、调度器（Dispatchers）以及
Flow 的冷流、热流、转换操作符（如 map、filter、collect）。</p>
<p>传统的 RxJava 仍然在一些项目中使用，了解 RxJava 的
Observable、Schedulers、Operators 等概念。</p>
<h3 id="jetpack-组件生态">Jetpack 组件生态</h3>
<p>数据库操作使用 Room，掌握实体类、DAO、数据库迁移、LiveData/Flow
支持。</p>
<p>数据存储使用 DataStore（替代 SharedPreferences），支持 Proto
数据存储和 Key-Value 存储。其相较于 SharedPreferences
更加安全和高效。</p>
<p>后台任务调度使用
WorkManager，支持定时任务、链式任务等。其优势在于能够处理设备重启、网络变化等场景。</p>
<p>大数据分页加载使用 Paging
3，支持从网络或数据库中高效加载大数据集，提供流式数据加载和自动分页。</p>
<p>路由管理使用 Navigation 组件，支持 Fragment、Compose 的路由导航，掌握
NavController、NavGraph、DeepLink 等概念。</p>
<h3 id="网络和数据">网络和数据</h3>
<p>网络请求仍然是经典的 Retrofit + OkHttp 组合，掌握 Retrofit
的接口定义、请求参数、响应解析、错误处理等。使用 OkHttp
进行底层网络请求，支持拦截器、缓存、SSL/TLS 配置等。</p>
<p>Json 解析使用 Gson 或 Moshi，Moshi 在 Kotlin 中更为友好，支持 Kotlin
特性如数据类和 null 安全。</p>
<p>Ktor Client 是一个现代的异步 HTTP
客户端，适用于需要协程支持的网络请求场景, 在 Kotlin Multiplatform
项目中常用。</p>
<h3 id="依赖注入di">依赖注入（DI）</h3>
<p>使用依赖注入框架来管理组件之间的依赖关系，简化代码结构。常用的依赖注入框架包括
Hilt（Google 官方推荐）、Dagger 2、Koin 等。</p>
<p>Hilt 是基于 Dagger
的简化版本，提供了更简单的注解和集成方式，适合大多数 Android 项目。</p>
<p>Dagger 2
是一个功能强大的依赖注入框架，适用于需要高度定制化的项目。</p>
<p>Koin 是一个轻量级的依赖注入框架，使用 Kotlin DSL
语法，适合小型项目或快速原型开发。它是 Kotlin
生态系统中的一个流行选择，在 Compose 项目中也有很好的支持。</p>
<h3 id="测试能力">测试能力</h3>
<p>单元测试使用 JUnit 5 或 JUnit 4 进行单元测试，掌握 Mockito、MockK 等
Mock 框架的使用。</p>
<p>UI 测试使用 Espresso 或 Jetpack Compose Testing Library 进行 UI
测试，支持编写可重复的 UI 测试用例。</p>
<p>Compose UI 测试使用 Compose Testing Library，支持编写可重复的 UI
测试用例，能够模拟用户交互和验证 UI 状态。</p>
<p>Instrumentation 测试使用 AndroidX Test
框架，支持在真实设备或模拟器上运行测试。</p>
<h3 id="性能优化">性能优化</h3>
<p>性能优化是现代 Android 开发的重要环节,
包括启动速度优化、内存管理、网络性能优化、帧率卡顿治理、ANR（Application
Not Responding）问题排查、多线程优化。</p>
<p>启动速度优化：使用 Android Profiler
分析应用启动时间，减少冷启动时间，优化热启动。</p>
<p>内存管理：使用 LeakCanary
检测内存泄漏，优化内存使用，避免内存泄漏和过度分配。</p>
<p>网络性能优化：使用 OkHttp
的缓存机制，减少网络请求次数，优化数据加载速度。</p>
<p>帧率卡顿治理：使用 Systrace、Traceview 等工具分析帧率卡顿问题，优化
UI 渲染性能。</p>
<p>ANR 问题排查：使用 StrictMode、ANR WatchDog 等工具检测 ANR
问题，优化主线程操作，避免长时间阻塞。</p>
<p>多线程优化：使用协程的 Dispatchers
优化多线程操作，避免线程切换开销。</p>
<p>内存泄漏检测：使用 LeakCanary
等工具检测内存泄漏，及时修复内存泄漏问题。</p>
<h3 id="项目构建与管理">项目构建与管理</h3>
<p>熟练掌握 Gradle 脚本（Groovy / Kotlin
DSL），包括构建配置、依赖管理、任务定义等。Gradle 是 Android
官方推荐的构建工具，支持灵活的构建配置和插件扩展。</p>
<p>多模块化项目管理，使用 Gradle
的多模块特性来组织大型项目，支持模块间依赖和共享代码。构建速度优化，使用
Gradle 的缓存机制、增量编译、配置缓存等特性来优化构建速度。</p>
<p>使用 Version Catalogs
来集中管理依赖版本，避免版本冲突和重复定义。</p>
<p>CI/CD 管道使用 GitHub Actions、GitLab CI、Bitrise、Firebase App
Distribution 等工具进行持续集成和持续交付。掌握 YAML 配置文件的编写和
CI/CD 流水线的设计。</p>
<h3 id="平台能力">平台能力</h3>
<p>掌握动态权限申请，了解 Android 6.0
及以上版本的权限模型，支持运行时权限请求和权限回调处理。</p>
<p>掌握相机、定位、蓝牙等硬件功能的使用，了解相关权限和 API
的使用方法。</p>
<p>掌握音视频处理，使用 Media3、ExoPlayer
等库进行音视频播放和处理，支持流媒体播放、缓存等功能。</p>
<p>掌握电池优化、前后台切换、通知等系统级功能的使用，了解相关 API
的使用方法。</p>
<p>掌握兼容性适配，了解折叠屏、多窗口、大屏幕等不同设备的适配方案。</p>
<h3 id="跨平台与拓展方向">跨平台与拓展方向</h3>
<p>Kotlin Multiplatform 是一种新兴的跨平台开发技术，支持在多个平台（如
Android、iOS、Web、桌面）上共享代码。目前在移动端主要用于 Android 和 iOS
的跨平台开发。相较于其他跨平台框架，Kotlin Multiplatform
允许开发者使用原生 UI 框架（如 Jetpack Compose 和
SwiftUI），从而提供更好的用户体验和性能。</p>
<p>Flutter 和 React Native
是两种流行的跨平台移动开发框架，适用于需要快速开发和部署的项目。Flutter
使用 Dart 语言，提供丰富的 UI 组件和高性能渲染引擎；React Native 使用
JavaScript 和 React 框架，支持热更新和丰富的生态系统。</p>
<p>Compose Multiplatform 是 JetBrains 推出的跨平台 UI
框架，支持在桌面（Windows、macOS、Linux）和 Web 上使用 Jetpack Compose
进行 UI 开发。目前在国内并非主流，但随着 JetBrains
的推动，未来有望获得更多关注。</p>
<h3 id="发布与应用管理">发布与应用管理</h3>
<p>掌握应用发布流程，包括应用签名、Bundle（AAB）打包、版本管理、构建变体（Build
Variants）等。</p>
<p>了解 Google Play Console
的使用，掌握应用上架、更新、用户反馈管理等功能。</p>
<p>使用 ProGuard 或 R8 进行代码混淆和优化，保护应用代码安全。</p>
<p>使用 Firebase Crashlytics、Bugsnag
等工具进行崩溃分析和日志管理，及时发现和修复应用问题。</p>
<h3 id="开发工具">开发工具</h3>
<p>Android Studio: 官方推荐的 IDE，基于 IntelliJ
IDEA，提供强大的代码编辑、调试、性能分析等功能。熟练使用其各种工具和插件，提高开发效率。</p>
<p>ADB (Android Debug Bridge): 用于与 Android
设备进行通信的命令行工具，支持安装应用、调试、日志查看等功能。</p>
<p>Profiler: 用于性能分析的工具，支持
CPU、内存、网络等多方面的性能监控和分析。</p>
<p>Layout Inspector:
用于查看和调试应用布局的工具，支持实时查看视图层次结构和属性。</p>
<p>Network Inspector:
用于监控和分析应用网络请求的工具，支持查看请求详情、响应时间等信息。</p>
<p>Lint:
用于代码质量检查的工具，支持检测潜在的错误、性能问题和不符合最佳实践的代码。</p>
<p>LeakCanary:
用于检测内存泄漏的工具，支持自动检测和报告内存泄漏问题。</p>
<p>StrictMode:
用于检测主线程阻塞和其他潜在问题的工具，支持配置不同的检测策略。</p>
<p>Gradle CLI: 用于命令行构建和管理项目的工具，支持执行各种 Gradle
任务和命令。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>应用开发</category>
      </categories>
  </entry>
  <entry>
    <title>C++ RAII</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++-RAII.html</url>
    <content><![CDATA[<p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是
C++
编程中的核心设计理念，用于管理资源的分配和释放。它通过将资源的生命周期绑定到对象的生命周期，利用
C++
的自动对象管理机制（主要是栈对象的构造和析构），确保资源在使用完毕后被正确释放，避免资源泄漏。</p>
<p>RAII 的核心思想是：</p>
<ul>
<li><strong>资源获取</strong>（如内存、文件句柄、锁、网络连接等）在对象构造时完成。</li>
<li><strong>资源释放</strong>在对象析构时自动完成。</li>
<li>利用 C++
的<strong>栈对象生命周期</strong>，当对象离开作用域（无论是正常退出还是抛出异常）时，析构函数会自动调用，确保资源正确清理。</li>
</ul>
<p>RAII 是 C++ 异常安全性和资源管理的基石，广泛应用于标准库和现代 C++
编程。</p>
<hr />
<h1 id="raii-的工作原理">RAII 的工作原理</h1>
<ol type="1">
<li><strong>资源与对象绑定</strong>：
<ul>
<li>在对象的构造函数中获取资源（如分配内存、打开文件、加锁）。</li>
<li>资源的释放逻辑在析构函数中实现。</li>
</ul></li>
<li><strong>自动管理</strong>：
<ul>
<li>C++ 保证栈上对象离开作用域时，其析构函数会被自动调用。</li>
<li>资源释放无需程序员手动干预。</li>
</ul></li>
<li><strong>异常安全</strong>：
<ul>
<li>即使抛出异常，栈解退（stack
unwinding）机制确保对象按逆序析构，防止资源泄漏。</li>
</ul></li>
</ol>
<hr />
<h1 id="raii-的代码示例">RAII 的代码示例</h1>
<p>以下是一个管理动态分配内存的 RAII 示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data; <span class="comment">// 动态分配的资源</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 构造函数获取资源</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource acquired: &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 析构函数释放资源</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource released&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource r; <span class="comment">// 栈上对象，自动管理</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using resource: &quot;</span> &lt;&lt; r.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="comment">// r 离开作用域，自动调用析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">useResource</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resource acquired: 42</span><br><span class="line">Using resource: 42</span><br><span class="line">Resource released</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li>构造函数分配内存（<code>new int</code>）。</li>
<li>析构函数释放内存（<code>delete data</code>）。</li>
<li>栈对象 <code>r</code>
离开作用域时自动释放资源，即使发生异常也能保证清理。</li>
</ul>
<hr />
<h1 id="raii-的典型应用">RAII 的典型应用</h1>
<p>RAII 在 C++ 中应用广泛，以下是常见场景：</p>
<ol type="1">
<li><p><strong>动态内存管理</strong>：</p>
<ul>
<li><p>标准库的智能指针（如 <code>std::unique_ptr</code> 和
<code>std::shared_ptr</code>）是 RAII 的经典实现。</p></li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 使用 ptr</span></span><br><span class="line">&#125; <span class="comment">// ptr 离开作用域，内存自动释放</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>文件管理</strong>：</p>
<ul>
<li><p><code>std::fstream</code>（如
<code>std::ifstream</code>、<code>std::ofstream</code>）使用 RAII
管理文件句柄。</p></li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    file &lt;&lt; <span class="string">&quot;Hello, RAII!&quot;</span>;</span><br><span class="line">&#125; <span class="comment">// file 离开作用域，自动关闭文件</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>互斥锁管理</strong>：</p>
<ul>
<li><p><code>std::lock_guard</code> 和 <code>std::unique_lock</code>
使用 RAII 管理线程同步中的锁。</p></li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// RAII 管理锁</span></span><br><span class="line">        ++counter;</span><br><span class="line">    &#125; <span class="comment">// lock 离开作用域，自动解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>其他资源</strong>：</p>
<ul>
<li>网络连接（如 <code>std::socket</code> 封装）。</li>
<li>数据库连接。</li>
<li>图形资源（如 OpenGL 上下文）。</li>
</ul></li>
</ol>
<hr />
<h1 id="raii-的优点">RAII 的优点</h1>
<ol type="1">
<li><strong>自动资源管理</strong>：
<ul>
<li>资源释放由析构函数自动完成，避免手动调用
<code>delete</code>、<code>close</code> 等。</li>
</ul></li>
<li><strong>异常安全</strong>：
<ul>
<li>栈解退机制确保即使抛出异常，资源也能正确释放。</li>
</ul></li>
<li><strong>代码简洁</strong>：
<ul>
<li>减少手动管理资源的代码，降低出错概率。</li>
</ul></li>
<li><strong>确定性释放</strong>：
<ul>
<li>资源在对象离开作用域时立即释放，行为可预测。</li>
</ul></li>
</ol>
<hr />
<h1 id="raii-的注意事项">RAII 的注意事项</h1>
<ol type="1">
<li><strong>避免手动管理</strong>：
<ul>
<li>不要在 RAII 对象之外手动释放资源（如
<code>delete ptr.get()</code>），否则可能导致未定义行为。</li>
</ul></li>
<li><strong>析构函数不抛异常</strong>：
<ul>
<li>析构函数应标记为
<code>noexcept</code>，避免抛出异常，否则可能导致程序终止（<code>std::terminate</code>）。</li>
</ul></li>
<li><strong>拷贝和移动</strong>：
<ul>
<li>独占资源（如
<code>std::unique_ptr</code>）通常禁用拷贝，允许移动。</li>
<li>共享资源（如 <code>std::shared_ptr</code>）需明确定义拷贝语义。</li>
</ul></li>
<li><strong>性能开销</strong>：
<ul>
<li>RAII
对象的构造和析构可能引入少量开销，但通常被安全性和简洁性抵消。</li>
</ul></li>
</ol>
<hr />
<h1 id="为什么-c-不需要-finally-结构">为什么 C++ 不需要
<code>finally</code> 结构？</h1>
<p>C++ 不提供 <code>finally</code> 结构，因为 RAII
提供了更优雅、系统化的替代方案。<code>finally</code>
通常用于确保资源在代码块结束时释放，但 RAII
通过以下方式实现相同的目标，且更简洁：</p>
<ol type="1">
<li><p><strong>RAII 的优势</strong>：</p>
<ul>
<li><p>RAII
将资源管理封装在对象中，析构函数自动释放资源，无需为每次资源获取添加
<code>finally</code> 子句。</p></li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File_handle</span> &#123;</span><br><span class="line">    FILE* p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File_handle</span>(<span class="type">const</span> <span class="type">char</span>* n, <span class="type">const</span> <span class="type">char</span>* a) &#123;</span><br><span class="line">        p = <span class="built_in">fopen</span>(n, a);</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">throw</span> <span class="built_in">Open_error</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">File_handle</span>() &#123; <span class="built_in">fclose</span>(p); &#125;</span><br><span class="line">    <span class="keyword">operator</span> FILE*() &#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fn)</span> </span>&#123;</span><br><span class="line">    <span class="function">File_handle <span class="title">f</span><span class="params">(fn, <span class="string">&quot;rw&quot;</span>)</span></span>; <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="comment">// 使用 f</span></span><br><span class="line">&#125; <span class="comment">// f 离开作用域，文件自动关闭</span></span><br></pre></td></tr></table></figure></li>
<li><p>相比之下，<code>finally</code>
需要显式编写清理代码，增加代码量和出错风险。</p></li>
</ul></li>
<li><p><strong>减少代码量</strong>：</p>
<ul>
<li>在大型系统中，资源获取次数远多于资源种类。RAII
通过为每种资源定义一个“句柄”类，复用清理逻辑，而 <code>finally</code>
需要为每次获取重复编写清理代码。</li>
</ul></li>
<li><p><strong>异常安全</strong>：</p>
<ul>
<li>RAII
利用栈解退机制，确保异常发生时资源仍被释放。<code>finally</code>
也能做到，但需要手动管理，容易遗漏。</li>
</ul></li>
</ol>
<hr />
<h1 id="使用-raii-防止资源泄漏">使用 RAII 防止资源泄漏</h1>
<h2 id="原因">原因</h2>
<ul>
<li><strong>泄漏不可接受</strong>：资源泄漏（如内存、文件句柄）会导致程序性能下降或崩溃。</li>
<li><strong>手动释放易错</strong>：程序员可能忘记释放资源，尤其在复杂代码或异常情况下。</li>
<li><strong>RAII 是最优解</strong>：RAII
是最简单、系统化的防止泄漏方法，利用对象的生命周期自动管理资源。</li>
</ul>
<h2 id="示例">示例</h2>
<ol type="1">
<li><p><strong>错误示例（可能泄漏）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">17</span>) <span class="keyword">throw</span> Bad&#123;<span class="string">&quot;in f()&quot;</span>, i&#125;;</span><br><span class="line">    <span class="comment">// 抛出异常，未释放 p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>手动释放（繁琐且易错）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">17</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p; <span class="comment">// 手动释放</span></span><br><span class="line">        <span class="keyword">throw</span> Bad&#123;<span class="string">&quot;in f()&quot;</span>, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] p; <span class="comment">// 正常退出时释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码冗长，多个 <code>throw</code>
点需要重复释放逻辑，容易遗漏。</li>
</ul></li>
<li><p><strong>使用 RAII（推荐）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">17</span>) <span class="keyword">throw</span> Bad&#123;<span class="string">&quot;in f()&quot;</span>, i&#125;;</span><br><span class="line">    <span class="comment">// p 离开作用域，自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::unique_ptr</code> 管理内存，异常安全且简洁。</li>
</ul></li>
<li><p><strong>更优选择（本地对象）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f5</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">    <span class="built_in">helper</span>(i); <span class="comment">// 可能抛出异常</span></span><br><span class="line">    <span class="comment">// v 离开作用域，自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>std::vector</code> 替代裸指针，更安全且高效。</li>
</ul></li>
<li><p><strong>隐式异常</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">helper</span>(i); <span class="comment">// 可能抛出异常</span></span><br><span class="line">    <span class="comment">// p 自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>即使 <code>helper</code> 抛出异常，<code>p</code>
仍会被正确释放。</li>
</ul></li>
</ol>
<h2 id="注意事项">注意事项</h2>
<ul>
<li><p><strong>无明显句柄时</strong>：如果无法定义 RAII 对象，可使用
<code>final_action</code> 作为最后手段，但优先使用 RAII。</p></li>
<li><p><strong>无异常环境</strong>：在禁用异常的场景（如嵌入式系统），可通过以下方式模拟
RAII：</p>
<ul>
<li><p>为资源句柄添加 <code>valid()</code>
检查，验证构造是否成功。</p></li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">vs</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 自定义 vector，带 valid()</span></span><br><span class="line">    <span class="keyword">if</span> (!vs.<span class="built_in">valid</span>()) &#123; <span class="comment">/* 处理错误 */</span> &#125;</span><br><span class="line">    <span class="function">ifstream <span class="title">fs</span><span class="params">(<span class="string">&quot;foo&quot;</span>)</span></span>; <span class="comment">// 自定义 ifstream，带 valid()</span></span><br><span class="line">    <span class="keyword">if</span> (!fs.<span class="built_in">valid</span>()) &#123; <span class="comment">/* 处理错误 */</span> &#125;</span><br><span class="line">&#125; <span class="comment">// 析构函数照常清理</span></span><br></pre></td></tr></table></figure></li>
<li><p>缺点：代码量增加，需手动检查
<code>valid()</code>，且无法隐式传播错误。</p></li>
</ul></li>
<li><p><strong>禁用异常的场景</strong>：</p>
<ul>
<li>极小型系统（内存不足，如 2K）。</li>
<li>硬实时系统（无法保证异常处理时间）。</li>
<li>遗留代码（指针使用复杂，缺乏所有权策略）。</li>
<li>异常实现效率低（慢、内存占用大或动态链接库支持差）。</li>
<li>管理决策（需挑战传统观念）。</li>
<li>除非有充分理由，优先使用异常实现 RAII。</li>
</ul></li>
</ul>
<hr />
<h1 id="总结">总结</h1>
<ul>
<li><strong>RAII</strong> 是 C++
的核心设计理念，通过将资源绑定到对象的生命周期，实现自动、异常安全的资源管理。</li>
<li><strong>原理</strong>：构造函数获取资源，析构函数释放资源，利用栈解退确保清理。</li>
<li><strong>应用</strong>：动态内存（<code>std::unique_ptr</code>、<code>std::shared_ptr</code>）、文件（<code>std::fstream</code>）、锁（<code>std::lock_guard</code>）、网络、数据库等。</li>
<li><strong>优点</strong>：自动管理、异常安全、代码简洁、确定性释放。</li>
<li><strong>注意事项</strong>：避免手动释放、确保析构函数不抛异常、正确处理拷贝和移动。</li>
<li><strong>无 <code>finally</code></strong>：RAII 比
<code>finally</code> 更简洁、系统化，减少代码量且异常安全。</li>
<li><strong>防止泄漏</strong>：RAII
是防止资源泄漏的最优方法，优于手动释放或 <code>finally</code>。</li>
</ul>
<p>RAII 体现了 C++ 的“用对象管理资源”哲学，是现代 C++（C++11
及以后）的基石。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 协程</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++-%E5%8D%8F%E7%A8%8B.html</url>
    <content><![CDATA[<p>C++20
引入了协程（Coroutines），协程是一种可以在执行过程中暂停和恢复的函数，允许在特定点挂起（suspend）执行，并将控制权交还给调用者，稍后可以从暂停点恢复执行。</p>
<h3 id="应用场景">应用场景</h3>
<p>与传统的函数调用不同，协程可以在不丢失上下文的情况下暂停，适合以下场景：</p>
<p>1.异步编程：例如处理 I/O
操作（如网络请求、文件读写）时，避免阻塞线程。</p>
<p>2.生成器：逐步生成数据序列，适合处理大数据流或惰性求值。</p>
<p>3.协作式多任务：多个任务协作运行，共享线程资源。</p>
<h3 id="关键字">关键字</h3>
<p>C++ 的协程是通过编译器支持的底层机制实现的，主要依赖三个关键字：</p>
<p>1.<code>co_await</code>：暂停协程并等待某个异步操作完成。</p>
<p>2.<code>co_yield</code>：暂停协程并向调用者返回一个值（用于生成器）。</p>
<p>3.<code>co_return</code>：结束协程并返回结果。</p>
<h3 id="关键组件">关键组件</h3>
<p>C++ 协程的实现依赖于几个关键组件，这些组件共同定义了协程的行为：</p>
<p>1.Promise 对象（<code>promise_type</code>）：每个协程都有一个关联的
<code>promise_type</code>，它定义了协程的行为和返回值。<code>promise_type</code>
是一个类，通常包含以下方法：</p>
<p><strong><code>get_return_object()</code></strong>：定义协程的返回值对象（通常是一个协程句柄或自定义类型）。</p>
<p><strong><code>initial_suspend()</code></strong>：决定协程在启动时是否立即挂起（返回
<code>std::suspend_always</code> 或
<code>std::suspend_never</code>）。</p>
<p><strong><code>final_suspend()</code></strong>：决定协程在结束时是否挂起。</p>
<p><strong><code>return_void()</code> 或
<code>return_value(T)</code></strong>：处理协程的返回值。</p>
<p><strong><code>yield_value(T)</code></strong>：处理通过
<code>co_yield</code> 返回的值（生成器场景）。</p>
<p><strong><code>unhandled_exception()</code></strong>：处理协程中未捕获的异常。</p>
<p>2.协程句柄（<code>std::coroutine_handle</code>）：<code>std::coroutine_handle</code>
是一个模板类，用于管理协程的状态和生命周期。它可以：恢复协程（<code>resume()</code>），检查协程是否完成（<code>done()</code>），销毁协程（<code>destroy()</code>）。</p>
<p>3.协程框架：协程的执行需要一个框架来管理暂停和恢复。C++20
标准库没有提供内置的协程调度器，因此开发者通常需要：手动管理协程句柄，使用第三方库（如
<code>liburing</code>、<code>boost::asio</code>）提供的事件循环或调度器。</p>
<p>4.暂停点：暂停点由 <code>co_await</code> 或 <code>co_yield</code>
定义：</p>
<p><code>co_await expr</code>：暂停协程，等待表达式
<code>expr</code>（通常是一个等待器，<code>awaitable</code>）完成。</p>
<p><code>co_yield expr</code>：暂停协程并向调用者返回一个值。</p>
<p>暂停时，协程的状态（包括局部变量）被保存在堆上，称为<strong>协程帧</strong>（coroutine
frame）。</p>
<h3 id="工作原理">工作原理</h3>
<p>C++ 协程的实现依赖编译器将协程函数转换为状态机（state
machine）。其工作原理如下：</p>
<p>1.<strong>函数转换</strong>：当编译器遇到
<code>co_await</code>、<code>co_yield</code> 或 <code>co_return</code>
时，它将协程函数拆分为多个状态，每个状态对应一个暂停点或结束点。</p>
<p>2.<strong>协程帧分配</strong>：协程的局部变量和状态存储在堆上的协程帧中，确保暂停后状态不丢失。</p>
<p>3.<strong>状态机执行</strong>：协程在暂停点挂起时，返回控制权给调用者；恢复时，从暂停点继续执行。</p>
<p>4.<strong>生命周期管理</strong>：协程帧的分配和销毁由
<code>promise_type</code> 和 <code>std::coroutine_handle</code>
管理。</p>
<h3 id="示例">示例</h3>
<h4 id="生成器示例使用-co_yield">生成器示例（使用
<code>co_yield</code>）</h4>
<p>这个示例实现一个生成整数序列的协程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        std::optional&lt;T&gt; value;</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">            value = val;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        std::coroutine_handle&lt;promise_type&gt; coro;</span><br><span class="line">        <span class="type">bool</span> done;</span><br><span class="line"></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">            <span class="keyword">if</span> (!coro.<span class="built_in">done</span>()) &#123;</span><br><span class="line">                coro.<span class="built_in">resume</span>();</span><br><span class="line">                done = coro.<span class="built_in">done</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *coro.<span class="built_in">promise</span>().value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; coro;</span><br><span class="line">    <span class="built_in">Generator</span>(std::coroutine_handle&lt;promise_type&gt; h) : <span class="built_in">coro</span>(h) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Generator</span>() &#123; <span class="keyword">if</span> (coro) coro.<span class="built_in">destroy</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        coro.<span class="built_in">resume</span>(); <span class="comment">// 运行到第一个 yield</span></span><br><span class="line">        <span class="keyword">return</span> &#123;coro, coro.<span class="built_in">done</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;coro, <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 1 到 n 的序列</span></span><br><span class="line"><span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">generate_sequence</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : <span class="built_in">generate_sequence</span>(<span class="number">5</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：<code>Generator</code> 是一个自定义协程类型，存储通过
<code>co_yield</code> 返回的值。<code>promise_type</code> 的
<code>yield_value</code> 方法将每次 <code>co_yield</code> 的值保存到
<code>values</code> 向量中。<code>main</code>
函数调用生成器并打印结果。</p>
<h4 id="异步示例使用-co_await">异步示例（使用
<code>co_await</code>）</h4>
<p>以下是一个模拟异步任务的协程，假设有一个简单的等待器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟的等待器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; <span class="comment">// 总是暂停</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟异步操作（如 I/O）</span></span><br><span class="line">        std::<span class="built_in">thread</span>([h]() &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">            h.<span class="built_in">resume</span>(); <span class="comment">// 恢复协程</span></span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">async_task</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; started\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> Awaiter&#123;&#125;; <span class="comment">// 模拟异步等待</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; completed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动 5 个异步任务（避免 10000 个以简化输出）</span></span><br><span class="line">    std::vector&lt;Task&gt; tasks;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        tasks.<span class="built_in">push_back</span>(<span class="built_in">async_task</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待所有任务完成（简单模拟）</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：<code>Awaiter</code> 模拟一个异步操作（如网络 I/O），在 100ms
后恢复协程。<code>co_await Awaiter{}</code>
暂停协程，直到异步操作完成。<code>main</code>
启动多个异步任务，实际场景中需要事件循环来管理。</p>
<h3 id="协程的优缺点">协程的优缺点</h3>
<p>优点</p>
<p>1.高效性：协程在用户态管理暂停和恢复，避免了线程切换的开销。</p>
<p>2.灵活性：C++ 协程是底层机制，允许开发者自定义调度和行为。</p>
<p>3.异步编程简化：与回调或 <code>std::future</code>
相比，协程代码更直观，类似同步代码。</p>
<p>4.生成器支持：适合处理流式数据或惰性求值。</p>
<p>缺点</p>
<p>1.复杂性：需要手动定义 <code>promise_type</code>
和调度逻辑，学习曲线陡峭。</p>
<p>2.标准库支持不足：C++20
没有内置事件循环或调度器，需依赖第三方库。</p>
<p>3.内存管理：协程帧在堆上分配，可能增加内存开销。</p>
<p>4.调试困难：状态机转换和协程帧管理可能导致调试复杂。</p>
<h3 id="性能优化">性能优化</h3>
<p>避免在协程中分配过多内存，合理设计暂停点。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习路线</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html</url>
    <content><![CDATA[<p>C++
是一门底层控制力强、应用广泛的语言，适合系统编程、游戏开发、嵌入式开发、性能敏感型软件等。下面是一份系统的
<strong>C++
学习路线图</strong>，涵盖从入门到进阶再到专家级阶段，并为每个阶段推荐了经典书籍。</p>
<hr />
<h2 id="学习路线总览">🚀 学习路线总览</h2>
<ol type="1">
<li><strong>基础阶段（语法与核心概念）</strong></li>
<li><strong>进阶阶段（面向对象与 STL）</strong></li>
<li><strong>高级阶段（现代 C++、并发、模板）</strong></li>
<li><strong>专家阶段（设计模式、Boost、源码级理解）</strong></li>
<li><strong>实战阶段（大型项目、系统编程、开源库）</strong></li>
</ol>
<hr />
<h2 id="每个阶段的学习重点与书籍推荐">📘
每个阶段的学习重点与书籍推荐</h2>
<hr />
<h3 id="第一阶段c-基础语法与核心概念c9803">🔰 第一阶段：C++
基础语法与核心概念（C++98/03）</h3>
<h4 id="学习目标">学习目标：</h4>
<ul>
<li>理解 C++ 的基本语法、数据类型、指针、引用、函数</li>
<li>掌握控制结构、数组、字符串、结构体、文件操作等基础内容</li>
</ul>
<h4 id="推荐书籍">推荐书籍：</h4>
<ol type="1">
<li><p><strong>《C++ Primer（第5版）》—— Stanley B. Lippman</strong></p>
<blockquote>
<p>适合初学者的“圣经”，循序渐进、详细解释语法，贯穿初学到面向对象。</p>
</blockquote></li>
<li><p><strong>《C++ Primer Plus》—— Stephen Prata</strong></p>
<blockquote>
<p>更注重基础，讲解更缓慢，适合零基础读者。</p>
</blockquote></li>
</ol>
<h4 id="实践建议">实践建议：</h4>
<ul>
<li>完成小程序练习（如：计算器、学生成绩管理、字符串处理）</li>
</ul>
<hr />
<h3 id="第二阶段面向对象编程与-stlc9803">🧱 第二阶段：面向对象编程与
STL（C++98/03）</h3>
<h4 id="学习目标-1">学习目标：</h4>
<ul>
<li>深入理解类、继承、多态、虚函数、封装</li>
<li>掌握 C++ 标准模板库（STL）：vector、map、list、algorithm 等</li>
</ul>
<h4 id="推荐书籍-1">推荐书籍：</h4>
<ol type="1">
<li><p><strong>《Effective C++》—— Scott Meyers</strong></p>
<blockquote>
<p>以条款形式总结实战经验，非常经典，写作精炼。</p>
</blockquote></li>
<li><p><strong>《STL源码剖析》—— 侯捷</strong></p>
<blockquote>
<p>深入剖析 STL 的实现机制，适合巩固 STL 理解。</p>
</blockquote></li>
<li><p><strong>《C++标准库（第二版）》—— Nicolai M.
Josuttis</strong></p>
<blockquote>
<p>全面介绍标准库中容器、算法、函数对象等。</p>
</blockquote></li>
</ol>
<h4 id="实践建议-1">实践建议：</h4>
<ul>
<li>使用 STL 编写实用程序（如：LRU缓存、模拟操作系统调度器）</li>
</ul>
<hr />
<h3 id="第三阶段现代-c模板编程与并发c11141720">🧠 第三阶段：现代
C++、模板编程与并发（C++11/14/17/20）</h3>
<h4 id="学习目标-2">学习目标：</h4>
<ul>
<li>熟练掌握 C++11 起的新特性：auto、lambda、智能指针、move 语义、范围
for、并发库等</li>
<li>深入理解模板与元编程</li>
</ul>
<h4 id="推荐书籍-2">推荐书籍：</h4>
<ol type="1">
<li><p><strong>《Effective Modern C++》—— Scott Meyers</strong></p>
<blockquote>
<p>讲解 C++11/14 最重要的新特性，提升代码现代化水平。</p>
</blockquote></li>
<li><p><strong>《C++ Concurrency in Action》—— Anthony
Williams</strong></p>
<blockquote>
<p>C++11 并发编程权威书，涉及 thread、mutex、future 等。</p>
</blockquote></li>
<li><p><strong>《C++ Templates（第二版）》—— David Vandevoorde &amp;
Nicolai Josuttis</strong></p>
<blockquote>
<p>模板编程权威书籍，讲解从基础到元编程。</p>
</blockquote></li>
</ol>
<h4 id="实践建议-2">实践建议：</h4>
<ul>
<li>实现线程池、协程调度器、模板容器等项目</li>
</ul>
<hr />
<h3 id="第四阶段专家级技能设计模式源码阅读boost">🧬
第四阶段：专家级技能（设计模式、源码阅读、Boost）</h3>
<h4 id="学习目标-3">学习目标：</h4>
<ul>
<li>熟悉常用设计模式在 C++ 中的实现方式</li>
<li>能读懂大型库（如 STL、Boost、Qt）源码</li>
<li>精通内存管理、异常安全、多线程设计等高级主题</li>
</ul>
<h4 id="推荐书籍-3">推荐书籍：</h4>
<ol type="1">
<li><p><strong>《深入理解C++11》—— 侯捷</strong></p>
<blockquote>
<p>深挖 C++11 核心语义，适合打基础。</p>
</blockquote></li>
<li><p><strong>《C++设计新思维》—— Andrei Alexandrescu</strong></p>
<blockquote>
<p>以策略模式切入模板元编程，难度较高但启发性极强。</p>
</blockquote></li>
<li><p><strong>《Modern C++ Design》—— Alexandrescu</strong></p>
<blockquote>
<p>将设计模式与模板元编程结合，是 Boost 的灵感来源之一。</p>
</blockquote></li>
<li><p><strong>《Design Patterns》—— GoF 四人组（非 C++ 专属，但 C++
实现典范）</strong></p></li>
</ol>
<hr />
<h3 id="第五阶段项目实战与系统编程">🔧 第五阶段：项目实战与系统编程</h3>
<h4 id="学习目标-4">学习目标：</h4>
<ul>
<li>能使用 C++ 开发高性能、多线程、模块化应用</li>
<li>掌握 Linux 下 C++ 的系统调用、网络编程、内存控制</li>
<li>深入理解开源项目架构</li>
</ul>
<h4 id="推荐书籍-4">推荐书籍：</h4>
<ol type="1">
<li><p><strong>《Linux高性能服务器编程》—— 游双</strong></p>
<blockquote>
<p>系统级 C++ 网络编程实战书，涵盖 IO、多线程、Reactor 模型。</p>
</blockquote></li>
<li><p><strong>《Unix环境高级编程（APUE）》—— Stevens</strong></p>
<blockquote>
<p>C/C++ 系统编程圣经，深入理解 Unix/Linux 下的编程接口。</p>
</blockquote></li>
<li><p><strong>《大型C++项目设计》—— John Lakos</strong></p>
<blockquote>
<p>讲解如何组织庞大 C++ 项目，面向架构。</p>
</blockquote></li>
</ol>
<hr />
<h2 id="练手项目建议">🧑‍💻 练手项目建议</h2>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 50%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th>难度</th>
<th>项目</th>
<th>涉及知识点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>🌱 初级</td>
<td>词频统计器、学生信息管理系统</td>
<td>IO、STL、类设计</td>
</tr>
<tr class="even">
<td>🌿 中级</td>
<td>LRU缓存、线程池、Web服务器</td>
<td>智能指针、线程、模板</td>
</tr>
<tr class="odd">
<td>🌳 高级</td>
<td>简易数据库、Redis克隆、协程框架</td>
<td>内存管理、系统调用、并发控制</td>
</tr>
<tr class="even">
<td>🌲 专家</td>
<td>编译器前端、操作系统内核模块、渲染引擎</td>
<td>模板、指令集、虚拟内存管理等</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="学习技巧与资源">💡 学习技巧与资源</h2>
<ul>
<li><strong>刷题练语法</strong>：LeetCode、牛客、洛谷（用 C++
解题熟悉语法与 STL）</li>
<li><strong>视频教程</strong>：B站《C++全套教程》《侯捷C++课程》《C++并发实战》</li>
<li><strong>开源阅读</strong>：阅读 <a
href="https://abseil.io/">Abseil</a>、<a
href="https://github.com/fmtlib/fmt">fmt</a>、<a
href="https://github.com/protocolbuffers/protobuf">protobuf</a>
等库源码</li>
<li><strong>博客 &amp; 文档</strong>：cppreference.com 是现代 C++
的权威文档</li>
</ul>
<hr />
<p>如果你告诉我你的目标（比如刷题、游戏开发、系统开发），我可以定制一条更适合你的学习路线。是否需要我帮你按“目标方向”细化路线？</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 实现协程调度器</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++-%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8.html</url>
    <content><![CDATA[<p>在 C++20
中，协程（Coroutines）的执行需要一个框架来管理暂停和恢复，而标准库并未提供内置的协程调度器或事件循环。因此，开发者需要手动管理协程句柄（<code>std::coroutine_handle</code>）或借助第三方库（如
<code>liburing</code> 或
<code>boost::asio</code>）来实现高效的调度。本回答将详细讲解如何<strong>手动管理协程句柄</strong>以及如何实现一个<strong>简单的事件循环或调度器</strong>，包括代码示例、实现原理和注意事项。</p>
<hr />
<h3 id="手动管理协程句柄"><strong>1. 手动管理协程句柄</strong></h3>
<p><code>std::coroutine_handle</code> 是 C++20
协程的核心接口，用于控制协程的生命周期和执行状态。手动管理协程句柄意味着开发者需要直接操作
<code>std::coroutine_handle</code> 来启动、暂停、恢复或销毁协程。</p>
<h4 id="stdcoroutine_handle-的核心功能"><strong>1.1
<code>std::coroutine_handle</code> 的核心功能</strong></h4>
<p><code>std::coroutine_handle</code> 提供了以下关键方法： -
<strong><code>resume()</code></strong>：恢复协程的执行，从上一个暂停点继续运行。
- <strong><code>done()</code></strong>：检查协程是否已完成（即到达
<code>final_suspend</code> 点）。 -
<strong><code>destroy()</code></strong>：销毁协程，释放协程帧的内存。 -
<strong><code>promise()</code></strong>：访问协程的
<code>promise_type</code> 对象，用于获取返回值或自定义状态。 -
<strong><code>from_promise()</code></strong>：从
<code>promise_type</code> 创建句柄（通常由编译器自动调用）。</p>
<h4 id="手动管理的步骤"><strong>1.2 手动管理的步骤</strong></h4>
<p>手动管理协程句柄通常涉及以下步骤： 1.
<strong>创建协程</strong>：通过调用协程函数，获取
<code>std::coroutine_handle</code>（通常由
<code>promise_type::get_return_object</code> 返回）。 2.
<strong>存储句柄</strong>：将句柄保存在容器（如 <code>std::vector</code>
或 <code>std::queue</code>）中，以便后续管理。 3.
<strong>恢复执行</strong>：根据需要调用 <code>resume()</code> 恢复协程。
4. <strong>检查状态</strong>：使用 <code>done()</code>
检查协程是否完成。 5.
<strong>清理资源</strong>：在协程完成或不再需要时调用
<code>destroy()</code>。</p>
<h4 id="手动管理示例"><strong>1.3 手动管理示例</strong></h4>
<p>以下是一个简单的示例，展示如何手动管理多个协程句柄：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程任务类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::coroutine_handle&lt;&gt; handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程函数</span></span><br><span class="line"><span class="function">Task <span class="title">coroutine</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; started\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;; <span class="comment">// 暂停点 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; resumed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;; <span class="comment">// 暂停点 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; completed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_coroutines = <span class="number">5</span>; <span class="comment">// 为了简化输出，使用 5 个协程</span></span><br><span class="line">    std::vector&lt;std::coroutine_handle&lt;&gt;&gt; handles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建协程并存储句柄</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_coroutines; ++i) &#123;</span><br><span class="line">        handles.<span class="built_in">push_back</span>(<span class="built_in">coroutine</span>(i).handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动恢复协程：第一轮</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First resume:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; h : handles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!h.<span class="built_in">done</span>()) &#123;</span><br><span class="line">            h.<span class="built_in">resume</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动恢复协程：第二轮</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSecond resume:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; h : handles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!h.<span class="built_in">done</span>()) &#123;</span><br><span class="line">            h.<span class="built_in">resume</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理已完成的协程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; h : handles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h.<span class="built_in">done</span>()) &#123;</span><br><span class="line">            h.<span class="built_in">destroy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Coroutine 0 started</span><br><span class="line">Coroutine 1 started</span><br><span class="line">Coroutine 2 started</span><br><span class="line">Coroutine 3 started</span><br><span class="line">Coroutine 4 started</span><br><span class="line"></span><br><span class="line">Second resume:</span><br><span class="line">Coroutine 0 resumed</span><br><span class="line">Coroutine 1 resumed</span><br><span class="line">Coroutine 2 resumed</span><br><span class="line">Coroutine 3 resumed</span><br><span class="line">Coroutine 4 resumed</span><br></pre></td></tr></table></figure></p>
<p><strong>说明</strong>： -
<strong>创建协程</strong>：<code>coroutine(i)</code> 返回一个
<code>Task</code>，其 <code>handle</code> 成员保存了协程句柄。 -
<strong>存储句柄</strong>：句柄存储在 <code>std::vector</code>
中，方便批量管理。 - <strong>恢复协程</strong>：通过
<code>resume()</code>
逐个恢复协程，每次恢复到一个暂停点（<code>co_await std::suspend_always{}</code>）。
- <strong>检查和清理</strong>：使用 <code>done()</code>
检查协程是否完成，并在完成后调用 <code>destroy()</code> 释放资源。</p>
<p><strong>局限性</strong>： - 手动管理适合小规模场景，但对于 10000
个协程，手动逐个恢复效率低下。 -
缺乏自动化调度机制，难以处理复杂的异步依赖或优先级。</p>
<hr />
<h3 id="实现一个简单的事件循环或调度器"><strong>2.
实现一个简单的事件循环或调度器</strong></h3>
<p>为了高效管理大量协程（如 10000
个），需要一个调度器或事件循环来自动化处理协程的暂停、恢复和清理。事件循环的核心思想是维护一个任务队列，循环检查并执行就绪的协程。</p>
<h4 id="事件循环调度器的核心组件"><strong>2.1
事件循环/调度器的核心组件</strong></h4>
<p>一个简单的事件循环或调度器通常包含以下部分： 1.
<strong>任务队列</strong>：存储待执行的协程句柄，通常使用
<code>std::queue</code> 或 <code>std::vector</code>。 2.
<strong>调度逻辑</strong>：决定何时恢复哪个协程（例如，轮询、优先级调度或基于事件）。
3. <strong>完成检测</strong>：检查协程是否完成，并清理已完成的协程。 4.
<strong>事件触发</strong>：处理外部事件（如 I/O
完成、定时器），决定哪些协程可以恢复。</p>
<h4 id="实现简单调度器"><strong>2.2 实现简单调度器</strong></h4>
<p>以下是一个简单的调度器实现，适合管理 10000 个协程。它使用
<code>std::queue</code>
存储协程句柄，并循环恢复协程直到所有任务完成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程任务类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::coroutine_handle&lt;&gt; handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单调度器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">    std::queue&lt;std::coroutine_handle&lt;&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加协程到队列</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">schedule</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">        tasks.<span class="built_in">push</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行所有协程直到完成</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> task = tasks.<span class="built_in">front</span>();</span><br><span class="line">            tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!task.<span class="built_in">done</span>()) &#123;</span><br><span class="line">                task.<span class="built_in">resume</span>(); <span class="comment">// 恢复协程</span></span><br><span class="line">                <span class="keyword">if</span> (!task.<span class="built_in">done</span>()) &#123;</span><br><span class="line">                    tasks.<span class="built_in">push</span>(task); <span class="comment">// 未完成，重新加入队列</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    task.<span class="built_in">destroy</span>(); <span class="comment">// 完成后销毁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                task.<span class="built_in">destroy</span>(); <span class="comment">// 确保销毁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程函数</span></span><br><span class="line"><span class="function">Task <span class="title">coroutine</span><span class="params">(<span class="type">int</span> id, Scheduler&amp; scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">5</span>) &#123; <span class="comment">// 仅打印前 5 个协程的输出</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; step &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">co_await</span> std::suspend_always&#123;&#125;; <span class="comment">// 暂停点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scheduler scheduler;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_coroutines = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 10000 个协程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_coroutines; ++i) &#123;</span><br><span class="line">        scheduler.<span class="built_in">schedule</span>(<span class="built_in">coroutine</span>(i, scheduler).handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Running &quot;</span> &lt;&lt; num_coroutines &lt;&lt; <span class="string">&quot; coroutines\n&quot;</span>;</span><br><span class="line">    scheduler.<span class="built_in">run</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All coroutines completed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出（部分）</strong>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 10000 coroutines</span><br><span class="line">Coroutine 0 step 0</span><br><span class="line">Coroutine 1 step 0</span><br><span class="line">Coroutine 2 step 0</span><br><span class="line">Coroutine 3 step 0</span><br><span class="line">Coroutine 4 step 0</span><br><span class="line">Coroutine 0 step 1</span><br><span class="line">Coroutine 1 step 1</span><br><span class="line">...</span><br><span class="line">All coroutines completed</span><br></pre></td></tr></table></figure></p>
<p><strong>说明</strong>： - <strong>调度器设计</strong>： - 使用
<code>std::queue</code> 存储协程句柄。 - <code>schedule</code>
方法将协程句柄加入队列。 - <code>run</code>
方法循环处理队列中的协程，每次恢复一个协程，并根据 <code>done()</code>
决定是否重新加入队列或销毁。 - <strong>协程行为</strong>： - 每个协程有
3
个暂停点（<code>co_await std::suspend_always{}</code>），模拟分步执行。
- 仅打印前 5 个协程的输出，避免过多日志。 - <strong>运行 10000
个协程</strong>： - 代码能够处理 10000
个协程，效率依赖于暂停点的数量和任务的复杂性。 -
每个协程的内存开销主要来自协程帧，约为几百字节（取决于局部变量）。</p>
<p><strong>编译运行</strong>： -
编译：<code>g++ -std=c++20 -fcoroutines main.cpp -o main</code> -
运行：<code>./main</code></p>
<h4 id="扩展支持异步事件"><strong>2.3 扩展：支持异步事件</strong></h4>
<p>上述调度器是同步的，适合简单任务。若要支持异步事件（如 I/O
或定时器），需要结合等待器（<code>awaitable</code>）。以下是一个扩展示例，模拟异步
I/O：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟异步等待器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AsyncAwaiter</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">thread</span>([h]() &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">            h.<span class="built_in">resume</span>();</span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line"><span class="function">campo</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程任务类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::coroutine_handle&lt;&gt; handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">    std::queue&lt;std::coroutine_handle&lt;&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">schedule</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">        tasks.<span class="built_in">push</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> task = tasks.<span class="built_in">front</span>();</span><br><span class="line">            tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!task.<span class="built_in">done</span>()) &#123;</span><br><span class="line">                task.<span class="built_in">resume</span>();</span><br><span class="line">                <span class="keyword">if</span> (!task.<span class="built_in">done</span>()) &#123;</span><br><span class="line">                    tasks-<span class="built_in">push</span>(task); <span class="comment">// 未完成，重新调度</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    task.<span class="built_in">destroy</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                task.<span class="built_in">destroy</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步协程</span></span><br><span class="line"><span class="function">Task <span class="title">async_coroutine</span><span class="params">(<span class="type">int</span> id, Scheduler&amp; scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">5</span>) std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; started\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> AsyncAwaiter&#123;&#125;; <span class="comment">// 模拟异步 I/O</span></span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">5</span>) std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; completed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scheduler scheduler;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_coroutines = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 10000 个协程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_coroutines; ++i) &#123;</span><br><span class="line">        scheduler.<span class="built_in">schedule</span>(<span class="built_in">async_coroutine</span>(i, scheduler).handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Running &quot;</span> &lt;&lt; num_coroutines &lt;&lt; <span class="string">&quot; coroutines\n&quot;</span>;</span><br><span class="line">    scheduler.<span class="built_in">run</span>();</span><br><span class="line">    <span class="comment">// 等待异步操作完成</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All coroutines completed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>： -
<strong>异步等待器</strong>：<code>AsyncAwaiter</code> 模拟 100ms
的异步操作（如网络 I/O），在完成后恢复协程。 -
<strong>调度器</strong>：与之前类似，但需要等待异步事件完成（通过
<code>sleep_for</code> 模拟）。 -
<strong>注意</strong>：实际异步场景需要集成事件循环（如
<code>epoll</code> 或 <code>libuv</code>）来监听 I/O 事件，而非使用
<code>sleep_for</code>。</p>
<hr />
<h3 id="实现调度器的关键考虑"><strong>3.
实现调度器的关键考虑</strong></h3>
<p>设计调度器时，需要考虑以下因素： 1.
<strong>任务优先级</strong>：可以扩展调度器支持优先级队列（<code>std::priority_queue</code>），优先执行高优先级协程。
2. <strong>异步事件</strong>：结合
<code>select</code>、<code>epoll</code>（Linux）或
<code>IOCP</code>（Windows）处理 I/O 事件。 3.
<strong>多线程支持</strong>：将协程分配到多个线程运行，提高并发性能。 4.
<strong>内存管理</strong>：协程帧在堆上分配，需优化内存使用（如使用自定义分配器）。
5. <strong>错误处理</strong>：通过
<code>promise_type::unhandled_exception</code> 处理异常。</p>
<h4 id="优化-10000-个协程的性能"><strong>3.1 优化 10000
个协程的性能</strong></h4>
<ul>
<li><strong>减少暂停点</strong>：每个 <code>co_await</code>
增加调度开销，尽量减少不必要的暂停。</li>
<li><strong>批量处理</strong>：一次恢复多个协程，减少队列操作开销。</li>
<li><strong>内存池</strong>：为协程帧使用内存池，减少动态分配的开销。</li>
<li><strong>并行调度</strong>：将任务分配到多个线程，每个线程运行一个调度器。</li>
</ul>
<hr />
<h3 id="与第三方库的对比"><strong>4. 与第三方库的对比</strong></h3>
<p>手动管理协程句柄和简单调度器适合学习或小规模应用，但在生产环境中，推荐使用成熟的第三方库：
- <strong><code>boost::asio</code></strong>：提供异步 I/O
和协程支持，内置事件循环，适合网络编程。 -
<strong><code>cppcoro</code></strong>：轻量级 C++
协程库，提供生成器、任务和调度器。 -
<strong><code>liburing</code></strong>：基于 Linux <code>io_uring</code>
的高性能异步 I/O 框架，适合大规模并发。</p>
<p><strong>手动管理 vs. 第三方库</strong>： -
<strong>手动管理</strong>：完全控制，适合定制化场景，但开发复杂，容易出错。
-
<strong>第三方库</strong>：提供现成的事件循环和调度器，开发效率高，性能优化好。</p>
<hr />
<h3 id="注意事项"><strong>5. 注意事项</strong></h3>
<ol type="1">
<li><strong>编译器支持</strong>：确保使用支持 C++20 协程的编译器（GCC
11+、Clang 14+、MSVC 2019+），并启用
<code>-fcoroutines</code>（GCC）或相应标志。</li>
<li><strong>内存开销</strong>：10000
个协程可能占用大量内存（每个协程帧约几百字节），需监控和优化。</li>
<li><strong>调试</strong>：协程状态机复杂，建议使用支持协程的调试器（如最新
GDB）。</li>
<li><strong>异步集成</strong>：手动调度器难以高效处理 I/O
事件，生产环境需结合事件循环库。</li>
</ol>
<hr />
<h3 id="总结"><strong>6. 总结</strong></h3>
<ul>
<li><strong>手动管理协程句柄</strong>：通过
<code>std::coroutine_handle</code> 的
<code>resume</code>、<code>done</code> 和 <code>destroy</code>
方法，开发者可以直接控制协程的执行和清理，适合简单场景。</li>
<li><strong>简单调度器</strong>：使用队列存储协程句柄，循环恢复未完成的协程，适合管理大量协程（如
10000 个）。</li>
<li><strong>异步支持</strong>：通过自定义等待器（如
<code>AsyncAwaiter</code>）模拟异步事件，实际应用需集成 I/O
事件循环。</li>
<li><strong>扩展性</strong>：手动调度器可扩展为优先级调度或多线程调度，但生产环境中建议使用
<code>boost::asio</code> 或 <code>cppcoro</code>。</li>
</ul>
<p>如果你需要更复杂的调度器实现（例如支持优先级、定时器或 I/O
事件）、第三方库集成的示例，或者其他具体问题，请告诉我！</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 实现环形缓冲区</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA.html</url>
    <content><![CDATA[<p>环形缓冲区（Ring
Buffer）是一种常见的用于数据流缓冲的结构，通常用于生产者-消费者模型、音视频处理等场景。</p>
<p>因为环形缓冲区使用的场景大多为性能敏感的场景，我们采用数组的数据结构和位运算来实现，以提高代码效率。位运算的效率要高于模运算，但是用位运算替代模运算的前提是缓冲区的大小必须为
2 的整数次幂，因为对于 2
的幂来说，模运算就是屏蔽高位，这个在下面展示代码的时候细说。</p>
<p>因为要适配不同的类型，在头文件中使用模板，由于模板类和模板函数是在使用时才实例化的，编译器需要在包含模板的地方就能看到其完整实现，如果编译器看不到它的实现，在链接时就会报错（undefined
reference），通常不能将模板的实现写在<code>.cpp</code>文件中。但是也不推荐把模板类的声明和定义全写在<code>.h</code>文件里，推荐的方式是<code>.h + .tpp</code>的方式，这样可以分离接口与实现，提高可读性，也可以避免不必要的重复编译——如果都写在<code>.h</code>文件中，每次这个头文件被<code>#include</code>，就会重新编译一遍模板定义，编译时间会变长。</p>
<p>环形缓冲区类的头文件 <code>RingBuffer.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RINGBUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFFER_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Capacity&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RingBuffer</span> &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>((Capacity &amp; (Capacity - <span class="number">1</span>)) == <span class="number">0</span>, <span class="string">&quot;Capacity must be a power of 2&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RingBuffer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T buffer_[Capacity];</span><br><span class="line">    <span class="type">size_t</span> head_;</span><br><span class="line">    <span class="type">size_t</span> tail_;</span><br><span class="line">    <span class="type">bool</span> full_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RingBuffer.tpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>环形缓冲区类的实现部分<code>RingBuffer.tpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RINGBUFFER_TPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFFER_TPP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Capacity&gt;</span><br><span class="line">RingBuffer&lt;T, Capacity&gt;::<span class="built_in">RingBuffer</span>()</span><br><span class="line">    : <span class="built_in">head_</span>(<span class="number">0</span>),<span class="built_in">tail_</span>(<span class="number">0</span>),<span class="built_in">full_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Capacity&gt;</span><br><span class="line"><span class="type">bool</span> RingBuffer&lt;T, Capacity&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (full_) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    buffer_[head_] = item;</span><br><span class="line">    head_ = (head_ + <span class="number">1</span>) &amp; (Capacity - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head_ == tail_) full_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Capacity&gt;</span><br><span class="line"><span class="type">bool</span> RingBuffer&lt;T, Capacity&gt;::<span class="built_in">pop</span>(T &amp;item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    item = buffer_[tail_];</span><br><span class="line">    tail_ = (tail_ + <span class="number">1</span>) &amp; (Capacity - <span class="number">1</span>);</span><br><span class="line">    full_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Capacity&gt;</span><br><span class="line"><span class="type">bool</span> RingBuffer&lt;T, Capacity&gt;::<span class="built_in">empty</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (!full_ &amp;&amp; (head_ == tail_));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Capacity&gt;</span><br><span class="line"><span class="type">bool</span> RingBuffer&lt;T, Capacity&gt;::<span class="built_in">full</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> full_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Capacity&gt;</span><br><span class="line"><span class="type">size_t</span> RingBuffer&lt;T, Capacity&gt;::<span class="built_in">size</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (full_) <span class="keyword">return</span> Capacity;</span><br><span class="line">    <span class="keyword">if</span> (head_ &gt;= tail_) <span class="keyword">return</span> head_ - tail_;</span><br><span class="line">    <span class="keyword">return</span> head_ + Capacity - tail_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Capacity&gt;</span><br><span class="line"><span class="type">void</span> RingBuffer&lt;T, Capacity&gt;::<span class="built_in">reset</span>() &#123;</span><br><span class="line">    head_ = tail_ = <span class="number">0</span>;</span><br><span class="line">    full_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>主函数代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RingBuffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RingBuffer&lt;<span class="type">int</span>, <span class="number">8</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.<span class="built_in">push</span>(i))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Pushed: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Buffer full, cannot push: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">while</span> (buffer.<span class="built_in">pop</span>(val)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Popped: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; buffer.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何判断一个数是 2 的幂？可以通过：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(Capacity &amp; (Capacity - <span class="number">1</span>)) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>因为 2 的幂都是形如 1000 这样的数字，减一后除了首位外全为
1，利用<code>&amp;</code>的位运算之后全为 0。</p>
<p>如何用位运算替代模运算？就是利用位运算屏蔽高位。例如用
<code>a &amp; (b - 1)</code> 替代 <code>a % b</code>，前提 b 是 2
的整数次幂。例如 1111 % 1000，就是把高于 000
的位数全部去掉，因此可以利用 1000 - 1 = 0111 的高位 0
来“与”掉所有的高位，因为 0 与任何数还是 0 ，1
与任何数还是数本身。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15 % 8 == 7</span><br><span class="line">0b1111 &amp; 0b0111 = 0b0111</span><br></pre></td></tr></table></figure>
<p>注意这里不能用移位操作（ &gt;&gt; 或者 &lt;&lt;
），左移和右移操作替代的是除法和乘法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x / 2^n   →   x &gt;&gt; n</span><br><span class="line">x * 2^n   →   x &lt;&lt; n</span><br></pre></td></tr></table></figure>
<p>环形缓冲区的头尾初始值都是 0，符合条件时进行 push 和 pop
操作时，head_ 和 tail_ 的值都后移。</p>
<p>每次执行 push
操作，先检测一下缓冲区是否是满的，如果不满就将数据插入头位置，然后把头位置后移一位，如果
head_ + 1 大于
Capacity，则触发一次回绕，通过求余（通过模运算或者位运算）得到新的
head_。除了初始状态<code>head_</code> = <code>tail_</code> =
0，<code>full_ = false</code>，后续的操作中，如果<code>head_</code>和<code>tail_</code>的值相同，则判定现在缓冲区已满（因为
<code>head_ == tail_</code> 时既可能是空也可能是满，必须通过
<code>full_</code> 标志来区分）。</p>
<p>size() 函数在处理 head_ &lt; tail_ 的情况时（这种情况出现在多次 push
操作使得回绕被触发，且 pop 的操作次数少于 push
操作的时候），计算缓冲区中的数据量时需要用 Capacity 减去 head_ 和 tail_
的差值。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 语法速览</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++-%E8%AF%AD%E6%B3%95%E9%80%9F%E8%A7%88.html</url>
    <content><![CDATA[<h1 id="hello-world">1. Hello World</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="变量与数据类型">2. 变量与数据类型</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">bool</span> d = <span class="literal">true</span>;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="条件语句ifelse-switch">3. 条件语句（if/else, switch）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) std::cout &lt;&lt; <span class="string">&quot;Positive\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>) std::cout &lt;&lt; <span class="string">&quot;Negative\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;Zero\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: std::cout &lt;&lt; <span class="string">&quot;It&#x27;s five\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: std::cout &lt;&lt; <span class="string">&quot;Other\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="循环forwhiledo-while">4. 循环（for/while/do-while）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) std::cout &lt;&lt; <span class="string">&quot;For &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; <span class="number">3</span>) std::cout &lt;&lt; <span class="string">&quot;While &quot;</span> &lt;&lt; j++ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123; std::cout &lt;&lt; <span class="string">&quot;Do-while &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125; <span class="keyword">while</span> (++k &lt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="函数定义">5. 函数定义</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="数组与字符串">6. 数组与字符串</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="指针和引用">7. 指针和引用</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>&amp; r = a;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="类与对象">8. 类与对象</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hi, I&#x27;m &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    p.<span class="built_in">greet</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="构造函数和析构函数">9. 构造函数和析构函数</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Demo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Demo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Demo d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="继承与多态">10. 继承与多态</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base speaking\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived speaking\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="stl-容器vector-示例">11. STL 容器（vector 示例）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="异常处理try-catch">12. 异常处理（try-catch）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Something went wrong&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="lambda-表达式">13. Lambda 表达式</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="文件读写fstream">14. 文件读写（fstream）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;Hello File&quot;</span>;</span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string content;</span><br><span class="line">    in &gt;&gt; content;</span><br><span class="line">    std::cout &lt;&lt; content &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="模板函数与类">15. 模板函数与类</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">double</span>&gt;(<span class="number">2.5</span>, <span class="number">1.5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="函数默认参数与重载">16. 函数默认参数与重载</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(std::string name = <span class="string">&quot;Guest&quot;</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) <span class="built_in">greet</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">greet</span>();            <span class="comment">// Hello, Guest!</span></span><br><span class="line">    <span class="built_in">greet</span>(<span class="string">&quot;Alice&quot;</span>);     <span class="comment">// Hello, Alice!</span></span><br><span class="line">    <span class="built_in">greet</span>(<span class="number">2</span>);           <span class="comment">// Hello, Guest! (twice)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="命名空间与别名">17. 命名空间与别名</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> math &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> m = math; <span class="comment">// 别名</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; m::<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="枚举enum-class">18. 枚举（enum class）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color c = Color::Green;</span><br><span class="line">    <span class="keyword">if</span> (c == Color::Green) std::cout &lt;&lt; <span class="string">&quot;Green\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="智能指针stdunique_ptr-stdshared_ptr">19.
智能指针（<code>std::unique_ptr</code>,
<code>std::shared_ptr</code>）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Construct\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destruct\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;MyClass&gt; uPtr = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;();</span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; sPtr1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; sPtr2 = sPtr1; <span class="comment">// 引用计数 +1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="类型推导-auto-decltype">20. 类型推导 (<code>auto</code>,
<code>decltype</code>)</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="number">42</span>;        <span class="comment">// 推导为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>)) y = <span class="number">5</span>;  <span class="comment">// 推导为 int</span></span><br><span class="line">    std::cout &lt;&lt; x + y &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="结构化绑定c17">21. 结构化绑定（C++17）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, std::string&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [id, name] = <span class="built_in">getData</span>();</span><br><span class="line">    std::cout &lt;&lt; id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="范围-for-与初始化-ifwhilec17">22. 范围 for 与初始化
if/while（C++17）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span> x = nums[<span class="number">0</span>]; x == <span class="number">1</span>) std::cout &lt;&lt; <span class="string">&quot;\nFirst is 1\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="constexpr-常量表达式">23. <code>constexpr</code> 常量表达式</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> val = <span class="built_in">square</span>(<span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="可变参数模板variadic-templates">24. 可变参数模板（Variadic
Templates）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T first, Args... rest)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="类型特征与-stdenable_if">25. 类型特征与
<code>std::enable_if</code></h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; add(2.5, 3.1) &lt;&lt; std::endl; // 编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="lambda-捕获值引用默认">26. Lambda 捕获（值/引用/默认）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">auto</span> f1 = [a, &amp;b]() &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">    b = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">f1</span>(); <span class="comment">// 输出 10 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="stdfunction-与函数对象">27. <code>std::function</code>
与函数对象</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = add;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="多线程stdthread">28. 多线程（<code>std::thread</code>）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(sayHello)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="锁与互斥stdmutex">29. 锁与互斥（<code>std::mutex</code>）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span>, <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="标准算法stdsort-stdtransform">30.
标准算法（<code>std::sort</code>, <code>std::transform</code>）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="协程c20co_yield-co_return-co_await">31.
协程（C++20）<code>co_yield</code>, <code>co_return</code>,
<code>co_await</code></h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span>;</span><br><span class="line">    <span class="keyword">using</span> handle_type = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="type">int</span> current_value;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Generator&#123;handle_type::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std::<span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            current_value = value;</span><br><span class="line">            <span class="keyword">return</span> std::suspend_always&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    handle_type coro;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Generator</span><span class="params">(handle_type h)</span> : coro(h) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Generator</span>() &#123; <span class="keyword">if</span> (coro) coro.<span class="built_in">destroy</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">next</span><span class="params">()</span> </span>&#123; coro.<span class="built_in">resume</span>(); <span class="keyword">return</span> !coro.<span class="built_in">done</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> coro.<span class="built_in">promise</span>().current_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Generator <span class="title">counter</span><span class="params">(<span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= max; ++i)</span><br><span class="line">        <span class="keyword">co_yield</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> gen = <span class="built_in">counter</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span> (gen.<span class="built_in">next</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; gen.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="stdoptional可选值">32. <code>std::optional</code>（可选值）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (result) std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; *result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;Divide by zero!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="stdvariant-和-stdvisit类型安全的-union">33.
<code>std::variant</code> 和 <code>std::visit</code>（类型安全的
union）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, std::string&gt; data = <span class="number">10</span>;</span><br><span class="line">    data = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; val) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    &#125;, data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="concepts概念约束c20">34. Concepts（概念约束，C++20）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;Addable T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; add(&quot;hi&quot;, 1); // 编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="模板元编程type-traits-递归模板">35. 模板元编程（Type Traits +
递归模板）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出 120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="crtp奇异递归模板模式">36. CRTP（奇异递归模板模式）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">implementation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;Derived&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">implementation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">interface</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="泛型-lambdac14c20-支持模板参数">37. 泛型 Lambda（C++14+，C++20
支持模板参数）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">1.5</span>, <span class="number">2.5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="类型擦除使用-stdfunction">38. 类型擦除：使用
<code>std::function</code></h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hi\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; f = sayHi;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="自定义迭代器最简可用版">39. 自定义迭代器（最简可用版）</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRange</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        <span class="type">int</span> current;</span><br><span class="line">        <span class="type">int</span> <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> current; &#125;</span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++() &#123; ++current; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123; <span class="keyword">return</span> current != other.current; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;; &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">5</span>&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : <span class="built_in">MyRange</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="nodiscard-maybe_unused-deprecated">40.
<code>[[nodiscard]]</code>, <code>[[maybe_unused]]</code>,
<code>[[deprecated]]</code></h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">importantValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;Use newFunction instead&quot;</span>)]] <span class="function"><span class="type">void</span> <span class="title">oldFunction</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// importantValue(); // 警告：返回值未使用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">importantValue</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oldFunction(); // 编译时警告</span></span><br><span class="line"></span><br><span class="line">    [[maybe_unused]] <span class="type">int</span> unused = <span class="number">123</span>; <span class="comment">// 避免未使用警告</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="c20-模块modules">41. <strong>C++20 模块（Modules）</strong></h1>
<blockquote>
<p>⚠️ 需编译器支持（如 GCC 11+/Clang 13+/MSVC 2019+），推荐使用 CMake +
MSVC 或 <code>g++ -fmodules-ts</code></p>
</blockquote>
<p>✅ 示例结构：</p>
<p><code>math.ixx</code>（模块接口文件）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> math;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ 编译指令（GCC 示例）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -std=c++20 -fmodules-ts math.ixx -c -o math.o</span><br><span class="line">g++ -std=c++20 -fmodules-ts main.cpp math.o -o main</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="三向比较---c20-spaceship-operator">42.
<strong>三向比较（&lt;=&gt;） - C++20 Spaceship Operator</strong></h1>
<p>✅ 自动生成所有比较运算符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Point&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point a&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, b&#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; (a &lt; b) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; (a == b) &lt;&lt; <span class="string">&quot;\n&quot;</span>;                   <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ 自定义三向比较返回值（强/弱/部分顺序）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weird</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::partial_ordering <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Weird&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || other.x &lt; <span class="number">0</span>) <span class="keyword">return</span> std::partial_ordering::unordered;</span><br><span class="line">        <span class="keyword">return</span> x &lt;=&gt; other.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Weird a&#123;<span class="number">5</span>&#125;, b&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; (a &lt; b) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// false，unordered</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="协程完整框架promise_type-全流程">43.
<strong>协程完整框架（promise_type 全流程）</strong></h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std::<span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; coro;</span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; h) : <span class="built_in">coro</span>(h) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Task</span>() &#123; <span class="keyword">if</span> (coro) coro.<span class="built_in">destroy</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Start coroutine\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ 补充说明：</p>
<ul>
<li><code>promise_type</code> 控制协程生命周期</li>
<li><code>get_return_object()</code> 返回外部包装类型</li>
<li>可进一步添加 <code>co_await</code> 处理异步等待等（协程通信）</li>
</ul>
<hr />
<h1 id="c-gui-示例使用-sfml-简洁-gui">44. <strong>C++ GUI 示例（使用
SFML 简洁 GUI）</strong></h1>
<blockquote>
<p>⚠️ GUI 不在标准库中，推荐使用跨平台库如 <code>SFML</code>,
<code>Dear ImGui</code>, <code>Qt</code>，这里给出 SFML 示例（需安装
SFML）</p>
</blockquote>
<p>✅ 示例（创建窗口 + 渲染圆形）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SFML/Graphics.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">sf::RenderWindow <span class="title">window</span><span class="params">(sf::VideoMode(<span class="number">400</span>, <span class="number">300</span>), <span class="string">&quot;My GUI&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">sf::CircleShape <span class="title">shape</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    shape.<span class="built_in">setFillColor</span>(sf::Color::Green);</span><br><span class="line">    shape.<span class="built_in">setPosition</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window.<span class="built_in">isOpen</span>()) &#123;</span><br><span class="line">        sf::Event event;</span><br><span class="line">        <span class="keyword">while</span> (window.<span class="built_in">pollEvent</span>(event))</span><br><span class="line">            <span class="keyword">if</span> (event.type == sf::Event::Closed) window.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">        window.<span class="built_in">clear</span>();</span><br><span class="line">        window.<span class="built_in">draw</span>(shape);</span><br><span class="line">        window.<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ 编译方式（Linux/macOS）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o app -lsfml-graphics -lsfml-window -lsfml-system</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🧩 也可以使用 <a href="https://github.com/ocornut/imgui">Dear
ImGui</a> 进行现代 GUI 编程，推荐结合 SDL/OpenGL。</p>
</blockquote>
<hr />
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++.html</url>
    <content><![CDATA[<h1 id="语法树">语法树</h1>
<pre><code class="highlight mermaid">graph LR
    A[&quot;C++ 语法概览&quot;]

    %% 1. 基础语法特性 (C++98/03 及之前)
    A --&gt; B[&quot;基础语法特性&lt;br&gt;C++98/03&quot;]
    B --&gt; B1[&quot;基本数据类型&quot;]
    B1 --&gt; B1a[&quot;整型: int, short, long&quot;]
    B1 --&gt; B1b[&quot;浮点型: float, double&quot;]
    B1 --&gt; B1c[&quot;字符型: char, wchar_t&quot;]
    B1 --&gt; B1d[&quot;布尔型: bool&quot;]
    B1 --&gt; B1e[&quot;修饰符: signed, unsigned&quot;]
    
    B --&gt; B2[&quot;变量与常量&quot;]
    B2 --&gt; B2a[&quot;变量声明与定义&quot;]
    B2 --&gt; B2b[&quot;常量: const&quot;]
    
    B --&gt; B3[&quot;运算符&quot;]
    B3 --&gt; B3a[&quot;算术运算符: +, -, *, /, %&quot;]
    B3 --&gt; B3b[&quot;关系运算符: ==, !=, &amp;lt;, &amp;gt;&quot;]
    B3 --&gt; B3c[&quot;逻辑运算符: &amp;amp;&amp;amp;, ||, !&quot;]
    B3 --&gt; B3d[&quot;位运算符: &amp;amp;, |, ^, ~, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;&quot;]
    B3 --&gt; B3e[&quot;赋值运算符: =, +=, -=&quot;]
    B3 --&gt; B3f[&quot;其他: sizeof, typeid&quot;]
         
    B --&gt; B4[&quot;控制结构&quot;]
    B4 --&gt; B4a[&quot;条件语句: if, else&quot;]
    B4 --&gt; B4b[&quot;开关语句: switch, case&quot;]
    B4 --&gt; B4c[&quot;循环: for, while, do-while&quot;]
    B4 --&gt; B4d[&quot;跳转: break, continue, return, goto&quot;]
    
    B --&gt; B5[&quot;函数&quot;]
    B5 --&gt; B5a[&quot;函数声明与定义&quot;]
    B5 --&gt; B5b[&quot;参数传递: 值, 引用&quot;]
    B5 --&gt; B5c[&quot;默认参数&quot;]
    B5 --&gt; B5d[&quot;函数重载&quot;]
    B5 --&gt; B5e[&quot;内联函数: inline&quot;]
    
    B --&gt; B6[&quot;指针与引用&quot;]
    B6 --&gt; B6a[&quot;指针: *&quot;]
    B6 --&gt; B6b[&quot;引用: &amp;amp;&quot;]
    B6 --&gt; B6c[&quot;空指针: NULL&quot;]
    
    B --&gt; B7[&quot;类与对象&quot;]
    B7 --&gt; B7a[&quot;类定义: class, struct&quot;]
    B7 --&gt; B7b[&quot;访问控制: public, private&quot;]
    B7 --&gt; B7c[&quot;构造函数与析构函数&quot;]
    B7 --&gt; B7d[&quot;拷贝构造函数&quot;]
    B7 --&gt; B7e[&quot;静态成员: static&quot;]
    B7 --&gt; B7f[&quot;友元: friend&quot;]
    B7 --&gt; B7g[&quot;继承&quot;]
    B7 --&gt; B7h[&quot;多态性: virtual, =0&quot;]
    
    B --&gt; B8[&quot;模板&quot;]
    B8 --&gt; B8a[&quot;函数模板&quot;]
    B8 --&gt; B8b[&quot;类模板&quot;]
    
    B --&gt; B9[&quot;异常处理&quot;]
    B9 --&gt; B9a[&quot;try, catch, throw&quot;]
    B9 --&gt; B9b[&quot;标准异常类&quot;]
    
    B --&gt; B10[&quot;命名空间&quot;]
    B10 --&gt; B10a[&quot;定义与使用&quot;]
    
    B --&gt; B11[&quot;动态内存管理&quot;]
    B11 --&gt; B11a[&quot;new, delete&quot;]
    
    B --&gt; B12[&quot;预处理器&quot;]
    B12 --&gt; B12a[&quot;宏定义: #define&quot;]
    B12 --&gt; B12b[&quot;条件编译: #ifdef&quot;]
    B12 --&gt; B12c[&quot;文件包含: #include&quot;]

    %% 2. 现代 C++ 新特性
    A --&gt; C[&quot;现代 C++ 新特性&quot;]
    
    C --&gt; C1[&quot;C++11&quot;]
    C1 --&gt; C1a[&quot;自动类型推导: auto, decltype&quot;]
    C1 --&gt; C1b[&quot;范围 for 循环&quot;]
    C1 --&gt; C1c[&quot;nullptr&quot;]
    C1 --&gt; C1d[&quot;智能指针: unique_ptr, shared_ptr&quot;]
    C1 --&gt; C1e[&quot;移动语义: &amp;amp;&amp;amp;, std::move&quot;]
    C1 --&gt; C1f[&quot;完美转发: std::forward&quot;]
    C1 --&gt; C1g[&quot;Lambda 表达式&quot;]
    C1 --&gt; C1h[&quot;模板改进: 可变参数模板&quot;]
    C1 --&gt; C1i[&quot;初始化改进: &#123;&#125;&quot;]
    C1 --&gt; C1j[&quot;并发支持: std::thread&quot;]
    C1 --&gt; C1k[&quot;新容器: array, unordered_map&quot;]
    C1 --&gt; C1l[&quot;constexpr, static_assert&quot;]
    
    C --&gt; C2[&quot;C++14&quot;]
    C2 --&gt; C2a[&quot;泛型 Lambda&quot;]
    C2 --&gt; C2b[&quot;返回类型推导: auto&quot;]
    C2 --&gt; C2c[&quot;constexpr 扩展&quot;]
    C2 --&gt; C2d[&quot;变量模板&quot;]
    
    C --&gt; C3[&quot;C++17&quot;]
    C3 --&gt; C3a[&quot;结构化绑定&quot;]
    C3 --&gt; C3b[&quot;if/switch 初始化&quot;]
    C3 --&gt; C3c[&quot;折叠表达式&quot;]
    C3 --&gt; C3d[&quot;std::optional, variant, any&quot;]
    C3 --&gt; C3e[&quot;文件系统库: std::filesystem&quot;]
    C3 --&gt; C3f[&quot;并行算法&quot;]
    
    C --&gt; C4[&quot;C++20&quot;]
    C4 --&gt; C4a[&quot;概念: Concepts&quot;]
    C4 --&gt; C4b[&quot;Ranges 库&quot;]
    C4 --&gt; C4c[&quot;协程: co_await, co_yield&quot;]
    C4 --&gt; C4d[&quot;模块: import&quot;]
    C4 --&gt; C4e[&quot;三路比较: &amp;lt;=&amp;gt;&quot;]
    C4 --&gt; C4f[&quot;consteval, constinit&quot;]
    C4 --&gt; C4g[&quot;std::span, bit_cast&quot;]

    %% 3. 其他特性
    A --&gt; D[&quot;其他特性&quot;]
    D --&gt; D1[&quot;标准库扩展&lt;br&gt;C++98+&quot;]
    D1 --&gt; D1a[&quot;STL: vector, map&quot;]
    D1 --&gt; D1b[&quot;输入输出: iostream&quot;]
    D1 --&gt; D1c[&quot;字符串: string, string_view&quot;]
    D1 --&gt; D1d[&quot;正则表达式: regex&quot;]
    
    D --&gt; D2[&quot;编译器特性&lt;br&gt;C++11+&quot;]
    D2 --&gt; D2a[&quot;属性: [[nodiscard]]&quot;]
    D2 --&gt; D2b[&quot;对齐控制: alignas&quot;]</code></pre>
<h1 id="详解">详解</h1>
<h2 id="基础语法特性c9803及之前"><strong>1.
基础语法特性（C++98/03及之前）</strong></h2>
<h3 id="基本数据类型"><strong>基本数据类型</strong></h3>
<p>C++
的基本数据类型是语言的核心，用于定义变量以存储不同种类的数据。这些类型的具体大小和范围依赖于编译器和硬件平台，但
C++ 标准提供了一些基本保证。以下是对每种数据类型的详细讲解。</p>
<h4 id="整型"><strong>整型</strong></h4>
<p>整型用于存储整数值，根据大小和符号性分为以下几种：</p>
<ul>
<li><strong><code>int</code></strong>
<ul>
<li><strong>功能</strong>：表示基本的整数类型，通常是平台上最自然的大小（一般
4 字节，32 位）。</li>
<li><strong>范围</strong>：有符号时，范围通常为
<code>-2,147,483,648</code> 到
<code>2,147,483,647</code>（<code>-2^31</code> 到
<code>2^31-1</code>）。</li>
<li><strong>使用场景</strong>：适用于大多数整数计算，如循环计数器、数组索引等。</li>
<li><strong>底层原理</strong>：存储为二进制补码形式，符号位决定正负。</li>
<li><strong>注意事项</strong>：溢出时行为未定义（例如
<code>INT_MAX + 1</code>）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;  <span class="comment">// 普通整数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int value: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// -2147483648</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2147483647</span></span><br><span class="line">    i = INT_MAX;  <span class="comment">// 使用 limits 中的宏定义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// i = i + 1;  // 未定义行为，溢出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>short</code></strong>
<ul>
<li><strong>功能</strong>：短整型，比 <code>int</code> 小，通常 2
字节（16 位）。</li>
<li><strong>范围</strong>：有符号时，范围为 <code>-32,768</code> 到
<code>32,767</code>（<code>-2^15</code> 到 <code>2^15-1</code>）。</li>
<li><strong>使用场景</strong>：适合存储较小的整数，节省内存，如小型计数器。</li>
<li><strong>底层原理</strong>：同样使用二进制补码表示。</li>
<li><strong>注意事项</strong>：范围较小，需注意溢出。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">short</span> s = <span class="number">32767</span>;  <span class="comment">// 短整型最大值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short value: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// -32768</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 32767</span></span><br><span class="line">    <span class="comment">// s = 32768;  // 溢出，未定义行为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>long</code></strong>
<ul>
<li><strong>功能</strong>：长整型，至少与 <code>int</code>
大小相同，通常 4 字节或 8 字节（视平台）。</li>
<li><strong>范围</strong>：32 位系统上有符号时为 <code>-2^31</code> 到
<code>2^31-1</code>，64 位系统上可能更大。</li>
<li><strong>使用场景</strong>：需要更大范围的整数，如文件大小。</li>
<li><strong>底层原理</strong>：补码表示，长度由编译器定义。</li>
<li><strong>注意事项</strong>：建议使用 <code>long long</code> 以确保 64
位支持。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> l = <span class="number">123456L</span>;  <span class="comment">// 长整型，带 L 后缀</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long value: &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>long long</code></strong>
<ul>
<li><strong>功能</strong>：超长整型，至少 8 字节（64 位），C++11
正式标准化。</li>
<li><strong>范围</strong>：有符号时为 <code>-2^63</code> 到
<code>2^63-1</code>（约 ±9.2×10^18）。</li>
<li><strong>使用场景</strong>：非常大的整数，如科学计算或时间戳。</li>
<li><strong>底层原理</strong>：补码表示，保证 64 位。</li>
<li><strong>注意事项</strong>：较老的编译器可能不支持。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ll = <span class="number">123456789LL</span>;  <span class="comment">// 超长整型，带 LL 后缀</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long value: &quot;</span> &lt;&lt; ll &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>unsigned</code> 修饰符</strong>
<ul>
<li><strong>功能</strong>：将整型变为无符号，范围从 0
开始，最大值翻倍。</li>
<li><strong>范围</strong>：如 <code>unsigned int</code> 为 0 到
<code>4,294,967,295</code>（2^32-1）。</li>
<li><strong>使用场景</strong>：非负数场景，如计数器、数组大小。</li>
<li><strong>底层原理</strong>：直接存储二进制值，无符号位。</li>
<li><strong>注意事项</strong>：与有符号类型混合运算需小心（如比较时可能出错）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ui = <span class="number">4294967295U</span>;  <span class="comment">// 无符号整数，带 U 后缀</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int value: &quot;</span> &lt;&lt; ui &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 4294967295</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="浮点型"><strong>浮点型</strong></h4>
<p>浮点型用于存储小数，基于 IEEE 754 标准。</p>
<ul>
<li><strong><code>float</code></strong>
<ul>
<li><strong>功能</strong>：单精度浮点数，4 字节，约 7 位有效数字。</li>
<li><strong>范围</strong>：大约 ±3.4×10^38，精度有限。</li>
<li><strong>使用场景</strong>：需要小数但精度要求不高的场景，如图形计算。</li>
<li><strong>底层原理</strong>：分为符号位、指数和尾数，遵循 IEEE
754。</li>
<li><strong>注意事项</strong>：浮点运算可能有精度误差（如 0.1 + 0.2 !=
0.3）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">3.14f</span>;  <span class="comment">// 单精度，带 f 后缀</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float value: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 最小正值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0.1 + 0.2: &quot;</span> &lt;&lt; (<span class="number">0.1f</span> + <span class="number">0.2f</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0.30000001（精度误差）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>double</code></strong>
<ul>
<li><strong>功能</strong>：双精度浮点数，8 字节，约 15 位有效数字。</li>
<li><strong>范围</strong>：大约 ±1.8×10^308，精度更高。</li>
<li><strong>使用场景</strong>：需要较高精度的浮点计算，如科学计算。</li>
<li><strong>底层原理</strong>：IEEE 754，双倍尾数位。</li>
<li><strong>注意事项</strong>：仍可能有精度误差，但比 <code>float</code>
小。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.1415926535</span>;  <span class="comment">// 双精度</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double value: &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>long double</code></strong>
<ul>
<li><strong>功能</strong>：扩展精度浮点数，大小和精度视平台而定（常 10
或 16 字节）。</li>
<li><strong>范围</strong>：通常比 <code>double</code>
大，精度更高。</li>
<li><strong>使用场景</strong>：需要极高精度的计算，如数学库。</li>
<li><strong>底层原理</strong>：依赖编译器实现，可能非 IEEE 754。</li>
<li><strong>注意事项</strong>：移植性差，不同平台行为不同。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.141592653589793238L</span>;  <span class="comment">// 扩展精度，带 L 后缀</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long double value: &quot;</span> &lt;&lt; ld &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long double min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">double</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long double max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">double</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="字符型"><strong>字符型</strong></h4>
<p>字符型用于存储单个字符或宽字符。</p>
<ul>
<li><strong><code>char</code></strong>
<ul>
<li><strong>功能</strong>：存储单字节字符，1 字节（8 位）。</li>
<li><strong>范围</strong>：有符号时 <code>-128</code> 到
<code>127</code>，无符号时 <code>0</code> 到 <code>255</code>。</li>
<li><strong>使用场景</strong>：表示 ASCII 字符，如字母、数字。</li>
<li><strong>底层原理</strong>：直接存储字符的编码值（如 ASCII）。</li>
<li><strong>注意事项</strong>：默认是否带符号由编译器决定。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;  <span class="comment">// ASCII 值为 65</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char: &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ASCII value: &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 65</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>wchar_t</code></strong>
<ul>
<li><strong>功能</strong>：宽字符，用于存储多字节字符（如
Unicode），大小视平台（常 2 或 4 字节）。</li>
<li><strong>范围</strong>：依赖实现，通常支持更大的字符集。</li>
<li><strong>使用场景</strong>：国际化程序中支持非 ASCII 字符。</li>
<li><strong>底层原理</strong>：存储 Unicode 或其他宽字符编码。</li>
<li><strong>注意事项</strong>：需要宽字符流（如
<code>wcout</code>）输出。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">wchar_t</span> wc = <span class="string">L&#x27;中&#x27;</span>;  <span class="comment">// 宽字符，带 L 前缀</span></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">&quot;wchar_t: &quot;</span> &lt;&lt; wc &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="布尔型"><strong>布尔型</strong></h4>
<ul>
<li><strong><code>bool</code></strong>
<ul>
<li><strong>功能</strong>：表示逻辑值 <code>true</code>（1）或
<code>false</code>（0），通常 1 字节。</li>
<li><strong>使用场景</strong>：条件判断、标志位。</li>
<li><strong>底层原理</strong>：存储为整数，0 表示假，非 0 表示真。</li>
<li><strong>注意事项</strong>：可以隐式转换为整数。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> b1 = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> b2 = <span class="literal">false</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;true: &quot;</span> &lt;&lt; b1 &lt;&lt; <span class="string">&quot;, false: &quot;</span> &lt;&lt; b2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1 0</span></span><br><span class="line">    <span class="type">int</span> i = b1;  <span class="comment">// 隐式转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h3 id="变量与常量"><strong>变量与常量</strong></h3>
<p>变量是程序中可修改的数据存储单元，常量则是不可修改的固定值。</p>
<ul>
<li><strong>变量</strong>
<ul>
<li><strong>功能</strong>：通过类型声明创建变量，可随时修改其值。</li>
<li><strong>使用场景</strong>：存储临时数据、计算中间结果。</li>
<li><strong>底层原理</strong>：分配内存空间，变量名映射到地址。</li>
<li><strong>注意事项</strong>：未初始化变量的值未定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;         <span class="comment">// 声明，未初始化</span></span><br><span class="line">    x = <span class="number">10</span>;        <span class="comment">// 赋值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    x = <span class="number">20</span>;        <span class="comment">// 修改</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>常量</strong>
<ul>
<li><strong>功能</strong>：使用 <code>const</code>
修饰，值在初始化后不可修改。</li>
<li><strong>使用场景</strong>：定义不变的值，如数学常数 PI。</li>
<li><strong>底层原理</strong>：编译器确保常量不可写，可能优化为内联值。</li>
<li><strong>注意事项</strong>：必须初始化，否则编译错误。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y = <span class="number">30</span>;  <span class="comment">// 常量，必须初始化</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 30</span></span><br><span class="line">    <span class="comment">// y = 40;  // 错误：常量不可修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h3 id="运算符"><strong>运算符</strong></h3>
<p>C++
提供了丰富的运算符，用于执行算术、逻辑、位操作等。以下逐一详细讲解。</p>
<h4 id="算术运算符"><strong>算术运算符</strong></h4>
<p>用于基本的数学运算。</p>
<ul>
<li><strong><code>+</code>（加法）</strong>
<ul>
<li><strong>功能</strong>：将两个操作数相加。</li>
<li><strong>使用场景</strong>：数值计算。</li>
<li><strong>注意事项</strong>：整数溢出未定义，浮点数可能有精度误差。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> sum = a + b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 3 = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>-</code>（减法）</strong>
<ul>
<li><strong>功能</strong>：从第一个操作数减去第二个。</li>
<li><strong>使用场景</strong>：计算差值。</li>
<li><strong>注意事项</strong>：同加法，注意溢出。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> diff = a - b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 - 3 = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>*</code>（乘法）</strong>
<ul>
<li><strong>功能</strong>：两个操作数相乘。</li>
<li><strong>使用场景</strong>：面积、体积计算等。</li>
<li><strong>注意事项</strong>：溢出风险更大。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> prod = a * b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 * 3 = &quot;</span> &lt;&lt; prod &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>/</code>（除法）</strong>
<ul>
<li><strong>功能</strong>：第一个操作数除以第二个。</li>
<li><strong>使用场景</strong>：平均值计算。</li>
<li><strong>注意事项</strong>：整数除法结果截断，除以 0 未定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> div = a / b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 / 3 = &quot;</span> &lt;&lt; div &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3（截断）</span></span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a) / b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10.0 / 3 = &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3.33333</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>%</code>（取模）</strong>
<ul>
<li><strong>功能</strong>：返回除法后的余数，仅适用于整数。</li>
<li><strong>使用场景</strong>：判断奇偶、循环计数。</li>
<li><strong>注意事项</strong>：除以 0 未定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> mod = a % b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 % 3 = &quot;</span> &lt;&lt; mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="关系运算符"><strong>关系运算符</strong></h4>
<p>用于比较两个值，返回布尔结果。</p>
<ul>
<li><strong><code>==</code>（等于）</strong>
<ul>
<li><strong>功能</strong>：检查两个操作数是否相等。</li>
<li><strong>使用场景</strong>：条件判断。</li>
<li><strong>注意事项</strong>：浮点数比较需注意精度。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">bool</span> eq = (a == b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 == 5: &quot;</span> &lt;&lt; eq &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>!=</code>（不等于）</strong>
<ul>
<li><strong>功能</strong>：检查两个操作数是否不相等。</li>
<li><strong>使用场景</strong>：排除特定值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">bool</span> neq = (a != b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 != 3: &quot;</span> &lt;&lt; neq &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&lt;</code>（小于）</strong>
<ul>
<li><strong>功能</strong>：检查第一个操作数是否小于第二个。</li>
<li><strong>使用场景</strong>：排序、循环条件。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">bool</span> lt = (a &lt; b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3 &lt; 5: &quot;</span> &lt;&lt; lt &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&gt;</code>（大于）</strong>
<ul>
<li><strong>功能</strong>：检查第一个操作数是否大于第二个。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">bool</span> gt = (a &gt; b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &gt; 3: &quot;</span> &lt;&lt; gt &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&lt;=</code>（小于等于）</strong>
<ul>
<li><strong>功能</strong>：检查第一个操作数是否小于或等于第二个。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">bool</span> le = (a &lt;= b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &lt;= 5: &quot;</span> &lt;&lt; le &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&gt;=</code>（大于等于）</strong>
<ul>
<li><strong>功能</strong>：检查第一个操作数是否大于或等于第二个。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">bool</span> ge = (a &gt;= b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &gt;= 3: &quot;</span> &lt;&lt; ge &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="逻辑运算符"><strong>逻辑运算符</strong></h4>
<p>用于组合布尔表达式。</p>
<ul>
<li><strong><code>&amp;&amp;</code>（与）</strong>
<ul>
<li><strong>功能</strong>：两个操作数都为真时返回真。</li>
<li><strong>使用场景</strong>：多条件判断。</li>
<li><strong>注意事项</strong>：短路求值（左边为假不计算右边）。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">true</span>, b = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> result = (a &amp;&amp; b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;true &amp;&amp; false: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>||</code>（或）</strong>
<ul>
<li><strong>功能</strong>：任一操作数为真时返回真。</li>
<li><strong>注意事项</strong>：短路求值（左边为真不计算右边）。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">true</span>, b = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> result = (a || b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;true || false: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>!</code>（非）</strong>
<ul>
<li><strong>功能</strong>：反转布尔值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> result = !a;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;!true: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="位运算符"><strong>位运算符</strong></h4>
<p>按位操作，直接操作二进制位。</p>
<ul>
<li><strong><code>&amp;</code>（按位与）</strong>
<ul>
<li><strong>功能</strong>：逐位进行与运算。</li>
<li><strong>使用场景</strong>：提取特定位、掩码操作。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 0011</span></span><br><span class="line">    <span class="type">int</span> result = a &amp; b;  <span class="comment">// 0001</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &amp; 3 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>|</code>（按位或）</strong>
<ul>
<li><strong>功能</strong>：逐位进行或运算。</li>
<li><strong>使用场景</strong>：设置特定位。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 0011</span></span><br><span class="line">    <span class="type">int</span> result = a | b;  <span class="comment">// 0111</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 | 3 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>^</code>（按位异或）</strong>
<ul>
<li><strong>功能</strong>：逐位异或，相同为 0，不同为 1。</li>
<li><strong>使用场景</strong>：交换值、检测差异。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 0011</span></span><br><span class="line">    <span class="type">int</span> result = a ^ b;  <span class="comment">// 0110</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 ^ 3 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>~</code>（按位取反）</strong>
<ul>
<li><strong>功能</strong>：将所有位取反。</li>
<li><strong>注意事项</strong>：结果为补码形式。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> result = ~a;  <span class="comment">// 1010（补码表示为 -6）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~5 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// -6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&lt;&lt;</code>（左移）</strong>
<ul>
<li><strong>功能</strong>：将位向左移动，低位补 0。</li>
<li><strong>使用场景</strong>：快速乘以 2 的幂。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> result = a &lt;&lt; <span class="number">1</span>;  <span class="comment">// 1010</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &lt;&lt; 1 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&gt;&gt;</code>（右移）</strong>
<ul>
<li><strong>功能</strong>：将位向右移动，符号位决定高位补 0 或 1。</li>
<li><strong>使用场景</strong>：快速除以 2 的幂。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> result = a &gt;&gt; <span class="number">1</span>;  <span class="comment">// 0010</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &gt;&gt; 1 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="赋值运算符"><strong>赋值运算符</strong></h4>
<p>用于修改变量值。</p>
<ul>
<li><strong><code>=</code>（赋值）</strong>
<ul>
<li><strong>功能</strong>：将右值赋给左值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>+=</code>（加赋值）</strong>
<ul>
<li><strong>功能</strong>：加后赋值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a += <span class="number">5</span>;  <span class="comment">// a = a + 5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a += 5: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>-=</code>（减赋值）</strong>
<ul>
<li><strong>功能</strong>：减后赋值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a -= <span class="number">3</span>;  <span class="comment">// a = a - 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a -= 3: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>其他赋值运算符</strong>（<code>*=</code>、<code>/=</code>、<code>%=</code>
等类似）
<ul>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a *= <span class="number">2</span>;  <span class="comment">// a = a * 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a *= 2: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="其他运算符"><strong>其他运算符</strong></h4>
<p>一些特殊运算符。</p>
<ul>
<li><strong><code>sizeof</code></strong>
<ul>
<li><strong>功能</strong>：返回类型或变量的字节大小。</li>
<li><strong>使用场景</strong>：内存分配、调试。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(int): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 通常 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(x): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>typeid</code></strong>
<ul>
<li><strong>功能</strong>：返回类型信息，需包含
<code>&lt;typeinfo&gt;</code>。</li>
<li><strong>使用场景</strong>：运行时类型检查。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Type of x: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// &quot;i&quot; (int)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>dynamic_cast</code></strong>
<ul>
<li><strong>功能</strong>：运行时类型转换，用于多态类型。</li>
<li><strong>使用场景</strong>：安全的向下转型。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b);</span><br><span class="line">    <span class="keyword">if</span> (d) std::cout &lt;&lt; <span class="string">&quot;Cast successful\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h3 id="控制结构"><strong>控制结构</strong></h3>
<p>控制结构用于管理程序的执行流程。</p>
<h4 id="条件语句"><strong>条件语句</strong></h4>
<ul>
<li><strong><code>if</code>、<code>else if</code>、<code>else</code></strong>
<ul>
<li><strong>功能</strong>：根据条件执行不同代码块。</li>
<li><strong>使用场景</strong>：分支逻辑。</li>
<li><strong>底层原理</strong>：条件表达式求值为真（非 0）时执行。</li>
<li><strong>注意事项</strong>：避免悬垂 else 问题。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Positive\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Zero\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Negative\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="开关语句"><strong>开关语句</strong></h4>
<ul>
<li><strong><code>switch</code>、<code>case</code>、<code>default</code></strong>
<ul>
<li><strong>功能</strong>：根据整数值跳转到对应分支。</li>
<li><strong>使用场景</strong>：多条件选择。</li>
<li><strong>底层原理</strong>：编译为跳转表或条件分支。</li>
<li><strong>注意事项</strong>：需要
<code>break</code>，否则会贯穿。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: std::cout &lt;&lt; <span class="string">&quot;One\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: std::cout &lt;&lt; <span class="string">&quot;Two\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: std::cout &lt;&lt; <span class="string">&quot;Other\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="循环"><strong>循环</strong></h4>
<ul>
<li><strong><code>for</code></strong>
<ul>
<li><strong>功能</strong>：固定次数循环，包含初始化、条件和增量。</li>
<li><strong>使用场景</strong>：数组遍历、计数。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>while</code></strong>
<ul>
<li><strong>功能</strong>：条件为真时重复执行。</li>
<li><strong>使用场景</strong>：不确定次数的循环。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>do-while</code></strong>
<ul>
<li><strong>功能</strong>：至少执行一次，后检查条件。</li>
<li><strong>使用场景</strong>：需要至少运行一次的循环。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="跳转"><strong>跳转</strong></h4>
<ul>
<li><strong><code>break</code></strong>
<ul>
<li><strong>功能</strong>：跳出当前循环或 switch。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>continue</code></strong>
<ul>
<li><strong>功能</strong>：跳过本次循环，继续下一次。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 3 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>return</code></strong>
<ul>
<li><strong>功能</strong>：退出函数并返回值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// 返回并退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>goto</code></strong>
<ul>
<li><strong>功能</strong>：跳转到指定标签。</li>
<li><strong>使用场景</strong>：复杂控制流（不推荐）。</li>
<li><strong>注意事项</strong>：易导致代码混乱。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> label;</span><br><span class="line">    x = <span class="number">1</span>;  <span class="comment">// 被跳过</span></span><br><span class="line">label:</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h3 id="函数"><strong>函数</strong></h3>
<p>函数是可重用的代码块，支持多种特性。</p>
<ul>
<li><p><strong>函数声明与定义</strong></p>
<ul>
<li><strong>功能</strong>：声明指定函数签名，定义实现具体逻辑。</li>
<li><strong>使用场景</strong>：模块化编程。</li>
<li><strong>底层原理</strong>：声明生成符号，定义分配代码段。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;  <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;  <span class="comment">// 定义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function called\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>参数传递</strong></p>
<ul>
<li><strong>值传递</strong>：传递副本，修改不影响原值。
<ul>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">byValue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; x = <span class="number">20</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">byValue</span>(a);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>引用传递</strong>：传递别名，修改影响原值。
<ul>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">byReference</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; x = <span class="number">20</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">byReference</span>(a);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p><strong>默认参数</strong></p>
<ul>
<li><strong>功能</strong>：为参数提供默认值，未传参时使用。</li>
<li><strong>注意事项</strong>：默认参数必须从右向左定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>, <span class="type">int</span> y = <span class="number">20</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();      <span class="comment">// 10, 20</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>);     <span class="comment">// 5, 20</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>, <span class="number">15</span>); <span class="comment">// 5, 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>函数重载</strong></p>
<ul>
<li><strong>功能</strong>：同名函数根据参数不同区分。</li>
<li><strong>底层原理</strong>：编译器通过名字修饰区分。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.5</span>, <span class="number">2.5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>内联函数</strong></p>
<ul>
<li><strong>功能</strong>：使用 <code>inline</code>
建议编译器内联展开，减少调用开销。</li>
<li><strong>使用场景</strong>：小型函数提升性能。</li>
<li><strong>注意事项</strong>：仅建议，编译器可能忽略。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">square</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h3 id="指针">指针</h3>
<p>C++
中的指针（Pointer）是一个非常核心且强大的概念，它允许直接操作内存地址。理解指针对于编写高效的
C++
程序、动态内存管理以及底层操作至关重要。下面我会从基础到进阶，详细讲解
C++ 指针的方方面面。</p>
<hr />
<h4 id="什么是指针">1. <strong>什么是指针？</strong></h4>
<ul>
<li><strong>定义</strong>：指针是一个变量，它存储的是另一个变量的内存地址。</li>
<li><strong>内存地址</strong>：在计算机中，每个变量都有一个内存地址，指针通过存储这个地址来间接访问变量。</li>
<li><strong>用途</strong>：
<ul>
<li>动态内存分配（new/delete）。</li>
<li>数组操作。</li>
<li>函数参数传递（避免拷贝大对象）。</li>
<li>实现数据结构（如链表、树）。</li>
</ul></li>
</ul>
<h5 id="指针的声明"><strong>指针的声明</strong></h5>
<p>指针通过 <code>*</code> 符号声明，格式为： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型 *指针名;</span><br></pre></td></tr></table></figure> -
<code>类型</code>：指针指向的数据类型。 -
<code>*</code>：表示这是一个指针。</p>
<p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptr; <span class="comment">// 声明一个指向 int 类型的指针</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="指针的基本操作">2. <strong>指针的基本操作</strong></h4>
<h5 id="获取变量地址"><strong>（1）获取变量地址</strong></h5>
<p>使用 <code>&amp;</code> 操作符获取变量的地址： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;x; <span class="comment">// ptr 存储 x 的地址</span></span><br></pre></td></tr></table></figure> -
<code>&amp;x</code>：获取变量 <code>x</code> 的内存地址。 -
<code>ptr</code>：存储 <code>x</code> 的地址。</p>
<h5
id="解引用访问指针指向的值"><strong>（2）解引用（访问指针指向的值）</strong></h5>
<p>使用 <code>*</code> 操作符访问指针指向的值： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x 的值: &quot;</span> &lt;&lt; x &lt;&lt; endl;         <span class="comment">// 输出: 10</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x 的地址: &quot;</span> &lt;&lt; &amp;x &lt;&lt; endl;      <span class="comment">// 输出: x 的地址（例如 0x7ffee4c0a4ac）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 存储的地址: &quot;</span> &lt;&lt; ptr &lt;&lt; endl; <span class="comment">// 输出: x 的地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 指向的值: &quot;</span> &lt;&lt; *ptr &lt;&lt; endl; <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改指针指向的值</span></span><br><span class="line">    *ptr = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;修改后 x 的值: &quot;</span> &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> -
<code>*ptr</code>：解引用，获取指针 <code>ptr</code> 指向的值。 - 修改
<code>*ptr</code> 会直接改变 <code>x</code>
的值，因为它们指向同一块内存。</p>
<h5 id="指针的初始化"><strong>（3）指针的初始化</strong></h5>
<p>未初始化的指针是危险的（野指针），可能指向随机内存。建议总是初始化指针：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">nullptr</span>; <span class="comment">// C++11 推荐，初始化为空指针</span></span><br></pre></td></tr></table></figure> - <code>nullptr</code>
表示指针不指向任何地址，避免野指针问题。</p>
<hr />
<h4 id="指针与数组">3. <strong>指针与数组</strong></h4>
<p>在 C++ 中，数组名本质上是一个指向数组第一个元素的指针。</p>
<h5 id="数组与指针的关系"><strong>数组与指针的关系</strong></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr = arr; <span class="comment">// arr 是一个指针，指向数组第一个元素</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数组第一个元素: &quot;</span> &lt;&lt; *ptr &lt;&lt; endl;        <span class="comment">// 输出: 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数组第二个元素: &quot;</span> &lt;&lt; *(ptr + <span class="number">1</span>) &lt;&lt; endl;  <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指针遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *(ptr + i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>arr</code> 等价于 <code>&amp;arr[0]</code>，是一个指针。</li>
<li><code>ptr + 1</code>：指针加 1，移动到下一个元素（偏移一个
<code>int</code> 的大小，通常是 4 字节）。</li>
<li><code>*(ptr + i)</code>：访问第 <code>i</code> 个元素。</li>
</ul>
<h5 id="数组下标与指针"><strong>数组下标与指针</strong></h5>
<p>数组下标操作 <code>arr[i]</code> 等价于 <code>*(arr + i)</code>：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">cout &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl;      <span class="comment">// 输出: 3</span></span><br><span class="line">cout &lt;&lt; *(arr + <span class="number">2</span>) &lt;&lt; endl;  <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="动态内存分配">4. <strong>动态内存分配</strong></h4>
<p>C++ 中可以使用 <code>new</code> 和 <code>delete</code>
动态分配和释放内存，指针是动态内存管理的核心。</p>
<h5 id="动态分配内存"><strong>动态分配内存</strong></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 分配一个 int 大小的内存</span></span><br><span class="line">*ptr = <span class="number">42</span>;</span><br><span class="line">cout &lt;&lt; *ptr &lt;&lt; endl; <span class="comment">// 输出: 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// 释放内存</span></span><br><span class="line">ptr = <span class="literal">nullptr</span>; <span class="comment">// 避免野指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>new</code>：分配内存并返回地址。</li>
<li><code>delete</code>：释放内存，避免内存泄漏。</li>
</ul>
<h5 id="动态分配数组"><strong>动态分配数组</strong></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 分配一个包含 5 个 int 的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; endl; <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] arr; <span class="comment">// 释放数组内存</span></span><br><span class="line">arr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>new int[5]</code>：分配数组。</li>
<li><code>delete[]</code>：释放数组内存（注意与 <code>delete</code>
的区别）。</li>
</ul>
<hr />
<h4 id="指针与函数">5. <strong>指针与函数</strong></h4>
<p>指针常用于函数参数传递，特别是在需要修改原始数据或避免拷贝大对象时。</p>
<h5 id="通过指针修改变量"><strong>（1）通过指针修改变量</strong></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(&amp;x, &amp;y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Before swap: x = 10, y = 20</span><br><span class="line">After swap: x = 20, y = 10</span><br></pre></td></tr></table></figure></li>
<li>传递地址给函数，通过解引用修改原始变量。</li>
</ul>
<h5
id="指针作为函数返回值"><strong>（2）指针作为函数返回值</strong></h5>
<p>函数可以返回指针，但需要小心返回局部变量的地址（会导致未定义行为）：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">createArray</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="built_in">createArray</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl; <span class="comment">// 输出: 0 1 2 3 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 返回动态分配的内存，调用者负责释放。</p>
<h5
id="避免返回局部变量地址"><strong>（3）避免返回局部变量地址</strong></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">badFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;x; <span class="comment">// 错误！x 是局部变量，函数返回后 x 被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>局部变量的地址在函数返回后无效，访问会导致未定义行为。</li>
</ul>
<hr />
<h4 id="指针的进阶用法">6. <strong>指针的进阶用法</strong></h4>
<h5
id="指针的指针多级指针"><strong>（1）指针的指针（多级指针）</strong></h5>
<p>指针可以指向另一个指针，形成多级指针： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;x;</span><br><span class="line"><span class="type">int</span> **pptr = &amp;ptr; <span class="comment">// 指向指针的指针</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; **pptr &lt;&lt; endl; <span class="comment">// 输出: 10</span></span><br></pre></td></tr></table></figure> -
<code>**pptr</code>：解引用两次，访问 <code>x</code> 的值。</p>
<h5
id="常量指针与指针常量"><strong>（2）常量指针与指针常量</strong></h5>
<ul>
<li><strong>常量指针</strong>（<code>const int *ptr</code>）：指针指向的值是常量，不能修改。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;x;</span><br><span class="line"><span class="comment">// *ptr = 20; // 错误，不能修改值</span></span><br></pre></td></tr></table></figure></li>
<li><strong>指针常量</strong>（<code>int *const ptr</code>）：指针本身是常量，不能指向其他地址。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 可以修改值</span></span><br><span class="line"><span class="comment">// ptr = nullptr; // 错误，不能修改指针地址</span></span><br></pre></td></tr></table></figure></li>
<li><strong>常量指针常量</strong>（<code>const int *const ptr</code>）：既不能修改值，也不能修改地址。</li>
</ul>
<h5 id="函数指针"><strong>（3）函数指针</strong></h5>
<p>函数指针指向函数的地址，用于回调或动态调用： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*funcPtr)() = sayHello; <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="built_in">funcPtr</span>(); <span class="comment">// 调用函数，输出: Hello!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="常见问题与注意事项">7. <strong>常见问题与注意事项</strong></h4>
<ul>
<li><strong>野指针</strong>：未初始化或已释放的指针，访问会导致未定义行为。
<ul>
<li>解决：始终初始化指针，释放后置为 <code>nullptr</code>。</li>
</ul></li>
<li><strong>内存泄漏</strong>：动态分配的内存未释放。
<ul>
<li>解决：使用 <code>delete</code> 释放内存，或者使用智能指针（如
<code>std::unique_ptr</code>、<code>std::shared_ptr</code>）。</li>
</ul></li>
<li><strong>悬空指针</strong>：指针指向的内存已被释放。
<ul>
<li>解决：释放后立即置为 <code>nullptr</code>。</li>
</ul></li>
<li><strong>指针越界</strong>：访问数组时超出范围。
<ul>
<li>解决：确保指针操作不越界，使用 <code>std::vector</code>
等容器更安全。</li>
</ul></li>
</ul>
<hr />
<h4 id="智能指针c11-及以上">8. <strong>智能指针（C++11
及以上）</strong></h4>
<p>C++11 引入了智能指针，简化了内存管理，推荐使用： -
<strong><code>std::unique_ptr</code></strong>：独占所有权，自动释放。 -
<strong><code>std::shared_ptr</code></strong>：共享所有权，引用计数。 -
<strong><code>std::weak_ptr</code></strong>：解决
<code>shared_ptr</code> 循环引用问题。</p>
<p><strong>示例：使用 <code>std::unique_ptr</code></strong>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; *ptr &lt;&lt; endl; <span class="comment">// 输出: 42</span></span><br><span class="line">    <span class="comment">// 离开作用域时，ptr 自动释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结">9. <strong>总结</strong></h4>
<ul>
<li><strong>指针基础</strong>：存储地址，使用 <code>*</code>
解引用，<code>&amp;</code> 取地址。</li>
<li><strong>指针与数组</strong>：数组名是指针，指针可以遍历数组。</li>
<li><strong>动态内存</strong>：使用 <code>new</code>
分配，<code>delete</code> 释放。</li>
<li><strong>函数指针</strong>：传递地址，避免拷贝或实现回调。</li>
<li><strong>注意事项</strong>：避免野指针、内存泄漏，使用智能指针更安全。</li>
</ul>
<h3 id="引用"><strong>引用</strong></h3>
<p>C++
中的引用（Reference）是一种非常重要的特性，它为变量提供了一个别名（alias），允许通过这个别名直接访问和操作原始变量。引用在
C++ 中广泛用于函数参数传递、避免拷贝开销、以及简化代码。以下我会详细讲解
C++ 引用的概念、用法、特点以及与指针的对比。</p>
<hr />
<h4 id="什么是引用">1. <strong>什么是引用？</strong></h4>
<ul>
<li><strong>定义</strong>：引用是某个变量的别名，操作引用等价于操作原始变量。</li>
<li><strong>语法</strong>：通过 <code>&amp;</code> 符号声明引用。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型 &amp;引用名 = 变量名;</span><br></pre></td></tr></table></figure></li>
<li><strong>本质</strong>：引用并不是一个独立的变量，它只是已有变量的别名，编译器会将对引用的操作直接映射到原始变量上。</li>
</ul>
<h5 id="基本示例"><strong>基本示例</strong></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;ref = x; <span class="comment">// ref 是 x 的引用</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;     <span class="comment">// 输出: 10</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl; <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    ref = <span class="number">20</span>; <span class="comment">// 修改引用，实际修改 x</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;     <span class="comment">// 输出: 20</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int &amp;ref = x</code>：<code>ref</code> 是 <code>x</code>
的引用。</li>
<li>修改 <code>ref</code> 会直接修改
<code>x</code>，因为它们指向同一个内存地址。</li>
</ul>
<hr />
<h4 id="引用的特点">2. <strong>引用的特点</strong></h4>
<h5 id="必须初始化"><strong>（1）必须初始化</strong></h5>
<p>引用在声明时必须初始化，且不能改变指向（不能重新绑定到另一个变量）。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// int &amp;ref; // 错误！引用必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;ref = x;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">ref = y; <span class="comment">// 不是让 ref 指向 y，而是将 y 的值赋给 ref（即 x）</span></span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl; <span class="comment">// 输出: 20</span></span><br></pre></td></tr></table></figure> - <code>ref = y</code>：将 <code>y</code> 的值赋给
<code>x</code>，而不是让 <code>ref</code> 指向 <code>y</code>。</p>
<h5 id="引用不是独立对象"><strong>（2）引用不是独立对象</strong></h5>
<p>引用不占用额外的内存，它只是变量的别名。<code>ref</code> 和
<code>x</code> 的地址相同： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; &amp;x &lt;&lt; endl;   <span class="comment">// 输出: x 的地址</span></span><br><span class="line">cout &lt;&lt; &amp;ref &lt;&lt; endl; <span class="comment">// 输出: 同一个地址</span></span><br></pre></td></tr></table></figure></p>
<h5
id="不能创建引用的引用"><strong>（3）不能创建引用的引用</strong></h5>
<p>引用本身不是对象，因此不能创建引用的引用： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = x;</span><br><span class="line"><span class="comment">// int &amp;&amp;ref2 = ref; // 错误！不能创建引用的引用</span></span><br></pre></td></tr></table></figure> -
注：<code>&amp;&amp;</code> 在 C++11 中表示右值引用（稍后会讲到）。</p>
<h5
id="不能创建数组的引用"><strong>（4）不能创建数组的引用</strong></h5>
<p>数组的引用是合法的，但不能创建引用的数组： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (&amp;refArr)[<span class="number">3</span>] = arr; <span class="comment">// 合法，引用一个数组</span></span><br><span class="line"><span class="comment">// int &amp;refArr[3] = arr; // 错误，不能创建引用的数组</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="引用的主要用途">3. <strong>引用的主要用途</strong></h4>
<h5 id="函数参数传递"><strong>（1）函数参数传递</strong></h5>
<p>引用常用于函数参数，避免拷贝大对象，提高效率。</p>
<p><strong>示例：按值传递 vs 按引用传递</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值传递（会拷贝）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapByValue</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按引用传递（直接操作原始变量）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapByReference</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swapByValue: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swapByValue</span>(x, y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swapByValue: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swapByReference: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swapByReference</span>(x, y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swapByReference: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 输出：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Before swapByValue: x = 10, y = 20</span><br><span class="line">After swapByValue: x = 10, y = 20</span><br><span class="line">Before swapByReference: x = 10, y = 20</span><br><span class="line">After swapByReference: x = 20, y = 10</span><br></pre></td></tr></table></figure> -
<code>swapByValue</code>：值传递，函数内的修改不影响原始变量。 -
<code>swapByReference</code>：引用传递，函数内的修改直接影响原始变量。</p>
<p><strong>效率优势</strong>：
对于大对象（如结构体、类对象），引用传递避免了拷贝开销：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printByValue</span><span class="params">(string s)</span> </span>&#123; <span class="comment">// 拷贝字符串，效率低</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printByReference</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123; <span class="comment">// 引用传递，无拷贝</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="函数返回值"><strong>（2）函数返回值</strong></h5>
<p>引用可以作为函数返回值，避免拷贝大对象： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index]; <span class="comment">// 返回数组元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">getElement</span>(arr, <span class="number">2</span>) = <span class="number">10</span>; <span class="comment">// 修改 arr[2]</span></span><br><span class="line">    cout &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl;  <span class="comment">// 输出: 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> -
返回引用允许直接修改数组元素。</p>
<p><strong>注意</strong>：不要返回局部变量的引用： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">badFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 错误！x 是局部变量，函数返回后 x 被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="简化代码"><strong>（3）简化代码</strong></h5>
<p>引用可以让代码更简洁，避免频繁使用指针和解引用： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = x;</span><br><span class="line">ref++; <span class="comment">// 直接操作引用，等价于 x++</span></span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl; <span class="comment">// 输出: 11</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="常量引用const-reference">4. <strong>常量引用（const
Reference）</strong></h4>
<p>常量引用常用于函数参数，防止意外修改原始数据，同时允许传递临时对象。</p>
<h5 id="基本用法"><strong>基本用法</strong></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref = x; <span class="comment">// 常量引用</span></span><br><span class="line"><span class="comment">// ref = 20; // 错误！不能通过常量引用修改 x</span></span><br></pre></td></tr></table></figure>
<h5 id="常量引用与临时对象"><strong>常量引用与临时对象</strong></h5>
<p>常量引用可以绑定到临时对象，而普通引用不行： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref = x + <span class="number">1</span>; <span class="comment">// 合法，绑定到临时对象</span></span><br><span class="line"><span class="comment">// int &amp;ref2 = x + 1; // 错误，非 const 引用不能绑定临时对象</span></span><br></pre></td></tr></table></figure></p>
<h5 id="函数参数中的常量引用"><strong>函数参数中的常量引用</strong></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;value)</span> </span>&#123; <span class="comment">// 常量引用，避免拷贝且防止修改</span></span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">print</span>(x);      <span class="comment">// 传递变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">20</span>);     <span class="comment">// 传递临时对象</span></span><br><span class="line">    <span class="built_in">print</span>(x + <span class="number">30</span>); <span class="comment">// 传递表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const int &amp;value</code>：既避免拷贝，又允许传递临时对象。</li>
</ul>
<hr />
<h4 id="c11-引入的右值引用rvalue-reference">5. <strong>C++11
引入的右值引用（Rvalue Reference）</strong></h4>
<p>C++11
引入了右值引用（<code>&amp;&amp;</code>），用于支持移动语义和完美转发，优化性能。</p>
<p><strong>左值与右值</strong></p>
<ul>
<li><strong>左值</strong>（Lvalue）：有固定内存地址，可以取地址的对象（比如变量）。</li>
<li><strong>右值</strong>（Rvalue）：临时对象或字面量，没有固定地址（比如
<code>x + 1</code>、字面量 <code>42</code>）。</li>
</ul>
<p><strong>右值引用</strong></p>
<p>右值引用可以绑定到右值，用于实现移动语义（避免拷贝）： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> &amp;lvalue)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;左值: &quot;</span> &lt;&lt; lvalue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> &amp;&amp;rvalue)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;右值: &quot;</span> &lt;&lt; rvalue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">print</span>(x);      <span class="comment">// 调用左值版本</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">20</span>);     <span class="comment">// 调用右值版本</span></span><br><span class="line">    <span class="built_in">print</span>(x + <span class="number">30</span>); <span class="comment">// 调用右值版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
- 输出： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左值: 10</span><br><span class="line">右值: 20</span><br><span class="line">右值: 40</span><br></pre></td></tr></table></figure></p>
<p><strong>移动语义</strong></p>
<p>右值引用常用于移动构造和移动赋值，避免深拷贝： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 转移资源</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;析构: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString s2 = <span class="built_in">move</span>(s1); <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> -
输出： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造: Hello</span><br><span class="line">移动构造</span><br><span class="line">析构: Hello</span><br></pre></td></tr></table></figure> - <code>move</code>：将 <code>s1</code>
转换为右值，触发移动构造，避免拷贝。</p>
<h5 id="移动构造函数和移动语义">移动构造函数和移动语义</h5>
<p>这段代码展示了 C++11
引入的右值引用和移动语义，用于优化资源管理，避免不必要的拷贝。</p>
<hr />
<ol type="1">
<li><strong>代码整体结构</strong></li>
</ol>
<ul>
<li><p><strong>头文件</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;iostream&gt;</code>：用于输入输出（<code>cout</code>）。</li>
<li><code>&lt;string&gt;</code>：虽然代码中没有直接使用
<code>std::string</code>，但可能是为了后续扩展。</li>
<li><code>using namespace std;</code>：避免每次使用
<code>std::cout</code> 时写 <code>std::</code>。</li>
</ul></li>
<li><p><strong>类 <code>MyString</code></strong>：</p>
<ul>
<li>这是一个自定义字符串类，内部使用 <code>char*</code>
管理动态分配的字符数组。</li>
<li>包含构造函数、移动构造函数和析构函数。</li>
</ul></li>
<li><p><strong>主函数 <code>main</code></strong>：</p>
<ul>
<li>创建一个 <code>MyString</code> 对象 <code>s1</code>，然后通过
<code>move</code> 将其资源移动到 <code>s2</code>。</li>
</ul></li>
</ul>
<hr />
<ol start="2" type="1">
<li><strong>逐部分分析</strong></li>
</ol>
<p><strong>（1）类 <code>MyString</code> 的定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 转移资源</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;析构: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>成员变量</strong></p>
<ul>
<li><code>char *data</code>：一个指针，指向动态分配的字符数组，用于存储字符串。</li>
</ul>
<p><strong>构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：从一个 C
风格字符串（<code>const char*</code>）构造 <code>MyString</code>
对象。</li>
<li><strong>细节</strong>：
<ul>
<li><code>strlen(str) + 1</code>：计算字符串长度（包括结尾的
<code>\0</code>）。</li>
<li><code>new char[strlen(str) + 1]</code>：动态分配内存，存储字符串。</li>
<li><code>strcpy(data, str)</code>：将输入字符串复制到 <code>data</code>
中。</li>
<li><code>cout &lt;&lt; "构造: " &lt;&lt; data &lt;&lt; endl</code>：打印构造信息。</li>
</ul></li>
</ul>
<p><strong>移动构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MyString</span>(MyString &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">    other.data = <span class="literal">nullptr</span>; <span class="comment">// 转移资源</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：这是 C++11
引入的移动构造函数，用于从一个右值（临时对象或被 <code>move</code>
的对象）转移资源。</li>
<li><strong>参数</strong>：
<ul>
<li><code>MyString &amp;&amp;other</code>：右值引用，表示
<code>other</code> 是一个右值（临时对象或即将销毁的对象）。</li>
</ul></li>
<li><strong>细节</strong>：
<ul>
<li><code>: data(other.data)</code>：初始化列表，将 <code>other</code>
的 <code>data</code> 指针直接赋值给当前对象的 <code>data</code>。</li>
<li><code>other.data = nullptr</code>：将 <code>other</code> 的
<code>data</code> 置为空，避免 <code>other</code>
析构时释放同一块内存。</li>
<li><code>noexcept</code>：表示这个函数不会抛出异常，移动构造函数通常需要是
<code>noexcept</code> 的，以便在标准库（如
<code>std::vector</code>）中使用时更安全。</li>
<li><code>cout &lt;&lt; "移动构造" &lt;&lt; endl</code>：打印移动构造信息。</li>
</ul></li>
</ul>
<p><strong>析构函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：在对象销毁时释放动态分配的内存。</li>
<li><strong>细节</strong>：
<ul>
<li><code>if (data)</code>：检查 <code>data</code>
是否为空指针（避免释放空指针）。</li>
<li><code>cout &lt;&lt; "析构: " &lt;&lt; data &lt;&lt; endl</code>：打印析构信息。</li>
<li><code>delete[] data</code>：释放 <code>data</code> 指向的内存。</li>
</ul></li>
</ul>
<p><strong>（2）主函数 <code>main</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString s2 = <span class="built_in">move</span>(s1); <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一行：创建 <code>s1</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>调用普通构造函数，构造一个 <code>MyString</code> 对象
<code>s1</code>。</p></li>
<li><p>内部：</p>
<ul>
<li><p>分配内存，存储字符串 “Hello”。</p></li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造: Hello</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p><strong>第二行：创建 <code>s2</code> 并移动
<code>s1</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyString s2 = <span class="built_in">move</span>(s1); <span class="comment">// 移动构造</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>作用</strong>：通过 <code>std::move</code> 将
<code>s1</code> 转换为右值，触发移动构造函数。</p></li>
<li><p><strong>细节</strong>：</p>
<ul>
<li><p><code>std::move(s1)</code>：将 <code>s1</code> 标记为右值（尽管
<code>s1</code> 是一个左值），告诉编译器可以“偷”它的资源。</p></li>
<li><p>调用移动构造函数：</p>
<ul>
<li><code>s2</code> 的 <code>data</code> 接管 <code>s1</code> 的
<code>data</code>（指向 “Hello” 的内存）。</li>
<li><code>s1</code> 的 <code>data</code> 被置为
<code>nullptr</code>。</li>
</ul></li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">移动构造</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p><strong>程序结束：析构</strong></p>
<ul>
<li><p><code>main</code> 函数结束时，<code>s1</code> 和 <code>s2</code>
离开作用域，调用析构函数。</p></li>
<li><p><code>s2</code> 的 <code>data</code> 指向 “Hello”，正常析构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">析构: Hello</span><br></pre></td></tr></table></figure></li>
<li><p><code>s1</code> 的 <code>data</code> 是
<code>nullptr</code>，不会释放内存（避免重复释放）。</p></li>
</ul>
<p><strong>完整输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造: Hello</span><br><span class="line">移动构造</span><br><span class="line">析构: Hello</span><br></pre></td></tr></table></figure>
<hr />
<ol start="3" type="1">
<li><strong>为什么需要移动构造函数？</strong></li>
</ol>
<p><strong>（1）问题：拷贝的开销</strong></p>
<p>如果没有移动构造函数，<code>MyString s2 = s1</code>
会调用拷贝构造函数（这里没有定义，默认会执行深拷贝）：</p>
<ul>
<li>深拷贝会重新分配内存，复制 “Hello”，然后 <code>s1</code> 和
<code>s2</code> 各自管理自己的内存。</li>
<li>问题：如果 <code>s1</code>
即将销毁（比如临时对象），这种拷贝是浪费的。</li>
</ul>
<p><strong>（2）移动语义的优势</strong></p>
<ul>
<li>移动构造函数通过“偷”资源（将 <code>s1</code> 的 <code>data</code>
直接给 <code>s2</code>），避免了深拷贝。</li>
<li><code>s1</code> 的 <code>data</code> 被置为
<code>nullptr</code>，确保它不会重复释放内存。</li>
<li><strong>效率</strong>：移动操作（指针赋值）比拷贝（内存分配和复制）快得多。</li>
</ul>
<p><strong>（3）<code>std::move</code> 的作用</strong></p>
<ul>
<li><code>std::move</code>
并不真正“移动”数据，它只是将对象转换为右值，告诉编译器可以调用移动构造函数。</li>
<li>移动后，<code>s1</code> 进入“可销毁”状态（<code>data</code> 为
<code>nullptr</code>），但仍然可以安全析构。</li>
</ul>
<hr />
<ol start="4" type="1">
<li><strong>代码中需要注意的点</strong></li>
</ol>
<p><strong>（1）内存管理</strong></p>
<ul>
<li><code>MyString</code> 使用动态内存（<code>new</code> 和
<code>delete[]</code>），需要小心管理。</li>
<li>移动构造函数通过将 <code>other.data</code> 置为
<code>nullptr</code>，避免了重复释放内存（double-free）的问题。</li>
</ul>
<p><strong>（2）缺少拷贝构造函数</strong></p>
<ul>
<li>这段代码没有定义拷贝构造函数和拷贝赋值运算符。</li>
<li>如果直接拷贝（<code>MyString s2 = s1</code>），编译器会生成默认的拷贝构造函数，导致浅拷贝（<code>s1</code>
和 <code>s2</code> 共享
<code>data</code>），析构时会重复释放内存，引发崩溃。</li>
<li><strong>改进</strong>：需要实现拷贝构造函数和拷贝赋值运算符（遵循“规则五”）。</li>
</ul>
<p><strong>改进后的代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString &amp;other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;析构: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString s2 = <span class="built_in">move</span>(s1); <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）<code>noexcept</code> 的重要性</strong></p>
<ul>
<li>移动构造函数标记为
<code>noexcept</code>，告诉编译器它不会抛出异常。</li>
<li>标准库（如 <code>std::vector</code>）在移动元素时会优先选择
<code>noexcept</code> 的移动构造函数，否则可能退回到拷贝。</li>
</ul>
<hr />
<ol start="5" type="1">
<li><strong>移动语义的核心思想</strong></li>
</ol>
<ul>
<li><strong>移动语义</strong>：将资源从一个对象“转移”到另一个对象，而不是拷贝。</li>
<li><strong>适用场景</strong>：
<ul>
<li>临时对象（右值）即将销毁时。</li>
<li>需要高效转移资源（如动态内存、文件句柄）。</li>
</ul></li>
<li><strong>好处</strong>：
<ul>
<li>避免不必要的深拷贝，提高性能。</li>
<li>资源管理更安全（避免重复释放）。</li>
</ul></li>
</ul>
<hr />
<ol start="6" type="1">
<li><strong>总结</strong></li>
</ol>
<ul>
<li><strong>代码功能</strong>：
<ul>
<li><code>MyString</code> 是一个管理动态字符串的类。</li>
<li>移动构造函数通过右值引用（<code>&amp;&amp;</code>）实现资源转移，避免深拷贝。</li>
<li><code>std::move</code> 将 <code>s1</code>
转换为右值，触发移动构造。</li>
</ul></li>
<li><strong>输出解释</strong>：
<ul>
<li>构造 <code>s1</code>：分配内存，存储 “Hello”。</li>
<li>移动构造 <code>s2</code>：将 <code>s1</code> 的 <code>data</code>
转移给 <code>s2</code>，<code>s1</code> 的 <code>data</code> 置为
<code>nullptr</code>。</li>
<li>析构：<code>s2</code> 释放 “Hello”，<code>s1</code> 的
<code>data</code> 是 <code>nullptr</code>，不释放。</li>
</ul></li>
<li><strong>改进建议</strong>：
<ul>
<li>添加拷贝构造函数和拷贝赋值运算符，避免浅拷贝问题。</li>
<li>考虑使用 <code>std::string</code> 替代
<code>char*</code>，更安全且方便。</li>
</ul></li>
</ul>
<p>如果你还有不明白的地方（比如右值引用的细节或拷贝构造函数的实现），可以告诉我，我会进一步讲解！</p>
<hr />
<h4 id="引用与指针的对比">6. <strong>引用与指针的对比</strong></h4>
<table>
<thead>
<tr class="header">
<th><strong>特性</strong></th>
<th><strong>引用</strong></th>
<th><strong>指针</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>初始化</strong></td>
<td>必须初始化，不能改变指向</td>
<td>可以不初始化，可改变指向</td>
</tr>
<tr class="even">
<td><strong>内存</strong></td>
<td>不占用额外内存（只是别名）</td>
<td>占用内存（存储地址）</td>
</tr>
<tr class="odd">
<td><strong>语法</strong></td>
<td>直接使用（无需解引用）</td>
<td>需要 <code>*</code> 解引用</td>
</tr>
<tr class="even">
<td><strong>安全性</strong></td>
<td>更安全，不会指向无效内存</td>
<td>可能出现野指针、悬空指针</td>
</tr>
<tr class="odd">
<td><strong>用途</strong></td>
<td>函数参数、简化代码</td>
<td>动态内存、复杂数据结构</td>
</tr>
</tbody>
</table>
<p><strong>选择建议</strong>： -
优先使用引用，除非需要动态内存分配或改变指向（用指针）。 -
函数参数传递时，引用比指针更简洁且安全。</p>
<hr />
<h4 id="注意事项">7. <strong>注意事项</strong></h4>
<ul>
<li><strong>避免返回局部变量的引用</strong>：局部变量在函数返回后销毁，返回其引用会导致未定义行为。</li>
<li><strong>引用与指针混用</strong>：引用可以绑定到指针解引用后的值：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;x;</span><br><span class="line"><span class="type">int</span> &amp;ref = *ptr; <span class="comment">// ref 绑定到 ptr 指向的值</span></span><br><span class="line">ref = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl; <span class="comment">// 输出: 20</span></span><br></pre></td></tr></table></figure></li>
<li><strong>性能优化</strong>：对于大对象，使用引用传递（尤其是
<code>const</code> 引用）可以避免拷贝。</li>
</ul>
<hr />
<h4 id="总结-1">8. <strong>总结</strong></h4>
<ul>
<li><strong>引用基础</strong>：引用是变量的别名，操作引用等价于操作原始变量。</li>
<li><strong>用途</strong>：
<ul>
<li>函数参数传递：避免拷贝，提高效率。</li>
<li>函数返回值：允许直接修改。</li>
<li>简化代码：无需解引用。</li>
</ul></li>
<li><strong>常量引用</strong>：防止修改，绑定临时对象。</li>
<li><strong>右值引用</strong>：支持移动语义，优化性能。</li>
<li><strong>与指针对比</strong>：引用更安全、简洁，但灵活性不如指针。</li>
</ul>
<hr />
<h3
id="类与对象面向对象特性"><strong>类与对象（面向对象特性）</strong></h3>
<p>C++ 的面向对象特性是其区别于 C
的重要部分，支持封装、继承和多态。以下是对每个子特性的详细讲解。</p>
<h4 id="类定义class-和-struct"><strong>类定义（<code>class</code> 和
<code>struct</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：类是用户定义的类型，封装数据和行为；<code>class</code>
默认访问权限为 <code>private</code>，<code>struct</code> 默认为
<code>public</code>。</li>
<li><strong>使用场景</strong>：建模现实世界的实体，如人、车等。</li>
<li><strong>底层原理</strong>：类是编译器的蓝图，实例化后分配内存，成员按声明顺序排列。</li>
<li><strong>注意事项</strong>：注意内存对齐可能增加对象大小；<code>class</code>
和 <code>struct</code> 在语法上等价，仅默认访问权限不同。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  <span class="comment">// class 定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;  <span class="comment">// struct 定义</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;  <span class="comment">// 默认 public</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyClass x: &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    MyStruct s;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyStruct y: &quot;</span> &lt;&lt; s.y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="访问控制publicprivateprotected"><strong>访问控制（<code>public</code>、<code>private</code>、<code>protected</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：控制类成员的访问权限：
<ul>
<li><code>public</code>：任何地方可访问。</li>
<li><code>private</code>：仅类内部和友元可访问。</li>
<li><code>protected</code>：类内部和派生类可访问。</li>
</ul></li>
<li><strong>使用场景</strong>：封装数据，隐藏实现细节。</li>
<li><strong>底层原理</strong>：访问控制由编译器在编译时检查，不影响运行时。</li>
<li><strong>注意事项</strong>：合理设计访问权限以保护数据一致性。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// 私有</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;  <span class="comment">// 受保护</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> z = <span class="number">30</span>;  <span class="comment">// 公有</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; obj.x &lt;&lt; &quot;\n&quot;;  // 错误：私有</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; obj.y &lt;&lt; &quot;\n&quot;;  // 错误：受保护</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; obj.z &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 30</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; obj.<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="构造函数与析构函数"><strong>构造函数与析构函数</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><strong>构造函数</strong>：初始化对象，名称与类名相同，无返回值。构造顺序：基类
-&gt; 成员对象 -&gt; 派生类。</li>
<li><strong>析构函数</strong>：清理资源，名称为
<code>~类名</code>，自动调用。析构顺序：派生类 -&gt; 成员对象 -&gt;
基类（与构造相反）。</li>
<li>局部对象遵循“后构造先析构”，全局/静态对象和数组元素也有类似规律。虚析构函数确保多态场景下析构顺序正确。</li>
</ul></li>
<li><strong>使用场景</strong>：管理对象生命周期，如分配/释放动态内存。</li>
<li><strong>底层原理</strong>：构造函数在对象创建时由编译器调用，析构函数在对象销毁时调用（栈上自动，堆上需
<code>delete</code>）。</li>
<li><strong>注意事项</strong>：若未定义，编译器提供默认版本；动态内存需手动释放。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) &#123;  <span class="comment">// 构造函数</span></span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="built_in">int</span>(val);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;  <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 栈上对象，自动析构</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 输出 Constructor -&gt; Value -&gt; Destructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="拷贝构造函数"><strong>拷贝构造函数</strong></h4>
<ul>
<li><strong>功能</strong>：以现有对象初始化新对象，形式为
<code>Class(const Class&amp;)</code>。</li>
<li><strong>使用场景</strong>：对象复制，如函数参数传递。</li>
<li><strong>底层原理</strong>：默认执行浅拷贝，自定义可实现深拷贝。</li>
<li><strong>注意事项</strong>：若有动态资源，需深拷贝以避免双重释放。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">int</span>(val)) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="built_in">int</span>(*other.ptr);  <span class="comment">// 深拷贝</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    MyClass b = a;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10, 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="成员函数与数据成员"><strong>成员函数与数据成员</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><strong>数据成员</strong>：类中的变量，存储对象状态。</li>
<li><strong>成员函数</strong>：类中的函数，操作数据成员。</li>
</ul></li>
<li><strong>使用场景</strong>：实现类的行为和属性。</li>
<li><strong>底层原理</strong>：成员函数共享，所有对象调用同一代码；数据成员每个对象独立存储。</li>
<li><strong>注意事项</strong>：避免成员函数修改意外数据。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; x++; &#125;  <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial x: &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    obj.<span class="built_in">increment</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After increment: &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="静态成员static"><strong>静态成员（<code>static</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><strong>静态数据成员</strong>：类级别共享，所有对象共用。</li>
<li><strong>静态成员函数</strong>：无需对象即可调用，仅访问静态成员。</li>
</ul></li>
<li><strong>使用场景</strong>：计数对象数量、工具函数。</li>
<li><strong>底层原理</strong>：静态成员存储在全局数据区，生命周期与程序相同。</li>
<li><strong>注意事项</strong>：静态数据成员需在类外定义。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 静态数据成员</span></span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; count++; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;  <span class="comment">// 静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>;  <span class="comment">// 类外定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass a, b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object count: &quot;</span> &lt;&lt; MyClass::<span class="built_in">getCount</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="友元friend"><strong>友元（<code>friend</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：允许外部函数或类访问私有成员。</li>
<li><strong>使用场景</strong>：实现紧密相关的类或函数。</li>
<li><strong>底层原理</strong>：编译器放宽访问限制。</li>
<li><strong>注意事项</strong>：过度使用破坏封装。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">print</span><span class="params">(MyClass&amp; obj)</span></span>;  <span class="comment">// 友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; obj.x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="built_in">print</span>(obj);  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="继承单继承多继承"><strong>继承（单继承、多继承）</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><strong>单继承</strong>：一个基类派生一个子类。</li>
<li><strong>多继承</strong>：多个基类派生一个子类。</li>
</ul></li>
<li><strong>使用场景</strong>：代码复用、建模层次关系。</li>
<li><strong>底层原理</strong>：子类对象包含基类子对象，多继承可能导致内存布局复杂。</li>
<li><strong>注意事项</strong>：多继承可能引发菱形继承问题。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;  <span class="comment">// 单继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> z = <span class="number">30</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Multi</span> : <span class="keyword">public</span> Base, <span class="keyword">public</span> Base2 &#123;  <span class="comment">// 多继承</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; d.x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; d.y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10, 20</span></span><br><span class="line">    Multi m;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; m.x &lt;&lt; <span class="string">&quot;, z: &quot;</span> &lt;&lt; m.z &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10, 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多态性虚函数-virtual纯虚函数-0"><strong>多态性（虚函数
<code>virtual</code>，纯虚函数 <code>= 0</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><strong>虚函数</strong>：通过基类指针调用派生类实现。</li>
<li><strong>纯虚函数</strong>：定义抽象接口，派生类必须实现。</li>
</ul></li>
<li><strong>使用场景</strong>：运行时多态，如插件系统。</li>
<li><strong>底层原理</strong>：虚函数通过虚表（vtable）实现，每个类一个虚表指针。</li>
<li><strong>注意事项</strong>：虚函数有运行时开销；纯虚函数使类抽象。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>; &#125;  <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pure</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;  <span class="comment">// 虚析构函数，当基类指针指向派生类对象时，如果基类的析构函数不是虚函数，delete 操作只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类中分配的资源（如动态内存、文件句柄等）无法释放，造成内存泄漏或资源未清理。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pure</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Pure implemented\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">speak</span>();  <span class="comment">// Derived</span></span><br><span class="line">    ptr-&gt;<span class="built_in">pure</span>();   <span class="comment">// Pure implemented</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="抽象类与接口"><strong>抽象类与接口</strong></h4>
<ul>
<li><strong>功能</strong>：含纯虚函数的类为抽象类，不能实例化；全纯虚函数类可作为接口。</li>
<li><strong>使用场景</strong>：定义通用接口，如策略模式。</li>
<li><strong>底层原理</strong>：抽象类阻止实例化，强制子类实现。</li>
<li><strong>注意事项</strong>：析构函数应为虚函数。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">action</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Interface</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Impl</span> : <span class="keyword">public</span> Interface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Action\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Interface* ptr = <span class="keyword">new</span> <span class="built_in">Impl</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">action</span>();  <span class="comment">// Action</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="模板"><strong>模板</strong></h3>
<p>模板支持泛型编程，使代码类型无关。</p>
<h4 id="函数模板"><strong>函数模板</strong></h4>
<ul>
<li><strong>功能</strong>：定义泛型函数，适用于多种类型。</li>
<li><strong>使用场景</strong>：通用算法，如最大值计算。</li>
<li><strong>底层原理</strong>：编译器为每种类型生成具体函数。</li>
<li><strong>注意事项</strong>：类型需支持函数中使用的操作。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> my_utils &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max int: &quot;</span> &lt;&lt; my_utils::<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// 5，会和 std::max 冲突， &lt;algorithm&gt; 库下的，或者使用 ::max ,表示使用全局命名空间中的 max</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max double: &quot;</span> &lt;&lt; my_utils::<span class="built_in">max</span>(<span class="number">1.5</span>, <span class="number">2.5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="类模板"><strong>类模板</strong></h4>
<ul>
<li><strong>功能</strong>：定义泛型类，成员类型可变。</li>
<li><strong>使用场景</strong>：容器类，如向量、列表。</li>
<li><strong>底层原理</strong>：编译器为每种类型实例化类。</li>
<li><strong>注意事项</strong>：模板定义和实现通常放在头文件中。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(T v)</span> </span>&#123; value = v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box&lt;<span class="type">int</span>&gt; <span class="title">intBox</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int box: &quot;</span> &lt;&lt; intBox.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    <span class="function">Box&lt;<span class="type">double</span>&gt; <span class="title">doubleBox</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double box: &quot;</span> &lt;&lt; doubleBox.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3.14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="异常处理"><strong>异常处理</strong></h3>
<p>异常处理机制用于管理运行时错误。</p>
<h4
id="trycatchthrow"><strong><code>try</code>、<code>catch</code>、<code>throw</code></strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><code>throw</code>：抛出异常。</li>
<li><code>try</code>：包裹可能抛异常的代码。</li>
<li><code>catch</code>：捕获并处理异常。</li>
</ul></li>
<li><strong>使用场景</strong>：错误处理，如文件操作失败。</li>
<li><strong>底层原理</strong>：异常通过栈展开传递，调用析构函数。</li>
<li><strong>注意事项</strong>：未捕获的异常终止程序。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Negative value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// Negative value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="标准异常类如-stdexception"><strong>标准异常类（如
<code>std::exception</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：提供标准化的异常类型。</li>
<li><strong>使用场景</strong>：一致性错误处理。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of bounds&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Out of range: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="命名空间"><strong>命名空间</strong></h3>
<p>命名空间用于组织代码，避免命名冲突。</p>
<h4
id="定义namespace"><strong>定义（<code>namespace</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：将标识符分组，限定作用域。</li>
<li><strong>使用场景</strong>：库开发、避免全局污染。</li>
<li><strong>底层原理</strong>：编译器通过命名空间修饰符号名。</li>
<li><strong>注意事项</strong>：嵌套命名空间增加复杂度。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> MySpace &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">namespace</span> Inner &#123;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; MySpace::x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; MySpace::Inner::y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用using"><strong>使用（<code>using</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：引入命名空间或特定符号。</li>
<li><strong>注意事项</strong>：<code>using namespace</code>
可能导致冲突。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> MySpace &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> MySpace::x;  <span class="comment">// 引入 x</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    <span class="comment">// using namespace MySpace;  // 引入整个命名空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="动态内存管理"><strong>动态内存管理</strong></h3>
<p>C++ 支持手动管理堆内存。</p>
<h4 id="new-和-delete"><strong><code>new</code> 和
<code>delete</code></strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><code>new</code>：分配堆内存并构造对象。</li>
<li><code>delete</code>：析构对象并释放内存。</li>
</ul></li>
<li><strong>使用场景</strong>：动态对象生命周期管理。</li>
<li><strong>底层原理</strong>：调用内存分配器（如
<code>malloc</code>）和构造函数。</li>
<li><strong>注意事项</strong>：成对使用，避免内存泄漏。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* ptr = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; ptr-&gt;x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;  <span class="comment">// 释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数组new-和-delete"><strong>数组（<code>new[]</code> 和
<code>delete[]</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：分配和释放连续内存块。</li>
<li><strong>注意事项</strong>：<code>new[]</code> 需用
<code>delete[]</code> 释放。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 分配并初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] arr;  <span class="comment">// 释放数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="预处理器"><strong>预处理器</strong></h3>
<p>预处理器在编译前处理代码。</p>
<h4
id="宏定义define"><strong>宏定义（<code>#define</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：定义常量或简单函数。</li>
<li><strong>使用场景</strong>：常量、调试开关。</li>
<li><strong>底层原理</strong>：文本替换，无类型检查。</li>
<li><strong>注意事项</strong>：避免复杂宏，易出错。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))  <span class="comment">// 注意括号</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PI: &quot;</span> &lt;&lt; PI &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3.14</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square(5): &quot;</span> &lt;&lt; <span class="built_in">SQUARE</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="条件编译ifdefifndefendif"><strong>条件编译（<code>#ifdef</code>、<code>#ifndef</code>、<code>#endif</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：根据条件包含或排除代码。</li>
<li><strong>使用场景</strong>：跨平台代码、调试。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Debug mode\n&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Release mode\n&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> RELEASE</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not release\n&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="文件包含include"><strong>文件包含（<code>#include</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：引入头文件或源代码。</li>
<li><strong>注意事项</strong>：使用 <code>&lt;&gt;</code>
表示标准库，<code>""</code> 表示用户文件。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 标准库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span>  <span class="comment">// 用户头文件（假设存在）</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h2 id="现代-c-新特性c11-及之后"><strong>2. 现代 C++ 新特性（C++11
及之后）</strong></h2>
<h3 id="c11"><strong>C++11</strong></h3>
<h4 id="raii">RAII</h4>
<p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是
C++
编程中的一种核心设计理念，用于管理资源的分配和释放。它通过将资源的生命周期绑定到对象的生命周期，利用
C++
的自动对象管理机制（主要是栈对象的构造和析构），确保资源在使用完毕后被正确释放，避免资源泄漏。以下是对
RAII 的详细讲解，包括其原理、实现方式、优点和典型应用。</p>
<hr />
<h5 id="什么是-raii">什么是 RAII？</h5>
<p>RAII 的核心思想是：</p>
<ul>
<li><strong>资源获取</strong>（如内存、文件句柄、锁、网络连接等）在对象构造时完成。</li>
<li><strong>资源释放</strong>在对象析构时自动完成。</li>
<li>利用 C++
的<strong>栈对象生命周期</strong>（当对象离开作用域时，析构函数自动调用），RAII
确保资源在不再需要时被正确清理，即使发生异常也能保证释放。</li>
</ul>
<p>RAII 是 C++ 异常安全性和资源管理的基础，广泛用于标准库和现代 C++
编程。</p>
<hr />
<h5 id="raii-的工作原理">RAII 的工作原理</h5>
<ol type="1">
<li><strong>资源与对象绑定</strong>：
<ul>
<li>在对象的构造函数中获取资源（例如分配内存、打开文件、加锁）。</li>
<li>资源的释放逻辑放在析构函数中。</li>
</ul></li>
<li><strong>自动管理</strong>：
<ul>
<li>C++
保证当对象离开作用域（无论是正常退出还是抛出异常），其析构函数都会被调用。</li>
<li>因此，资源的释放是自动的，无需程序员手动干预。</li>
</ul></li>
<li><strong>异常安全</strong>：
<ul>
<li>即使代码抛出异常，栈上的对象仍会按逆序析构（栈解退，stack
unwinding），确保资源不泄漏。</li>
</ul></li>
</ol>
<hr />
<h5 id="raii-的代码示例">RAII 的代码示例</h5>
<p>以下是一个简单的 RAII 示例，用于管理动态分配的内存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data; <span class="comment">// 动态分配的资源</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 构造函数中获取资源</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource acquired: &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 析构函数中释放资源</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource released&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource r; <span class="comment">// 栈上对象，自动管理</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using resource: &quot;</span> &lt;&lt; r.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 即使这里抛出异常，r 的析构函数也会被调用</span></span><br><span class="line">&#125; <span class="comment">// r 离开作用域，自动调用析构函数释放资源</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">useResource</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resource acquired: 42</span><br><span class="line">Using resource: 42</span><br><span class="line">Resource released</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中：</p>
<ul>
<li><code>Resource</code>
对象的构造函数分配内存（<code>new int</code>）。</li>
<li>析构函数释放内存（<code>delete data</code>）。</li>
<li><code>r</code>
是栈对象，离开作用域时自动调用析构函数，确保内存不泄漏。</li>
</ul>
<hr />
<h5 id="raii-的典型应用">RAII 的典型应用</h5>
<p>RAII 在 C++ 中无处不在，以下是几个常见场景：</p>
<ol type="1">
<li><strong>动态内存管理</strong>：
<ul>
<li>标准库的智能指针（如 <code>std::unique_ptr</code> 和
<code>std::shared_ptr</code>）是 RAII 的经典实现。</li>
<li>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 使用 ptr</span></span><br><span class="line">&#125; <span class="comment">// ptr 离开作用域，内存自动释放</span></span><br></pre></td></tr></table></figure></li>
<li><code>unique_ptr</code> 在析构时自动调用
<code>delete</code>，无需手动释放。</li>
</ul></li>
<li><strong>文件管理</strong>：
<ul>
<li><code>std::fstream</code>（如
<code>std::ifstream</code>、<code>std::ofstream</code>）使用 RAII
管理文件句柄。</li>
<li>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    file &lt;&lt; <span class="string">&quot;Hello, RAII!&quot;</span>;</span><br><span class="line">&#125; <span class="comment">// file 离开作用域，自动关闭文件</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>互斥锁管理</strong>：
<ul>
<li><code>std::lock_guard</code> 和 <code>std::unique_lock</code> 使用
RAII 管理线程同步中的锁。</li>
<li>示例（结合你的线程代码）： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// RAII 管理锁</span></span><br><span class="line">        ++counter;</span><br><span class="line">    &#125; <span class="comment">// lock 离开作用域，自动解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>lock_guard</code>
在构造时加锁，析构时解锁，保证即使抛出异常，锁也会释放。</li>
</ul></li>
<li><strong>其他资源</strong>：
<ul>
<li>网络连接（如 <code>std::socket</code> 的封装）。</li>
<li>数据库连接。</li>
<li>图形资源（如 OpenGL 上下文）。</li>
</ul></li>
</ol>
<hr />
<h5 id="raii-的优点">RAII 的优点</h5>
<ol type="1">
<li><strong>自动资源管理</strong>：
<ul>
<li>资源释放由析构函数自动完成，避免手动调用
<code>delete</code>、<code>close</code> 等。</li>
</ul></li>
<li><strong>异常安全</strong>：
<ul>
<li>即使抛出异常，栈解退机制确保析构函数被调用，防止资源泄漏。</li>
</ul></li>
<li><strong>代码简洁</strong>：
<ul>
<li>减少手动管理资源的代码，降低出错概率。</li>
</ul></li>
<li><strong>确定性释放</strong>：
<ul>
<li>资源在对象离开作用域时立即释放，行为可预测。</li>
</ul></li>
</ol>
<hr />
<h5 id="raii-的注意事项">RAII 的注意事项</h5>
<ol type="1">
<li><strong>避免手动管理</strong>：
<ul>
<li>不要在 RAII 对象之外手动释放资源（如
<code>delete ptr.get()</code>），否则可能导致未定义行为。</li>
</ul></li>
<li><strong>析构函数不抛异常</strong>：
<ul>
<li>RAII 依赖析构函数的调用，析构函数应保证不抛出异常（通常标记为
<code>noexcept</code>）。</li>
<li>如果析构函数抛出异常，可能导致程序终止（<code>std::terminate</code>）。</li>
</ul></li>
<li><strong>拷贝和移动</strong>：
<ul>
<li>RAII 对象管理独占资源时（如
<code>std::unique_ptr</code>），通常禁用拷贝，允许移动。</li>
<li>如果需要共享资源（如
<code>std::shared_ptr</code>），需明确定义拷贝语义。</li>
</ul></li>
<li><strong>性能开销</strong>：
<ul>
<li>RAII
对象的构造和析构可能引入少量开销，但通常被其安全性和简洁性抵消。</li>
</ul></li>
</ol>
<hr />
<h5 id="raii-与你的线程代码">RAII 与你的线程代码</h5>
<p>在你的原始代码中： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>std::thread</code> 本身不是严格的 RAII
对象，因为它不会自动调用 <code>join</code> 或 <code>detach</code>。如果
<code>t1</code> 未被 <code>join</code> 或 <code>detach</code>
就离开作用域，程序会调用 <code>std::terminate</code>。</li>
<li>改进方式：使用 RAII 封装
<code>std::thread</code>，确保线程总是被正确管理： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadRAII</span> &#123;</span><br><span class="line">    std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadRAII</span><span class="params">(std::thread&amp;&amp; thread)</span> : t(std::move(thread)) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">ThreadRAII</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) t.<span class="built_in">join</span>(); <span class="comment">// 自动 join</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ThreadRAII</span>(<span class="type">const</span>.ConcurrentThreadRAII&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝</span></span><br><span class="line">    ThreadRAII&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadRAII&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ThreadRAII <span class="title">t1</span><span class="params">(std::thread(increment))</span></span>;</span><br><span class="line">    <span class="function">ThreadRAII <span class="title">t2</span><span class="params">(std::thread(increment))</span></span>;</span><br><span class="line">    <span class="comment">// 离开作用域时，t1 和 t2 自动 join</span></span><br><span class="line">    std::cout &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ThreadRAII</code> 确保线程在析构时被 <code>join</code>，符合
RAII 原则。</li>
</ul></li>
</ul>
<p>此外，修复数据竞争时使用的 <code>std::lock_guard</code> 是 RAII
的典型应用，确保锁的自动释放。</p>
<hr />
<h5 id="总结-2">总结</h5>
<ul>
<li><strong>RAII</strong> 是 C++ 的核心
idiom，通过将资源管理绑定到对象的构造和析构，实现自动、异常安全的资源管理。</li>
<li>它广泛应用于内存（智能指针）、文件、锁等场景，简化代码并提高可靠性。</li>
<li>关键点：资源在构造函数中获取，析构函数中释放；利用栈解退保证释放。</li>
<li>在你的线程代码中，RAII 可用于管理锁（如
<code>std::lock_guard</code>）或封装线程（如
<code>ThreadRAII</code>），解决数据竞争和线程管理问题。</li>
<li>RAII 是现代 C++（如 C++11
及以后）的基石，体现了“用对象管理资源”的哲学。</li>
</ul>
<p>如果需要更深入的讲解或特定示例，请告诉我！</p>
<h4 id="自动类型推导"><strong>自动类型推导</strong></h4>
<ul>
<li><strong><code>auto</code></strong>
<ul>
<li><strong>功能</strong>：让编译器根据初始化表达式推导变量类型。</li>
<li><strong>使用场景</strong>：简化复杂类型声明，如迭代器。</li>
<li><strong>底层原理</strong>：编译时类型推导，不影响运行时。</li>
<li><strong>注意事项</strong>：需初始化；不改变类型安全。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = <span class="number">10</span>;  <span class="comment">// int</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="number">3.14</span>;  <span class="comment">// double</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ni: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, d: &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>decltype</code></strong>
<ul>
<li><strong>功能</strong>：提取表达式的类型，用于声明变量。</li>
<li><strong>使用场景</strong>：模板编程、类型推导。</li>
<li><strong>底层原理</strong>：编译时分析表达式类型。</li>
<li><strong>注意事项</strong>：可与 <code>auto</code> 结合使用。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(x) y = <span class="number">20</span>;  <span class="comment">// y 是 int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">decltype</span>(x + <span class="number">3.14</span>) z = <span class="number">5.5</span>;  <span class="comment">// z 是 double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 5.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="范围-for-循环"><strong>范围 for 循环</strong></h4>
<ul>
<li><strong>功能</strong>：基于范围的循环，简化容器遍历。</li>
<li><strong>使用场景</strong>：数组、STL 容器遍历。</li>
<li><strong>底层原理</strong>：编译器将其转换为迭代器循环。</li>
<li><strong>注意事项</strong>：容器需支持 <code>begin()</code> 和
<code>end()</code>。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) &#123;  <span class="comment">// 按值</span></span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; x : v) &#123;  <span class="comment">// 按引用修改</span></span><br><span class="line">        x *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 2 4 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="nullptr"><strong>nullptr</strong></h4>
<ul>
<li><strong>功能</strong>：替代 <code>NULL</code>，明确表示空指针。</li>
<li><strong>使用场景</strong>：初始化指针、检查有效性。</li>
<li><strong>底层原理</strong>：<code>nullptr</code> 是
<code>nullptr_t</code> 类型，避免整数转换问题。</li>
<li><strong>注意事项</strong>：比
<code>NULL</code>（0）更类型安全。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;int\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>*)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;pointer\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pointer is null\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// func(NULL);  // 歧义，可能调用 int</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>);  <span class="comment">// 明确调用 pointer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="智能指针"><strong>智能指针</strong></h4>
<ul>
<li><strong><code>std::unique_ptr</code></strong>
<ul>
<li><strong>功能</strong>：独占所有权的智能指针，自动释放内存。</li>
<li><strong>使用场景</strong>：管理单一所有权的动态资源。</li>
<li><strong>底层原理</strong>：RAII 封装，析构时调用
<code>delete</code>。</li>
<li><strong>注意事项</strong>：不可复制，只能移动。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *uptr &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; uptr2 = uptr;  // 错误：不可复制</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uptr2 = std::<span class="built_in">move</span>(uptr);  <span class="comment">// 移动</span></span><br><span class="line">    <span class="keyword">if</span> (!uptr) std::cout &lt;&lt; <span class="string">&quot;uptr is null\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;uptr2: &quot;</span> &lt;&lt; *uptr2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>std::shared_ptr</code></strong>
<ul>
<li><strong>功能</strong>：共享所有权的智能指针，引用计数管理。</li>
<li><strong>使用场景</strong>：多个对象共享资源。</li>
<li><strong>底层原理</strong>：引用计数为 0 时释放内存。</li>
<li><strong>注意事项</strong>：避免循环引用。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sptr1: &quot;</span> &lt;&lt; *sptr1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sptr2 = sptr1;  <span class="comment">// 共享</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;sptr2: &quot;</span> &lt;&lt; *sptr2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Use count: &quot;</span> &lt;&lt; sptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After scope, sptr1: &quot;</span> &lt;&lt; *sptr1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 引用计数为 0，释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>std::weak_ptr</code></strong>
<ul>
<li><strong>功能</strong>：弱引用指针，解决 <code>shared_ptr</code>
循环引用。</li>
<li><strong>使用场景</strong>：配合 <code>shared_ptr</code>
管理复杂关系。</li>
<li><strong>底层原理</strong>：不增加引用计数，需通过
<code>lock()</code> 获取 <code>shared_ptr</code>。</li>
<li><strong>注意事项</strong>：需检查有效性。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">// struct 在 C++ 中可以像 class 一样使用，包含成员变量、构造函数、析构函数等，struct 默认 public，class 默认 private</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; prev;  <span class="comment">// 避免循环引用</span></span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    n1-&gt;next = n2;</span><br><span class="line">    n2-&gt;prev = n1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 正常销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="移动语义"><strong>移动语义</strong></h4>
<ul>
<li><strong>右值引用（<code>T&amp;&amp;</code>）</strong>
<ul>
<li><strong>功能</strong>：绑定到右值（如临时对象），支持移动语义。</li>
<li><strong>使用场景</strong>：优化资源转移，避免拷贝。</li>
<li><strong>底层原理</strong>：右值引用延长临时对象生命周期。</li>
<li><strong>注意事项</strong>：区分左值和右值。</li>
</ul></li>
<li><strong>移动构造函数和 <code>std::move</code></strong>
<ul>
<li><strong>功能</strong>：转移资源所有权，减少深拷贝。</li>
<li><strong>底层原理</strong>：将资源指针转移，原对象置为可销毁状态。</li>
<li><strong>注意事项</strong>：移动后原对象状态需定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val = <span class="number">0</span>) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(val)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;  <span class="comment">// 移动构造函数</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data ? *data : <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    MyClass b = std::<span class="built_in">move</span>(a);  <span class="comment">// 移动</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0, 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="完美转发"><strong>完美转发</strong></h4>
<ul>
<li><strong>功能</strong>：通过 <code>std::forward</code>
和右值引用，保持参数的值类别（左值或右值）。</li>
<li><strong>使用场景</strong>：模板函数转发参数。</li>
<li><strong>底层原理</strong>：利用引用折叠规则（<code>T&amp;&amp;</code>
可绑定左值或右值）。</li>
<li><strong>注意事项</strong>：需与模板配合。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Lvalue: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Rvalue: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    forward(x);     <span class="comment">// Lvalue: 10</span></span><br><span class="line">    forward(<span class="number">20</span>);    <span class="comment">// Rvalue: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="lambda-表达式"><strong>Lambda 表达式</strong></h4>
<p>C++ 的 Lambda
表达式是一种便捷的方式，用于在代码中定义匿名函数对象。它在 C++11
中引入，广泛用于简化回调、函数式编程以及需要临时函数的场景。</p>
<ul>
<li><p><strong>功能</strong>：定义匿名函数，支持捕获外部变量。</p></li>
<li><p><strong>使用场景</strong>：回调、局部逻辑。</p></li>
<li><p><strong>底层原理</strong>：编译器生成闭包类。</p></li>
<li><p><strong>注意事项</strong>：捕获方式影响变量生命周期。</p></li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [x]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;  <span class="comment">// 按值捕获</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;By value: &quot;</span> &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">auto</span> refFunc = [&amp;x]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;  <span class="comment">// 按引用捕获</span></span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;By reference: &quot;</span> &lt;&lt; <span class="built_in">refFunc</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h5 id="lambda-表达式的基本语法"><strong>1. Lambda
表达式的基本语法</strong></h5>
<p>Lambda 表达式的完整语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt; return_type &#123; body &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>[capture]</code>（捕获列表）</strong>：指定外部变量如何被
Lambda 表达式捕获（按值或按引用）。</li>
<li><strong><code>(parameters)</code>（参数列表）</strong>：类似普通函数的参数，定义
Lambda 接受的输入。</li>
<li><strong><code>mutable</code></strong>（可选）：允许在按值捕获时修改捕获的变量（默认按值捕获是只读的）。</li>
<li><strong><code>-&gt; return_type</code>（返回类型，可选）</strong>：显式指定返回类型，通常由编译器推导。</li>
<li><strong><code>{ body }</code>（函数体）</strong>：Lambda
的实现逻辑。</li>
</ul>
<hr />
<h5 id="捕获列表详解"><strong>2. 捕获列表详解</strong></h5>
<p>捕获列表决定了 Lambda
如何访问外部作用域的变量。捕获方式有以下几种：</p>
<h6 id="按值捕获-x"><strong>(1) 按值捕获 <code>[x]</code></strong></h6>
<ul>
<li>外部变量被复制到 Lambda 内部，Lambda 持有该变量的副本。</li>
<li>默认情况下，按值捕获的变量是只读的，不能修改。</li>
<li>如果需要修改副本，可以使用 <code>mutable</code>
关键字，但不会影响外部变量。</li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [x]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;  <span class="comment">// x 是副本</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出 20</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 依然输出 20，因为 func 内部的 x 是副本</span></span><br></pre></td></tr></table></figure></p>
<h6 id="按引用捕获-x"><strong>(2) 按引用捕获
<code>[&amp;x]</code></strong></h6>
<ul>
<li>Lambda 直接引用外部变量，修改 Lambda 内部的变量会影响外部变量。</li>
<li>如果外部变量被销毁（例如离开作用域），Lambda
引用它会导致未定义行为（悬垂引用）。</li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> refFunc = [&amp;x]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;  <span class="comment">// x 是引用</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">refFunc</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出 40，因为 refFunc 引用了修改后的 x</span></span><br></pre></td></tr></table></figure></p>
<h6 id="全局捕获"><strong>(3) 全局捕获</strong></h6>
<ul>
<li><code>[=]</code>：按值捕获所有外部变量的副本。</li>
<li><code>[&amp;]</code>：按引用捕获所有外部变量。</li>
<li>混合捕获：可以组合，例如 <code>[=, &amp;x]</code>
表示默认按值捕获，但 <code>x</code> 按引用捕获。</li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> mixed = [=, &amp;x]() &#123; <span class="keyword">return</span> x + y; &#125;;  <span class="comment">// y 按值，x 按引用</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">mixed</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出 25（x=20, y=5 的副本）</span></span><br></pre></td></tr></table></figure></p>
<h6 id="捕获-this"><strong>(4) 捕获 <code>this</code></strong></h6>
<ul>
<li>在类成员函数中，<code>[this]</code>
捕获当前对象的指针，<code>[*this]</code>（C++17
起）捕获当前对象的副本。</li>
<li>按引用捕获 <code>[&amp;]</code> 隐式包含 <code>this</code>。</li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> lambda = [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">lambda</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>(5) 空捕获 <code>[]</code></strong></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> callback = [](<span class="type">int</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Callback: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>Lambda 表达式的捕获列表是
[]，表示<strong>空捕获</strong>，即<strong>不捕获任何外部变量</strong>，既不是按值捕获也不是按引用捕获。</p>
<p>空捕获列表 ([])：[] 表示 Lambda
表达式不从外部作用域捕获任何变量。</p>
<p>无外部变量引用：Lambda 的函数体 { std::cout &lt;&lt; “Callback:”
&lt;&lt; x &lt;&lt; “”; } 只使用了参数 x（通过函数调用传入）和全局对象
std::cout。std::cout 是全局的，不需要捕获，而 x 是 Lambda
的参数，不是外部作用域的变量。</p>
<p>捕获（按值 [=] 或按引用 [&amp;]）只有在 Lambda
访问外部作用域的变量时才起作用。例如，如果 Lambda 使用了外部的 int
y，才会涉及捕获方式。</p>
<hr />
<h5 id="lambda-的工作原理"><strong>3. Lambda 的工作原理</strong></h5>
<p>Lambda
表达式实际上是编译器生成的匿名类的实例（称为闭包对象）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [x]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>编译器会生成类似以下的类： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">// 捕获的变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Lambda</span>(<span class="type">int</span> x_) : <span class="built_in">x</span>(x_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125; <span class="comment">// 重载函数调用操作符，operator() 是重载的函数调用操作符，() 表示这个操作符不接受参数（空参数列表），int 是返回值类型，表示调用这个操作符会返回一个整数，const 表示这个成员函数不会修改对象的状态（x 不会被改变）。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>调用 <code>func()</code> 实际上是调用这个类的
<code>operator()</code>。这解释了 Lambda 为什么可以像函数一样使用。</p>
<hr />
<h5 id="lambda-的常见用途"><strong>4. Lambda 的常见用途</strong></h5>
<ol type="1">
<li><p><strong>标准库算法</strong>：与 <code>&lt;algorithm&gt;</code>
配合，例如 <code>std::sort</code>、<code>std::for_each</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>异步编程</strong>：与 <code>std::async</code>
或线程配合。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = []() &#123; std::cout &lt;&lt; <span class="string">&quot;Running task\n&quot;</span>; &#125;;</span><br><span class="line">std::<span class="built_in">async</span>(std::launch::async, task);</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>回调函数</strong>：传递给需要回调的函数。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> callback = [](<span class="type">int</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Callback: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;;<span class="comment">// </span></span><br><span class="line"><span class="built_in">someFunction</span>(callback);</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>立即执行</strong>（IIFE，Immediately Invoked Function
Expression）： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = []() &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;();  <span class="comment">// 立即调用，result = 42</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<hr />
<h5 id="注意事项-1"><strong>5. 注意事项</strong></h5>
<ol type="1">
<li><p><strong>生命周期问题</strong>：</p>
<ul>
<li>按引用捕获时，确保捕获的变量在 Lambda 使用时仍然有效。</li>
<li>示例（错误用法）： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> [&amp;x]() &#123; <span class="keyword">return</span> x; &#125;;  <span class="comment">// 悬垂引用，x 在函数返回后销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>性能开销</strong>：</p>
<ul>
<li>按值捕获会复制变量，可能会增加内存开销。</li>
<li>对于大对象，考虑按引用捕获或使用 <code>std::move</code>（C++11
起支持移动捕获，C++14 增强）。</li>
</ul></li>
<li><p><strong>C++14/17 增强</strong>：</p>
<ul>
<li><p><strong>C++14</strong>：支持泛型 Lambda（<code>auto</code>
参数）和初始化捕获。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [y = <span class="number">10</span>](<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> x + y; &#125;;  <span class="comment">// 初始化捕获</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>C++17</strong>：支持 <code>[*this]</code>
捕获对象副本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 [*this] 捕获对象副本</span></span><br><span class="line">        <span class="keyword">auto</span> lambda = [*<span class="keyword">this</span>]() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Lambda: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="comment">// 修改 x 不影响原始对象</span></span><br><span class="line">            x = <span class="number">20</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Lambda modified: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 Lambda</span></span><br><span class="line">        <span class="built_in">lambda</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始对象的 x 未改变</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Original: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟异步回调</span></span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">createAsyncCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回 Lambda，捕获 [*this]</span></span><br><span class="line">        <span class="keyword">return</span> [*<span class="keyword">this</span>]() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Async callback: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试 [*this] 捕获</span></span><br><span class="line">    Example obj;</span><br><span class="line">    obj.<span class="built_in">createLambda</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试异步场景</span></span><br><span class="line">    <span class="keyword">auto</span> callback = obj.<span class="built_in">createAsyncCallback</span>();</span><br><span class="line">    <span class="comment">// obj 销毁后，callback 仍然有效，因为它持有 obj 的副本</span></span><br><span class="line">    <span class="built_in">callback</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>C++20</strong>：支持无状态 Lambda 的默认构造和赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个无状态 Lambda，lambda 不捕获任何变量（[]），因此是无状态的，行为完全由函数体 &#123; return 42; &#125; 定义。</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = []() &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造无状态 Lambda（C++20），decltype(lambda) defaultLambda; 创建一个默认构造的闭包对象，行为与 lambda 相同。</span></span><br><span class="line">    <span class="keyword">decltype</span>(lambda) defaultLambda; <span class="comment">// 默认构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default constructed Lambda: &quot;</span> &lt;&lt; <span class="built_in">defaultLambda</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值（C++20），assignedLambda = lambda; 将 lambda 的行为复制到 assignedLambda，这是 C++20 新增的功能。</span></span><br><span class="line">    <span class="keyword">decltype</span>(lambda) assignedLambda;</span><br><span class="line">    assignedLambda = lambda; <span class="comment">// 赋值操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Assigned Lambda: &quot;</span> &lt;&lt; <span class="built_in">assignedLambda</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储在容器中，std::vector 和 std::optional 可以存储无状态 Lambda，因为它们支持默认构造和赋值。</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="title">decltype</span><span class="params">(lambda)</span>&gt; <span class="title">lambdaVector</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 默认构造 3 个 Lambda</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; l : lambdaVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Vector Lambda: &quot;</span> &lt;&lt; <span class="built_in">l</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::optional</span></span><br><span class="line">    std::optional&lt;<span class="keyword">decltype</span>(lambda)&gt; optionalLambda;</span><br><span class="line">    optionalLambda = lambda; <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">if</span> (optionalLambda) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Optional Lambda: &quot;</span> &lt;&lt; optionalLambda.<span class="built_in">value</span>()() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Lambda 捕获变量（有状态
Lambda），则无法使用默认构造或赋值，因为它们的行为依赖捕获的变量。</p>
<figure class="highlight cpp"><figcaption><span>compiling</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> statefulLambda = [x]() &#123; <span class="keyword">return</span> x; &#125;;</span><br><span class="line"><span class="keyword">decltype</span>(statefulLambda) defaultLambda; <span class="comment">// 错误：无默认构造函数</span></span><br><span class="line">statefulLambda = statefulLambda; <span class="comment">// 错误：无赋值操作符</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>mutable 关键字</strong>：</p>
<ul>
<li>按值捕获默认只读，使用 <code>mutable</code> 允许修改副本。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [x]() <span class="keyword">mutable</span> &#123; x += <span class="number">1</span>; <span class="keyword">return</span> x; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出 11</span></span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;       <span class="comment">// 输出 10，外部 x 不变</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h4 id="模板改进"><strong>模板改进</strong></h4>
<ul>
<li><strong>可变参数模板</strong>
<ul>
<li><strong>功能</strong>：支持不定数量的模板参数。</li>
<li><strong>使用场景</strong>：通用函数，如打印。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args);  <span class="comment">// C++17 折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="string">&quot; &quot;</span>, <span class="number">2.5</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;hello&quot;</span>);  <span class="comment">// 1 2.5 hello</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>模板别名</strong>
<ul>
<li><strong>功能</strong>：使用 <code>using</code>
定义模板类型别名。</li>
<li><strong>使用场景</strong>：简化复杂类型。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T&gt;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="初始化改进"><strong>初始化改进</strong></h4>
<ul>
<li><strong>统一初始化</strong>
<ul>
<li><strong>功能</strong>：使用 <code>{}</code> 初始化所有类型。</li>
<li><strong>使用场景</strong>：一致性初始化。</li>
<li><strong>注意事项</strong>：窄化转换（如 double 到 int）被禁止。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">double</span> d&#123;<span class="number">3.14</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, d: &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// int y&#123;3.14&#125;;  // 错误：窄化转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>初始化列表</strong>
<ul>
<li><strong>功能</strong>：用 <code>{}</code> 初始化容器或对象。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="并发支持"><strong>并发支持</strong></h4>
<p>C++ 的并发控制是现代 C++（特别是 C++11
及之后）的一个重要特性，旨在支持多线程编程并确保线程安全。并发控制涉及管理多个线程对共享资源的访问，避免数据竞争（data
race）、死锁（deadlock）等问题，同时最大化性能。</p>
<hr />
<h5 id="并发控制的核心概念"><strong>1. 并发控制的核心概念</strong></h5>
<h6 id="线程threads"><strong>(1) 线程（Threads）</strong></h6>
<ul>
<li>C++11 引入了 <code>&lt;thread&gt;</code>
头文件，支持原生线程管理。</li>
<li>线程表示并行执行的独立控制流，多个线程可能同时访问共享资源。</li>
<li>问题：未经同步的共享资源访问可能导致数据竞争。</li>
</ul>
<h6 id="数据竞争data-race"><strong>(2) 数据竞争（Data
Race）</strong></h6>
<ul>
<li>当多个线程同时访问共享资源（例如变量），且至少一个线程是写操作时，可能导致未定义行为。</li>
<li>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">        ++counter; <span class="comment">// counter 可能不是 2000，因为 ++counter 不是原子操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>; </span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>std::thread</code>
构造函数接受一个可调用对象（如函数、函数指针、lambda
表达式等）以及可选的参数。语法：<code>std::thread variable_name(callable, args...)</code>。在
<code>thread t1(increment);</code> 中，<code>increment</code>
是一个无参函数，因此没有额外参数。</p>
<p>构造 <code>t1</code> 时，<code>std::thread</code>
会分配一个新的线程（由操作系统管理），并在该线程中调用
<code>increment()</code>。新线程立即开始运行，除非系统资源受限。</p>
<p><code>t1</code>
的生命周期从构造开始，直到线程执行完成或程序结束。如果 <code>t1</code>
未被 <code>join</code> 或 <code>detach</code>，程序在 <code>t1</code>
析构时（例如离开作用域）会调用
<code>std::terminate</code>，导致程序崩溃。<code>t1.join()</code>
确保主线程等待 <code>t1</code> 完成，避免此问题。</p>
<p>写 <code>thread t1(increment);</code> 而不是
<code>thread t1(increment());</code>
是因为后者可能被解析为函数声明（称为“最令人头痛的解析”，most vexing
parse）。<code>thread t1(increment);</code>
明确表示创建一个线程对象，调用 <code>increment</code> 函数。</p>
<p><code>increment</code> 可以是任何可调用对象，例如：</p>
<ul>
<li><p>函数指针：<code>void (*func)() = increment; thread t1(func);</code></p></li>
<li><p>Lambda
表达式：<code>thread t1([](){ /* 代码 */ });</code></p></li>
<li><p>函数对象（functor）：<code>thread t1(MyFunctor());</code></p></li>
<li><p>如果 <code>increment</code> 需要参数，需在构造时提供：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(increment, <span class="number">42</span>)</span></span>; <span class="comment">// 传递参数 42</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>如果 <code>increment</code>
抛出异常，线程会终止，异常不会传播到主线程。需在 <code>increment</code>
内部捕获异常，或使用其他机制（如 <code>std::future</code>）处理。</p>
<p><code>counter</code> 是全局变量，被 <code>t1</code> 和
<code>t2</code> 共享。<code>++counter</code>
不是原子操作，即可能被其他线程中断，它实际上涉及三个步骤：</p>
<ol type="1">
<li>读取 <code>counter</code> 的当前值。</li>
<li>将值加 1。</li>
<li>将新值写回 <code>counter</code>。</li>
</ol>
<p>要确保 <code>counter</code> 总是
2000，需要消除数据竞争。常见方法：</p>
<ol type="1">
<li><p><strong>使用互斥锁（Mutex）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        ++counter;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mutex</code> 确保每次只有 一个线程能访问
<code>counter</code>，避免竞争。</li>
<li>缺点：频繁加锁解锁可能降低性能。</li>
</ul></li>
<li><p><strong>使用原子操作</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::atomic&lt;int&gt;</code> 提供原子操作，保证
<code>++counter</code> 不被中断。</li>
<li>更高效，适合简单计数器场景。</li>
</ul></li>
<li><p><strong>减少锁的粒度</strong>：</p>
<ul>
<li>将整个循环放在锁内（而不是每次迭代都加锁）可以减少加锁开销：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h6 id="同步原语synchronization-primitives"><strong>(3)
同步原语（Synchronization Primitives）</strong></h6>
<p>C++ 提供了多种工具来控制并发：</p>
<ul>
<li><strong>互斥锁（Mutex）</strong>：防止多个线程同时访问共享资源。</li>
<li><strong>条件变量（Condition
Variable）</strong>：协调线程间的等待和通知。</li>
<li><strong>原子操作（Atomic
Operations）</strong>：无锁的线程安全操作。</li>
<li><strong>未来（Future）和承诺（Promise）</strong>：异步任务的结果传递。</li>
<li><strong>线程局部存储（Thread-Local
Storage）</strong>：每个线程独立的数据。</li>
</ul>
<hr />
<h5 id="c-并发控制的主要工具"><strong>2. C++
并发控制的主要工具</strong></h5>
<h6 id="互斥锁mutex"><strong>(1)
互斥锁（<code>&lt;mutex&gt;</code>）</strong></h6>
<p>互斥锁用于保护共享资源，确保一次只有一个线程访问临界区。</p>
<ul>
<li><p><strong>常用类型</strong>：</p>
<ul>
<li><code>std::mutex</code>：基本互斥锁。</li>
<li><code>std::recursive_mutex</code>：允许同一线程多次锁定。</li>
<li><code>std::timed_mutex</code>：支持超时。</li>
<li><code>std::shared_mutex</code>（C++17）：支持读写锁（多个读线程或单个写线程）。</li>
</ul></li>
<li><p><strong>锁管理工具</strong>：</p>
<ul>
<li><code>std::lock_guard</code>：RAII 风格的锁，自动解锁。</li>
<li><code>std::unique_lock</code>：更灵活的锁，支持延迟锁定或转移。</li>
<li><code>std::scoped_lock</code>（C++17）：简化多锁管理，避免死锁。</li>
</ul></li>
<li><p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动锁定和解锁</span></span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter: &quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 2000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>注意</strong>：</p>
<ul>
<li>避免死锁：使用 <code>std::scoped_lock</code> 或按固定顺序加锁。</li>
<li>最小化锁的范围以提高性能。</li>
</ul></li>
</ul>
<h6 id="条件变量condition_variable"><strong>(2)
条件变量（<code>&lt;condition_variable&gt;</code>）</strong></h6>
<p>条件变量用于线程间的同步，允许一个线程等待特定条件，另一个线程通知条件满足。</p>
<ul>
<li><p><strong>常用类型</strong>：</p>
<ul>
<li><code>std::condition_variable</code>：与 <code>std::mutex</code>
配合使用。</li>
<li><code>std::condition_variable_any</code>：支持任意锁类型。</li>
</ul></li>
<li><p><strong>示例</strong>（生产者-消费者模型）：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !q.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 等待队列非空</span></span><br><span class="line">        <span class="type">int</span> value = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>注意</strong>：</p>
<ul>
<li>使用 <code>std::unique_lock</code> 与条件变量配合。</li>
<li>避免虚假唤醒（spurious wakeup），使用条件检查（如
<code>[] { return !q.empty(); }</code>）。</li>
</ul></li>
</ul>
<h6 id="原子操作atomic"><strong>(3)
原子操作（<code>&lt;atomic&gt;</code>）</strong></h6>
<p>原子操作提供无锁的线程安全操作，适合简单数据类型（如计数器）。</p>
<ul>
<li><p><strong>常用类型</strong>：</p>
<ul>
<li><code>std::atomic&lt;T&gt;</code>：支持整数、指针等类型的原子操作。</li>
<li><code>std::atomic_flag</code>：最简单的原子标志。</li>
</ul></li>
<li><p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// 原子递增</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter: &quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 2000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>内存序（Memory Order）</strong>：</p>
<ul>
<li><code>std::memory_order_relaxed</code>：最低性能约束。</li>
<li><code>std::memory_order_seq_cst</code>：默认，强一致性。</li>
<li>选择合适的内存序以平衡性能和正确性。</li>
</ul></li>
</ul>
<h6 id="未来和承诺future"><strong>(4)
未来和承诺（<code>&lt;future&gt;</code>）</strong></h6>
<p><code>std::future</code> 和 <code>std::promise</code>
用于异步任务的结果传递。</p>
<ul>
<li><p><strong>组件</strong>：</p>
<ul>
<li><code>std::promise</code>：设置任务结果。</li>
<li><code>std::future</code>：获取任务结果。</li>
<li><code>std::async</code>：异步执行函数。</li>
</ul></li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">42</span>); <span class="comment">// Set result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(prom))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// Prints 42</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, compute, <span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>：</p>
<ul>
<li><code>std::async</code> 的启动策略（<code>std::launch::async</code>
或 <code>std::launch::deferred</code>）影响执行时机。</li>
<li><code>std::future::get()</code> 阻塞直到结果可用。</li>
</ul></li>
</ul>
<h6 id="线程局部存储thread"><strong>(5)
线程局部存储（<code>&lt;thread&gt;</code>）</strong></h6>
<p><code>thread_local</code>
变量为每个线程提供独立副本，避免共享资源竞争。</p>
<ul>
<li><p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> tls_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++tls_counter;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; tls_counter &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>输出</strong>（可能）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread 1234: 1</span><br><span class="line">Thread 5678: 1</span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h5 id="c17-和-c20-的并发改进"><strong>3. C++17 和 C++20
的并发改进</strong></h5>
<h6 id="c17"><strong>C++17</strong></h6>
<ul>
<li><strong>并行算法</strong>（<code>&lt;algorithm&gt;</code>）：
<ul>
<li>支持并行执行标准算法，例如 <code>std::sort</code>：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execution&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(std::execution::par, vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li>
<li>执行策略：<code>std::execution::seq</code>（顺序）、<code>par</code>（并行）、<code>par_unseq</code>（并行无序）。</li>
</ul></li>
<li><strong>共享锁</strong>（<code>std::shared_mutex</code>）：
<ul>
<li>支持读写锁，允许多个读线程同时访问： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_mutex smtx;</span><br><span class="line"><span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(smtx)</span></span>; <span class="comment">// 读锁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Read: &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(smtx)</span></span>; <span class="comment">// 写锁</span></span><br><span class="line">    ++data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h6 id="c20"><strong>C++20</strong></h6>
<ul>
<li><strong>信号量（<code>&lt;semaphore&gt;</code>）</strong>：
<ul>
<li>提供轻量级同步，例如 <code>std::counting_semaphore</code>：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;1&gt; <span class="title">sem</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem.<span class="built_in">acquire</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task running\n&quot;</span>;</span><br><span class="line">    sem.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>屏障（<code>&lt;barrier&gt;</code>）</strong>：
<ul>
<li>协调多个线程到达同步点： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;barrier&gt;</span></span></span><br><span class="line"><span class="function">std::barrier <span class="title">barrier</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; phase 1\n&quot;</span>;</span><br><span class="line">    barrier.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; phase 2\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>锁存器（<code>&lt;latch&gt;</code>）</strong>：
<ul>
<li>单次同步，线程等待计数归零： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="function">std::latch <span class="title">latch</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; done\n&quot;</span>;</span><br><span class="line">    latch.<span class="built_in">count_down</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>协作中断（<code>&lt;jthread&gt;</code>）</strong>：
<ul>
<li><code>std::jthread</code> 自动加入线程，支持中断：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jthread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(std::stop_token token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!token.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Running...\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t</span><span class="params">(task)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    t.<span class="built_in">request_stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h5 id="注意事项-2"><strong>4. 注意事项</strong></h5>
<ol type="1">
<li><strong>死锁</strong>：多锁时使用 <code>std::scoped_lock</code>
或固定加锁顺序。</li>
<li><strong>性能</strong>：优先考虑原子操作或无锁结构，减少锁争用。</li>
<li><strong>异常安全</strong>：使用 RAII（如
<code>std::lock_guard</code>）确保锁在异常时释放。</li>
<li><strong>调试</strong>：使用工具（如
ThreadSanitizer）检测数据竞争。</li>
<li><strong>C++ 版本</strong>：确保编译器支持目标特性（例如
<code>-std=c++20</code>）。</li>
</ol>
<hr />
<h5 id="总结-3"><strong>5. 总结</strong></h5>
<ul>
<li><strong>核心工具</strong>：互斥锁、条件变量、原子操作、未来/承诺、线程局部存储。</li>
<li><strong>C++17
改进</strong>：并行算法、<code>std::shared_mutex</code>。</li>
<li><strong>C++20
增强</strong>：信号量、屏障、锁存器、<code>std::jthread</code>。</li>
</ul>
<h4 id="constexpr"><strong>constexpr</strong></h4>
<ul>
<li><strong>功能</strong>：定义编译时常量或函数。</li>
<li><strong>使用场景</strong>：优化性能、静态断言。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="built_in">square</span>(<span class="number">3</span>)];  <span class="comment">// 编译时计算 9</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="c14"><strong>C++14</strong></h3>
<p>C++14 是 C++11 的增量更新，增强了语言的易用性和表达能力。</p>
<h4 id="泛型-lambda"><strong>泛型 Lambda</strong></h4>
<ul>
<li><strong>功能</strong>：允许 Lambda 表达式的参数使用
<code>auto</code>，使其支持泛型。</li>
<li><strong>使用场景</strong>：需要处理多种类型的匿名函数，如通用回调。</li>
<li><strong>底层原理</strong>：编译器为 Lambda
生成一个模板化的闭包类，每个类型实例化一个具体函数。</li>
<li><strong>注意事项</strong>：提高了代码灵活性，但可能增加编译时间；需确保参数类型支持
Lambda 体内的操作。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> genericLambda = [](<span class="keyword">auto</span> x) &#123;  <span class="comment">// 参数 x 是泛型的</span></span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; <span class="built_in">genericLambda</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// 6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; <span class="built_in">genericLambda</span>(<span class="number">3.14</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 4.14</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Char: &quot;</span> &lt;&lt; <span class="built_in">genericLambda</span>(<span class="string">&#x27;A&#x27;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;    <span class="comment">// &#x27;B&#x27; (ASCII 66)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="返回类型推导"><strong>返回类型推导</strong></h4>
<ul>
<li><strong>功能</strong>：允许函数使用 <code>auto</code>
作为返回类型，由函数体推导。</li>
<li><strong>使用场景</strong>：简化函数声明，尤其在返回值类型复杂时。</li>
<li><strong>底层原理</strong>：编译器根据 <code>return</code>
语句推导类型，所有返回路径必须一致。</li>
<li><strong>注意事项</strong>：不能用于声明（需定义）；递归函数需显式返回类型。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;  <span class="comment">// 返回类型推导为 int</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;  <span class="comment">// 返回类型推导为 double</span></span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;          <span class="comment">// 5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply: &quot;</span> &lt;&lt; <span class="built_in">multiply</span>(<span class="number">2.5</span>, <span class="number">3.0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 7.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="constexpr-扩展"><strong>constexpr 扩展</strong></h4>
<ul>
<li><strong>功能</strong>：扩展 <code>constexpr</code>
函数，支持更复杂的编译时计算（如循环、条件语句）。</li>
<li><strong>使用场景</strong>：需要编译时计算复杂表达式，如数学函数。</li>
<li><strong>底层原理</strong>：编译器在编译时执行函数，确保结果为常量。</li>
<li><strong>注意事项</strong>：函数体内限制放宽，但仍需满足常量表达式要求（如无动态内存分配）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;  <span class="comment">// 编译时计算阶乘</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;  <span class="comment">// C++14 允许循环</span></span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="built_in">factorial</span>(<span class="number">4</span>)];  <span class="comment">// 编译时计算 24</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 24</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial(4): &quot;</span> &lt;&lt; <span class="built_in">factorial</span>(<span class="number">4</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="变量模板"><strong>变量模板</strong></h4>
<ul>
<li><strong>功能</strong>：允许定义模板化的变量，提供类型参数化的常量。</li>
<li><strong>使用场景</strong>：泛型常量，如类型相关的数学常数。</li>
<li><strong>底层原理</strong>：编译器为每种类型实例化变量。</li>
<li><strong>注意事项</strong>：需显式指定类型或推导。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535</span>);  <span class="comment">// 变量模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Float pi: &quot;</span> &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// 3.14159</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double pi: &quot;</span> &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 3.14159</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="c17-1"><strong>C++17</strong></h3>
<p>C++17 引入了更多实用特性，提升了语言的现代化程度。</p>
<h4 id="结构化绑定"><strong>结构化绑定</strong></h4>
<ul>
<li><strong>功能</strong>：解构赋值，将聚合类型（如
<code>pair</code>、<code>tuple</code>、结构体）的成员绑定到变量。</li>
<li><strong>使用场景</strong>：简化多返回值函数的使用。</li>
<li><strong>底层原理</strong>：编译器生成临时对象并解构，绑定到新变量。</li>
<li><strong>注意事项</strong>：需支持结构化绑定的类型（如
<code>std::pair</code> 或含 <code>std::tuple_size</code> 的类型）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = p;  <span class="comment">// 结构化绑定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1, 2.5</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> a; <span class="type">double</span> b; &#125;;</span><br><span class="line">    Point pt&#123;<span class="number">3</span>, <span class="number">4.5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [a, b] = pt;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3, 4.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="if-和-switch-初始化"><strong>if 和 switch 初始化</strong></h4>
<ul>
<li><strong>功能</strong>：允许在 <code>if</code> 和 <code>switch</code>
语句中初始化变量，限制作用域。</li>
<li><strong>使用场景</strong>：临时变量仅用于条件判断。</li>
<li><strong>底层原理</strong>：编译器将初始化和条件组合为单一语句。</li>
<li><strong>注意事项</strong>：变量作用域限于 <code>if</code> 或
<code>switch</code> 块。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span> x = <span class="number">10</span>; x &gt; <span class="number">0</span>) &#123;  <span class="comment">// 初始化并判断</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is positive: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; x &lt;&lt; &quot;\n&quot;;  // 错误：x 超出作用域</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="type">int</span> y = <span class="number">2</span>; y) &#123;  <span class="comment">// 初始化并切换</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: std::cout &lt;&lt; <span class="string">&quot;y is 2\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: std::cout &lt;&lt; <span class="string">&quot;Other\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="折叠表达式"><strong>折叠表达式</strong></h4>
<ul>
<li><strong>功能</strong>：简化可变参数模板的处理，允许对参数包进行一元或二元操作。</li>
<li><strong>使用场景</strong>：批量操作参数，如求和、打印。</li>
<li><strong>底层原理</strong>：编译器展开参数包并应用操作符。</li>
<li><strong>注意事项</strong>：支持常见运算符（如
<code>+</code>、<code>*</code>、<code>&amp;&amp;</code> 等）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);  <span class="comment">// 二元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args);  <span class="comment">// 打印所有参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="number">42</span>, <span class="string">&quot;\n&quot;</span>);  <span class="comment">// Hello 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="stdoptional"><strong>std::optional</strong></h4>
<ul>
<li><strong>功能</strong>：表示可能为空的值，提供类型安全的可选值。</li>
<li><strong>使用场景</strong>：函数可能无返回值，或值可选。</li>
<li><strong>底层原理</strong>：封装值和状态，析构时自动清理。</li>
<li><strong>注意事项</strong>：需检查是否有值（<code>has_value()</code>
或 <code>*</code>）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">maybeInt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;  <span class="comment">// 无值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> opt1 = <span class="built_in">maybeInt</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (opt1) std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *opt1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">auto</span> opt2 = <span class="built_in">maybeInt</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!opt2) std::cout &lt;&lt; <span class="string">&quot;No value\n&quot;</span>;  <span class="comment">// No value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="stdvariant"><strong>std::variant</strong></h4>
<ul>
<li><strong>功能</strong>：类型安全的联合类型，可存储多种类型之一。</li>
<li><strong>使用场景</strong>：替代 <code>union</code>，如状态机。</li>
<li><strong>底层原理</strong>：存储当前类型索引和值，析构时调用正确析构函数。</li>
<li><strong>注意事项</strong>：访问需使用 <code>std::get</code> 或
<code>std::visit</code>，错误访问抛异常。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; v = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(v) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    v = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(v) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3.14</span></span><br><span class="line">    v = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(v) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// Hello</span></span><br><span class="line">    <span class="comment">// std::get&lt;int&gt;(v);  // 抛出 std::bad_variant_access</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="stdany"><strong>std::any</strong></h4>
<ul>
<li><strong>功能</strong>：存储任意类型的值，提供类型擦除。</li>
<li><strong>使用场景</strong>：需要动态类型的场景，如脚本引擎。</li>
<li><strong>底层原理</strong>：使用类型擦除技术，存储值和类型信息。</li>
<li><strong>注意事项</strong>：访问需使用
<code>std::any_cast</code>，类型错误抛异常。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    a = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">double</span>&gt;(a) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3.14</span></span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// Hello</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a);  <span class="comment">// 抛出 std::bad_any_cast</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bad cast: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="文件系统库stdfilesystem"><strong>文件系统库（<code>std::filesystem</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：提供文件和目录操作的标准化接口。</li>
<li><strong>使用场景</strong>：文件管理、路径处理。</li>
<li><strong>底层原理</strong>：封装操作系统文件 API。</li>
<li><strong>注意事项</strong>：需链接文件系统库（如
<code>-lstdc++fs</code> 在某些编译器）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fs::path p = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (fs::<span class="built_in">exists</span>(p)) &#123;</span><br><span class="line">        std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot; exists\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot; does not exist\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : fs::<span class="built_in">directory_iterator</span>(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; entry.<span class="built_in">path</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 列出当前目录</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="并行算法"><strong>并行算法</strong></h4>
<ul>
<li><strong>功能</strong>：STL 算法支持并行执行，优化多核性能。</li>
<li><strong>使用场景</strong>：大数据排序、变换。</li>
<li><strong>底层原理</strong>：依赖线程池或底层并发支持。</li>
<li><strong>注意事项</strong>：需编译器支持（如
<code>-ltbb</code>）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(std::execution::par, v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());  <span class="comment">// 并行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 1 3 4 5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="inline-变量"><strong>inline 变量</strong></h4>
<ul>
<li><strong>功能</strong>：允许在头文件中定义 <code>inline</code>
静态变量，避免多重定义。</li>
<li><strong>使用场景</strong>：头文件中的全局常量。</li>
<li><strong>底层原理</strong>：编译器保证单一实例。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_H</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> globalVar = <span class="number">42</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="c20-1"><strong>C++20</strong></h3>
<p>C++20 是近年来最大的更新，引入了许多革新特性。</p>
<h4 id="概念concepts"><strong>概念（Concepts）</strong></h4>
<ul>
<li><strong>功能</strong>：约束模板参数，提供类型检查。</li>
<li><strong>使用场景</strong>：泛型编程中确保类型满足要求。</li>
<li><strong>底层原理</strong>：编译时验证类型特性。</li>
<li><strong>注意事项</strong>：需支持 C++20 的编译器。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> std::integral&lt;T&gt;  <span class="comment">// 约束 T 为整数类型</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// add(2.5, 3.5);  // 错误：double 不满足 integral</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ranges-库"><strong>Ranges 库</strong></h4>
<ul>
<li><strong>功能</strong>：提供范围操作，增强 STL 的功能性。</li>
<li><strong>使用场景</strong>：链式处理容器数据。</li>
<li><strong>底层原理</strong>：基于迭代器，新增视图概念。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> even = v | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    std::ranges::<span class="built_in">sort</span>(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 1 3 4 5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nEven: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : even) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="协程coroutines"><strong>协程（Coroutines）</strong></h4>
<ul>
<li><strong>功能</strong>：支持异步编程，允许函数暂停和恢复。</li>
<li><strong>使用场景</strong>：异步 I/O、生成器。</li>
<li><strong>底层原理</strong>：编译器生成状态机，依赖协程框架。</li>
<li><strong>注意事项</strong>：需库支持（如
<code>cppcoro</code>），示例简化。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="keyword">this</span>&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; value = v; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; coro;</span><br><span class="line">    <span class="built_in">Generator</span>(promise_type* p) : <span class="built_in">coro</span>(std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*p)) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Generator</span>() &#123; <span class="keyword">if</span> (coro) coro.<span class="built_in">destroy</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123; coro.<span class="built_in">resume</span>(); <span class="keyword">return</span> coro.<span class="built_in">promise</span>().value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Generator <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> i;  <span class="comment">// 暂停并返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> g = <span class="built_in">generate</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; g.<span class="built_in">next</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="模块modules"><strong>模块（Modules）</strong></h4>
<ul>
<li><strong>功能</strong>：替代头文件，提供模块化编程。</li>
<li><strong>使用场景</strong>：大型项目，减少编译依赖。</li>
<li><strong>底层原理</strong>：编译器生成模块单元，优化编译。</li>
<li><strong>注意事项</strong>：需 C++20
支持，主流编译器支持尚不完善。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from module\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();  <span class="comment">// Hello from module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="三路比较运算符"><strong>三路比较运算符（<code>&lt;=&gt;</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：提供默认比较运算符，返回比较结果。</li>
<li><strong>使用场景</strong>：简化自定义类型的比较。</li>
<li><strong>底层原理</strong>：返回 <code>std::strong_ordering</code>
等类型。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Point&amp; other) <span class="type">const</span> = <span class="keyword">default</span>;  <span class="comment">// 默认比较</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1&#123;<span class="number">1</span>&#125;, p2&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1 &lt; p2: &quot;</span> &lt;&lt; (p1 &lt; p2) &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1 == p2: &quot;</span> &lt;&lt; (p1 == p2) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="consteval-和-constinit"><strong>consteval 和
constinit</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><code>consteval</code>：强制编译时计算。</li>
<li><code>constinit</code>：控制常量初始化。</li>
</ul></li>
<li><strong>使用场景</strong>：编译时优化、初始化控制。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;  <span class="comment">// 必须编译时计算</span></span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> global = <span class="built_in">square</span>(<span class="number">5</span>);  <span class="comment">// 确保编译时初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square(3): &quot;</span> &lt;&lt; <span class="built_in">square</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 9</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global: &quot;</span> &lt;&lt; global &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="新工具"><strong>新工具</strong></h4>
<ul>
<li><strong><code>std::span</code></strong>
<ul>
<li><strong>功能</strong>：提供连续内存的视图。</li>
<li><strong>使用场景</strong>：操作数组或容器片段。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::span&lt;<span class="type">int</span>&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(arr, <span class="number">3</span>)</span></span>;  <span class="comment">// 前 3 个元素</span></span><br><span class="line">    <span class="built_in">print</span>(s);  <span class="comment">// 1 2 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>std::bit_cast</code></strong>
<ul>
<li><strong>功能</strong>：类型安全的位转换。</li>
<li><strong>使用场景</strong>：低级数据处理。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bit&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">uint32_t</span> i = std::<span class="built_in">bit_cast</span>&lt;<span class="type">uint32_t</span>&gt;(f);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Float as uint32_t: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1065353216</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4
id="日历和时区支持stdchrono-扩展"><strong>日历和时区支持（<code>std::chrono</code>
扩展）</strong></h4>
<ul>
<li><strong>功能</strong>：支持日期和时区操作。</li>
<li><strong>使用场景</strong>：时间相关应用。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">auto</span> now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Now: &quot;</span> &lt;&lt; now.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> today = <span class="built_in">floor</span>&lt;days&gt;(now);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Year: &quot;</span> &lt;&lt; year_month_day&#123;today&#125;.<span class="built_in">year</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h2 id="其他特性总结"><strong>3. 其他特性总结</strong></h2>
<h3 id="标准库扩展"><strong>标准库扩展</strong></h3>
<ul>
<li><strong>功能</strong>：STL 提供容器（如
<code>vector</code>）、算法、I/O 等。</li>
<li><strong>使用场景</strong>：日常编程。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nString: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="编译器特性"><strong>编译器特性</strong></h3>
<ul>
<li><strong>属性（<code>[[nodiscard]]</code> 等）</strong>
<ul>
<li><p><strong>功能</strong>：提供编译器提示。</p></li>
<li><p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// func();  // 警告：忽略返回值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h1 id="问题研究">问题研究</h1>
<h2 id="c-如何实现多态">C++ 如何实现多态</h2>
<p>在 C++
中，多态（Polymorphism）是面向对象编程的核心特性之一，它允许在运行时根据对象的实际类型执行不同的行为。C++
主要通过 <strong>虚函数（Virtual Functions）</strong> 和
<strong>继承（Inheritance）</strong> 实现多态，尤其是
<strong>运行时多态（Runtime
Polymorphism）</strong>，也称为动态多态。下面我将详细讲解 C++
如何实现多态及其底层原理，包括实现机制、使用场景、示例代码和注意事项。</p>
<hr />
<h3 id="c-多态的分类"><strong>1. C++ 多态的分类</strong></h3>
<p>C++ 中的多态分为两种：</p>
<ul>
<li><strong>编译时多态（Compile-time Polymorphism）</strong>：
<ul>
<li>通过 <strong>函数重载（Function Overloading）</strong> 和
<strong>运算符重载（Operator Overloading）</strong> 实现。</li>
<li>在编译时根据参数类型或数量确定调用哪个函数。</li>
<li><strong>原理</strong>：编译器通过名称修饰（Name
Mangling）生成唯一的函数签名。</li>
<li>示例（不展开，因为问题聚焦运行时多态）： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>);     <span class="comment">// Int: 5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);  <span class="comment">// Double: 3.14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>运行时多态（Runtime Polymorphism）</strong>：
<ul>
<li>通过 <strong>虚函数</strong> 和 <strong>基类指针/引用</strong>
实现。</li>
<li>在运行时根据对象的实际类型决定调用哪个函数。</li>
<li>这是本文重点讲解的内容。</li>
</ul></li>
</ul>
<hr />
<h3 id="运行时多态的实现方式"><strong>2.
运行时多态的实现方式</strong></h3>
<p>C++ 通过以下机制实现运行时多态： -
<strong>继承</strong>：定义基类和派生类，形成层次结构。 -
<strong>虚函数</strong>：在基类中使用 <code>virtual</code>
关键字声明函数，派生类可以重写（Override）。 -
<strong>基类指针或引用</strong>：通过基类类型的指针或引用调用虚函数。</p>
<h4 id="关键字和语法"><strong>关键字和语法</strong></h4>
<ul>
<li><strong><code>virtual</code></strong>：标记函数为虚函数，启用动态分派。</li>
<li><strong><code>override</code></strong>（C++11）：显式声明派生类重写基类虚函数（可选，但推荐）。</li>
<li><strong><code>final</code></strong>（C++11）：禁止进一步重写虚函数或继承类（可选）。</li>
</ul>
<h4 id="基本示例-1"><strong>基本示例</strong></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">// 虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base speaking\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;  <span class="comment">// 虚析构函数（重要）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived speaking\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    ptr-&gt;<span class="built_in">speak</span>();  <span class="comment">// 输出 &quot;Derived speaking&quot;</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;    <span class="comment">// 正确调用 Derived 的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Derived speaking</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，尽管 <code>ptr</code> 是 <code>Base*</code>
类型，但调用 <code>speak()</code> 时执行了 <code>Derived</code>
的版本，这就是运行时多态。</p>
<hr />
<h3 id="多态的底层原理虚函数表vtable"><strong>3.
多态的底层原理：虚函数表（vtable）</strong></h3>
<p>C++ 使用 <strong>虚函数表（Virtual Function Table，简称
vtable）</strong> 和 <strong>虚表指针（vptr）</strong>
来实现运行时多态。以下是详细原理：</p>
<h4 id="虚函数表的概念"><strong>3.1 虚函数表的概念</strong></h4>
<ul>
<li><strong>定义</strong>：每个包含虚函数的类在编译时会生成一个虚函数表（vtable），这是一个函数指针数组，存储该类所有虚函数的地址。</li>
<li><strong>内容</strong>：vtable
中按声明顺序存储虚函数的地址，派生类重写虚函数时会替换对应位置的地址。</li>
<li><strong>唯一性</strong>：每个类（而不是每个对象）拥有一个唯一的
vtable，共享给所有该类实例。</li>
</ul>
<h4 id="虚表指针vptr"><strong>3.2 虚表指针（vptr）</strong></h4>
<ul>
<li><strong>定义</strong>：每个包含虚函数的对象在内存中额外存储一个指向其类
vtable 的指针（vptr）。</li>
<li><strong>位置</strong>：vptr
通常存储在对象内存布局的开头（具体位置由编译器决定）。</li>
<li><strong>初始化</strong>：在对象构造时，构造函数会将 vptr
设置为指向该类的 vtable。</li>
</ul>
<h4 id="运行时分派的流程"><strong>3.3 运行时分派的流程</strong></h4>
<ol type="1">
<li><strong>对象创建</strong>：
<ul>
<li>创建 <code>Derived</code> 对象时，<code>Derived</code> 的构造函数将
vptr 设置为指向 <code>Derived</code> 的 vtable。</li>
<li><code>Derived</code> 的 vtable 中，<code>speak()</code> 的地址是
<code>Derived::speak</code> 的实现。</li>
</ul></li>
<li><strong>虚函数调用</strong>：
<ul>
<li>通过 <code>Base* ptr</code> 调用 <code>ptr-&gt;speak()</code>。</li>
<li>编译器生成代码，访问 <code>ptr</code> 指向对象的 vptr。</li>
<li>根据 vptr 找到 <code>Derived</code> 的 vtable。</li>
<li>从 vtable 中提取 <code>speak()</code>
的函数地址（偏移固定，由编译器确定）。</li>
<li>调用该地址对应的函数（即 <code>Derived::speak</code>）。</li>
</ul></li>
<li><strong>销毁对象</strong>：
<ul>
<li>删除对象时，虚析构函数确保按正确顺序调用析构函数（从派生类到基类）。</li>
</ul></li>
</ol>
<h4 id="内存布局示意图"><strong>内存布局示意图</strong></h4>
<p>假设 <code>Base</code> 和 <code>Derived</code> 的定义如上： -
<strong>Base 类 vtable</strong>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0]: Base::speak</span><br><span class="line">[1]: Base::~Base</span><br></pre></td></tr></table></figure> - <strong>Derived 类
vtable</strong>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0]: Derived::speak  // 重写</span><br><span class="line">[1]: Derived::~Derived</span><br></pre></td></tr></table></figure> - <strong>对象内存</strong>：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Derived 对象：</span><br><span class="line">| vptr (指向 Derived 的 vtable) |</span><br><span class="line">| 数据成员（若有）            |</span><br></pre></td></tr></table></figure></p>
<h4 id="编译器如何处理"><strong>3.4 编译器如何处理</strong></h4>
<ul>
<li><strong>静态代码</strong>：编译器为每个虚函数调用生成间接调用指令（如
<code>call [vptr + offset]</code>）。</li>
<li><strong>动态分派</strong>：运行时通过 vptr 和 vtable
确定实际函数地址。</li>
</ul>
<hr />
<h3 id="详细示例与验证"><strong>4. 详细示例与验证</strong></h3>
<p>以下代码展示多态的实现，并通过调试手段验证 vtable 的存在：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::func1\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::func2\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::func1\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::func2\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b1 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* b2 = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Calling through Base pointer:\n&quot;</span>;</span><br><span class="line">    b1-&gt;<span class="built_in">func1</span>();  <span class="comment">// Base::func1</span></span><br><span class="line">    b1-&gt;<span class="built_in">func2</span>();  <span class="comment">// Base::func2</span></span><br><span class="line">    b2-&gt;<span class="built_in">func1</span>();  <span class="comment">// Derived::func1</span></span><br><span class="line">    b2-&gt;<span class="built_in">func2</span>();  <span class="comment">// Derived::func2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> b1;  <span class="comment">// Base destroyed</span></span><br><span class="line">    <span class="keyword">delete</span> b2;  <span class="comment">// Derived destroyed -&gt; Base destroyed</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用引用</span></span><br><span class="line">    Derived d;</span><br><span class="line">    Base&amp; ref = d;</span><br><span class="line">    ref.<span class="built_in">func1</span>();  <span class="comment">// Derived::func1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calling through Base pointer:</span><br><span class="line">Base::func1</span><br><span class="line">Base::func2</span><br><span class="line">Derived::func1</span><br><span class="line">Derived::func2</span><br><span class="line">Base destroyed</span><br><span class="line">Derived destroyed</span><br><span class="line">Base destroyed</span><br><span class="line">Derived::func1</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>验证 vtable</strong>：在调试器（如 GDB 或 Visual
Studio）中检查对象地址，会发现额外指针（vptr），其值指向 vtable。可以用
<code>sizeof</code> 检查对象大小： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of Base: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; <span class="string">&quot;\n&quot;</span>;    <span class="comment">// 通常 8（vptr）</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of Derived: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Derived) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 通常 8（共享 vptr）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="注意事项与限制"><strong>5. 注意事项与限制</strong></h3>
<ul>
<li><strong>虚函数的开销</strong>：
<ul>
<li><strong>空间开销</strong>：每个对象增加一个 vptr（通常 4 或 8
字节），每个类一个 vtable。</li>
<li><strong>时间开销</strong>：虚函数调用需要间接寻址，比直接调用慢。</li>
</ul></li>
<li><strong>虚析构函数</strong>：
<ul>
<li>如果基类析构函数不是虚函数，通过基类指针删除派生类对象只会调用基类析构函数，导致资源泄漏。</li>
<li>示例（错误情况）： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">public</span>: ~<span class="built_in">Base</span>() &#123;&#125; &#125;;  <span class="comment">// 非虚析构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="keyword">public</span>: ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived\n&quot;</span>; &#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;  <span class="comment">// 只调用 Base::~Base，Derived::~Derived 被跳过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>纯虚函数（<code>= 0</code>）</strong>：
<ul>
<li>定义抽象类，强制派生类实现。</li>
<li>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Abstract</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mustImplement</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>非虚函数</strong>：通过基类指针调用时，始终执行基类版本，不实现多态。</li>
<li><strong>多重继承</strong>：
<ul>
<li>多继承下，每个基类的 vtable 独立，对象可能有多个 vptr。</li>
</ul></li>
</ul>
<hr />
<h3 id="多态的使用场景"><strong>6. 多态的使用场景</strong></h3>
<ul>
<li><strong>插件系统</strong>：基类定义接口，派生类实现具体功能。</li>
<li><strong>策略模式</strong>：运行时切换行为。</li>
<li><strong>框架设计</strong>：如 GUI 框架中，基类
<code>Widget</code>，派生类
<code>Button</code>、<code>TextBox</code>。</li>
</ul>
<hr />
<h3 id="总结-4"><strong>7. 总结</strong></h3>
<ul>
<li><strong>如何实现</strong>：C++
通过虚函数和基类指针/引用实现运行时多态。</li>
<li><strong>原理</strong>：依赖虚函数表（vtable）和虚表指针（vptr），编译器生成间接调用，运行时根据对象类型分派。</li>
<li><strong>关键点</strong>：需要 <code>virtual</code>
关键字、继承体系和动态绑定。</li>
<li><strong>优势</strong>：灵活性高，支持扩展。</li>
<li><strong>代价</strong>：增加内存和性能开销。</li>
</ul>
<p>如果需要更深入探讨（如 vtable
的内存布局、多继承下的实现，或性能分析），请告诉我，我可以进一步扩展！</p>
<h3 id="示意图">8. 示意图</h3>
<p>好的，我将使用 Mermaid 语法为你绘制 C++ 多态底层原理的图示，展示
<strong>虚函数表（vtable）</strong> 和 <strong>虚表指针（vptr）</strong>
的工作机制。由于 Mermaid
是一种基于文本的绘图工具，我会尽量清晰地表达多态的内存布局和调用流程。</p>
<p>以下是两种图： 1. <strong>类层次结构和 vtable
的关系图</strong>：展示基类和派生类的虚函数表。 2.
<strong>对象内存布局和调用流程图</strong>：展示对象中的 vptr 如何指向
vtable 并实现动态分派。</p>
<hr />
<h4 id="图-1类层次结构和虚函数表的关系"><strong>图
1：类层次结构和虚函数表的关系</strong></h4>
<p>这个图展示了 <code>Base</code> 和 <code>Derived</code>
类的继承关系，以及它们的 vtable 如何存储虚函数地址。</p>
<pre><code class="highlight mermaid">classDiagram
    class Base &#123;
        +speak()
        +~Base()
        -vptr
    &#125;
    class Derived &#123;
        +speak()
        +~Derived()
        -vptr
    &#125;
    Derived --|&gt; Base : 继承

    class Base_vtable &#123;
        +speak
        +~Base
    &#125;
    class Derived_vtable &#123;
        +speak
        +~Derived
    &#125;

    Base --&gt; Base_vtable
    Derived --&gt; Derived_vtable</code></pre>
<h5 id="解释"><strong>解释</strong></h5>
<ul>
<li><strong>Base 和 Derived 类</strong>：<code>Base</code>
是基类，<code>Derived</code> 是派生类，通过继承关系连接。</li>
<li><strong>虚函数表（vtable）</strong>：
<ul>
<li><code>Base_vtable</code>：存储 <code>Base::speak</code> 和
<code>Base::~Base</code> 的地址。</li>
<li><code>Derived_vtable</code>：存储 <code>Derived::speak</code> 和
<code>Derived::~Derived</code> 的地址，<code>speak</code> 被重写。</li>
</ul></li>
<li><strong>vptr</strong>：每个类实例包含一个虚表指针，指向其对应的
vtable。</li>
</ul>
<hr />
<h4 id="图-2对象内存布局和调用流程"><strong>图
2：对象内存布局和调用流程</strong></h4>
<p>这个图展示了 <code>Base* ptr = new Derived()</code>
的内存布局和运行时调用 <code>ptr-&gt;speak()</code> 的流程。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Main as main()
    participant Ptr as Base* ptr
    participant Obj as Derived 对象
    participant Vptr as vptr
    participant Vtable as Derived_vtable

    Main-&gt;&gt;Ptr: ptr = new Derived()
    Note right of Ptr: 分配 Derived 对象
    Ptr-&gt;&gt;Obj: 构造 Derived
    Obj-&gt;&gt;Vptr: 设置 vptr 指向 Derived_vtable
    Vptr-&gt;&gt;Vtable: 关联

    Main-&gt;&gt;Ptr: ptr-&gt;speak()
    Ptr-&gt;&gt;Obj: 访问对象
    Obj-&gt;&gt;Vptr: 获取 vptr
    Vptr-&gt;&gt;Vtable: 查找 vtable
    Vtable--&gt;&gt;Main: 调用 Derived::speak()

    Main-&gt;&gt;Ptr: delete ptr
    Ptr-&gt;&gt;Obj: 析构
    Obj-&gt;&gt;Vptr: 获取 vptr
    Vptr-&gt;&gt;Vtable: 调用 Derived::~Derived()
    Vtable--&gt;&gt;Obj: 完成析构</code></pre>
<h5 id="内存布局示意图-1"><strong>内存布局示意图</strong></h5>
<p>由于 Mermaid 不直接支持内存布局图，我用文本描述并结合上图解释：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Derived 对象内存布局：</span><br><span class="line">+-------------------+</span><br><span class="line">| vptr (指向 Derived_vtable) |  &lt;- 虚表指针</span><br><span class="line">+-------------------+</span><br><span class="line">| 数据成员（若有）   |</span><br><span class="line">+-------------------+</span><br><span class="line"></span><br><span class="line">Derived_vtable：</span><br><span class="line">+-------------------+</span><br><span class="line">| [0] Derived::speak |  &lt;- 虚函数地址</span><br><span class="line">| [1] Derived::~Derived |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure></p>
<h5 id="解释-1"><strong>解释</strong></h5>
<ul>
<li><strong>对象创建</strong>：
<ul>
<li><code>new Derived()</code> 创建对象，构造函数设置 <code>vptr</code>
指向 <code>Derived_vtable</code>。</li>
</ul></li>
<li><strong>虚函数调用</strong>：
<ul>
<li><code>ptr-&gt;speak()</code>：通过 <code>ptr</code> 访问对象，找到
<code>vptr</code>。</li>
<li><code>vptr</code> 指向 <code>Derived_vtable</code>，表中
<code>[0]</code> 是 <code>Derived::speak</code> 的地址。</li>
<li>调用该地址，执行 <code>Derived::speak</code>。</li>
</ul></li>
<li><strong>对象销毁</strong>：
<ul>
<li><code>delete ptr</code>：通过 <code>vptr</code> 找到
<code>Derived_vtable</code>，调用 <code>Derived::~Derived</code>。</li>
</ul></li>
</ul>
<hr />
<h4 id="代码验证"><strong>代码验证</strong></h4>
<p>以下代码与图对应，供参考： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base speaking\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived speaking\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">speak</span>();  <span class="comment">// 通过 vtable 调用 Derived::speak</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;    <span class="comment">// 通过 vtable 调用 Derived::~Derived</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Derived speaking</span><br><span class="line">Derived destroyed</span><br><span class="line">Base destroyed</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-5"><strong>总结</strong></h4>
<ul>
<li><strong>图 1</strong> 展示了类与 vtable
的静态关系，说明多态依赖继承和虚函数重写。</li>
<li><strong>图 2</strong> 展示了运行时动态分派的过程，强调 vptr 和
vtable 的作用。</li>
<li><strong>原理</strong>：C++
通过虚函数表和虚表指针实现运行时多态，确保基类指针能正确调用派生类的函数。</li>
</ul>
<p>如果需要调整图表内容、增加细节（如多继承的
vtable）或进一步解释，请告诉我！</p>
<h2 id="c-的模板和-java-的泛型比较">C++ 的模板和 Java 的泛型比较</h2>
<p>在编程语言中，C++ 的模板（Templates）和 Java
的泛型（Generics）都是为了实现代码的通用性和类型安全而设计的机制，但它们的实现方式、设计理念和使用场景有显著差异。以下从多个方面对它们进行比较，用中文详细讲解。</p>
<hr />
<h3 id="基本概念">1. <strong>基本概念</strong></h3>
<ul>
<li><p><strong>C++ 模板</strong>：</p>
<ul>
<li>C++
的模板是一种编译时（compile-time）的机制，允许开发者编写与类型无关的代码。</li>
<li>它是基于“代码生成”的思想：编译器在编译时根据模板参数生成具体的代码（称为“模板实例化”）。</li>
<li>模板可以用于类（类模板）、函数（函数模板）以及变量（C++14
引入变量模板）。</li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);      <span class="comment">// 实例化为 add&lt;int&gt;</span></span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">add</span>(<span class="number">1.5</span>, <span class="number">2.5</span>); <span class="comment">// 实例化为 add&lt;double&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Java 泛型</strong>：</p>
<ul>
<li>Java 的泛型是一种运行时（runtime）支持的机制，引入于 Java
5，主要用于提高类型安全性，避免运行时类型转换错误。</li>
<li>它是基于“类型擦除”（type
erasure）的实现：在编译时，泛型信息会被擦除，生成的字节码中只保留原始类型（raw
type），通过类型检查确保安全性。</li>
<li>泛型主要用于类、接口和方法。</li>
</ul>
<p>示例： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Box&lt;Integer&gt; intBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">    intBox.set(<span class="number">10</span>);</span><br><span class="line">    System.out.println(intBox.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h3 id="实现机制">2. <strong>实现机制</strong></h3>
<ul>
<li><strong>C++ 模板</strong>：
<ul>
<li><strong>编译时实例化</strong>：每次使用不同的类型调用模板时，编译器会生成一份新的代码。例如，<code>add&lt;int&gt;</code>
和 <code>add&lt;double&gt;</code> 会生成两份独立的函数。</li>
<li><strong>无类型擦除</strong>：模板保留所有类型信息，编译器完全知道每个实例的具体类型。</li>
<li><strong>鸭子类型（Duck
Typing）</strong>：模板不要求类型实现特定接口，只要代码在语法上有效（比如支持
<code>+</code> 操作），编译就能通过。这也可能导致晦涩的错误信息。</li>
</ul></li>
<li><strong>Java 泛型</strong>：
<ul>
<li><strong>类型擦除</strong>：编译后，泛型类型信息被擦除，<code>Box&lt;Integer&gt;</code>
和 <code>Box&lt;String&gt;</code> 在字节码中都是
<code>Box</code>，只不过编译器插入了必要的类型转换（如
<code>(Integer)</code>）。</li>
<li><strong>运行时统一</strong>：由于擦除，运行时无法直接获取泛型参数的类型（需要通过反射绕过）。</li>
<li><strong>类型约束</strong>：泛型通常需要通过 <code>extends</code> 或
<code>super</code> 指定类型边界，要求类型实现特定接口或继承特定类。</li>
</ul></li>
</ul>
<hr />
<h3 id="灵活性与约束">3. <strong>灵活性与约束</strong></h3>
<ul>
<li><strong>C++ 模板</strong>：
<ul>
<li><strong>灵活性极高</strong>：可以用于任何类型，甚至包括基本类型（如
<code>int</code>、<code>double</code>），无需显式约束。</li>
<li><strong>支持非类型参数</strong>：模板不仅支持类型参数，还支持整数、指针等非类型参数。
示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[N];</span><br><span class="line">&#125;;</span><br><span class="line">Array&lt;<span class="number">5</span>&gt; arr; <span class="comment">// 固定大小数组</span></span><br></pre></td></tr></table></figure></li>
<li><strong>缺点</strong>：缺乏运行时类型检查，错误通常在编译时暴露，且错误信息可能复杂难懂。</li>
</ul></li>
<li><strong>Java 泛型</strong>：
<ul>
<li><strong>约束较多</strong>：不支持基本类型（如
<code>int</code>、<code>double</code>），必须使用包装类（如
<code>Integer</code>、<code>Double</code>），因为泛型基于对象。</li>
<li><strong>不支持非类型参数</strong>：只能使用类型参数，无法像 C++
那样用常量值作为模板参数。</li>
<li><strong>优点</strong>：通过类型擦除和编译时检查，保证了运行时的类型安全，且错误信息通常更直观。</li>
</ul></li>
</ul>
<hr />
<h3 id="性能">4. <strong>性能</strong></h3>
<ul>
<li><strong>C++ 模板</strong>：
<ul>
<li><strong>零运行时开销</strong>：由于模板在编译时生成具体代码，运行时没有额外的类型检查或转换开销，性能几乎等同于手写特定类型的代码。</li>
<li><strong>代码膨胀</strong>：每个类型实例化都会生成新代码，可能导致二进制文件变大。</li>
</ul></li>
<li><strong>Java 泛型</strong>：
<ul>
<li><strong>运行时开销</strong>：由于类型擦除和潜在的自动装箱/拆箱（如
<code>int</code> 到 <code>Integer</code>），可能引入性能损耗。</li>
<li><strong>代码复用</strong>：字节码中只有一个类定义，不会因为泛型参数不同而重复生成代码，二进制文件更小。</li>
</ul></li>
</ul>
<hr />
<h3 id="使用场景">5. <strong>使用场景</strong></h3>
<ul>
<li><strong>C++ 模板</strong>：
<ul>
<li><strong>高性能通用库</strong>：如
STL（标准模板库）中的容器（<code>vector</code>、<code>map</code>）和算法（<code>sort</code>），充分利用编译时优化。</li>
<li><strong>元编程</strong>：C++
模板支持模板元编程（TMP），可以实现复杂的编译时计算。 示例：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出 120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>Java 泛型</strong>：
<ul>
<li><strong>类型安全容器</strong>：如
<code>List&lt;T&gt;</code>、<code>Map&lt;K, V&gt;</code>，避免运行时类型转换错误。</li>
<li><strong>API 设计</strong>：泛型广泛用于框架和库（如 Java Collections
Framework），提高代码可读性和安全性。</li>
<li><strong>不支持元编程</strong>：由于类型擦除和运行时限制，泛型无法实现像
C++ 那样的编译时计算。</li>
</ul></li>
</ul>
<hr />
<h3 id="优缺点总结">6. <strong>优缺点总结</strong></h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 36%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>C++ 模板</th>
<th>Java 泛型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>实现时机</strong></td>
<td>编译时实例化</td>
<td>编译时检查，运行时擦除</td>
</tr>
<tr class="even">
<td><strong>类型支持</strong></td>
<td>支持基本类型和对象类型</td>
<td>仅支持对象类型（需包装类）</td>
</tr>
<tr class="odd">
<td><strong>灵活性</strong></td>
<td>高，支持非类型参数和元编程</td>
<td>较低，约束较多</td>
</tr>
<tr class="even">
<td><strong>性能</strong></td>
<td>无运行时开销，可能代码膨胀</td>
<td>有装箱/拆箱开销，代码复用好</td>
</tr>
<tr class="odd">
<td><strong>错误检测</strong></td>
<td>编译时，可能信息复杂</td>
<td>编译时，信息较清晰</td>
</tr>
<tr class="even">
<td><strong>运行时类型信息</strong></td>
<td>保留</td>
<td>擦除，需反射获取</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="实际例子对比">7. <strong>实际例子对比</strong></h3>
<ul>
<li><p><strong>C++ 模板</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line">    <span class="built_in">Container</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Container&lt;<span class="type">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">42</span>)</span></span>;      <span class="comment">// 实例化为 Container&lt;int&gt;</span></span><br><span class="line">    <span class="function">Container&lt;<span class="type">double</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">3.14</span>)</span></span>; <span class="comment">// 实例化为 Container&lt;double&gt;</span></span><br><span class="line">    c<span class="number">1.</span><span class="built_in">print</span>(); <span class="comment">// 输出 42</span></span><br><span class="line">    c<span class="number">2.</span><span class="built_in">print</span>(); <span class="comment">// 输出 3.14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Java 泛型</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Container</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Container</span><span class="params">(T v)</span> &#123; <span class="built_in">this</span>.value = v; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123; System.out.println(value); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Container&lt;Integer&gt; c1 = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;&gt;(<span class="number">42</span>);</span><br><span class="line">    Container&lt;Double&gt; c2 = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;&gt;(<span class="number">3.14</span>);</span><br><span class="line">    c1.print(); <span class="comment">// 输出 42</span></span><br><span class="line">    c2.print(); <span class="comment">// 输出 3.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>区别</strong>：C++
生成两个不同类（<code>Container&lt;int&gt;</code> 和
<code>Container&lt;double&gt;</code>），Java
生成单一字节码，运行时靠类型检查。</li>
</ul></li>
</ul>
<hr />
<h3 id="结论">8. <strong>结论</strong></h3>
<ul>
<li><strong>C++
模板</strong>更适合追求性能和灵活性的场景，尤其是嵌入式系统或高性能计算。它提供了强大的编译时能力，但需要开发者处理复杂的编译错误。</li>
<li><strong>Java
泛型</strong>更适合注重类型安全和代码简洁性的场景，适用于企业级应用和需要运行时一致性的环境，但牺牲了一些灵活性和性能。</li>
</ul>
<p>两者各有千秋，选择哪种取决于项目需求和语言生态。如果你有具体的应用场景想讨论，可以告诉我，我再深入分析！</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Java</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java.html</url>
    <content><![CDATA[<h1 id="语法树">语法树</h1>
<pre><code class="highlight mermaid">graph LR
    A[Java 语法概览]

    %% 1. 基础语法特性 (Java SE 1.0-7)
    A --&gt; B[基础语法特性&lt;br&gt;Java SE 1.0-7]
    B --&gt; B1[基本数据类型]
    B1 --&gt; B1a[&quot;整型: byte, short, int, long&quot;]
    B1 --&gt; B1b[&quot;浮点型: float, double&quot;]
    B1 --&gt; B1c[&quot;字符型: char&quot;]
    B1 --&gt; B1d[&quot;布尔型: boolean&quot;]
    
    B --&gt; B2[变量与常量]
    B2 --&gt; B2a[&quot;变量声明与定义&quot;]
    B2 --&gt; B2b[&quot;常量: final&quot;]
    
    B --&gt; B3[运算符]
    B3 --&gt; B3a[&quot;算术运算符: +, -, *, /, %&quot;]
    B3 --&gt; B3b[&quot;关系运算符: ==, !=, &amp;lt;, &amp;gt;&quot;]
    B3 --&gt; B3c[&quot;逻辑运算符: &amp;amp;&amp;amp;, ||, !&quot;]
    B3 --&gt; B3d[&quot;位运算符: &amp;amp;, |, ^, ~, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;&quot;]
    B3 --&gt; B3e[&quot;赋值运算符: =, +=, -=&quot;]
    B3 --&gt; B3f[&quot;其他: instanceof, ternary ?:&quot;]
    
    B --&gt; B4[控制结构]
    B4 --&gt; B4a[&quot;条件语句: if, else&quot;]
    B4 --&gt; B4b[&quot;开关语句: switch, case&quot;]
    B4 --&gt; B4c[&quot;循环: for, while, do-while&quot;]
    B4 --&gt; B4d[&quot;跳转: break, continue, return&quot;]
    
    B --&gt; B5[函数与方法]
    B5 --&gt; B5a[&quot;方法定义与调用&quot;]
    B5 --&gt; B5b[&quot;参数传递: 值传递&quot;]
    B5 --&gt; B5c[&quot;方法重载&quot;]
    
    B --&gt; B6[类与对象]
    B6 --&gt; B6a[&quot;类定义: class&quot;]
    B6 --&gt; B6b[&quot;访问控制: public, private, protected&quot;]
    B6 --&gt; B6c[&quot;构造函数&quot;]
    B6 --&gt; B6d[&quot;静态成员: static&quot;]
    B6 --&gt; B6e[&quot;继承: extends&quot;]
    B6 --&gt; B6f[&quot;多态性: override&quot;]
    B6 --&gt; B6g[&quot;接口: interface&quot;]
    B6 --&gt; B6h[&quot;抽象类: abstract&quot;]
    
    B --&gt; B7[包与命名空间]
    B7 --&gt; B7a[&quot;包定义: package&quot;]
    B7 --&gt; B7b[&quot;导入: import&quot;]
    
    B --&gt; B8[异常处理]
    B8 --&gt; B8a[&quot;try, catch, finally&quot;]
    B8 --&gt; B8b[&quot;throw, throws&quot;]
    B8 --&gt; B8c[&quot;自定义异常&quot;]
    
    B --&gt; B9[泛型]
    B9 --&gt; B9a[&quot;泛型类&quot;]
    B9 --&gt; B9b[&quot;泛型方法&quot;]
    B9 --&gt; B9c[&quot;通配符: ?, extends, super&quot;]
    
    B --&gt; B10[动态内存管理]
    B10 --&gt; B10a[&quot;new&quot;]
    
    B --&gt; B11[注解]
    B11 --&gt; B11a[&quot;内置注解: @Override, @Deprecated&quot;]
    B11 --&gt; B11b[&quot;自定义注解&quot;]

    %% 2. 现代 Java 新特性
    A --&gt; C[现代 Java 新特性]
    
    C --&gt; C1[Java 8]
    C1 --&gt; C1a[&quot;Lambda 表达式&quot;]
    C1 --&gt; C1b[&quot;函数式接口: @FunctionalInterface&quot;]
    C1 --&gt; C1c[&quot;Stream API&quot;]
    C1 --&gt; C1d[&quot;Optional 类&quot;]
    C1 --&gt; C1e[&quot;默认方法: default&quot;]
    C1 --&gt; C1f[&quot;静态方法: 接口中 static&quot;]
    C1 --&gt; C1g[&quot;方法引用: ::&quot;]
    C1 --&gt; C1h[&quot;日期时间 API: java.time&quot;]
    
    C --&gt; C2[Java 9]
    C2 --&gt; C2a[&quot;模块化: module-info.java&quot;]
    C2 --&gt; C2b[&quot;私有接口方法&quot;]
    C2 --&gt; C2c[&quot;try-with-resources 改进&quot;]
    C2 --&gt; C2d[&quot;集合工厂方法: List.of()&quot;]
    
    C --&gt; C3[Java 10]
    C3 --&gt; C3a[&quot;局部变量类型推导: var&quot;]
    
    C --&gt; C4[Java 11]
    C4 --&gt; C4a[&quot;字符串增强: strip(), lines()&quot;]
    C4 --&gt; C4b[&quot;HTTP Client API&quot;]
    
    C --&gt; C5[Java 14]
    C5 --&gt; C5a[&quot;Switch 表达式&quot;]
    C5 --&gt; C5b[&quot;instanceof 模式匹配&quot;]
    
    C --&gt; C6[Java 15]
    C6 --&gt; C6a[&quot;文本块: &quot;&quot;&quot;...&quot;&quot;&quot;&quot;]
    
    C --&gt; C7[Java 17]
    C7 --&gt; C7a[&quot;密封类: sealed, permits&quot;]
    C7 --&gt; C7b[&quot;模式匹配 Switch (预览)&quot;]
    
    C --&gt; C8[Java 21]
    C8 --&gt; C8a[&quot;虚拟线程&quot;]
    C8 --&gt; C8b[&quot;结构化并发&quot;]
    C8 --&gt; C8c[&quot;记录模式匹配&quot;]

    %% 3. 其他特性
    A --&gt; D[其他特性]
    D --&gt; D1[标准库扩展&lt;br&gt;Java SE 1.0+]
    D1 --&gt; D1a[&quot;集合框架: List, Map, Set&quot;]
    D1 --&gt; D1b[&quot;输入输出: java.io, java.nio&quot;]
    D1 --&gt; D1c[&quot;并发库: java.util.concurrent&quot;]
    D1 --&gt; D1d[&quot;字符串: String, StringBuilder&quot;]
    
    D --&gt; D2[编译器与运行时]
    D2 --&gt; D2a[&quot;JVM: 垃圾回收&quot;]
    D2 --&gt; D2b[&quot;反射: java.lang.reflect&quot;]</code></pre>
<h1 id="详解">详解</h1>
<h2 id="基础语法特性-java-se-1.0-7">1. 基础语法特性 (Java SE 1.0-7)</h2>
<h3 id="基本数据类型">1.1 基本数据类型</h3>
<h4 id="整型-byte-short-int-long">1.1.1 整型 (<code>byte</code>,
<code>short</code>, <code>int</code>, <code>long</code>)</h4>
<ul>
<li><strong>功能</strong>：表示整数值，范围分别为 8 位、16 位、32 位和
64 位。</li>
<li><strong>使用场景</strong>：存储数值数据，如计数器、索引、文件大小。</li>
<li><strong>底层原理</strong>：在 JVM
中存储为二进制补码，<code>long</code> 需要加 <code>L</code>
后缀以区分。</li>
<li><strong>注意事项</strong>：注意溢出问题，<code>byte</code> 范围为
-128 到 127。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerTypes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2147483647</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">9223372036854775807L</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;byte: &quot;</span> + b + <span class="string">&quot;, int: &quot;</span> + i + <span class="string">&quot;, long: &quot;</span> + l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="浮点型-float-double">1.1.2 浮点型 (<code>float</code>,
<code>double</code>)</h4>
<ul>
<li><strong>功能</strong>：表示浮点数，<code>float</code> 32
位，<code>double</code> 64 位。</li>
<li><strong>使用场景</strong>：科学计算、图形处理、需要小数运算的场景。</li>
<li><strong>底层原理</strong>：遵循 IEEE 754
浮点标准，分为符号、指数和尾数。</li>
<li><strong>注意事项</strong>：<code>float</code> 需要加 <code>f</code>
后缀，避免精度丢失问题。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloatTypes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14159</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;float: &quot;</span> + f + <span class="string">&quot;, double: &quot;</span> + d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="字符型-char">1.1.3 字符型 (<code>char</code>)</h4>
<ul>
<li><strong>功能</strong>：表示单个 Unicode 字符（16 位）。</li>
<li><strong>使用场景</strong>：处理单个字符，如字母、符号。</li>
<li><strong>底层原理</strong>：存储为无符号整数，对应 Unicode
编码。</li>
<li><strong>注意事项</strong>：范围为 0 到 65535，可用 <code>\u</code>
表示 Unicode。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">unicode</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;char: &quot;</span> + c + <span class="string">&quot;, unicode: &quot;</span> + unicode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="布尔型-boolean">1.1.4 布尔型 (<code>boolean</code>)</h4>
<ul>
<li><strong>功能</strong>：表示真假值（<code>true</code> 或
<code>false</code>）。</li>
<li><strong>使用场景</strong>：条件判断、标志位。</li>
<li><strong>底层原理</strong>：JVM 实现中通常占 1
位，但实际大小取决于实现。</li>
<li><strong>注意事项</strong>：不能与整数直接转换。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BooleanType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;boolean: &quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="变量与常量">1.2 变量与常量</h3>
<h4 id="变量声明与定义">1.2.1 变量声明与定义</h4>
<ul>
<li><strong>功能</strong>：分配内存并命名，用于存储数据。</li>
<li><strong>使用场景</strong>：任何需要临时存储数据的场景。</li>
<li><strong>底层原理</strong>：在栈或堆中分配内存，类型决定大小。</li>
<li><strong>注意事项</strong>：局部变量必须初始化，类变量有默认值。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableDeclaration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x: &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="常量-final">1.2.2 常量 (<code>final</code>)</h4>
<ul>
<li><strong>功能</strong>：定义不可修改的值。</li>
<li><strong>使用场景</strong>：定义数学常数、配置值。</li>
<li><strong>底层原理</strong>：编译时替换为字面量，运行时不可变。</li>
<li><strong>注意事项</strong>：必须在声明时或构造函数中初始化。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PI: &quot;</span> + PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="运算符">1.3 运算符</h3>
<h4 id="算术运算符--">1.3.1 算术运算符 (<code>+</code>, <code>-</code>,
<code>*</code>, <code>/</code>, <code>%</code>)</h4>
<ul>
<li><strong>功能</strong>：执行基本数学运算。</li>
<li><strong>使用场景</strong>：计算、数值处理。</li>
<li><strong>底层原理</strong>：基于 CPU 算术逻辑单元（ALU）执行。</li>
<li><strong>注意事项</strong>：除以 0 会抛出
<code>ArithmeticException</code>。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticOperators</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a + b = &quot;</span> + (a + b));</span><br><span class="line">        System.out.println(<span class="string">&quot;a % b = &quot;</span> + (a % b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="关系运算符">1.3.2 关系运算符 (<code>==</code>, <code>!=</code>,
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
<code>&gt;=</code>)</h4>
<ul>
<li><strong>功能</strong>：比较两个值，返回布尔结果。</li>
<li><strong>使用场景</strong>：条件判断、排序。</li>
<li><strong>底层原理</strong>：比较内存中的二进制值。</li>
<li><strong>注意事项</strong>：对象用 <code>equals()</code> 而非
<code>==</code>。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RelationalOperators</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a &gt; b: &quot;</span> + (a &gt; b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="逻辑运算符">1.3.3 逻辑运算符 (<code>&amp;&amp;</code>,
<code>||</code>, <code>!</code>)</h4>
<ul>
<li><strong>功能</strong>：组合布尔表达式。</li>
<li><strong>使用场景</strong>：多条件判断。</li>
<li><strong>底层原理</strong>：短路求值，<code>&amp;&amp;</code>
前为假则不计算后。</li>
<li><strong>注意事项</strong>：确保操作数是布尔值。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogicalOperators</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">true</span>, y = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x &amp;&amp; y: &quot;</span> + (x &amp;&amp; y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="位运算符">1.3.4 位运算符 (<code>&amp;</code>, <code>|</code>,
<code>^</code>, <code>~</code>, <code>&lt;&lt;</code>,
<code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>)</h4>
<ul>
<li><strong>功能</strong>：按位操作整数。</li>
<li><strong>使用场景</strong>：位标志、低级优化。</li>
<li><strong>底层原理</strong>：直接操作二进制位。</li>
<li><strong>注意事项</strong>：<code>&gt;&gt;&gt;</code>
是无符号右移。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitOperators</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 0101</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a &lt;&lt; 1: &quot;</span> + (a &lt;&lt; <span class="number">1</span>)); <span class="comment">// 1010</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="赋值运算符--">1.3.5 赋值运算符 (<code>=</code>, <code>+=</code>,
<code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>)</h4>
<ul>
<li><strong>功能</strong>：赋值或复合运算。</li>
<li><strong>使用场景</strong>：更新变量值。</li>
<li><strong>底层原理</strong>：直接修改内存值。</li>
<li><strong>注意事项</strong>：类型需匹配。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssignmentOperators</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        a += <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a: &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="其他运算符-instanceof">1.3.6 其他运算符
(<code>instanceof</code>, <code>?:</code>)</h4>
<ul>
<li><strong>功能</strong>：类型检查（<code>instanceof</code>）和条件选择（<code>?:</code>）。</li>
<li><strong>使用场景</strong>：对象类型判断、三元表达式。</li>
<li><strong>底层原理</strong>：<code>instanceof</code>
检查类层次，<code>?:</code> 是条件分支。</li>
<li><strong>注意事项</strong>：<code>instanceof</code>
不适用于基本类型。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherOperators</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;s instanceof String: &quot;</span> + (s <span class="keyword">instanceof</span> String));</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (x &gt; <span class="number">0</span>) ? <span class="string">&quot;Positive&quot;</span> : <span class="string">&quot;Negative&quot;</span>;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="控制结构">1.4 控制结构</h3>
<h4 id="条件语句-if-else">1.4.1 条件语句 (<code>if</code>,
<code>else</code>)</h4>
<ul>
<li><strong>功能</strong>：根据条件执行代码。</li>
<li><strong>使用场景</strong>：分支逻辑。</li>
<li><strong>底层原理</strong>：JVM 跳转指令（<code>if_icmpeq</code>
等）。</li>
<li><strong>注意事项</strong>：避免嵌套过深。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) System.out.println(<span class="string">&quot;Positive&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;Non-positive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="开关语句-switch-case">1.4.2 开关语句 (<code>switch</code>,
<code>case</code>)</h4>
<ul>
<li><strong>功能</strong>：多分支选择。</li>
<li><strong>使用场景</strong>：固定值匹配。</li>
<li><strong>底层原理</strong>：编译为跳转表或条件分支。</li>
<li><strong>注意事项</strong>：需
<code>break</code>，支持基本类型和枚举。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: System.out.println(<span class="string">&quot;Monday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: System.out.println(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="循环-for-while-do-while">1.4.3 循环 (<code>for</code>,
<code>while</code>, <code>do-while</code>)</h4>
<ul>
<li><strong>功能</strong>：重复执行代码。</li>
<li><strong>使用场景</strong>：迭代、遍历。</li>
<li><strong>底层原理</strong>：跳转和条件检查指令。</li>
<li><strong>注意事项</strong>：避免死循环。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Loops</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) System.out.println(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; <span class="number">2</span>) &#123; System.out.println(x++); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="跳转-break-continue-return">1.4.4 跳转 (<code>break</code>,
<code>continue</code>, <code>return</code>)</h4>
<ul>
<li><strong>功能</strong>：控制循环或方法流程。</li>
<li><strong>使用场景</strong>：提前退出、跳过迭代。</li>
<li><strong>底层原理</strong>：跳转到指定字节码位置。</li>
<li><strong>注意事项</strong>：谨慎使用带标签的
<code>break</code>。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Jumps</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="函数与方法">1.5 函数与方法</h3>
<h4 id="方法定义与调用">1.5.1 方法定义与调用</h4>
<ul>
<li><strong>功能</strong>：封装可重用代码。</li>
<li><strong>使用场景</strong>：逻辑复用。</li>
<li><strong>底层原理</strong>：JVM 调用栈帧。</li>
<li><strong>注意事项</strong>：方法必须在类中。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDef</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(add(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="参数传递-值传递">1.5.2 参数传递 (值传递)</h4>
<ul>
<li><strong>功能</strong>：将参数值传递给方法。</li>
<li><strong>使用场景</strong>：方法输入。</li>
<li><strong>底层原理</strong>：复制变量值，对象传递引用副本。</li>
<li><strong>注意事项</strong>：无法修改原始基本类型变量。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamPassing</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(<span class="type">int</span> x)</span> &#123; x = <span class="number">20</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        modify(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;a: &quot;</span> + a); <span class="comment">// 仍为 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="方法重载">1.5.3 方法重载</h4>
<ul>
<li><strong>功能</strong>：同名方法不同参数。</li>
<li><strong>使用场景</strong>：提高代码灵活性。</li>
<li><strong>底层原理</strong>：编译时根据签名区分。</li>
<li><strong>注意事项</strong>：返回值类型不影响重载。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodOverload</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(add(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(add(<span class="number">2.5</span>, <span class="number">3.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="类与对象">1.6 类与对象</h3>
<h4 id="类定义-class">1.6.1 类定义 (<code>class</code>)</h4>
<ul>
<li><strong>功能</strong>：定义对象模板。</li>
<li><strong>使用场景</strong>：面向对象编程。</li>
<li><strong>底层原理</strong>：编译为字节码，JVM 加载。</li>
<li><strong>注意事项</strong>：类名与文件名一致。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDef</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassDef</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassDef</span>();</span><br><span class="line">        System.out.println(obj.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="访问控制-public-private-protected">1.6.2 访问控制
(<code>public</code>, <code>private</code>, <code>protected</code>)</h4>
<ul>
<li><strong>功能</strong>：控制成员访问权限。</li>
<li><strong>使用场景</strong>：封装数据。</li>
<li><strong>底层原理</strong>：编译器检查访问规则。</li>
<li><strong>注意事项</strong>：默认访问为包级。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AccessControl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccessControl</span>();</span><br><span class="line">        System.out.println(obj.getX());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="构造函数">1.6.3 构造函数</h4>
<ul>
<li><strong>功能</strong>：初始化对象。</li>
<li><strong>使用场景</strong>：对象创建时设置初始值。</li>
<li><strong>底层原理</strong>：JVM 调用 <code>&lt;init&gt;</code>
方法。</li>
<li><strong>注意事项</strong>：无返回值，可重载。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Constructor(<span class="type">int</span> x) &#123; <span class="built_in">this</span>.x = x; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Constructor</span>(<span class="number">5</span>);</span><br><span class="line">        System.out.println(obj.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="静态成员-static">1.6.4 静态成员 (<code>static</code>)</h4>
<ul>
<li><strong>功能</strong>：属于类而非实例。</li>
<li><strong>使用场景</strong>：共享数据或工具方法。</li>
<li><strong>底层原理</strong>：存储在方法区。</li>
<li><strong>注意事项</strong>：不能访问非静态成员。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMember</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    StaticMember() &#123; count++; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticMember</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticMember</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="继承-extends">1.6.5 继承 (<code>extends</code>)</h4>
<ul>
<li><strong>功能</strong>：子类继承父类成员。</li>
<li><strong>使用场景</strong>：代码复用。</li>
<li><strong>底层原理</strong>：类层次存储在 JVM。</li>
<li><strong>注意事项</strong>：Java 只支持单继承。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123; <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inheritance</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Inheritance</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inheritance</span>();</span><br><span class="line">        System.out.println(obj.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多态性-override">1.6.6 多态性 (<code>@Override</code>)</h4>
<ul>
<li><strong>功能</strong>：子类覆盖父类方法。</li>
<li><strong>使用场景</strong>：动态行为。</li>
<li><strong>底层原理</strong>：虚方法表（vtable）。</li>
<li><strong>注意事项</strong>：需一致签名。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Sound&quot;</span>); &#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Polymorphism</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Woof&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Polymorphism</span>();</span><br><span class="line">        dog.sound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="接口-interface">1.6.7 接口 (<code>interface</code>)</h4>
<ul>
<li><strong>功能</strong>：定义方法契约。</li>
<li><strong>使用场景</strong>：多实现、解耦。</li>
<li><strong>底层原理</strong>：编译为抽象类。</li>
<li><strong>注意事项</strong>：方法默认
<code>public abstract</code>。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123; <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Meow&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InterfaceDemo</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceDemo</span>();</span><br><span class="line">        cat.sound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="抽象类-abstract">1.6.8 抽象类 (<code>abstract</code>)</h4>
<ul>
<li><strong>功能</strong>：部分实现，禁止实例化。</li>
<li><strong>使用场景</strong>：定义通用模板。</li>
<li><strong>底层原理</strong>：与普通类类似，但限制实例化。</li>
<li><strong>注意事项</strong>：可包含具体方法。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123; <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Circle&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractClass</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractClass</span>();</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="包与命名空间">1.7 包与命名空间</h3>
<h4 id="包定义-package">1.7.1 包定义 (<code>package</code>)</h4>
<ul>
<li><strong>功能</strong>：组织类文件。</li>
<li><strong>使用场景</strong>：避免命名冲突。</li>
<li><strong>底层原理</strong>：对应文件系统目录。</li>
<li><strong>注意事项</strong>：包名小写。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypackage;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;In mypackage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="导入-import">1.7.2 导入 (<code>import</code>)</h4>
<ul>
<li><strong>功能</strong>：引用其他包的类。</li>
<li><strong>使用场景</strong>：使用标准库或第三方类。</li>
<li><strong>底层原理</strong>：编译时解析类路径。</li>
<li><strong>注意事项</strong>：避免使用 <code>*</code> 影响性能。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImportDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="异常处理">1.8 异常处理</h3>
<h4 id="try-catch-finally">1.8.1 <code>try</code>, <code>catch</code>,
<code>finally</code></h4>
<ul>
<li><strong>功能</strong>：捕获和处理异常。</li>
<li><strong>使用场景</strong>：错误处理。</li>
<li><strong>底层原理</strong>：JVM 异常表跳转。</li>
<li><strong>注意事项</strong>：<code>finally</code> 总是执行。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="throw-throws">1.8.2 <code>throw</code>, <code>throws</code></h4>
<ul>
<li><strong>功能</strong>：抛出异常或声明异常。</li>
<li><strong>使用场景</strong>：自定义错误。</li>
<li><strong>底层原理</strong>：JVM 异常栈追踪。</li>
<li><strong>注意事项</strong>：<code>throws</code> 在方法签名。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            check(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="自定义异常">1.8.3 自定义异常</h4>
<ul>
<li><strong>功能</strong>：定义特定异常类型。</li>
<li><strong>使用场景</strong>：业务逻辑错误。</li>
<li><strong>底层原理</strong>：继承 <code>Exception</code> 或
<code>RuntimeException</code>。</li>
<li><strong>注意事项</strong>：提供有意义的错误信息。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    MyException(String msg) &#123; <span class="built_in">super</span>(msg); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;Custom error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="泛型">1.9 泛型</h3>
<h4 id="泛型类">1.9.1 泛型类</h4>
<ul>
<li><strong>功能</strong>：类型参数化。</li>
<li><strong>使用场景</strong>：通用数据结构。</li>
<li><strong>底层原理</strong>：类型擦除，编译时替换为
<code>Object</code>。</li>
<li><strong>注意事项</strong>：不能用基本类型。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    Box(T value) &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    T <span class="title function_">getValue</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Box&lt;Integer&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;(<span class="number">123</span>);</span><br><span class="line">        System.out.println(box.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="泛型方法">1.9.2 泛型方法</h4>
<ul>
<li><strong>功能</strong>：方法级类型参数。</li>
<li><strong>使用场景</strong>：灵活处理类型。</li>
<li><strong>底层原理</strong>：编译时推导类型。</li>
<li><strong>注意事项</strong>：类型参数在方法签名。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethod</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        print(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="通配符-extends-super">1.9.3 通配符 (<code>?</code>,
<code>extends</code>, <code>super</code>)</h4>
<ul>
<li><strong>功能</strong>：限制泛型范围。</li>
<li><strong>使用场景</strong>：处理未知类型或上下界。</li>
<li><strong>底层原理</strong>：编译时类型检查。</li>
<li><strong>注意事项</strong>：<code>extends</code>
用于读取，<code>super</code> 用于写入。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wildcards</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ArrayList&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Number n : list) System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        printList(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="动态内存管理">1.10 动态内存管理</h3>
<h4 id="new">1.10.1 <code>new</code></h4>
<ul>
<li><strong>功能</strong>：分配对象内存。</li>
<li><strong>使用场景</strong>：创建对象。</li>
<li><strong>底层原理</strong>：JVM 在堆上分配，垃圾回收管理。</li>
<li><strong>注意事项</strong>：无需手动释放。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewOperator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="注解">1.11 注解</h3>
<h4 id="内置注解-override-deprecated">1.11.1 内置注解
(<code>@Override</code>, <code>@Deprecated</code>)</h4>
<ul>
<li><strong>功能</strong>：提供元数据。</li>
<li><strong>使用场景</strong>：标记方法覆盖、废弃。</li>
<li><strong>底层原理</strong>：编译器或运行时处理。</li>
<li><strong>注意事项</strong>：<code>@Override</code>
确保签名正确。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuiltInAnnotations</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Overridden&quot;</span>; &#125;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Old&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">BuiltInAnnotations</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="自定义注解">1.11.2 自定义注解</h4>
<ul>
<li><strong>功能</strong>：定义特定元数据。</li>
<li><strong>使用场景</strong>：框架开发。</li>
<li><strong>底层原理</strong>：反射读取注解。</li>
<li><strong>注意事项</strong>：需指定保留策略。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;Test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomAnnotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Annotated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h2 id="现代-java-新特性">2. 现代 Java 新特性</h2>
<h3 id="java-8">2.1 Java 8</h3>
<h4 id="lambda-表达式">2.1.1 Lambda 表达式</h4>
<ul>
<li><strong>功能</strong>：简化函数式编程。</li>
<li><strong>使用场景</strong>：替代匿名类。</li>
<li><strong>底层原理</strong>：编译为 <code>invokedynamic</code>
指令。</li>
<li><strong>注意事项</strong>：需配合函数式接口。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyFunc</span> &#123; <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyFunc</span> <span class="variable">func</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Lambda&quot;</span>);</span><br><span class="line">        func.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="函数式接口-functionalinterface">2.1.2 函数式接口
(<code>@FunctionalInterface</code>)</h4>
<ul>
<li><strong>功能</strong>：标记单一抽象方法的接口。</li>
<li><strong>使用场景</strong>：Lambda 的目标类型。</li>
<li><strong>底层原理</strong>：编译器检查方法数量。</li>
<li><strong>注意事项</strong>：只能有一个抽象方法。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyFunc</span> &#123; <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalInterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyFunc</span> <span class="variable">func</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Running&quot;</span>);</span><br><span class="line">        func.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="stream-api">2.1.3 Stream API</h4>
<ul>
<li><strong>功能</strong>：流式处理集合。</li>
<li><strong>使用场景</strong>：数据过滤、映射。</li>
<li><strong>底层原理</strong>：管道操作，延迟执行。</li>
<li><strong>注意事项</strong>：流只能使用一次。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).stream()</span><br><span class="line">              .filter(x -&gt; x &gt; <span class="number">1</span>)</span><br><span class="line">              .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="optional-类">2.1.4 Optional 类</h4>
<ul>
<li><strong>功能</strong>：处理可能为空的值。</li>
<li><strong>使用场景</strong>：避免
<code>NullPointerException</code>。</li>
<li><strong>底层原理</strong>：封装对象引用。</li>
<li><strong>注意事项</strong>：不要用 <code>get()</code> 直接取值。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(opt.orElse(<span class="string">&quot;Default&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="默认方法-default">2.1.5 默认方法 (<code>default</code>)</h4>
<ul>
<li><strong>功能</strong>：接口中提供默认实现。</li>
<li><strong>使用场景</strong>：扩展接口功能。</li>
<li><strong>底层原理</strong>：编译为普通方法。</li>
<li><strong>注意事项</strong>：多接口冲突需显式覆盖。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Default&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultMethod</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DefaultMethod</span>().defaultMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="静态方法-接口中-static">2.1.6 静态方法 (接口中
<code>static</code>)</h4>
<ul>
<li><strong>功能</strong>：接口中的工具方法。</li>
<li><strong>使用场景</strong>：接口相关工具。</li>
<li><strong>底层原理</strong>：与类静态方法相同。</li>
<li><strong>注意事项</strong>：不能被实现类继承。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Static&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyInterface.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="方法引用">2.1.7 方法引用 (<code>::</code>)</h4>
<ul>
<li><strong>功能</strong>：简化 Lambda。</li>
<li><strong>使用场景</strong>：引用已有方法。</li>
<li><strong>底层原理</strong>：编译为 Lambda 表达式。</li>
<li><strong>注意事项</strong>：方法签名需匹配。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="日期时间-api-java.time">2.1.8 日期时间 API
(<code>java.time</code>)</h4>
<ul>
<li><strong>功能</strong>：处理日期和时间。</li>
<li><strong>使用场景</strong>：时间计算、格式化。</li>
<li><strong>底层原理</strong>：基于 ISO 8601 标准。</li>
<li><strong>注意事项</strong>：线程安全，替代 <code>Date</code>。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="java-9">2.2 Java 9</h3>
<h4 id="模块化-module-info.java">2.2.1 模块化
(<code>module-info.java</code>)</h4>
<ul>
<li><strong>功能</strong>：封装模块，控制依赖。</li>
<li><strong>使用场景</strong>：大型项目管理。</li>
<li><strong>底层原理</strong>：JVM 加载模块描述符。</li>
<li><strong>注意事项</strong>：需配置模块路径。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module-info.java</span></span><br><span class="line"><span class="keyword">module</span> mymodule &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.base;</span><br><span class="line">    <span class="keyword">exports</span> mypackage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mypackage/MyClass.java</span></span><br><span class="line"><span class="keyword">package</span> mypackage;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Module demo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="私有接口方法">2.2.2 私有接口方法</h4>
<ul>
<li><strong>功能</strong>：接口中私有实现。</li>
<li><strong>使用场景</strong>：复用接口代码。</li>
<li><strong>底层原理</strong>：编译为私有方法。</li>
<li><strong>注意事项</strong>：仅接口内部使用。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123; privateMethod(); &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Private&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateInterface</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PrivateInterface</span>().method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="try-with-resources-改进">2.2.3 <code>try-with-resources</code>
改进</h4>
<ul>
<li><strong>功能</strong>：简化资源管理。</li>
<li><strong>使用场景</strong>：文件、连接关闭。</li>
<li><strong>底层原理</strong>：自动调用 <code>close()</code>。</li>
<li><strong>注意事项</strong>：资源需实现
<code>AutoCloseable</code>。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryWithResources</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">StringReader</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> (br) &#123;</span><br><span class="line">            System.out.println(br.readLine());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="集合工厂方法-list.of">2.2.4 集合工厂方法
(<code>List.of()</code>)</h4>
<ul>
<li><strong>功能</strong>：创建不可变集合。</li>
<li><strong>使用场景</strong>：快速初始化。</li>
<li><strong>底层原理</strong>：返回不可变实现。</li>
<li><strong>注意事项</strong>：不可修改。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="java-10">2.3 Java 10</h3>
<h4 id="局部变量类型推导-var">2.3.1 局部变量类型推导
(<code>var</code>)</h4>
<ul>
<li><strong>功能</strong>：自动推导变量类型。</li>
<li><strong>使用场景</strong>：简化代码。</li>
<li><strong>底层原理</strong>：编译时确定类型。</li>
<li><strong>注意事项</strong>：仅限局部变量。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// int</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(x + <span class="string">&quot; &quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="java-11">2.4 Java 11</h3>
<h4 id="字符串增强-strip-lines">2.4.1 字符串增强 (<code>strip()</code>,
<code>lines()</code>)</h4>
<ul>
<li><strong>功能</strong>：增强字符串操作。</li>
<li><strong>使用场景</strong>：文本处理。</li>
<li><strong>底层原理</strong>：基于 <code>String</code> 内部数组。</li>
<li><strong>注意事项</strong>：<code>strip()</code> 支持 Unicode
空白。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringEnhance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;  Hello\nWorld  &quot;</span>;</span><br><span class="line">        System.out.println(text.strip());</span><br><span class="line">        text.lines().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="http-client-api">2.4.2 HTTP Client API</h4>
<ul>
<li><strong>功能</strong>：发送 HTTP 请求。</li>
<li><strong>使用场景</strong>：网络通信。</li>
<li><strong>底层原理</strong>：基于 NIO。</li>
<li><strong>注意事项</strong>：支持异步请求。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line">        <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">                .uri(URI.create(<span class="string">&quot;https://example.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body().substring(<span class="number">0</span>, <span class="number">50</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="java-14">2.5 Java 14</h3>
<h4 id="switch-表达式">2.5.1 Switch 表达式</h4>
<ul>
<li><strong>功能</strong>：Switch 返回值。</li>
<li><strong>使用场景</strong>：简化多分支。</li>
<li><strong>底层原理</strong>：编译为条件跳转。</li>
<li><strong>注意事项</strong>：需覆盖所有情况。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt; <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> -&gt; <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="instanceof-模式匹配">2.5.2 <code>instanceof</code> 模式匹配</h4>
<ul>
<li><strong>功能</strong>：类型检查并转换。</li>
<li><strong>使用场景</strong>：简化类型处理。</li>
<li><strong>底层原理</strong>：编译器优化类型检查。</li>
<li><strong>注意事项</strong>：变量作用域限于条件。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceofPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="java-15">2.6 Java 15</h3>
<h4 id="文本块-...">2.6.1 文本块 (<code>"""..."""</code>)</h4>
<ul>
<li><strong>功能</strong>：多行字符串。</li>
<li><strong>使用场景</strong>：HTML、SQL。</li>
<li><strong>底层原理</strong>：编译为单行字符串。</li>
<li><strong>注意事项</strong>：自动去除缩进。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            &lt;html&gt;</span></span><br><span class="line"><span class="string">                &lt;body&gt;Hello&lt;/body&gt;</span></span><br><span class="line"><span class="string">            &lt;/html&gt;</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.println(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="java-17">2.7 Java 17</h3>
<h4 id="密封类-sealed-permits">2.7.1 密封类 (<code>sealed</code>,
<code>permits</code>)</h4>
<ul>
<li><strong>功能</strong>：限制继承。</li>
<li><strong>使用场景</strong>：控制类层次。</li>
<li><strong>底层原理</strong>：编译器检查继承。</li>
<li><strong>注意事项</strong>：子类需声明 <code>final</code> 或
<code>sealed</code>。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Circle &#123;&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SealedClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        System.out.println(shape <span class="keyword">instanceof</span> Circle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="模式匹配-switch-预览">2.7.2 模式匹配 Switch (预览)</h4>
<ul>
<li><strong>功能</strong>：增强 Switch 类型匹配。</li>
<li><strong>使用场景</strong>：复杂条件处理。</li>
<li><strong>底层原理</strong>：编译器模式分析。</li>
<li><strong>注意事项</strong>：需启用预览特性。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">case</span> String s -&gt; <span class="string">&quot;String: &quot;</span> + s;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="string">&quot;Other&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="java-21">2.8 Java 21</h3>
<h4 id="虚拟线程">2.8.1 虚拟线程</h4>
<ul>
<li><strong>功能</strong>：轻量级线程。</li>
<li><strong>使用场景</strong>：高并发任务。</li>
<li><strong>底层原理</strong>：JVM 调度器管理。</li>
<li><strong>注意事项</strong>：需 JDK 21。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">vThread</span> <span class="operator">=</span> Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Virtual thread&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        vThread.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="结构化并发">2.8.2 结构化并发</h4>
<ul>
<li><strong>功能</strong>：管理并发任务。</li>
<li><strong>使用场景</strong>：多任务协调。</li>
<li><strong>底层原理</strong>：基于
<code>StructuredTaskScope</code>。</li>
<li><strong>注意事项</strong>：需 JDK 21。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.StructuredTaskScope;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StructuredConcurrency</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;</span><br><span class="line">            scope.fork(() -&gt; &#123; System.out.println(<span class="string">&quot;Task 1&quot;</span>); <span class="keyword">return</span> <span class="literal">null</span>; &#125;);</span><br><span class="line">            scope.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="记录模式匹配">2.8.3 记录模式匹配</h4>
<ul>
<li><strong>功能</strong>：解构记录。</li>
<li><strong>使用场景</strong>：简化数据处理。</li>
<li><strong>底层原理</strong>：编译器模式匹配。</li>
<li><strong>注意事项</strong>：需 JDK 21。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecordPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x: &quot;</span> + x + <span class="string">&quot;, y: &quot;</span> + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h2 id="其他特性">3. 其他特性</h2>
<h3 id="标准库扩展">3.1 标准库扩展</h3>
<h4 id="集合框架-list-map-set">3.1.1 集合框架 (<code>List</code>,
<code>Map</code>, <code>Set</code>)</h4>
<ul>
<li><strong>功能</strong>：管理动态数据。</li>
<li><strong>使用场景</strong>：数据存储、查询。</li>
<li><strong>底层原理</strong>：基于数组或链表。</li>
<li><strong>注意事项</strong>：选择合适的实现类。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="输入输出-java.io-java.nio">3.1.2 输入输出 (<code>java.io</code>,
<code>java.nio</code>)</h4>
<ul>
<li><strong>功能</strong>：文件和流操作。</li>
<li><strong>使用场景</strong>：读写文件、网络。</li>
<li><strong>底层原理</strong>：基于 OS 文件系统。</li>
<li><strong>注意事项</strong>：关闭资源。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IODemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="并发库-java.util.concurrent">3.1.3 并发库
(<code>java.util.concurrent</code>)</h4>
<ul>
<li><strong>功能</strong>：多线程支持。</li>
<li><strong>使用场景</strong>：并发任务。</li>
<li><strong>底层原理</strong>：线程池、锁机制。</li>
<li><strong>注意事项</strong>：避免死锁。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        executor.submit(() -&gt; System.out.println(<span class="string">&quot;Task&quot;</span>));</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="字符串-string-stringbuilder">3.1.4 字符串 (<code>String</code>,
<code>StringBuilder</code>)</h4>
<ul>
<li><strong>功能</strong>：处理文本。</li>
<li><strong>使用场景</strong>：字符串操作。</li>
<li><strong>底层原理</strong>：<code>String</code>
不可变，<code>StringBuilder</code> 可变。</li>
<li><strong>注意事项</strong>：频繁拼接用
<code>StringBuilder</code>。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(str + <span class="string">&quot; &quot;</span> + sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="编译器与运行时">3.2 编译器与运行时</h3>
<h4 id="jvm-垃圾回收">3.2.1 JVM (垃圾回收)</h4>
<ul>
<li><strong>功能</strong>：自动内存管理。</li>
<li><strong>使用场景</strong>：运行 Java 程序。</li>
<li><strong>底层原理</strong>：标记-清除、分代回收。</li>
<li><strong>注意事项</strong>：调优 GC 参数。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Temp&quot;</span>);</span><br><span class="line">        s = <span class="literal">null</span>; <span class="comment">// 可被 GC 回收</span></span><br><span class="line">        System.gc(); <span class="comment">// 建议 GC</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="反射-java.lang.reflect">3.2.2 反射
(<code>java.lang.reflect</code>)</h4>
<ul>
<li><strong>功能</strong>：运行时检查类信息。</li>
<li><strong>使用场景</strong>：框架开发。</li>
<li><strong>底层原理</strong>：JVM 元数据。</li>
<li><strong>注意事项</strong>：性能开销大。</li>
<li><strong>示例代码</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; cls = String.class;</span><br><span class="line">        Method[] methods = cls.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) System.out.println(m.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 语法速览</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java-%E8%AF%AD%E6%B3%95%E9%80%9F%E8%A7%88.html</url>
    <content><![CDATA[<h1 id="hello-world">1. Hello World</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="变量与数据类型">2. 变量与数据类型</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">d</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">        System.out.println(a + <span class="string">&quot; &quot;</span> + b + <span class="string">&quot; &quot;</span> + c + <span class="string">&quot; &quot;</span> + d + <span class="string">&quot; &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="条件语句if-else-switch">3. 条件语句（if / else / switch）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) System.out.println(<span class="string">&quot;Positive&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>) System.out.println(<span class="string">&quot;Negative&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;Zero&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: System.out.println(<span class="string">&quot;One&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: System.out.println(<span class="string">&quot;Five&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: System.out.println(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="循环for-while-do-while">4. 循环（for / while / do-while）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) System.out.println(<span class="string">&quot;For: &quot;</span> + i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; <span class="number">3</span>) System.out.println(<span class="string">&quot;While: &quot;</span> + j++);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123; System.out.println(<span class="string">&quot;DoWhile: &quot;</span> + k++); &#125; <span class="keyword">while</span> (k &lt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="方法定义与调用">5. 方法定义与调用</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(add(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="数组与字符串">6. 数组与字符串</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) System.out.print(n + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="类与对象">7. 类与对象</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hi, I&#x27;m &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        p.age = <span class="number">25</span>;</span><br><span class="line">        p.greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="构造函数与-this-关键字">8. 构造函数与 this 关键字</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Person(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;, &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        p.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="继承与方法重写override">9. 继承与方法重写（<span
class="citation" data-cites="Override">@Override</span>）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal speaks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        a.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="接口与多态">10. 接口与多态</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing Circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Drawable</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        d.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="异常处理try-catch-finally">11.
异常处理（try-catch-finally）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="静态方法和变量">12. 静态方法和变量</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Utils.greet();</span><br><span class="line">        System.out.println(Utils.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="枚举enum">13. 枚举（enum）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, GREEN, BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Color</span> <span class="variable">c</span> <span class="operator">=</span> Color.GREEN;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> RED -&gt; System.out.println(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> GREEN -&gt; System.out.println(<span class="string">&quot;Green&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> BLUE -&gt; System.out.println(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="集合框架list-set-map">14. 集合框架（List / Set / Map）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">        Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">        set.forEach(System.out::println);</span><br><span class="line">        map.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;: &quot;</span> + v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="lambda-表达式与-stream-apijava-8">15. Lambda 表达式与 Stream
API（Java 8+）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        nums.stream().filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="多线程基础thread-与-runnable">16. 多线程基础：Thread 与
Runnable</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello from thread!&quot;</span>));</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="泛型类方法限定通配符">17. 泛型（类、方法、限定通配符）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    T value;</span><br><span class="line">    Box(T value) &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Box&lt;String&gt; b = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(b.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(T[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : array) System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="内部类与匿名类">18. 内部类与匿名类</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">outerVal</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner: &quot;</span> + outerVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello from anonymous class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="注解annotation">19. 注解（Annotation）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Info &#123;</span><br><span class="line">    String <span class="title function_">author</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">version</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Info(author = &quot;Yao&quot;, version = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> Main.class.getAnnotation(Info.class);</span><br><span class="line">        System.out.println(info.author() + <span class="string">&quot; v&quot;</span> + info.version());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="反射基础">20. 反射基础</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method m : cls.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.getName().equals(<span class="string">&quot;length&quot;</span>))</span><br><span class="line">                System.out.println(<span class="string">&quot;Found: &quot;</span> + m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="文件读写io">21. 文件读写（IO）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">            writer.write(<span class="string">&quot;Hello File!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">            System.out.println(reader.readLine());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="nio-文件读取java-7">22. NIO 文件读取（Java 7+）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> Files.readString(Path.of(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Read: &quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="枚举增强用法带方法和属性">23. 枚举增强用法：带方法和属性</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Level</span> &#123;</span><br><span class="line">    LOW(<span class="number">1</span>), MEDIUM(<span class="number">2</span>), HIGH(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Level(<span class="type">int</span> v) &#123; <span class="built_in">this</span>.val = v; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span> &#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Level.HIGH.getVal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="optional避免-nullpointerexception">24. Optional（避免
NullPointerException）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Optional&lt;String&gt; maybe = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(maybe.map(String::toUpperCase).orElse(<span class="string">&quot;Empty&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="synchronized-关键字线程安全同步">25. <code>synchronized</code>
关键字：线程安全同步</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) increment(); &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) increment(); &#125;);</span><br><span class="line">        t1.start(); t2.start(); t1.join(); t2.join();</span><br><span class="line">        System.out.println(count); <span class="comment">// 应该是2000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="线程池-executorservice">26. 线程池 ExecutorService</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(() -&gt; <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + future.get());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="volatile-保证变量可见性">27. <code>volatile</code>
保证变量可见性</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (running);</span><br><span class="line">            System.out.println(<span class="string">&quot;Stopped&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="reentrantlock-可重入锁">28. ReentrantLock 可重入锁</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Locked section&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="stream-apimapfiltercollect">29. Stream
API：map/filter/collect</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        List&lt;String&gt; upper = list.stream()</span><br><span class="line">            .filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(upper); <span class="comment">// [APPLE]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="recordjava-14简化数据类">30. record（Java 14+）：简化数据类</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(p.name() + <span class="string">&quot;, &quot;</span> + p.age());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="sealed-classjava-15">31. sealed class（Java 15+）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Circle, Square &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> Circle) System.out.println(<span class="string">&quot;It&#x27;s a Circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="简单-java-gui-示例swing">32. 简单 Java GUI 示例（Swing）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Hello GUI&quot;</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Click Me&quot;</span>);</span><br><span class="line">        button.addActionListener(e -&gt; JOptionPane.showMessageDialog(frame, <span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">        frame.add(button);</span><br><span class="line">        frame.setSize(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="socket-网络通信客户端">33. Socket 网络通信（客户端）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;example.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">        out.print(<span class="string">&quot;GET / HTTP/1.1\r\nHost: example.com\r\n\r\n&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(in.readLine());</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="jdbc-简单访问以-sqlite-为例">34. JDBC 简单访问（以 SQLite
为例）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;org.sqlite.JDBC&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:sqlite:test.db&quot;</span>);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        stmt.executeUpdate(<span class="string">&quot;CREATE TABLE IF NOT EXISTS users (name TEXT)&quot;</span>);</span><br><span class="line">        stmt.executeUpdate(<span class="string">&quot;INSERT INTO users VALUES (&#x27;Alice&#x27;)&quot;</span>);</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM users&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="java-模块系统java-9">35. Java 模块系统（Java 9+）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：module-info.java</span></span><br><span class="line"><span class="keyword">module</span> com.example.hello &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.example.hello;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：com/example/hello/Hello.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from module!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.example.hello.Hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Hello.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="lambda-表达式-与-函数式接口">36. Lambda 表达式 与
函数式接口</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Function&lt;String, Integer&gt; strLength = s -&gt; s.length();</span><br><span class="line">        System.out.println(strLength.apply(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// 输出 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="completablefuture-异步编程">37. CompletableFuture 异步编程</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">                .thenApply(s -&gt; s + <span class="string">&quot; World&quot;</span>);</span><br><span class="line">        System.out.println(future.get()); <span class="comment">// 输出 &quot;Hello World&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="junit5-单元测试基础">38. JUnit5 单元测试基础</h1>
<p>确保使用 JDK + Maven 或 IDE 支持，添加依赖后可运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名: Calculator.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名: CalculatorTest.java</span></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        assertEquals(<span class="number">5</span>, calc.add(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><small>（需要 JUnit 5 依赖，Maven 示例可提供）</small></p>
<hr />
<h1 id="使用-gson-解析和生成-json">39. 使用 Gson 解析和生成 JSON</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;Alice\&quot;,\&quot;age\&quot;:30&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> gson.fromJson(json, Person.class);</span><br><span class="line">        System.out.println(p.name + <span class="string">&quot; is &quot;</span> + p.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><small>（需添加 Gson
依赖：<code>com.google.code.gson:gson:2.10.1</code>）</small></p>
<hr />
<h1 id="使用-maven-构建项目示例-pom.xml">40. 使用 Maven 构建项目（示例
<code>pom.xml</code>）</h1>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件名: pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr />
<h1 id="使用-gradle-构建项目示例-build.gradle">41. 使用 Gradle
构建项目（示例 <code>build.gradle</code>）</h1>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.google.code.gson:gson:2.10.1&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter:5.10.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="java-servlet-示例java-web">42. Java Servlet 示例（Java
Web）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.*;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;Hello from Servlet!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><small>（需部署到如 Tomcat、Jetty 的 Servlet 容器）</small></p>
<hr />
<h1 id="注解annotation与反射使用">43. 注解（Annotation）与反射使用</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;HelloAnnotation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Main.class.getMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">ann</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;Annotation value: &quot;</span> + ann.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Main</span>().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="反射动态创建类与调用方法">44. 反射动态创建类与调用方法</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;greet&quot;</span>, String.class);</span><br><span class="line">        method.invoke(<span class="literal">null</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="多线程基础实现-runnable-接口">45. 多线程基础：实现 Runnable
接口</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Main</span>());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="多线程使用-synchronized-同步">46. 多线程：使用 synchronized
同步</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) counter.increment(); &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) counter.increment(); &#125;);</span><br><span class="line">        t1.start(); t2.start();</span><br><span class="line">        t1.join(); t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Count: &quot;</span> + counter.count); <span class="comment">// 2000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="使用-reentrantlock-进行加锁">47. 使用 ReentrantLock
进行加锁</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) main.increment(); &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) main.increment(); &#125;);</span><br><span class="line">        t1.start(); t2.start(); t1.join(); t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Count: &quot;</span> + main.count); <span class="comment">// 2000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="volatile-保证变量可见性-1">48. volatile 保证变量可见性</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 循环等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopped.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(m::run);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        m.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="socket-编程简单服务器与客户端">49. Socket
编程：简单服务器与客户端</h1>
<p>Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Client says: &quot;</span> + reader.readLine());</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">        writer.println(<span class="string">&quot;Hello from client!&quot;</span>);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="枚举类型的高级用法">50. 枚举类型的高级用法</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    PLUS &#123; <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125; &#125;,</span><br><span class="line">    MINUS &#123; <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x - y; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Operation.PLUS.apply(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5.0</span></span><br><span class="line">        System.out.println(Operation.MINUS.apply(<span class="number">5</span>, <span class="number">2</span>)); <span class="comment">// 3.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>继续为你整理 Java 更高级和实用的语法特性（第 51 ～ 60
部分），每个示例都可<strong>直接运行</strong>。</p>
<hr />
<h1 id="java-stream-高级操作groupingby-averaging">51. Java Stream
高级操作：groupingBy + averaging</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Spike&quot;</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Long&gt; counts = names.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(name -&gt; name, Collectors.counting()));</span><br><span class="line"></span><br><span class="line">        System.out.println(counts); <span class="comment">// &#123;Jerry=2, Tom=2, Spike=1&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="try-with-resources-自动释放资源">52. try-with-resources
自动释放资源</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">            System.out.println(br.readLine());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>test.txt</code> 文件需在项目根目录。适用于任何
<code>AutoCloseable</code> 类型。</p>
</blockquote>
<hr />
<h1 id="record简化-java-beanjava-14">53. record：简化 Java Bean（Java
14+）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(u.name() + <span class="string">&quot;, &quot;</span> + u.age());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="java-lambda-表达式与函数式接口">54. Java Lambda
表达式与函数式接口</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Function&lt;String, Integer&gt; parseLength = str -&gt; str.length();</span><br><span class="line">        System.out.println(parseLength.apply(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="optional-使用避免-nullpointerexception">55. Optional 使用：避免
NullPointerException</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Optional&lt;String&gt; name = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> name.orElse(<span class="string">&quot;Default&quot;</span>);</span><br><span class="line">        System.out.println(result); <span class="comment">// Default</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="接口的默认方法java-8">56. 接口的默认方法（Java 8+）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from default method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> <span class="keyword">implements</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Main</span>().greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="文件读写java-nio">57. 文件读写（Java NIO）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">        Files.write(path, <span class="string">&quot;Hello NIO&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> Files.readString(path);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="使用-threadpoolexecutor-线程池">58. 使用 ThreadPoolExecutor
线程池</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executor.submit(() -&gt; System.out.println(<span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">        executor.submit(() -&gt; System.out.println(<span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="动态代理proxy">59. 动态代理（Proxy）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Hello.class&#125;,</span><br><span class="line">            (proxy, method, args1) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Before method&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        hello.say(); <span class="comment">// Before method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="简单-guiswing-示例">60. 简单 GUI（Swing 示例）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Hello GUI&quot;</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Click Me&quot;</span>);</span><br><span class="line">        button.addActionListener(e -&gt; JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;Button clicked!&quot;</span>));</span><br><span class="line">        frame.add(button);</span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin SAM 转换改进</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/Kotlin-SAM-%E8%BD%AC%E6%8D%A2%E6%94%B9%E8%BF%9B.html</url>
    <content><![CDATA[<p><code>SAM 转换改进</code> 是 Kotlin 语言在支持<strong>Java
接口函数式调用（Single Abstract Method，简称
SAM）</strong>方面做的增强和优化。下面我详细讲解：</p>
<hr />
<h2 id="什么是-samsingle-abstract-method">🧠 1. 什么是 SAM（Single
Abstract Method）</h2>
<p><strong>SAM 接口</strong>指的是那种只定义了一个抽象方法的接口，像
Java 里的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 中可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;run&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Kotlin 也支持这种简写方式，这就是 <strong>SAM 转换</strong>。</p>
<hr />
<h2 id="kotlin-的-sam-转换改进前">✅ 2. Kotlin 的 SAM
转换（改进前）</h2>
<p>在 Kotlin 的早期版本里：</p>
<ul>
<li>SAM 转换 <strong>只对 Java 的接口</strong>生效。</li>
<li>Kotlin 自己定义的接口，即使只有一个抽象方法，也<strong>不支持 SAM
转换</strong>。</li>
</ul>
<h3 id="示例仅对-java-接口有效">示例（仅对 Java 接口有效）：</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = Thread &#123; println(<span class="string">&quot;Running in thread&quot;</span>) &#125; <span class="comment">// ✅ Kotlin 自动帮你转成 Runnable</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="sam-转换改进支持-kotlin-自定义函数接口">🚀 3. SAM 转换改进：支持
Kotlin 自定义函数接口</h2>
<p>从 Kotlin 1.4 开始，<strong>SAM 转换被扩展到 Kotlin
自己定义的接口</strong> —— 但有前提条件：</p>
<ul>
<li>必须标注为 <code>fun interface</code>（函数接口）</li>
</ul>
<h3 id="示例">示例：</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">(action: <span class="type">Action</span>)</span></span> &#123;</span><br><span class="line">    action.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以像 Java lambda 那样使用了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">doAction &#123; println(<span class="string">&quot;Action running&quot;</span>) &#125; <span class="comment">// ✅ SAM 转换生效</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="总结sam-转换改进了什么">🔍 4. 总结：SAM 转换改进了什么？</h2>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>版本前</th>
<th>Kotlin 自定义接口不支持 SAM 转换（只能用匿名类）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Kotlin 1.4+</td>
<td>支持使用 <code>fun interface</code> 实现 SAM 转换，像 Java lambda
那样简洁</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="使用建议">✅ 5. 使用建议</h2>
<ul>
<li>如果你要让 Kotlin 支持 lambda 表达式形式调用你写的接口，请用
<code>fun interface</code>。</li>
<li>Kotlin
也建议尽量用函数类型（<code>(T) -&gt; R</code>）代替接口，但当需要 Java
兼容时 <code>fun interface</code> 更合适。</li>
</ul>
<hr />
<h2 id="示例对比总结">💡 示例对比总结</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 的 SAM 接口</span></span><br><span class="line">Thread &#123; println(<span class="string">&quot;Hello&quot;</span>) &#125; <span class="comment">// ✅ Kotlin 自动转换成 Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin 自定义函数接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> MyCallback &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">(cb: <span class="type">MyCallback</span>)</span></span> &#123; cb.call() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 lambda</span></span><br><span class="line">run &#123; println(<span class="string">&quot;Called!&quot;</span>) &#125; <span class="comment">// ✅ Kotlin 1.4+ 支持</span></span><br></pre></td></tr></table></figure>
<hr />
<p>如果你正在用某个库，比如
Retrofit、RxJava、或协程等，想知道它有没有用到 SAM
或如何简化代码，我也可以帮你分析实际场景。需要吗？</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin lazy 委托的底层实现原理</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/Kotlin-lazy-%E5%A7%94%E6%89%98%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<p><code>lazy</code> 委托是 Kotlin
的一种属性委托，用于实现延迟初始化。所谓属性委托，就是将属性的 getter 和
setter 操作委托给其他对象来处理。<code>lazy</code>
委托允许我们在第一次访问属性时才进行初始化，后续访问直接返回已缓存的值。这种机制可以提高性能，避免不必要的开销，尤其是在处理开销较大的对象时。</p>
<h3 id="使用">使用</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyVal: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    println(<span class="string">&quot;Computed&quot;</span>)</span><br><span class="line">    <span class="string">&quot;Lazy&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(lazyVal)  <span class="comment">// 输出: Computed, Lazy</span></span><br><span class="line">println(lazyVal)  <span class="comment">// 输出: Lazy（不再计算）</span></span><br></pre></td></tr></table></figure>
<p><code>lazyVal</code> 使用 <code>lazy</code>
委托延迟初始化，只有首次访问时执行初始化块
<code>{ println("Computed"); "Lazy" }</code>，后续访问直接返回缓存值。</p>
<hr />
<h3 id="底层实现原理">底层实现原理</h3>
<p>Kotlin 的 <code>lazy</code> 委托是标准库中的一种属性委托，通过
<code>by lazy { ... }</code> 实现延迟初始化。其底层依赖于
<code>Lazy&lt;T&gt;</code> 接口和线程安全的实现类（默认使用
<code>SynchronizedLazyImpl</code>）。以下是实现细节：</p>
<h4 id="lazy-委托的定义">1. <code>lazy</code> 委托的定义</h4>
<ul>
<li><code>lazy</code> 是一个高阶函数，定义在 Kotlin 标准库中：
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 <code>initializer: () -&gt; T</code> 是一个无参
Lambda，返回类型为 <code>T</code>（此处 <code>T</code> 是
<code>String</code>）。</li>
<li>返回 <code>Lazy&lt;T&gt;</code> 接口实例，具体实现是
<code>SynchronizedLazyImpl</code>。</li>
</ul></li>
<li><code>Lazy&lt;T&gt;</code> 接口： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lazy</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> value: T</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>value</code> 属性获取委托值。</li>
<li><code>isInitialized()</code> 检查是否已初始化。</li>
</ul></li>
</ul>
<p>这里把 <code>lazyVal</code> 的初始化逻辑封装在一个 <code>Lazy</code>
对象中，后续访问 <code>lazyVal</code> 时，实际上是访问这个
<code>Lazy</code> 对象的 <code>value</code> 属性。</p>
<h4 id="synchronizedlazyimpl-的实现">2.
<code>SynchronizedLazyImpl</code> 的实现</h4>
<ul>
<li><p><code>lazy</code> 默认使用
<code>SynchronizedLazyImpl</code>，其核心逻辑如下（简化伪代码）：
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SynchronizedLazyImpl</span>&lt;<span class="type">out T</span>&gt;(initializer: () -&gt; T, lock: Any? = <span class="literal">null</span>) : Lazy&lt;T&gt;, Serializable &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> initializer: (() -&gt; T)? = initializer</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Volatile</span> <span class="comment">// 确保多线程环境下的可见性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _value: Any? = UNINITIALIZED_VALUE</span><br><span class="line"></span><br><span class="line">  <span class="comment">// final field to ensure safe publication of &#x27;SynchronizedLazyImpl&#x27; itself through</span></span><br><span class="line">  <span class="comment">// var lazy = lazy() &#123;&#125;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> lock = lock ?: <span class="keyword">this</span> <span class="comment">// 使用自身作为锁</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> value: T</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">val</span> _v1 = _value</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果 _value 已经初始化，直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (_v1 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">              <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">              <span class="keyword">return</span> _v1 <span class="keyword">as</span> T</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> synchronized(lock) &#123;</span><br><span class="line">              <span class="keyword">val</span> _v2 = _value</span><br><span class="line">              <span class="keyword">if</span> (_v2 !== UNINITIALIZED_VALUE) &#123; <span class="comment">// 再次检查，避免多线程下重复初始化</span></span><br><span class="line">                  <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span> (_v2 <span class="keyword">as</span> T)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">val</span> typedValue = initializer!!() <span class="comment">// 调用 initializer 初始化值</span></span><br><span class="line">                  _value = typedValue</span><br><span class="line">                  initializer = <span class="literal">null</span></span><br><span class="line">                  typedValue</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = _value !== UNINITIALIZED_VALUE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="keyword">if</span> (isInitialized()) value.toString() <span class="keyword">else</span> <span class="string">&quot;Lazy value not initialized yet.&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeReplace</span><span class="params">()</span></span>: Any = InitializedLazyImpl(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>关键点</strong>：</p>
<ul>
<li><strong>延迟初始化</strong>：
<ul>
<li><code>_value</code> 初始为
<code>UNINITIALIZED_VALUE</code>（哨兵对象）。</li>
<li>首次访问 <code>value</code> 时，检查 <code>_value</code>
是否未初始化，若是则调用 <code>initializer()</code>（即
<code>{ println("Computed"); "Lazy" }</code>）。</li>
</ul></li>
<li><strong>线程安全</strong>：
<ul>
<li>使用 <code>@Volatile</code> 确保 <code>_value</code> 的可见性。</li>
<li><code>synchronized(lock)</code> 实现双重检查锁（Double-Checked
Locking），保证多线程环境下初始化只执行一次。</li>
</ul></li>
<li><strong>缓存结果</strong>：
<ul>
<li>初始化后，<code>_value</code>
保存结果（<code>"Lazy"</code>），后续访问直接返回，无需再次调用
<code>initializer</code>。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="编译后的代码">3. 编译后的代码</h4>
<ul>
<li><p>Kotlin 编译器将 <code>lazyVal</code> 的访问转换为对
<code>Lazy</code> 对象的调用。简化后的字节码（伪代码）：
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">val</span> lazyVal: String <span class="keyword">by</span> lazy &#123; println(<span class="string">&quot;Computed&quot;</span>); <span class="string">&quot;Lazy&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（大致等效）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> lazyVal$delegate: Lazy&lt;String&gt; = lazy &#123; println(<span class="string">&quot;Computed&quot;</span>); <span class="string">&quot;Lazy&quot;</span> &#125;</span><br><span class="line"><span class="keyword">val</span> lazyVal: String</span><br><span class="line">    <span class="keyword">get</span>() = lazyVal$delegate.value</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>访问流程</strong>：</p>
<ul>
<li>第一次 <code>lazyVal</code> 访问：
<ul>
<li>调用 <code>lazyVal$delegate.value</code>。</li>
<li><code>SynchronizedLazyImpl</code> 执行
<code>initializer</code>，打印 <code>Computed</code>，返回
<code>"Lazy"</code>，并缓存。</li>
</ul></li>
<li>第二次访问：
<ul>
<li>直接返回缓存的 <code>_value</code>（<code>"Lazy"</code>），无
<code>initializer</code> 调用。</li>
</ul></li>
</ul></li>
</ul>
<hr />
<h3 id="其他懒加载模式">其他懒加载模式</h3>
<ul>
<li><code>lazy</code> 支持不同线程安全模式，通过
<code>LazyThreadSafetyMode</code> 参数： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyVal: String <span class="keyword">by</span> lazy(LazyThreadSafetyMode.NONE) &#123; <span class="string">&quot;Lazy&quot;</span> &#125; <span class="comment">// 无同步，单线程使用</span></span><br><span class="line"><span class="keyword">val</span> lazyValPub: String <span class="keyword">by</span> lazy(LazyThreadSafetyMode.PUBLICATION) &#123; <span class="string">&quot;Lazy&quot;</span> &#125; <span class="comment">// 允许多线程初始化，最终一致</span></span><br></pre></td></tr></table></figure></li>
<li>默认 <code>SYNCHRONIZED</code>（如上述代码）适合多线程场景。</li>
</ul>
<hr />
<h3 id="总结">总结</h3>
<ul>
<li><strong>底层实现</strong>：
<ul>
<li><code>lazy</code> 委托通过 <code>SynchronizedLazyImpl</code>
实现延迟初始化。</li>
<li>使用双重检查锁确保线程安全，首次访问执行
<code>initializer</code>，后续返回缓存值。</li>
<li>编译器将 <code>lazyVal</code> 转换为 <code>Lazy</code> 对象的
<code>value</code> 访问。</li>
</ul></li>
<li><strong>关键机制</strong>：
<ul>
<li>属性委托（<code>by</code>）将 <code>get</code> 操作转发给
<code>Lazy</code>。</li>
<li><code>@Volatile</code> 和 <code>synchronized</code>
保证多线程安全。</li>
<li><code>_value</code> 缓存初始化结果，优化性能。</li>
</ul></li>
<li><strong>实践</strong>：
<ul>
<li><code>lazy</code>
适合昂贵初始化的场景（如数据库连接、配置加载）。</li>
<li>注意线程安全模式的选择（默认 <code>SYNCHRONIZED</code>
适合多数场景）。</li>
</ul></li>
</ul>
<p>通过 <code>lazy</code> 委托，Kotlin
提供了一种高效、线程安全的延迟初始化机制。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin suspend 函数的实现机制</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/Kotlin-suspend-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.html</url>
    <content><![CDATA[<p>标记为 <code>suspend</code>
的函数成为挂起函数，可以在协程上下文中运行，能够暂停执行（不阻塞线程）并在适当的时候恢复执行。通过挂起和恢复机制，挂起函数允许非阻塞的异步编程，适合处理
I/O 操作、耗时任务等场景。挂起函数只能在另一个挂起函数或协程作用域（如
<code>CoroutineScope</code>）中调用。</p>
<p>Kotlin 的挂起函数并不是直接由 JVM
提供支持，而是通过编译器将挂起函数的代码转换为普通的 JVM
字节码，利用状态机（Continuation）机制来实现暂停和恢复。</p>
<p>Kotlin 编译器将挂起函数的代码重写为<strong>Continuation-Passing
Style</strong>（延续传递风格）。这意味着挂起函数的每次暂停点都会被拆分成一个状态机的状态，函数的执行状态通过
<code>Continuation</code> 对象保存和恢复。</p>
<p><code>Continuation&lt;T&gt;</code>是Kotlin 协程的核心接口是
，它表示一个执行的延续点，包含两个主要方法：</p>
<ol type="1">
<li><code>resumeWith(result: Result&lt;T&gt;)</code>：恢复协程的执行，传递结果或异常。</li>
<li><code>context: CoroutineContext</code>：协程的上下文，包含调度器、异常处理器等信息。每个挂起函数在编译时会额外接受一个
<code>Continuation</code> 参数，用于传递执行状态。</li>
</ol>
<p>一个挂起函数会被编译器分解为多个状态（对应每个 <code>suspend</code>
点）。编译器生成一个状态机，状态机记录当前执行到哪个暂停点，并存储局部变量、参数等信息。每次调用挂起函数时，实际上是调用状态机的某个状态，恢复时从上一次暂停的状态继续执行。</p>
<p>挂起函数的每次暂停和恢复都被表示为状态机的状态切换。状态机通过一个整数
<code>label</code>
来跟踪当前的状态。编译器将挂起函数的代码分成多个块，每个块对应一个暂停点（<code>suspend</code>
点）。每个暂停点会保存函数的局部变量、参数等到 <code>Continuation</code>
对象中。当协程恢复时，状态机根据 <code>label</code>
跳转到正确的代码块，继续执行。</p>
<p><strong>伪代码示例</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">myFunction</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">&quot;Step 1&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 暂停点</span></span><br><span class="line">    println(<span class="string">&quot;Step 2&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 编译后大致等价于：
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myFunction</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">String</span>&gt;)</span></span>: Any &#123;</span><br><span class="line">    <span class="keyword">val</span> state = continuation <span class="keyword">as</span>? MyFunctionContinuation ?: MyFunctionContinuation()</span><br><span class="line">    <span class="keyword">when</span> (state.label) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;Step 1&quot;</span>)</span><br><span class="line">            state.label = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (DelayKt.delay(<span class="number">1000</span>, state) == COROUTINE_SUSPENDED) <span class="keyword">return</span> COROUTINE_SUSPENDED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">1</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;Step 2&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>COROUTINE_SUSPENDED</code>
是一个特殊标记，表示协程已暂停。<code>state.label</code>
用于记录当前状态，<code>0</code> 表示初始状态，<code>1</code>
表示第一个暂停点之后的恢复状态。</p>
<p>当挂起函数调用另一个挂起函数（如
<code>delay</code>、<code>withContext</code>），会返回
<code>COROUTINE_SUSPENDED</code>，表示协程暂停。当协程恢复时，<code>Continuation.resumeWith</code>
被调用，传递上一次暂停的结果。状态机根据 <code>label</code>
跳转到对应的代码块，继续执行。挂起函数的暂停和恢复通常涉及
<code>CoroutineDispatcher</code>，它决定协程在哪个线程上运行。例如，<code>Dispatchers.IO</code>
用于 I/O 操作，<code>Dispatchers.Main</code> 用于 UI 线程。</p>
<p>Kotlin 协程的运行时由 <code>kotlinx.coroutines</code>
库提供，包含调度器、协程作用域、Continuation
等核心组件。每个协程都有一个上下文<code>CoroutineContext</code>，存储调度器、异常处理器等信息，控制协程的行为。调度器<code>Dispatcher</code>决定协程在哪个线程上执行或恢复。例如，<code>Dispatchers.Default</code>
用于 CPU 密集型任务，<code>Dispatchers.IO</code> 用于阻塞操作。</p>
<p>假设有以下挂起函数： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">&quot;Fetching data...&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Data&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 调用时：编译器将
<code>fetchData</code> 转换为接受 <code>Continuation</code>
参数的普通函数。调用 <code>fetchData</code> 时，传递一个
<code>Continuation</code>
对象，包含当前状态（<code>label</code>）和上下文。</p>
<p>暂停时：执行到 <code>delay(1000)</code> 时，<code>delay</code>
函数返回
<code>COROUTINE_SUSPENDED</code>，协程暂停。状态机保存当前状态（<code>label = 1</code>）和局部变量到
<code>Continuation</code>。</p>
<p>恢复时：调度器（例如
<code>Dispatchers.Default</code>）在延时结束后调用
<code>Continuation.resumeWith</code>，恢复协程。状态机根据
<code>label</code> 跳转到暂停点后的代码，继续执行
<code>return "Data"</code>。</p>
<p>挂起函数不保留完整的调用栈，而是通过 <code>Continuation</code>
保存状态，减少内存占用。暂停时线程可以执行其他任务，恢复时根据调度器选择合适的线程。Kotlin
编译器尽量减少状态机的开销，确保性能接近手写异步代码。</p>
<p>传统 Java 异步编程依赖回调，容易导致“回调地狱”。Kotlin
协程通过挂起函数提供结构化的异步编程，代码更简洁。Java 的
<code>CompletableFuture</code>
类似协程，但需要显式处理回调和线程切换，而协程通过编译器和运行时自动管理。Kotlin
协程的调度器（如
<code>Dispatchers.IO</code>）底层基于线程池，但通过挂起机制减少线程切换的开销。</p>
<p>Kotlin 协程提供 <code>kotlinx.coroutines.debug</code>
模块，可以打印协程的运行状态。IntelliJ IDEA 等 IDE
支持协程调试，显示暂停点和状态机信息。挂起函数中的异常通过
<code>Continuation.resumeWith</code>
传递，<code>CoroutineExceptionHandler</code> 可以捕获和处理异常。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 作用域函数 let 的实现原理</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/Kotlin-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0-let-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<p>Kotlin 中的 <code>let</code> 是一个
<strong>标准库扩展函数</strong>，它广泛用于作用域函数（Scope
Functions）中，尤其适用于对可空对象（nullable）做非空判断并执行代码块的场景。</p>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = <span class="string">&quot;123&quot;</span></span><br><span class="line">name?.let &#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子等价于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> it = name</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，<code>name?.let { ... }</code> 只有当 <code>name</code>
非空时才执行 <code>let</code> 的 lambda 块。lambda 表达式中
<code>it</code> 就是 <code>name</code> 的非空值。<code>let</code> 返回
lambda 的返回值。</p>
<h3 id="实现原理">实现原理</h3>
<p>Kotlin 的 <code>let</code> 函数定义在
<code>commonMain/kotlin/util/Standard.kt</code> 中，源码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是一个
<strong>内联（inline）函数</strong>，在编译时会被内联展开，避免 lambda
带来的性能开销。泛型 <code>&lt;T, R&gt;</code> 表示接收一个类型为
<code>T</code> 的对象，返回一个类型为 <code>R</code>
的结果。<code>T.let</code> 表示 <code>let</code> 是类型 <code>T</code>
的扩展函数。<code>block: (T) -&gt; R</code> 是接收 <code>T</code>
的函数（lambda 表达式）。也就是说，它只是将当前对象 <code>this</code>
传入了 <code>block(this)</code> 中。</p>
<p><code>@kotlin.internal.InlineOnly</code>，这是一个
<strong>注解（Annotation）</strong>，用于标记某个函数 <strong>只能在被
inline（内联）时使用</strong>，否则编译器会报错。</p>
<p>比如下面的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InlineOnly</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示这个 <code>let</code> 函数
<strong>不会生成实际函数调用</strong>（它只能内联展开），避免 Java 或非
Kotlin 编译器调用这个方法。</p>
<p>为什么要限制只能
inline？为了提高性能，避免生成函数对象和调用开销，同时
<strong>确保代码安全地被内联使用</strong>，防止其他模块通过反射或 Java
调用这个方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">contract &#123;</span><br><span class="line">    callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是Kotlin 的 <strong>Contract DSL</strong>，用于
<strong>给编译器更多关于 lambda
执行行为的信息</strong>，提升智能分析、空安全和优化。表示<code>block</code>
这个 lambda 参数，在函数调用过程中会
<strong>被调用且只调用一次</strong>（Exactly
once）。这使得编译器可以进行一些静态分析优化，例如在下面这种空检查中，判断
<code>name</code> 非空：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = <span class="string">&quot;abc&quot;</span></span><br><span class="line">name?.let &#123;</span><br><span class="line">    <span class="comment">// 编译器知道这里 it 一定非空，不会再要求你加 !!</span></span><br><span class="line">    println(it.length) <span class="comment">// 安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InvocationKind</code> 类型说明：</p>
<ul>
<li><code>EXACTLY_ONCE</code>：block 会被调用且仅一次</li>
<li><code>AT_LEAST_ONCE</code>：一定会调用一次或多次</li>
<li><code>AT_MOST_ONCE</code>：最多一次，可能不调用</li>
<li><code>UNKNOWN</code>：不确定</li>
</ul>
<p>编译器依靠这个信息进行<strong>控制流分析</strong>，提升非空智能推断、性能优化、检测死代码等能力。</p>
<p><code>R</code> 是泛型返回类型。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;T, R&gt;</code> 是泛型声明，<code>T</code>是调用
<code>let</code>
的对象类型（接收者），<code>R</code>是<code>block</code>
函数返回值的类型，也是 <code>let</code> 函数的最终返回值类型。</p>
<p>举例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">val</span> length: <span class="built_in">Int</span> = name.let &#123; it.length &#125; <span class="comment">// block 返回 Int，所以 R = Int</span></span><br></pre></td></tr></table></figure>
<p>也可以是任意类型：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> upper = <span class="string">&quot;abc&quot;</span>.let &#123; it.uppercase() &#125; <span class="comment">// R = String</span></span><br><span class="line"><span class="keyword">val</span> printResult = <span class="string">&quot;abc&quot;</span>.let &#123; println(it) &#125; <span class="comment">// R = Unit</span></span><br></pre></td></tr></table></figure>
<h3 id="编译后字节码">编译后字节码</h3>
<p>比如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = <span class="string">&quot;123&quot;</span></span><br><span class="line">name?.let &#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致翻译成 Java 是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器把 <code>?.let { ... }</code> 直接转成了
<code>if != null</code> 的判断。lambda
是内联展开的，不会有额外函数对象生成，所以效率非常高。</p>
<h3 id="常见用途">常见用途</h3>
<p><strong>处理 nullable 类型</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = getName()</span><br><span class="line">name?.let &#123;</span><br><span class="line">    println(<span class="string">&quot;非空值是：<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>链式调用</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map &#123; it * <span class="number">2</span> &#125;.let &#123;</span><br><span class="line">    it.joinToString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>限定作用域变量</strong>（避免变量污染）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> userInput = readLine()</span><br><span class="line">userInput?.let &#123;</span><br><span class="line">    <span class="keyword">val</span> trimmed = it.trim()</span><br><span class="line">    println(<span class="string">&quot;你输入的是：<span class="variable">$trimmed</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// trimmed 在此作用域外不可见</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 内联函数</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/Kotlin-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<p>Kotlin 的 <strong>内联函数（inline function）</strong>
是一种<strong>优化手段</strong>，它允许在编译时将函数的代码“展开”到调用处，从而避免函数调用的开销，尤其适用于
<strong>高阶函数（接受函数作为参数）</strong> 的场景。</p>
<h2 id="什么是内联函数">什么是内联函数</h2>
<p>正常函数调用会产生函数对象、栈帧和跳转指令，但内联函数会在编译时将函数<strong>代码插入到调用点</strong>，避免这些开销。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">    block()</span><br><span class="line">    println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doSomething &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后大致等价于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数体会“复制粘贴”到调用点。</p>
<h2 id="什么时候使用-inline">什么时候使用 <code>inline</code></h2>
<p>Kotlin 中<strong>高阶函数</strong>（比如
<code>let</code>、<code>run</code>、<code>with</code>、<code>apply</code>）频繁使用内联，避免函数对象的创建（<code>block: () -&gt; Unit</code>
不会生成 Function 对象），避免 lambda 的闭包捕获、堆分配和 GC
开销。普通业务函数不推荐使用内联，会导致代码膨胀。</p>
<h2 id="inline-的工作原理">inline 的工作原理</h2>
<p>内联函数不是运行时特性，而是<strong>编译器替换机制</strong>。<code>inline fun foo(block: () -&gt; Unit)</code>
编译器看到后就会展开 <code>block()</code>
的实现到调用点。如果有多个调用点，会展开多次（可能造成代码膨胀）。</p>
<p>使用 <code>return@label</code>可以局部返回：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doSomething &#123;</span><br><span class="line">        println(<span class="string">&quot;Inside block&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@doSomething</span> <span class="comment">// 局部返回，不影响 main</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不加 inline 会怎么样，编译器会生成 Function
实例（Function0），lambda 体被封装为对象，可能造成性能下降，尤其是在
Android 中。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="noinline-与-crossinline">noinline 与 crossinline</h2>
<h3 id="noinline"><code>noinline</code></h3>
<p>默认情况下，所有函数参数都会被内联。但你可以用 <code>noinline</code>
排除部分参数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(block1: () -&gt; <span class="type">Unit</span>, <span class="keyword">noinline</span> block2: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block1()  <span class="comment">// 被内联</span></span><br><span class="line">    block2()  <span class="comment">// 作为函数对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>noinline</code>
主要用于函数参数需要作为对象传递，以及不能内联的上下文（如存储到变量）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doOps</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    inlineBlock: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">noinline</span> logging: () -&gt; <span class="type">Unit</span>  <span class="comment">// 这里阻止了 logging 被内联</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    inlineBlock()   <span class="comment">// 内联</span></span><br><span class="line">    <span class="keyword">val</span> func = logging  <span class="comment">// 如果不加 noinline 会编译错误，因为不能传递被内联的 lambda</span></span><br><span class="line">    func()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="crossinline"><code>crossinline</code></h3>
<p>禁止 lambda 用 <code>return</code> 做“非局部返回”。默认情况下，内联
lambda 可以直接 <code>return</code>，但有风险。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">higherOrder</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">    block()</span><br><span class="line">    println(<span class="string">&quot;After&quot;</span>) <span class="comment">// 如果 block 里直接 return，这行永远不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    higherOrder &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">// 这是“非局部返回”：会从 test() 函数直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要禁止这种“跳出上层函数”的行为，加 <code>crossinline</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">higherOrder</span><span class="params">(<span class="keyword">crossinline</span> block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">    block()</span><br><span class="line">    println(<span class="string">&quot;After&quot;</span>) <span class="comment">// 如果 block 里直接 return，这行永远不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    higherOrder &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">// 现在 block() 里面不能写 return 了,这里会报错，但是依然可以写 return@higherOrder</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项与风险">注意事项与风险</h2>
<h3 id="代码膨胀">代码膨胀</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">heavy</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">    heavy &#123; ... &#125; <span class="comment">// 编译后生成 1000 份代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数体复杂，调用频繁时，会导致APK 变大，方法数上升。</p>
<h3 id="调试困难">调试困难</h3>
<p>内联函数展开后，调试栈信息会变得混乱，调试时跳转不准。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 协程</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/Kotlin-%E5%8D%8F%E7%A8%8B.html</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>Kotlin 协程引入于 Kotlin
1.3，是一种基于线程的轻量级并发工具，适合处理异步任务，基于
<code>kotlinx.coroutines</code> 库。Kotlin
协程支持挂起（suspend）机制，可以挂起和恢复，允许以顺序风格编写异步代码，类似于同步代码，但不会阻塞线程，同时避免传统回调地狱。协程的核心优势包括资源高效（不阻塞线程）和结构化并发（确保资源管理）。每个协程必须在一个作用域（<code>CoroutineScope</code>）中启动。</p>
<p>协程语法点包括：</p>
<ol type="1">
<li>启动协程（如 <code>launch</code>、<code>async</code>）</li>
<li>挂起函数</li>
<li>上下文和调度器（如 <code>Dispatchers</code>）</li>
<li>取消和超时</li>
<li>异常处理</li>
<li>结构化并发（如 <code>coroutineScope</code>）</li>
<li>通道（<code>Channel</code>）</li>
<li>流（<code>Flow</code>）</li>
<li>选择表达式（<code>select</code>）</li>
<li>测试工具</li>
</ol>
<p>协程实际应用场景包括网络请求、数据库操作、并发任务和超时处理。</p>
<h2 id="语法总结">语法总结</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 23%" />
<col style="width: 44%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>语法点</strong></th>
<th><strong>用途</strong></th>
<th><strong>示例场景</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>launch</code></td>
<td>启动无返回结果的协程</td>
<td>后台任务，如日志记录</td>
</tr>
<tr class="even">
<td><code>async</code></td>
<td>启动返回结果的协程</td>
<td>并行计算结果</td>
</tr>
<tr class="odd">
<td><code>runBlocking</code></td>
<td>阻塞线程等待协程完成</td>
<td>测试或主函数入口</td>
</tr>
<tr class="even">
<td><code>withContext</code></td>
<td>切换上下文运行挂起块</td>
<td>网络请求或 I/O 操作</td>
</tr>
<tr class="odd">
<td><code>suspend</code> 函数</td>
<td>定义可挂起的异步函数</td>
<td>网络请求或 I/O 操作</td>
</tr>
<tr class="even">
<td><code>Dispatchers</code></td>
<td>选择执行线程（如 IO、Main、Default）</td>
<td>UI 更新或数据库操作</td>
</tr>
<tr class="odd">
<td><code>Job</code> 和 <code>Deferred</code></td>
<td>管理任务生命周期和结果</td>
<td>等待任务完成或取消</td>
</tr>
<tr class="even">
<td>取消和超时</td>
<td>取消协程或设置时间限制</td>
<td>超时网络请求</td>
</tr>
<tr class="odd">
<td>异常处理</td>
<td>处理协程中的异常</td>
<td>错误日志记录</td>
</tr>
<tr class="even">
<td><code>coroutineScope</code></td>
<td>结构化并发管理子协程</td>
<td>确保任务顺序执行</td>
</tr>
<tr class="odd">
<td><code>supervisorScope</code></td>
<td>容错结构化并发</td>
<td>子任务失败不影响其他</td>
</tr>
<tr class="even">
<td><code>Channel</code></td>
<td>协程间通信</td>
<td>生产者-消费者模式</td>
</tr>
<tr class="odd">
<td><code>Flow</code></td>
<td>处理异步数据流</td>
<td>实时数据更新，如传感器数据</td>
</tr>
<tr class="even">
<td><code>select</code></td>
<td>选择第一个可用结果</td>
<td>多个异步操作竞争</td>
</tr>
<tr class="odd">
<td><code>yield</code></td>
<td>让出执行权</td>
<td>协作式多任务</td>
</tr>
<tr class="even">
<td><code>joinAll</code></td>
<td>等待多个 Job 完成</td>
<td>批量任务同步</td>
</tr>
<tr class="odd">
<td><code>awaitAll</code></td>
<td>等待多个 Deferred 结果</td>
<td>并发结果收集</td>
</tr>
<tr class="even">
<td>测试工具</td>
<td>测试协程行为</td>
<td>单元测试和集成测试</td>
</tr>
</tbody>
</table>
<h2 id="启动协程">启动协程</h2>
<h3 id="launch"><code>launch</code></h3>
<p>启动不返回结果的协程。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async"><code>async</code></h3>
<p>启动返回 <code>Deferred&lt;T&gt;</code> 的协程，用于获取结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;The answer is <span class="subst">$&#123;deferred.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="runblocking"><code>runBlocking</code></h3>
<p>阻塞当前线程直到协程完成，常用于测试或主函数。用于在
<code>main</code>函数中桥接阻塞与非阻塞代码。在作用域中启动的所有协程（如
<code>launch {}</code>）必须完成，<code>runBlocking</code>才会返回。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;inside launch&quot;</span>)</span><br><span class="line">    	&#125;</span><br><span class="line">        </span><br><span class="line">        println(<span class="string">&quot;Hello from runBlocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中， <code>runBlocking { ... }</code>
会阻塞当前线程，在当前线程中创建一个顶层协程（<code>CoroutineScope</code>），<code>println("Hello from runBlocking")</code>
是在 <code>runBlocking</code>
的协程中执行的（运行在主线程，但属于协程代码）。</p>
<h3 id="withcontext"><code>withContext</code></h3>
<p>在指定上下文运行挂起块，返回结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    <span class="string">&quot;Data from network&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = fetchData()</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="挂起函数">挂起函数</h2>
<h3 id="suspend">suspend</h3>
<p>挂起函数用 <code>suspend</code>
关键字标记，只能从其他挂起函数或协程中调用，支持 <code>delay</code>
等挂起操作。 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;Done something&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="协程作用域">协程作用域</h2>
<h3 id="kotlin-协程作用域">Kotlin 协程作用域</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 21%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th>##</th>
<th>协程作用域</th>
<th>是否结构化</th>
<th>是否阻塞线程</th>
<th>生命周期</th>
<th>典型用途</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>runBlocking</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>直到 block 执行完毕</td>
<td>测试、main 函数入口</td>
<td>✅（仅限测试/入口）</td>
</tr>
<tr class="even">
<td>2</td>
<td><code>coroutineScope</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>当前 <code>suspend</code> 函数结束</td>
<td>并发封装、函数内结构化并发</td>
<td>✅ 推荐</td>
</tr>
<tr class="odd">
<td>3</td>
<td><code>supervisorScope</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>当前 <code>suspend</code> 函数结束</td>
<td>容错并发（互不影响）</td>
<td>✅ 推荐</td>
</tr>
<tr class="even">
<td>4</td>
<td><code>GlobalScope</code></td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>应用进程存活期间</td>
<td>后台任务（不推荐）</td>
<td>⚠️ 慎用（可能泄漏）</td>
</tr>
<tr class="odd">
<td>5</td>
<td>自定义 <code>CoroutineScope(...)</code></td>
<td>✅/❌ 取决于 Job</td>
<td>❌ 否</td>
<td>由 Job 控制（手动 cancel）</td>
<td>封装类、组件内任务</td>
<td>✅ 合理使用</td>
</tr>
<tr class="even">
<td>7</td>
<td><code>actor</code> / <code>produce</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>通道关闭或被取消</td>
<td>Channel 并发、消息队列</td>
<td>✅ 特定场景推荐</td>
</tr>
</tbody>
</table>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;🔷 1. runBlocking started on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. coroutineScope（结构化并发）</span></span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            println(<span class="string">&quot;🔷 2. coroutineScope: child coroutine on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. supervisorScope（不会因子协程失败而取消整个作用域）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay(<span class="number">200</span>)</span><br><span class="line">                println(<span class="string">&quot;🔷 3. supervisorScope: success task&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;🔷 3. supervisorScope: failed task&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;🔴 Caught exception from supervisorScope: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. GlobalScope（不建议常用）</span></span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">300</span>)</span><br><span class="line">        println(<span class="string">&quot;🔷 4. GlobalScope coroutine on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待 GlobalScope 启动的协程完成</span></span><br><span class="line">    <span class="comment">// 如果不加这一行，上面的 GlobalScope 无法打印，因为 GlobalScope 启动的是一个全局线程，不是 runBlocking 的一部分，runBlocking 执行完就退出了，主线程结束，整个进程随之结束，导致 GlobalScope 中来不及打印就被强行终止了。</span></span><br><span class="line">    job.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 自定义 CoroutineScope</span></span><br><span class="line">    <span class="keyword">val</span> customScope = CoroutineScope(Job() + Dispatchers.Default)</span><br><span class="line">    <span class="keyword">val</span> customJob = customScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;🔷 5. Custom CoroutineScope running on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. produce 示例（生产者管道）</span></span><br><span class="line">    <span class="keyword">val</span> numberProducer = produce &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            send(it * it)</span><br><span class="line">        &#125;</span><br><span class="line">        close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> numberProducer) &#123;</span><br><span class="line">        println(<span class="string">&quot;🔷 6. produce: received <span class="variable">$num</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. actor 示例（带状态协程处理器）</span></span><br><span class="line">    <span class="keyword">val</span> sumActor = actor&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            sum += msg</span><br><span class="line">            println(<span class="string">&quot;🔷 7. actor: received <span class="variable">$msg</span>, current sum = <span class="variable">$sum</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).forEach &#123; sumActor.send(it) &#125;</span><br><span class="line">    sumActor.close()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;🕒 Waiting for GlobalScope &amp; other coroutines...&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 等待其他 coroutine 执行完成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记得手动 cancel 非结构化作用域</span></span><br><span class="line">    customJob.join()</span><br><span class="line">    customScope.cancel()</span><br><span class="line">    println(<span class="string">&quot;✅ runBlocking completed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="android-扩展作用域">Android 扩展作用域</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 3%" />
<col style="width: 18%" />
<col style="width: 9%" />
<col style="width: 29%" />
<col style="width: 29%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="header">
<th>##</th>
<th>Android Scope</th>
<th>是否结构化</th>
<th>生命周期绑定对象</th>
<th>典型用途</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>viewModelScope</code></td>
<td>✅ 是</td>
<td>ViewModel 生命周期</td>
<td>网络/IO/业务逻辑</td>
<td>✅ 推荐</td>
</tr>
<tr class="even">
<td>2</td>
<td><code>lifecycleScope</code></td>
<td>✅ 是</td>
<td>Activity / Fragment 生命周期</td>
<td>启动任务 / UI操作</td>
<td>✅ 推荐</td>
</tr>
<tr class="odd">
<td>3</td>
<td><code>repeatOnLifecycle</code></td>
<td>✅ 是</td>
<td>生命周期状态变化（如 STARTED）</td>
<td>生命周期感知、数据收集（Flow）</td>
<td>✅ 推荐</td>
</tr>
</tbody>
</table>
<p><code>MainActivity.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.activity.ComponentActivity</span><br><span class="line"><span class="keyword">import</span> androidx.activity.viewModels</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Lifecycle</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.lifecycleScope</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.repeatOnLifecycle</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.delay</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> viewModels&lt;MyViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ✅ 1. lifecycleScope：跟随 Activity 生命周期</span></span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            delay(<span class="number">300</span>)</span><br><span class="line">            println(<span class="string">&quot;1️⃣ lifecycleScope → Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ✅ 2. repeatOnLifecycle：STARTED 时自动启动，STOPPED 时自动取消</span></span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            repeatOnLifecycle(Lifecycle.State.STARTED) &#123;</span><br><span class="line">                viewModel.timerFlow.collect &#123;</span><br><span class="line">                    println(<span class="string">&quot;2️⃣ repeatOnLifecycle collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ✅ 3. viewModelScope（定义在 ViewModel 中）</span></span><br><span class="line">        viewModel.loadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MyViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewModelScope</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.delay</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flow 模拟定时器</span></span><br><span class="line">    <span class="keyword">val</span> timerFlow: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">        <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            emit(counter++)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            println(<span class="string">&quot;3️⃣ viewModelScope → Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1️⃣ lifecycleScope → Thread: main</span><br><span class="line">3️⃣ viewModelScope → Thread: main</span><br><span class="line">2️⃣ repeatOnLifecycle collect: 0</span><br><span class="line">2️⃣ repeatOnLifecycle collect: 1</span><br><span class="line">2️⃣ repeatOnLifecycle collect: 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ul>
<li><p><code>lifecycleScope</code> → 生命周期感知，自动取消协程（适合 UI
层数据加载等）</p></li>
<li><p><code>repeatOnLifecycle</code> → 更细粒度的生命周期感知（可结合
<code>Flow</code> 实现 UI 活动期间自动收集）</p></li>
<li><p><code>viewModelScope</code> → 随
<code>ViewModel.onCleared()</code> 自动取消，适合业务处理逻辑</p></li>
</ul>
<h3 id="使用场景">使用场景</h3>
<table>
<thead>
<tr class="header">
<th>使用场景</th>
<th>推荐作用域</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>main 函数或测试</td>
<td><code>runBlocking</code></td>
</tr>
<tr class="even">
<td>挂起函数内并发</td>
<td><code>coroutineScope</code></td>
</tr>
<tr class="odd">
<td>容错并发</td>
<td><code>supervisorScope</code></td>
</tr>
<tr class="even">
<td>UI 层任务</td>
<td><code>viewModelScope</code> / <code>lifecycleScope</code></td>
</tr>
<tr class="odd">
<td>库或类封装内建 scope</td>
<td><code>CoroutineScope(...)</code></td>
</tr>
<tr class="even">
<td>Flow、通道数据源</td>
<td><code>produce</code> / <code>actor</code> 内隐含作用域</td>
</tr>
<tr class="odd">
<td>后台不销毁任务</td>
<td>极少情况用 <code>GlobalScope</code>（通常不推荐）</td>
</tr>
</tbody>
</table>
<h2 id="协程上下文和调度器">协程上下文和调度器</h2>
<p>调度器（如
<code>Dispatchers.Main</code>、<code>Dispatchers.IO</code>、<code>Dispatchers.Default</code>、<code>Dispatchers.Unconfined</code>）决定协程运行的线程。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(Dispatchers.Main) &#123; &#125;      <span class="comment">// UI线程</span></span><br><span class="line">launch(Dispatchers.IO) &#123; &#125;        <span class="comment">// IO密集型</span></span><br><span class="line">launch(Dispatchers.Default) &#123; &#125;   <span class="comment">// CPU密集型</span></span><br><span class="line">launch(Dispatchers.Unconfined) &#123; &#125; <span class="comment">// 不固定线程，惯性调度</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;Running on IO thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="job-和-deferred">Job 和 Deferred</h2>
<h3 id="job">Job</h3>
<p>🔹 <code>Job</code>：表示一个可以被取消的协程任务</p>
<p>✅ 特点：</p>
<ul>
<li>代表一个正在运行的协程任务</li>
<li>可以：
<ul>
<li>取消（<code>job.cancel()</code>）</li>
<li>等待其完成（<code>job.join()</code>）</li>
</ul></li>
<li><strong>不返回结果值</strong>，只表示任务的生命周期</li>
</ul>
<p>✅ 示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Job completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Waiting for job...&quot;</span>)</span><br><span class="line">    job.join() <span class="comment">// 等待协程完成</span></span><br><span class="line">    println(<span class="string">&quot;Main function continues&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="deferred">Deferred</h3>
<p>🔹 <code>Deferred&lt;T&gt;</code>：表示一个带返回值的协程任务（类似于
<code>Future&lt;T&gt;</code>）</p>
<p>✅ 特点：</p>
<ul>
<li>是 <code>Job</code> 的子类型</li>
<li>表示一个异步计算的结果</li>
<li>使用 <code>async</code> 创建，调用 <code>.await()</code>
获取结果</li>
<li>也可以取消、检查是否完成</li>
</ul>
<p>✅ 示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred: Deferred&lt;<span class="built_in">Int</span>&gt; = async &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Doing other things...&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = deferred.await() <span class="comment">// 等待并获取返回值</span></span><br><span class="line">    println(<span class="string">&quot;Result: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>🔍 <code>Job</code> 与 <code>Deferred</code> 的对比</p>
<table>
<thead>
<tr class="header">
<th>属性/行为</th>
<th><code>Job</code></th>
<th><code>Deferred&lt;T&gt;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>是否返回结果值</td>
<td>❌ 无</td>
<td>✅ 有返回值 (<code>T</code>)</td>
</tr>
<tr class="even">
<td>创建方式</td>
<td><code>launch { ... }</code></td>
<td><code>async { ... }</code></td>
</tr>
<tr class="odd">
<td>获取结果方式</td>
<td>无</td>
<td><code>await()</code></td>
</tr>
<tr class="even">
<td>取消任务</td>
<td>✅ <code>.cancel()</code></td>
<td>✅ <code>.cancel()</code></td>
</tr>
<tr class="odd">
<td>等待完成</td>
<td>✅ <code>.join()</code></td>
<td>✅ <code>.await()</code></td>
</tr>
<tr class="even">
<td>是否继承自 Job</td>
<td>✅ 本身就是</td>
<td>✅ 是 <code>Job</code> 的子接口</td>
</tr>
<tr class="odd">
<td>典型用途</td>
<td>启动独立任务</td>
<td>启动异步计算并获取值</td>
</tr>
</tbody>
</table>
<hr />
<p>✅ 使用建议</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 27%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="header">
<th>场景</th>
<th>使用类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>启动任务但不关心结果</td>
<td><code>launch</code> → <code>Job</code></td>
<td>适合 UI 更新、日志、并发 fire-and-forget</td>
</tr>
<tr class="even">
<td>启动异步任务并获取值</td>
<td><code>async</code> → <code>Deferred&lt;T&gt;</code></td>
<td>比如网络请求、计算、数据处理等</td>
</tr>
</tbody>
</table>
<hr />
<p>💡 补充知识点：<code>async</code> 的懒启动模式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> deferred = async(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 之后需要时调用 await 会启动</span></span><br><span class="line"><span class="keyword">val</span> result = deferred.await()</span><br></pre></td></tr></table></figure>
<h2 id="取消和超时">取消和超时</h2>
<h3 id="cancel">cancel</h3>
<p>取消：用 <code>cancel</code> 取消协程。<br />
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;Coroutine executing <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">    println(<span class="string">&quot;Coroutine cancelled&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可响应取消的方式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">        <span class="comment">// 做一些任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="withtimeout">withTimeout</h3>
<p>超时：用 <code>withTimeout</code> 设置时间限制。 抛出
<code>TimeoutCancellationException</code> ❌</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        withTimeout(<span class="number">1300L</span>) &#123;</span><br><span class="line">            repeat(<span class="number">5</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;Processing <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: TimeoutCancellationException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Timed out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="withtimeoutornull">withTimeoutOrNull</h3>
<p>返回 <code>null</code>，不抛异常 ✅</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">withTimeout(<span class="number">1000</span>) &#123;</span><br><span class="line">    delay(<span class="number">2000</span>) <span class="comment">// 抛出 TimeoutCancellationException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1000</span>) &#123;</span><br><span class="line">    delay(<span class="number">2000</span>)</span><br><span class="line">    <span class="string">&quot;This won&#x27;t return&quot;</span></span><br><span class="line">&#125; ?: <span class="string">&quot;Timeout!&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="异常处理">异常处理</h2>
<p>使用 <code>CoroutineExceptionHandler</code>
处理异常（launch中使用）。<br />
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 在 Kotlin 中，_ 是一个 占位符变量名，表示“我不关心这个参数的值”。</span></span><br><span class="line">    <span class="keyword">val</span> handler = CoroutineExceptionHandler &#123; _, exception -&gt;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$exception</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(handler) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exception(<span class="string">&quot;Error in coroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>try-catch</code> 处理异常。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exception(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协程组合与并发控制">协程组合与并发控制</h2>
<h3 id="并发执行任务-组合结果">并发执行任务 + 组合结果</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 模拟耗时任务</span></span><br><span class="line">    println(<span class="string">&quot;👤 getUser completed on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User123&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPosts</span><span class="params">()</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    delay(<span class="number">800</span>) <span class="comment">// 模拟另一个耗时任务</span></span><br><span class="line">    println(<span class="string">&quot;📝 getPosts completed on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="string">&quot;Post A&quot;</span>, <span class="string">&quot;Post B&quot;</span>, <span class="string">&quot;Post C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;🚀 Running in [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userDeferred = async &#123; getUser() &#125;</span><br><span class="line">    <span class="keyword">val</span> postsDeferred = async &#123; getPosts() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to 是 Kotlin 中的一个非常常用的 中缀函数，用于创建键值对 (Pair)。</span></span><br><span class="line">    <span class="comment">// val (a, b) 是解构（destructuring），用多个变量同时接收一个对象（Pair、Triple、map 或数据类）的多个字段值。</span></span><br><span class="line">    <span class="keyword">val</span> (a, b) = userDeferred.await() to postsDeferred.await()</span><br><span class="line">    println(<span class="string">&quot;✅ Combined result: <span class="variable">$a</span> + <span class="variable">$b</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺序执行多个挂起函数">顺序执行多个挂起函数</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;👤 getUser completed on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User456&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPosts</span><span class="params">(user: <span class="type">String</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    delay(<span class="number">800</span>)</span><br><span class="line">    println(<span class="string">&quot;📝 getPosts for <span class="variable">$user</span> completed on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="string">&quot;Post X&quot;</span>, <span class="string">&quot;Post Y&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;🚀 Running in [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user = getUser()</span><br><span class="line">    <span class="keyword">val</span> posts = getPosts(user)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;✅ Result for <span class="variable">$user</span>: <span class="variable">$posts</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区别说明</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 11%" />
<col style="width: 27%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th>模式</th>
<th>是否并发</th>
<th>用法</th>
<th>适合场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>async + await</code></td>
<td>✅ 是</td>
<td>并发获取多个独立结果</td>
<td>多个不依赖关系的网络/API 请求</td>
</tr>
<tr class="even">
<td>顺序调用</td>
<td>❌ 否</td>
<td>一个接一个</td>
<td>后一个依赖前一个结果</td>
</tr>
</tbody>
</table>
<h2 id="结构化并发">结构化并发</h2>
<p>结构化并发的核心：</p>
<ul>
<li>父协程自动管理子协程</li>
<li>作用域退出时取消未完成子协程</li>
<li>错误自动传播</li>
</ul>
<h3 id="coroutinescope">coroutineScope</h3>
<p><code>coroutineScope</code>: 创建作用域，等待所有子协程完成。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performTasks</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    performTasks()</span><br><span class="line">    println(<span class="string">&quot;All tasks completed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="supervisorscope">supervisorScope</h3>
<p><code>supervisorScope</code>: 类似，但子协程失败不影响其他。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performTasks</span><span class="params">()</span></span> = supervisorScope &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="keyword">throw</span> Exception(<span class="string">&quot;Task 1 failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task 2 completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        performTasks()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught exception: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Main function continues&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通道channels">通道（Channels）</h2>
<p>用于协程间通信，支持生产者-消费者模式。<br />
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) channel.send(x * x)</span><br><span class="line">        channel.close()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (y <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(y)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="流flows">流（Flows）</h2>
<p>Flow（协程版响应式流） 的特性：</p>
<ul>
<li>是冷流（调用 collect 才执行）</li>
<li>自动挂起支持</li>
<li>支持背压、变换、合并等操作符（如 map、filter、combine）</li>
</ul>
<p>处理异步数据流。<br />
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            emit(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.collect &#123; </span><br><span class="line">        value -&gt; println(value) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择表达式select-expression">选择表达式（Select
Expression）</h2>
<p>同时等待多个挂起操作，选择第一个可用结果。<br />
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.selects.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectExample1</span><span class="params">(scope: <span class="type">CoroutineScope</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> deferred1 = scope.async &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            <span class="string">&quot;Result 1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> deferred2 = scope.async &#123;</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">            <span class="string">&quot;Result 2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        select&lt;String&gt; &#123;</span><br><span class="line">            deferred1.onAwait &#123; it &#125;</span><br><span class="line">            deferred2.onAwait &#123; it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="string">&quot;Error occurred: <span class="subst">$&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectExample2</span><span class="params">()</span></span>: String = coroutineScope &#123;</span><br><span class="line">    <span class="comment">// 表示从 coroutineScope block 中返回, 而不是返回外部函数，可省略</span></span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@coroutineScope</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> deferred1 = async &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            <span class="string">&quot;Result 1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> deferred2 = async &#123;</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">            <span class="string">&quot;Result 2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        select&lt;String&gt; &#123;</span><br><span class="line">            deferred1.onAwait &#123; it &#125;</span><br><span class="line">            deferred2.onAwait &#123; it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="string">&quot;Error occurred: <span class="subst">$&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> result1 = selectExample1(<span class="keyword">this</span>)</span><br><span class="line">        println(result1)</span><br><span class="line">        <span class="keyword">val</span> result2 = selectExample2()</span><br><span class="line">        println(result2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="工具函数">工具函数</h2>
<h3 id="yield">yield</h3>
<p>让出执行权，允许其他协程运行，适合协作式多任务。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;Coroutine 1: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            yield()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;Coroutine 2: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            yield()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<code>Coroutine 1</code> 和 <code>Coroutine 2</code>
交替执行。</p>
<h3 id="joinall">joinAll</h3>
<p>等待多个 <code>Job</code> 完成。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;Job 1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">            delay(<span class="number">2000L</span>)</span><br><span class="line">            println(<span class="string">&quot;Job 2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        joinAll(job1, job2)</span><br><span class="line">        println(<span class="string">&quot;All jobs completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<code>Job 1</code>、<code>Job 2</code>、<code>All jobs completed</code>。</p>
<h3 id="awaitall">awaitAll</h3>
<p>等待多个 <code>Deferred</code> 完成，返回结果列表。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> deferred1 = async &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> deferred2 = async &#123;</span><br><span class="line">            delay(<span class="number">2000L</span>)</span><br><span class="line">            <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> results = awaitAll(deferred1, deferred2)</span><br><span class="line">        println(results)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<code>Results: [1, 2]</code>。</p>
<h2 id="测试协程">测试协程</h2>
<p>使用 <code>runBlockingTest</code> 和
<code>TestCoroutineDispatcher</code> 测试协程，适合单元测试。
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.async</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.delay</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.advanceTimeBy</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.runTest</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert</span><br><span class="line"><span class="keyword">import</span> kotlin.test.Test</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoroutineTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            <span class="number">42</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        advanceTimeBy(<span class="number">1000L</span>)</span><br><span class="line">        <span class="keyword">val</span> result = deferred.await()</span><br><span class="line">        println(<span class="string">&quot;Result in test: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        Assert.assertEquals(<span class="number">42</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3&quot;</span>)</span><br><span class="line">testImplementation(<span class="string">&quot;junit:junit:4.13.2&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="实际应用场景">实际应用场景</h2>
<h3 id="网络请求android">网络请求（Android）</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> retrofit2.Retrofit</span><br><span class="line"><span class="keyword">import</span> retrofit2.converter.gson.GsonConverterFactory</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.GET</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;data&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">&quot;https://api.example.com/&quot;</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> apiService = retrofit.create(ApiService::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> <span class="keyword">data</span> = apiService.getData()</span><br><span class="line">                println(<span class="string">&quot;Fetched data: <span class="variable">$data</span>&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                println(<span class="string">&quot;Error: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据库操作">数据库操作</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.room.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepository</span>(<span class="keyword">private</span> <span class="keyword">val</span> dao: UserDao) &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertUser</span><span class="params">(user: <span class="type">User</span>)</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">        dao.insert(user)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> repository = UserRepository(<span class="comment">/* DAO instance */</span>)</span><br><span class="line">    launch &#123; repository.insertUser(User(<span class="number">1</span>, <span class="string">&quot;John&quot;</span>)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发-api-调用">并发 API 调用</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData1</span><span class="params">()</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="string">&quot;Data 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData2</span><span class="params">()</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">1500</span>)</span><br><span class="line">    <span class="string">&quot;Data 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred1 = async &#123; fetchData1() &#125;</span><br><span class="line">    <span class="keyword">val</span> deferred2 = async &#123; fetchData2() &#125;</span><br><span class="line">    <span class="keyword">val</span> results = awaitAll(deferred1, deferred2)</span><br><span class="line">    println(<span class="string">&quot;Results: <span class="variable">$results</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="超时处理">超时处理</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">longRunningTask</span><span class="params">()</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">3000</span>)</span><br><span class="line">    <span class="string">&quot;Done&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        withTimeout(<span class="number">2000L</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> result = longRunningTask()</span><br><span class="line">            println(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: TimeoutCancellationException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Task timed out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://kotlinlang.org/docs/coroutines-guide.html">Kotlin
Coroutines Guide with Examples</a>：提供核心特性和示例</li>
<li><a href="https://kotlinlang.org/docs/coroutines-basics.html">Kotlin
Coroutines Basics Introduction</a>：涵盖基础概念</li>
<li><a href="https://developer.android.com/kotlin/coroutines">Kotlin
Coroutines on Android Detailed Guide</a>：专注于 Android 应用</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 属性委托 observable 的实现原理</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/Kotlin-%E5%B1%9E%E6%80%A7%E5%A7%94%E6%89%98-observable-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<p>Kotlin 的 <code>Delegates.observable</code> 是 Kotlin
标准库中提供的一个属性委托，它允许你在属性的值发生变化时自动执行某段逻辑，比如常用于监听属性变化（例如
UI 数据更新）。</p>
<h1 id="基本使用示例">🔧 基本使用示例：</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;initial&quot;</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;property.name&#125;</span> changed from <span class="variable">$oldValue</span> to <span class="variable">$newValue</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">    name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name changed from initial to Alice</span><br><span class="line">name changed from Alice to Bob</span><br></pre></td></tr></table></figure>
<h1 id="实现原理">⚙️ 实现原理</h1>
<h2
id="delegates.observable...-返回了一个实现了-readwriteproperty-接口的对象">✅
1. <code>Delegates.observable(...)</code> 返回了一个实现了
<code>ReadWriteProperty</code> 接口的对象：</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">observable</span><span class="params">(initialValue: <span class="type">T</span>, <span class="keyword">crossinline</span> onChange: (<span class="type">property</span>: <span class="type">KProperty</span>&lt;*&gt;, <span class="type">oldValue</span>: <span class="type">T</span>, <span class="type">newValue</span>: <span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>:</span><br><span class="line">            ReadWriteProperty&lt;Any?, T&gt; =</span><br><span class="line">        <span class="keyword">object</span> : ObservableProperty&lt;T&gt;(initialValue) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterChange</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;, oldValue: <span class="type">T</span>, newValue: <span class="type">T</span>)</span></span> = onChange(property, oldValue, newValue)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>它返回了一个 <code>ObservableProperty</code> 实例。</p>
<hr />
<h2 id="observableproperty-实现了属性委托接口readwriteproperty">✅ 2.
<code>ObservableProperty</code>
实现了属性委托接口<code>ReadWriteProperty</code>：</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ObservableProperty</span>&lt;<span class="type">V</span>&gt;(initialValue: V) : ReadWriteProperty&lt;Any?, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value = initialValue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeChange</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;, oldValue: <span class="type">V</span>, newValue: <span class="type">V</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterChange</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;, oldValue: <span class="type">V</span>, newValue: <span class="type">V</span>)</span></span>: <span class="built_in">Unit</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">V</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">if</span> (!beforeChange(property, oldValue, value)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        afterChange(property, oldValue, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;ObservableProperty(value=<span class="variable">$value</span>)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>beforeChange</code>在属性值被变更前被调用，默认返回<code>true</code>，就是说即使你写出这样的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;init&quot;</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;property.name&#125;</span> changed from <span class="variable">$oldValue</span> to <span class="variable">$newValue</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name = <span class="string">&quot;init&quot;</span></span><br><span class="line">    name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也会输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name changed from init to init</span><br><span class="line">name changed from init to Bob</span><br></pre></td></tr></table></figure>
<p><code>ObservableProperty</code>内部维护了属性值，并在
<code>setValue</code>
方法中触发回调，这个回调的实现就是我们传入的<code>lambda</code>参数<code>onChange</code>。</p>
<p>每次我们通过赋值等操作修改被委托的属性时，都会触发
<code>setValue()</code> 方法，从而调用 <code>onChange</code> 回调。</p>
<hr />
<h1 id="总结工作机制">📌 总结：工作机制</h1>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>步骤</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1️⃣</td>
<td><code>Delegates.observable(initialValue, onChange)</code> 返回
<code>ObservableProperty</code> 实例</td>
</tr>
<tr class="even">
<td>2️⃣</td>
<td><code>ObservableProperty</code> 实现了
<code>ReadWriteProperty</code> 接口</td>
</tr>
<tr class="odd">
<td>3️⃣</td>
<td>Kotlin 编译器在 <code>by</code> 后会将属性访问转发给
<code>getValue()</code> 和 <code>setValue()</code></td>
</tr>
<tr class="even">
<td>4️⃣</td>
<td><code>setValue()</code> 中自动触发 <code>onChange()</code> 回调</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="使用场景">💡 使用场景</h1>
<ul>
<li>数据绑定（如 UI）</li>
<li>表单输入监听</li>
<li>MVVM 架构中 <code>ViewModel</code> 属性监听</li>
<li>日志审计、调试属性变化等</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 待研究问题</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/Kotlin-%E5%BE%85%E7%A0%94%E7%A9%B6%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<ol type="1">
<li><code>lateinit</code> 和 <code>lazy</code> 的区别</li>
</ol>
<ul>
<li><code>lateinit</code>
是一个修饰符，用于延迟初始化变量，通常用于非空类型的属性。它允许在稍后的时间点初始化变量，而不是在声明时立即赋值。</li>
<li><code>lazy</code>
是一个函数，用于延迟计算变量的值。它通常用于只读属性，并且在第一次访问时才会计算值。</li>
<li><code>lateinit</code> 变量可以在任何时候被重新赋值，而
<code>lazy</code> 变量一旦被计算后就不能再改变。</li>
<li><code>lateinit</code> 变量必须是可变的（var），而 <code>lazy</code>
变量通常是不可变的（val）。</li>
<li><code>lateinit</code> 变量在访问之前必须被初始化，否则会抛出异常，而
<code>lazy</code> 变量在第一次访问时会自动计算并返回值。</li>
<li><code>lateinit</code> 变量可以用于任何类型的属性，而
<code>lazy</code> 变量通常用于只读属性。</li>
<li><code>lateinit</code> 变量可以在类的构造函数中初始化，而
<code>lazy</code> 变量通常在类的主体中定义。</li>
<li><code>lateinit</code> 变量可以用于非空类型的属性，而
<code>lazy</code> 变量通常用于可空类型的属性。</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 语法速览</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/Kotlin-%E8%AF%AD%E6%B3%95%E9%80%9F%E8%A7%88.html</url>
    <content><![CDATA[<h1 id="变量和常量">1. 变量和常量</h1>
<ul>
<li><code>val</code>：不可变变量（只读，类似 final）</li>
<li><code>var</code>：可变变量</li>
<li>类型推断：Kotlin 支持自动推断变量类型</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;Alice&quot;</span> <span class="comment">// 不可变，类型推断为 String</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">25</span>      <span class="comment">// 可变，类型推断为 Int</span></span><br><span class="line">    <span class="comment">// name = &quot;Bob&quot;   // 错误：val 不能重新赋值</span></span><br><span class="line">    age = <span class="number">26</span>          <span class="comment">// 正确：var 可以重新赋值</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Name: <span class="variable">$name</span>, Age: <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="基本数据类型">2. 基本数据类型</h1>
<ul>
<li>常见类型：<code>Int</code>, <code>Double</code>,
<code>String</code>, <code>Boolean</code>, <code>List</code>,
<code>Map</code> 等</li>
<li>无基本类型与引用类型的区分，全部是对象</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> integer: <span class="built_in">Int</span> = <span class="number">42</span></span><br><span class="line">    <span class="keyword">val</span> double: <span class="built_in">Double</span> = <span class="number">3.14</span></span><br><span class="line">    <span class="keyword">val</span> text: String = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Int: <span class="variable">$integer</span>, Double: <span class="variable">$double</span>, String: <span class="variable">$text</span>, Boolean: <span class="variable">$isActive</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="控制流if-表达式">3. 控制流：if 表达式</h1>
<ul>
<li><code>if</code> 在 Kotlin 中是表达式，可以返回值</li>
<li>替代三元运算符（Kotlin 无三元运算符）</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> score = <span class="number">85</span></span><br><span class="line">    <span class="keyword">val</span> grade = <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        <span class="string">&quot;A&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="string">&quot;B&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;C&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Score: <span class="variable">$score</span>, Grade: <span class="variable">$grade</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="控制流when-表达式">4. 控制流：when 表达式</h1>
<ul>
<li>类似 <code>switch</code>，但更强大，支持多种条件</li>
<li>也是表达式，可返回值</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> day = <span class="number">3</span></span><br><span class="line">    <span class="keyword">val</span> dayName = <span class="keyword">when</span> (day) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; <span class="string">&quot;Monday&quot;</span></span><br><span class="line">        <span class="number">2</span> -&gt; <span class="string">&quot;Tuesday&quot;</span></span><br><span class="line">        <span class="number">3</span> -&gt; <span class="string">&quot;Wednesday&quot;</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Day <span class="variable">$day</span> is <span class="variable">$dayName</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="循环">5. 循环</h1>
<ul>
<li><code>for</code>：用于迭代集合或范围</li>
<li><code>while</code> 和 <code>do-while</code>：与 Java 类似</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// for 循环</span></span><br><span class="line">    println(<span class="string">&quot;Numbers 1 to 5:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="variable">$i</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while 循环</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">3</span></span><br><span class="line">    println(<span class="string">&quot;Counting down:&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="variable">$count</span> &quot;</span>)</span><br><span class="line">        count--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="函数">6. 函数</h1>
<ul>
<li>使用 <code>fun</code> 关键字</li>
<li>支持默认参数、命名参数、单表达式函数</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带默认参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">(name: <span class="type">String</span>, greeting: <span class="type">String</span> = <span class="string">&quot;Hi&quot;</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$greeting</span>, <span class="variable">$name</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单表达式函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(x: <span class="type">Int</span>, op: (<span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span> = op(x)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    println(greet(<span class="string">&quot;Alice&quot;</span>))</span><br><span class="line">    println(greet(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Hello&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    println(sum(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">    </span><br><span class="line">    println(apply(<span class="number">5</span>) &#123; it * <span class="number">2</span> &#125;)  <span class="comment">// 10，等价于 apply(5, &#123; it * 2 &#125;)</span></span><br><span class="line">    println(apply(<span class="number">5</span>) &#123; x: <span class="built_in">Int</span> -&gt; x * <span class="number">2</span> &#125;) <span class="comment">// 完整形式</span></span><br><span class="line">    println(apply(<span class="number">5</span>, ::double))  <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="类和对象">7. 类和对象</h1>
<ul>
<li>使用 <code>class</code> 定义类</li>
<li>属性自动生成 getter/setter</li>
<li>支持构造函数、主构造函数、初始化块</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123; <span class="comment">// 主构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> secret = <span class="number">42</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> subclassVisible = <span class="string">&quot;Protected&quot;</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> moduleVisible = <span class="string">&quot;Internal&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    	<span class="keyword">get</span>() = field</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) field = value</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123; <span class="comment">// 初始化块</span></span><br><span class="line">        println(<span class="string">&quot;Person created: <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">introduce</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Hi, I&#x27;m <span class="variable">$name</span>, <span class="variable">$age</span> years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAgeAfterYears</span><span class="params">(years: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age + years</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    person.introduce()</span><br><span class="line">    println(<span class="string">&quot;Age in 5 years: <span class="subst">$&#123;person.getAgeAfterYears(<span class="number">5</span>)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="继承和接口">8. 继承和接口</h1>
<ul>
<li>默认类是 <code>final</code>，需用 <code>open</code> 允许继承</li>
<li>接口使用 <code>interface</code>，实现用 <code>:</code></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Pet</span>(<span class="keyword">val</span> name: String) <span class="comment">// 使用 val 或者 var 把 name 声明为属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(name: String) : Pet(name), Animal &#123; <span class="comment">// 这里的 name 只是构造函数的参数，不是属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> says Woof!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>: <span class="built_in">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="keyword">val</span> radius: <span class="built_in">Double</span>) : Shape() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span> = Math.PI * radius * radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dog = Dog(<span class="string">&quot;Buddy&quot;</span>)</span><br><span class="line">    dog.makeSound()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="空安全">9. 空安全</h1>
<ul>
<li>可空类型用 <code>?</code> 表示</li>
<li>安全调用 <code>?.</code>，Elvis 运算符 <code>?:</code>，非空断言
<code>!!</code></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nullableString: String? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 安全调用</span></span><br><span class="line">    println(<span class="string">&quot;Length: <span class="subst">$&#123;nullableString?.length&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// Elvis 运算符</span></span><br><span class="line">    <span class="keyword">val</span> length = nullableString?.length ?: <span class="number">0</span></span><br><span class="line">    <span class="comment">// val length = nullableString?.length ?: throw IllegalArgumentException(&quot;nullableString 不能为空&quot;)</span></span><br><span class="line">    println(<span class="string">&quot;Length with Elvis: <span class="variable">$length</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// 非空断言（小心使用）</span></span><br><span class="line">    <span class="comment">// val length2 = nullableString!!.length // 会抛出 NullPointerException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="集合">10. 集合</h1>
<ul>
<li>支持 <code>List</code>, <code>Set</code>, <code>Map</code></li>
<li>提供不可变和可变集合：<code>listOf</code>,
<code>mutableListOf</code> 等</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> mutableList = mutableListOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> map = mapOf(<span class="number">1</span> to <span class="string">&quot;one&quot;</span>, <span class="number">2</span> to <span class="string">&quot;two&quot;</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Numbers: <span class="variable">$numbers</span>&quot;</span>)</span><br><span class="line">    mutableList.add(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Mutable List: <span class="variable">$mutableList</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Map: <span class="variable">$map</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="lambda-表达式和匿名函数">11. Lambda 表达式和匿名函数</h1>
<ul>
<li>Lambda 语法：<code>{ 参数 -&gt; 表达式 }</code></li>
<li>常用于集合操作</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// Lambda 过滤</span></span><br><span class="line">    <span class="keyword">val</span> evenNumbers = numbers.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125; <span class="comment">// it 是 lambda 表达式的默认参数名，仅在 lambda 有一个参数时才可用</span></span><br><span class="line">    println(<span class="string">&quot;Even numbers: <span class="variable">$evenNumbers</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 映射</span></span><br><span class="line">    <span class="keyword">val</span> squared = numbers.map &#123; x -&gt; x * x &#125; <span class="comment">// 手动制定参数名为 x，也可以写成 &#123; it * it &#125;</span></span><br><span class="line">    println(<span class="string">&quot;Squared: <span class="variable">$squared</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多参数必须显式命名</span></span><br><span class="line">    <span class="keyword">val</span> map = mapOf(<span class="string">&quot;a&quot;</span> to <span class="number">1</span>, <span class="string">&quot;b&quot;</span> to <span class="number">2</span>)</span><br><span class="line">	map.forEach &#123; key, value -&gt; println(<span class="string">&quot;<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数引用简写</span></span><br><span class="line">    <span class="keyword">val</span> names = listOf(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">	names.forEach(::println) <span class="comment">// ::println 等价于 &#123; name -&gt; println(name) &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匿名函数</span></span><br><span class="line">    <span class="keyword">val</span> f1 = <span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> f2 = &#123; x: <span class="built_in">Int</span> -&gt; x + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> f3 = &#123; x: <span class="built_in">Int</span> -&gt; println(x + <span class="number">1</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> f4 : (<span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> = &#123; x -&gt; println(x + <span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="扩展函数">12. 扩展函数</h1>
<ul>
<li>为现有类添加方法，无需继承</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">reverse</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reversed()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">addExclamation</span><span class="params">()</span></span> = <span class="string">&quot;<span class="variable">$this</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    println(text.reverse())</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>.addExclamation())  <span class="comment">// Hello!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="数据类">13. 数据类</h1>
<ul>
<li>使用 <code>data class</code> 自动生成 <code>toString</code>,
<code>equals</code>, <code>hashCode</code>
等，主构造函数至少一个参数，不可被 open</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user1 = User(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    <span class="keyword">val</span> user2 = User(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    println(<span class="string">&quot;User1: <span class="variable">$user1</span>&quot;</span>)</span><br><span class="line">    println(user.copy(name = <span class="string">&quot;Bob&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="协程">14. 协程</h1>
<ul>
<li>用于异步编程，需引入 <code>kotlinx.coroutines</code></li>
<li>使用 <code>launch</code> 或 <code>async</code> 启动协程</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> suspendFunc: <span class="keyword">suspend</span> () -&gt; <span class="built_in">Unit</span> = &#123; println(<span class="string">&quot;Suspended&quot;</span>) &#125;</span><br><span class="line">    <span class="comment">// 运行协程</span></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;Hello from coroutine!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;Main thread continues&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：协程示例需要添加
<code>kotlinx-coroutines-core</code> 依赖到项目中，否则无法运行。</p>
<h2 id="概述">概述</h2>
<p>Kotlin 协程引入于 Kotlin
1.3，是一种基于线程的轻量级并发工具，适合处理异步任务，基于
<code>kotlinx.coroutines</code> 库。Kotlin
协程支持挂起（suspend）机制，可以挂起和恢复，允许以顺序风格编写异步代码，类似于同步代码，但不会阻塞线程，同时避免传统回调地狱。协程的核心优势包括资源高效（不阻塞线程）和结构化并发（确保资源管理）。每个协程必须在一个作用域（<code>CoroutineScope</code>）中启动。</p>
<p>协程语法点包括：</p>
<ol type="1">
<li>启动协程（如 <code>launch</code>、<code>async</code>）</li>
<li>挂起函数</li>
<li>上下文和调度器（如 <code>Dispatchers</code>）</li>
<li>取消和超时</li>
<li>异常处理</li>
<li>结构化并发（如 <code>coroutineScope</code>）</li>
<li>通道（<code>Channel</code>）</li>
<li>流（<code>Flow</code>）</li>
<li>选择表达式（<code>select</code>）</li>
<li>测试工具</li>
</ol>
<p>协程实际应用场景包括网络请求、数据库操作、并发任务和超时处理。</p>
<h2 id="语法总结">语法总结</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 23%" />
<col style="width: 44%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>语法点</strong></th>
<th><strong>用途</strong></th>
<th><strong>示例场景</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>launch</code></td>
<td>启动无返回结果的协程</td>
<td>后台任务，如日志记录</td>
</tr>
<tr class="even">
<td><code>async</code></td>
<td>启动返回结果的协程</td>
<td>并行计算结果</td>
</tr>
<tr class="odd">
<td><code>runBlocking</code></td>
<td>阻塞线程等待协程完成</td>
<td>测试或主函数入口</td>
</tr>
<tr class="even">
<td><code>withContext</code></td>
<td>切换上下文运行挂起块</td>
<td>网络请求或 I/O 操作</td>
</tr>
<tr class="odd">
<td><code>suspend</code> 函数</td>
<td>定义可挂起的异步函数</td>
<td>网络请求或 I/O 操作</td>
</tr>
<tr class="even">
<td><code>Dispatchers</code></td>
<td>选择执行线程（如 IO、Main、Default）</td>
<td>UI 更新或数据库操作</td>
</tr>
<tr class="odd">
<td><code>Job</code> 和 <code>Deferred</code></td>
<td>管理任务生命周期和结果</td>
<td>等待任务完成或取消</td>
</tr>
<tr class="even">
<td>取消和超时</td>
<td>取消协程或设置时间限制</td>
<td>超时网络请求</td>
</tr>
<tr class="odd">
<td>异常处理</td>
<td>处理协程中的异常</td>
<td>错误日志记录</td>
</tr>
<tr class="even">
<td><code>coroutineScope</code></td>
<td>结构化并发管理子协程</td>
<td>确保任务顺序执行</td>
</tr>
<tr class="odd">
<td><code>supervisorScope</code></td>
<td>容错结构化并发</td>
<td>子任务失败不影响其他</td>
</tr>
<tr class="even">
<td><code>Channel</code></td>
<td>协程间通信</td>
<td>生产者-消费者模式</td>
</tr>
<tr class="odd">
<td><code>Flow</code></td>
<td>处理异步数据流</td>
<td>实时数据更新，如传感器数据</td>
</tr>
<tr class="even">
<td><code>select</code></td>
<td>选择第一个可用结果</td>
<td>多个异步操作竞争</td>
</tr>
<tr class="odd">
<td><code>yield</code></td>
<td>让出执行权</td>
<td>协作式多任务</td>
</tr>
<tr class="even">
<td><code>joinAll</code></td>
<td>等待多个 Job 完成</td>
<td>批量任务同步</td>
</tr>
<tr class="odd">
<td><code>awaitAll</code></td>
<td>等待多个 Deferred 结果</td>
<td>并发结果收集</td>
</tr>
<tr class="even">
<td>测试工具</td>
<td>测试协程行为</td>
<td>单元测试和集成测试</td>
</tr>
</tbody>
</table>
<h2 id="启动协程">启动协程</h2>
<h3 id="launch">14.1<code>launch</code></h3>
<p>启动不返回结果的协程。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async">14.2<code>async</code></h3>
<p>启动返回 <code>Deferred&lt;T&gt;</code> 的协程，用于获取结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData1</span><span class="params">()</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    <span class="string">&quot;Data1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData2</span><span class="params">()</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    <span class="string">&quot;Data2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred1 = async &#123; fetchData1() &#125;</span><br><span class="line">    <span class="keyword">val</span> deferred2 = async &#123; fetchData2() &#125;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;deferred1.await()&#125;</span> and <span class="subst">$&#123;deferred2.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="runblocking">14.3<code>runBlocking</code></h3>
<p>阻塞当前线程直到协程完成，常用于测试或主函数。用于在
<code>main</code>函数中桥接阻塞与非阻塞代码。在作用域中启动的所有协程（如
<code>launch {}</code>）必须完成，<code>runBlocking</code>才会返回。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;inside launch&quot;</span>)</span><br><span class="line">    	&#125;</span><br><span class="line">        </span><br><span class="line">        println(<span class="string">&quot;Hello from runBlocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中， <code>runBlocking { ... }</code>
会阻塞当前线程，在当前线程中创建一个顶层协程（<code>CoroutineScope</code>），<code>println("Hello from runBlocking")</code>
是在 <code>runBlocking</code>
的协程中执行的（运行在主线程，但属于协程代码）。</p>
<h3 id="withcontext">14.4<code>withContext</code></h3>
<p>在指定上下文运行挂起块，返回结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    <span class="string">&quot;Data from network&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = fetchData()</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="挂起函数">挂起函数</h2>
<h3 id="suspend">14.5 <code>suspend</code></h3>
<p>挂起函数用 <code>suspend</code>
关键字标记，只能从其他挂起函数或协程中调用，支持 <code>delay</code>
等挂起操作。 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;Done something&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="协程作用域">协程作用域</h2>
<h3 id="kotlin-协程作用域">14.6 Kotlin 协程作用域</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 21%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th>##</th>
<th>协程作用域</th>
<th>是否结构化</th>
<th>是否阻塞线程</th>
<th>生命周期</th>
<th>典型用途</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>runBlocking</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>直到 block 执行完毕</td>
<td>测试、main 函数入口</td>
<td>✅（仅限测试/入口）</td>
</tr>
<tr class="even">
<td>2</td>
<td><code>coroutineScope</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>当前 <code>suspend</code> 函数结束</td>
<td>并发封装、函数内结构化并发</td>
<td>✅ 推荐</td>
</tr>
<tr class="odd">
<td>3</td>
<td><code>supervisorScope</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>当前 <code>suspend</code> 函数结束</td>
<td>容错并发（互不影响）</td>
<td>✅ 推荐</td>
</tr>
<tr class="even">
<td>4</td>
<td><code>GlobalScope</code></td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>应用进程存活期间</td>
<td>后台任务（不推荐）</td>
<td>⚠️ 慎用（可能泄漏）</td>
</tr>
<tr class="odd">
<td>5</td>
<td>自定义 <code>CoroutineScope(...)</code></td>
<td>✅/❌ 取决于 Job</td>
<td>❌ 否</td>
<td>由 Job 控制（手动 cancel）</td>
<td>封装类、组件内任务</td>
<td>✅ 合理使用</td>
</tr>
<tr class="even">
<td>7</td>
<td><code>actor</code> / <code>produce</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>通道关闭或被取消</td>
<td>Channel 并发、消息队列</td>
<td>✅ 特定场景推荐</td>
</tr>
</tbody>
</table>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;🔷 1. runBlocking started on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. coroutineScope（结构化并发）</span></span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            println(<span class="string">&quot;🔷 2. coroutineScope: child coroutine on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. supervisorScope（不会因子协程失败而取消整个作用域）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay(<span class="number">200</span>)</span><br><span class="line">                println(<span class="string">&quot;🔷 3. supervisorScope: success task&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;🔷 3. supervisorScope: failed task&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;🔴 Caught exception from supervisorScope: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. GlobalScope（不建议常用）</span></span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">300</span>)</span><br><span class="line">        println(<span class="string">&quot;🔷 4. GlobalScope coroutine on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待 GlobalScope 启动的协程完成</span></span><br><span class="line">    <span class="comment">// 如果不加这一行，上面的 GlobalScope 无法打印，因为 GlobalScope 启动的是一个全局线程，不是 runBlocking 的一部分，runBlocking 执行完就退出了，主线程结束，整个进程随之结束，导致 GlobalScope 中来不及打印就被强行终止了。</span></span><br><span class="line">    job.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 自定义 CoroutineScope</span></span><br><span class="line">    <span class="keyword">val</span> customScope = CoroutineScope(Job() + Dispatchers.Default)</span><br><span class="line">    <span class="keyword">val</span> customJob = customScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;🔷 5. Custom CoroutineScope running on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. produce 示例（生产者管道）</span></span><br><span class="line">    <span class="keyword">val</span> numberProducer = produce &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            send(it * it)</span><br><span class="line">        &#125;</span><br><span class="line">        close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> numberProducer) &#123;</span><br><span class="line">        println(<span class="string">&quot;🔷 6. produce: received <span class="variable">$num</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. actor 示例（带状态协程处理器）</span></span><br><span class="line">    <span class="keyword">val</span> sumActor = actor&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            sum += msg</span><br><span class="line">            println(<span class="string">&quot;🔷 7. actor: received <span class="variable">$msg</span>, current sum = <span class="variable">$sum</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).forEach &#123; sumActor.send(it) &#125;</span><br><span class="line">    sumActor.close()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;🕒 Waiting for GlobalScope &amp; other coroutines...&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 等待其他 coroutine 执行完成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记得手动 cancel 非结构化作用域</span></span><br><span class="line">    customJob.join()</span><br><span class="line">    customScope.cancel()</span><br><span class="line">    println(<span class="string">&quot;✅ runBlocking completed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="android-扩展作用域">14.7 Android 扩展作用域</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 3%" />
<col style="width: 18%" />
<col style="width: 9%" />
<col style="width: 29%" />
<col style="width: 29%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="header">
<th>##</th>
<th>Android Scope</th>
<th>是否结构化</th>
<th>生命周期绑定对象</th>
<th>典型用途</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>viewModelScope</code></td>
<td>✅ 是</td>
<td>ViewModel 生命周期</td>
<td>网络/IO/业务逻辑</td>
<td>✅ 推荐</td>
</tr>
<tr class="even">
<td>2</td>
<td><code>lifecycleScope</code></td>
<td>✅ 是</td>
<td>Activity / Fragment 生命周期</td>
<td>启动任务 / UI操作</td>
<td>✅ 推荐</td>
</tr>
<tr class="odd">
<td>3</td>
<td><code>repeatOnLifecycle</code></td>
<td>✅ 是</td>
<td>生命周期状态变化（如 STARTED）</td>
<td>生命周期感知、数据收集（Flow）</td>
<td>✅ 推荐</td>
</tr>
</tbody>
</table>
<p><code>MainActivity.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.activity.ComponentActivity</span><br><span class="line"><span class="keyword">import</span> androidx.activity.viewModels</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Lifecycle</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.lifecycleScope</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.repeatOnLifecycle</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.delay</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> viewModels&lt;MyViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ✅ 1. lifecycleScope：跟随 Activity 生命周期</span></span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            delay(<span class="number">300</span>)</span><br><span class="line">            println(<span class="string">&quot;1️⃣ lifecycleScope → Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ✅ 2. repeatOnLifecycle：STARTED 时自动启动，STOPPED 时自动取消</span></span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            repeatOnLifecycle(Lifecycle.State.STARTED) &#123;</span><br><span class="line">                viewModel.timerFlow.collect &#123;</span><br><span class="line">                    println(<span class="string">&quot;2️⃣ repeatOnLifecycle collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ✅ 3. viewModelScope（定义在 ViewModel 中）</span></span><br><span class="line">        viewModel.loadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MyViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewModelScope</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.delay</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flow 模拟定时器</span></span><br><span class="line">    <span class="keyword">val</span> timerFlow: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">        <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            emit(counter++)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            println(<span class="string">&quot;3️⃣ viewModelScope → Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1️⃣ lifecycleScope → Thread: main</span><br><span class="line">3️⃣ viewModelScope → Thread: main</span><br><span class="line">2️⃣ repeatOnLifecycle collect: 0</span><br><span class="line">2️⃣ repeatOnLifecycle collect: 1</span><br><span class="line">2️⃣ repeatOnLifecycle collect: 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ul>
<li><p><code>lifecycleScope</code> → 生命周期感知，自动取消协程（适合 UI
层数据加载等）</p></li>
<li><p><code>repeatOnLifecycle</code> → 更细粒度的生命周期感知（可结合
<code>Flow</code> 实现 UI 活动期间自动收集）</p></li>
<li><p><code>viewModelScope</code> → 随
<code>ViewModel.onCleared()</code> 自动取消，适合业务处理逻辑</p></li>
</ul>
<h3 id="使用场景">使用场景</h3>
<table>
<thead>
<tr class="header">
<th>使用场景</th>
<th>推荐作用域</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>main 函数或测试</td>
<td><code>runBlocking</code></td>
</tr>
<tr class="even">
<td>挂起函数内并发</td>
<td><code>coroutineScope</code></td>
</tr>
<tr class="odd">
<td>容错并发</td>
<td><code>supervisorScope</code></td>
</tr>
<tr class="even">
<td>UI 层任务</td>
<td><code>viewModelScope</code> / <code>lifecycleScope</code></td>
</tr>
<tr class="odd">
<td>库或类封装内建 scope</td>
<td><code>CoroutineScope(...)</code></td>
</tr>
<tr class="even">
<td>Flow、通道数据源</td>
<td><code>produce</code> / <code>actor</code> 内隐含作用域</td>
</tr>
<tr class="odd">
<td>后台不销毁任务</td>
<td>极少情况用 <code>GlobalScope</code>（通常不推荐）</td>
</tr>
</tbody>
</table>
<h2 id="协程上下文和调度器">14.8 协程上下文和调度器</h2>
<p>调度器（如
<code>Dispatchers.Main</code>、<code>Dispatchers.IO</code>、<code>Dispatchers.Default</code>、<code>Dispatchers.Unconfined</code>）决定协程运行的线程。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(Dispatchers.Main) &#123; &#125;      <span class="comment">// UI线程</span></span><br><span class="line">launch(Dispatchers.IO) &#123; &#125;        <span class="comment">// IO密集型</span></span><br><span class="line">launch(Dispatchers.Default) &#123; &#125;   <span class="comment">// CPU密集型</span></span><br><span class="line">launch(Dispatchers.Unconfined) &#123; &#125; <span class="comment">// 不固定线程，惯性调度</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;Running on IO thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="job-和-deferred">Job 和 Deferred</h2>
<h3 id="job">14.9 Job</h3>
<p>🔹 <code>Job</code>：表示一个可以被取消的协程任务</p>
<p>✅ 特点：</p>
<ul>
<li>代表一个正在运行的协程任务</li>
<li>可以：
<ul>
<li>取消（<code>job.cancel()</code>）</li>
<li>等待其完成（<code>job.join()</code>）</li>
</ul></li>
<li><strong>不返回结果值</strong>，只表示任务的生命周期</li>
</ul>
<p>✅ 示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Job completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Waiting for job...&quot;</span>)</span><br><span class="line">    job.join() <span class="comment">// 等待协程完成</span></span><br><span class="line">    println(<span class="string">&quot;Main function continues&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="deferred">14.10 Deferred</h3>
<p>🔹 <code>Deferred&lt;T&gt;</code>：表示一个带返回值的协程任务（类似于
<code>Future&lt;T&gt;</code>）</p>
<p>✅ 特点：</p>
<ul>
<li>是 <code>Job</code> 的子类型</li>
<li>表示一个异步计算的结果</li>
<li>使用 <code>async</code> 创建，调用 <code>.await()</code>
获取结果</li>
<li>也可以取消、检查是否完成</li>
</ul>
<p>✅ 示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred: Deferred&lt;<span class="built_in">Int</span>&gt; = async &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Doing other things...&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = deferred.await() <span class="comment">// 等待并获取返回值</span></span><br><span class="line">    println(<span class="string">&quot;Result: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>🔍 <code>Job</code> 与 <code>Deferred</code> 的对比</p>
<table>
<thead>
<tr class="header">
<th>属性/行为</th>
<th><code>Job</code></th>
<th><code>Deferred&lt;T&gt;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>是否返回结果值</td>
<td>❌ 无</td>
<td>✅ 有返回值 (<code>T</code>)</td>
</tr>
<tr class="even">
<td>创建方式</td>
<td><code>launch { ... }</code></td>
<td><code>async { ... }</code></td>
</tr>
<tr class="odd">
<td>获取结果方式</td>
<td>无</td>
<td><code>await()</code></td>
</tr>
<tr class="even">
<td>取消任务</td>
<td>✅ <code>.cancel()</code></td>
<td>✅ <code>.cancel()</code></td>
</tr>
<tr class="odd">
<td>等待完成</td>
<td>✅ <code>.join()</code></td>
<td>✅ <code>.await()</code></td>
</tr>
<tr class="even">
<td>是否继承自 Job</td>
<td>✅ 本身就是</td>
<td>✅ 是 <code>Job</code> 的子接口</td>
</tr>
<tr class="odd">
<td>典型用途</td>
<td>启动独立任务</td>
<td>启动异步计算并获取值</td>
</tr>
</tbody>
</table>
<hr />
<p>✅ 使用建议</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 27%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="header">
<th>场景</th>
<th>使用类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>启动任务但不关心结果</td>
<td><code>launch</code> → <code>Job</code></td>
<td>适合 UI 更新、日志、并发 fire-and-forget</td>
</tr>
<tr class="even">
<td>启动异步任务并获取值</td>
<td><code>async</code> → <code>Deferred&lt;T&gt;</code></td>
<td>比如网络请求、计算、数据处理等</td>
</tr>
</tbody>
</table>
<hr />
<p>💡 补充知识点：<code>async</code> 的懒启动模式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> deferred = async(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 之后需要时调用 await 会启动</span></span><br><span class="line"><span class="keyword">val</span> result = deferred.await()</span><br></pre></td></tr></table></figure>
<h2 id="取消和超时">取消和超时</h2>
<h3 id="cancel">14.11 cancel</h3>
<p>取消：用 <code>cancel</code> 取消协程。<br />
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;Coroutine executing <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">    println(<span class="string">&quot;Coroutine cancelled&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可响应取消的方式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">        <span class="comment">// 做一些任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="withtimeout">14.12 withTimeout</h3>
<p>超时：用 <code>withTimeout</code> 设置时间限制。 抛出
<code>TimeoutCancellationException</code> ❌</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        withTimeout(<span class="number">1300L</span>) &#123;</span><br><span class="line">            repeat(<span class="number">5</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;Processing <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: TimeoutCancellationException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Timed out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="withtimeoutornull">14.13 withTimeoutOrNull</h3>
<p>返回 <code>null</code>，不抛异常 ✅</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">withTimeout(<span class="number">1000</span>) &#123;</span><br><span class="line">    delay(<span class="number">2000</span>) <span class="comment">// 抛出 TimeoutCancellationException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1000</span>) &#123;</span><br><span class="line">    delay(<span class="number">2000</span>)</span><br><span class="line">    <span class="string">&quot;This won&#x27;t return&quot;</span></span><br><span class="line">&#125; ?: <span class="string">&quot;Timeout!&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="异常处理">14.14 异常处理</h2>
<p>使用 <code>CoroutineExceptionHandler</code>
处理异常（launch中使用）。<br />
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 在 Kotlin 中，_ 是一个 占位符变量名，表示“我不关心这个参数的值”。</span></span><br><span class="line">    <span class="keyword">val</span> handler = CoroutineExceptionHandler &#123; _, exception -&gt;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$exception</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(handler) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exception(<span class="string">&quot;Error in coroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>try-catch</code> 处理异常。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exception(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协程组合与并发控制">协程组合与并发控制</h2>
<h3 id="并发执行任务-组合结果">14.15 并发执行任务 + 组合结果</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 模拟耗时任务</span></span><br><span class="line">    println(<span class="string">&quot;👤 getUser completed on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User123&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPosts</span><span class="params">()</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    delay(<span class="number">800</span>) <span class="comment">// 模拟另一个耗时任务</span></span><br><span class="line">    println(<span class="string">&quot;📝 getPosts completed on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="string">&quot;Post A&quot;</span>, <span class="string">&quot;Post B&quot;</span>, <span class="string">&quot;Post C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;🚀 Running in [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userDeferred = async &#123; getUser() &#125;</span><br><span class="line">    <span class="keyword">val</span> postsDeferred = async &#123; getPosts() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to 是 Kotlin 中的一个非常常用的 中缀函数，用于创建键值对 (Pair)。</span></span><br><span class="line">    <span class="comment">// val (a, b) 是解构（destructuring），用多个变量同时接收一个对象（Pair、Triple、map 或数据类）的多个字段值。</span></span><br><span class="line">    <span class="keyword">val</span> (a, b) = userDeferred.await() to postsDeferred.await()</span><br><span class="line">    println(<span class="string">&quot;✅ Combined result: <span class="variable">$a</span> + <span class="variable">$b</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺序执行多个挂起函数">14.16 顺序执行多个挂起函数</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;👤 getUser completed on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User456&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPosts</span><span class="params">(user: <span class="type">String</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    delay(<span class="number">800</span>)</span><br><span class="line">    println(<span class="string">&quot;📝 getPosts for <span class="variable">$user</span> completed on [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="string">&quot;Post X&quot;</span>, <span class="string">&quot;Post Y&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;🚀 Running in [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user = getUser()</span><br><span class="line">    <span class="keyword">val</span> posts = getPosts(user)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;✅ Result for <span class="variable">$user</span>: <span class="variable">$posts</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区别说明</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 11%" />
<col style="width: 27%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th>模式</th>
<th>是否并发</th>
<th>用法</th>
<th>适合场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>async + await</code></td>
<td>✅ 是</td>
<td>并发获取多个独立结果</td>
<td>多个不依赖关系的网络/API 请求</td>
</tr>
<tr class="even">
<td>顺序调用</td>
<td>❌ 否</td>
<td>一个接一个</td>
<td>后一个依赖前一个结果</td>
</tr>
</tbody>
</table>
<h2 id="结构化并发">结构化并发</h2>
<p>结构化并发的核心：</p>
<ul>
<li>父协程自动管理子协程</li>
<li>作用域退出时取消未完成子协程</li>
<li>错误自动传播</li>
</ul>
<h3 id="coroutinescope">14.17 coroutineScope</h3>
<p><code>coroutineScope</code>: 创建作用域，等待所有子协程完成。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performTasks</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    performTasks()</span><br><span class="line">    println(<span class="string">&quot;All tasks completed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="supervisorscope">14.18 supervisorScope</h3>
<p><code>supervisorScope</code>: 类似，但子协程失败不影响其他。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performTasks</span><span class="params">()</span></span> = supervisorScope &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="keyword">throw</span> Exception(<span class="string">&quot;Task 1 failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task 2 completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        performTasks()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught exception: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Main function continues&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通道channels">14.19 通道（Channels）</h2>
<p>用于协程间通信，支持生产者-消费者模式。<br />
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) channel.send(x * x)</span><br><span class="line">        channel.close()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (y <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(y)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="流flows">14.20 流（Flows）</h2>
<p>Flow（协程版响应式流） 的特性：</p>
<ul>
<li>是冷流（调用 collect 才执行）</li>
<li>自动挂起支持</li>
<li>支持背压、变换、合并等操作符（如 map、filter、combine）</li>
</ul>
<p>处理异步数据流。<br />
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            emit(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.collect &#123; </span><br><span class="line">        value -&gt; println(value) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择表达式select-expression">14.21 选择表达式（Select
Expression）</h2>
<p>同时等待多个挂起操作，选择第一个可用结果。<br />
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.selects.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectExample1</span><span class="params">(scope: <span class="type">CoroutineScope</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> deferred1 = scope.async &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            <span class="string">&quot;Result 1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> deferred2 = scope.async &#123;</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">            <span class="string">&quot;Result 2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        select&lt;String&gt; &#123;</span><br><span class="line">            deferred1.onAwait &#123; it &#125;</span><br><span class="line">            deferred2.onAwait &#123; it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="string">&quot;Error occurred: <span class="subst">$&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectExample2</span><span class="params">()</span></span>: String = coroutineScope &#123;</span><br><span class="line">    <span class="comment">// 表示从 coroutineScope block 中返回, 而不是返回外部函数，可省略</span></span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@coroutineScope</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> deferred1 = async &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            <span class="string">&quot;Result 1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> deferred2 = async &#123;</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">            <span class="string">&quot;Result 2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        select&lt;String&gt; &#123;</span><br><span class="line">            deferred1.onAwait &#123; it &#125;</span><br><span class="line">            deferred2.onAwait &#123; it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="string">&quot;Error occurred: <span class="subst">$&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> result1 = selectExample1(<span class="keyword">this</span>)</span><br><span class="line">        println(result1)</span><br><span class="line">        <span class="keyword">val</span> result2 = selectExample2()</span><br><span class="line">        println(result2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="工具函数">工具函数</h2>
<h3 id="yield">14.23 yield</h3>
<p>让出执行权，允许其他协程运行，适合协作式多任务。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;Coroutine 1: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            yield()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;Coroutine 2: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            yield()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<code>Coroutine 1</code> 和 <code>Coroutine 2</code>
交替执行。</p>
<h3 id="joinall">14.24 joinAll</h3>
<p>等待多个 <code>Job</code> 完成。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;Job 1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">            delay(<span class="number">2000L</span>)</span><br><span class="line">            println(<span class="string">&quot;Job 2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        joinAll(job1, job2)</span><br><span class="line">        println(<span class="string">&quot;All jobs completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<code>Job 1</code>、<code>Job 2</code>、<code>All jobs completed</code>。</p>
<h3 id="awaitall">14.25 awaitAll</h3>
<p>等待多个 <code>Deferred</code> 完成，返回结果列表。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> deferred1 = async &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> deferred2 = async &#123;</span><br><span class="line">            delay(<span class="number">2000L</span>)</span><br><span class="line">            <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> results = awaitAll(deferred1, deferred2)</span><br><span class="line">        println(results)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<code>Results: [1, 2]</code>。</p>
<h2 id="测试协程">14.26 测试协程</h2>
<p>使用 <code>runBlockingTest</code> 和
<code>TestCoroutineDispatcher</code> 测试协程，适合单元测试。
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.async</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.delay</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.advanceTimeBy</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.runTest</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert</span><br><span class="line"><span class="keyword">import</span> kotlin.test.Test</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoroutineTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            <span class="number">42</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        advanceTimeBy(<span class="number">1000L</span>)</span><br><span class="line">        <span class="keyword">val</span> result = deferred.await()</span><br><span class="line">        println(<span class="string">&quot;Result in test: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        Assert.assertEquals(<span class="number">42</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3&quot;</span>)</span><br><span class="line">testImplementation(<span class="string">&quot;junit:junit:4.13.2&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="实际应用场景">实际应用场景</h2>
<h3 id="网络请求android">14.27 网络请求（Android）</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> retrofit2.Retrofit</span><br><span class="line"><span class="keyword">import</span> retrofit2.converter.gson.GsonConverterFactory</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.GET</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;data&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">&quot;https://api.example.com/&quot;</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> apiService = retrofit.create(ApiService::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> <span class="keyword">data</span> = apiService.getData()</span><br><span class="line">                println(<span class="string">&quot;Fetched data: <span class="variable">$data</span>&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                println(<span class="string">&quot;Error: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据库操作">14.28 数据库操作</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.room.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepository</span>(<span class="keyword">private</span> <span class="keyword">val</span> dao: UserDao) &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertUser</span><span class="params">(user: <span class="type">User</span>)</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">        dao.insert(user)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> repository = UserRepository(<span class="comment">/* DAO instance */</span>)</span><br><span class="line">    launch &#123; repository.insertUser(User(<span class="number">1</span>, <span class="string">&quot;John&quot;</span>)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发-api-调用">14.29 并发 API 调用</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData1</span><span class="params">()</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="string">&quot;Data 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData2</span><span class="params">()</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">1500</span>)</span><br><span class="line">    <span class="string">&quot;Data 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred1 = async &#123; fetchData1() &#125;</span><br><span class="line">    <span class="keyword">val</span> deferred2 = async &#123; fetchData2() &#125;</span><br><span class="line">    <span class="keyword">val</span> results = awaitAll(deferred1, deferred2)</span><br><span class="line">    println(<span class="string">&quot;Results: <span class="variable">$results</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="超时处理">14.30 超时处理</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">longRunningTask</span><span class="params">()</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">3000</span>)</span><br><span class="line">    <span class="string">&quot;Done&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        withTimeout(<span class="number">2000L</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> result = longRunningTask()</span><br><span class="line">            println(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: TimeoutCancellationException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Task timed out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://kotlinlang.org/docs/coroutines-guide.html">Kotlin
Coroutines Guide with Examples</a>：提供核心特性和示例</li>
<li><a href="https://kotlinlang.org/docs/coroutines-basics.html">Kotlin
Coroutines Basics Introduction</a>：涵盖基础概念</li>
<li><a href="https://developer.android.com/kotlin/coroutines">Kotlin
Coroutines on Android Detailed Guide</a>：专注于 Android 应用</li>
</ul>
<h1 id="对象声明">15. 对象声明</h1>
<p>使用 object 创建单例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Singleton.hello()  <span class="comment">// Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="伴生对象">16. 伴生对象</h1>
<p>在类中使用 companion object 定义静态成员</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; <span class="comment">// 相当于静态方法/字段，提供类级别的静态成员支持</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span> = MyClass() <span class="comment">// 伴生对象中的工厂函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> instance = MyClass.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyClass <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="导入">17. 导入</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.PI <span class="keyword">as</span> MathPI</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(MathPI)  <span class="comment">// 3.141592653589793</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异常处理-1">18. 异常处理</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Negative not allowed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="keyword">try</span> &#123;</span><br><span class="line">        validate(-<span class="number">1</span>)</span><br><span class="line">        <span class="string">&quot;Success&quot;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IllegalArgumentException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error: <span class="subst">$&#123;e.message&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="string">&quot;Failed&quot;</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Cleanup&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Result: <span class="variable">$result</span>&quot;</span>)  <span class="comment">// Failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型">19. 泛型</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> value: T) <span class="comment">// 泛型类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">printItem</span><span class="params">(item: <span class="type">T</span>)</span></span> = println(item) <span class="comment">// 泛型函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Producer</span>&lt;<span class="type">out T</span>&gt; &#123; <span class="comment">// 使用协变 out 限制类型只能作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringProducer</span> : <span class="type">Producer</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;<span class="type">in T</span>&gt; &#123; <span class="comment">// 使用逆变 in 限制类型只能作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnyConsumer</span> : <span class="type">Consumer</span>&lt;<span class="type">Any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">Any</span>)</span></span> = println(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList</span><span class="params">(list: <span class="type">List</span>&lt;*&gt;)</span></span> = println(list) <span class="comment">// 通配符 *，类型为 Any?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intBox = Box(<span class="number">42</span>)</span><br><span class="line">    <span class="keyword">val</span> strBox = Box(<span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;intBox.value&#125;</span>, <span class="subst">$&#123;strBox.value&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    printItem(<span class="number">42</span>)  <span class="comment">// 42</span></span><br><span class="line">    printItem(<span class="string">&quot;Kotlin&quot;</span>)  <span class="comment">// Kotlin</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> producer: Producer&lt;String&gt; = StringProducer()</span><br><span class="line">    println(producer.produce())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> consumer: Consumer&lt;Any&gt; = AnyConsumer()</span><br><span class="line">    consumer.consume(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    printList(listOf(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>))  <span class="comment">// [1, A]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义注解">20. 自定义注解</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">MyAnnotation</span>(<span class="keyword">val</span> priority: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation(1)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">annotated</span><span class="params">()</span></span> = println(<span class="string">&quot;Annotated&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    annotated()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中缀函数">21. 中缀函数</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">plus</span><span class="params">(x: <span class="type">Int</span>)</span></span> = <span class="keyword">this</span> + x <span class="comment">// 表达式函数体 = 允许类型推断，代码块函数体 &#123;&#125; 必须显式写出返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="number">5</span> plus <span class="number">3</span>)  <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="运算符重载">22. 运算符重载</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span> = Point(x + other.x, y + other.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    println(p1 + p2)  <span class="comment">// Point(x=4, y=6)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内联类已废弃">23. 内联类（已废弃）</h1>
<ul>
<li>使用 inline class
定义单值包装类，编译时展开为原始类型，避免对象分配。</li>
<li>不支持接口实现。</li>
<li>使用 <code>@JvmInline value class</code> 替代
<code>inline class</code>。</li>
<li>不可扩展，不可被集成。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> value: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = Name(<span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">    println(name.value)  <span class="comment">// Kotlin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联类和内联值类特性：</p>
<table>
<thead>
<tr class="header">
<th>能做吗</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>❌ 继承类</td>
<td>不行，value class 不能继承任何类（除了 <code>Any</code>）</td>
</tr>
<tr class="even">
<td>❌ 被继承</td>
<td>不行，value class 自身也不能被继承</td>
</tr>
<tr class="odd">
<td>✅ 实现接口</td>
<td>可以实现接口</td>
</tr>
<tr class="even">
<td>✅ 内联优化</td>
<td>可以提升性能，避免创建对象</td>
</tr>
</tbody>
</table>
<h1 id="内联值类">24. 内联值类</h1>
<ul>
<li>场景：当需要包装单一值并保持性能（如
ID、计数、单位类型），使用内联值类；复杂对象仍使用普通
<code>data class</code>。</li>
<li>为什么不直接使用原始类型？
<ul>
<li>内联值类为原始类型添加语义，防止误用。</li>
<li>代码可读性增加。</li>
<li>内联值类允许为原始类型添加方法或实现接口，封装特定逻辑，而不增加运行时开销。</li>
<li>领域驱动设计（DDD）。在复杂系统中，内联值类支持领域建模，用类型区分不同概念（如
<code>OrderId</code> vs <code>ProductId</code>），提高代码一致性。</li>
<li>内联值类可以在构造时验证值，防止非法状态，而原始类型无法限制。</li>
<li>内联值类通过 <code>@JvmInline</code> 在编译时替换为底层原始类型（如
<code>Int</code>），几乎无额外内存或性能开销，接近直接使用原始类型的效率。</li>
</ul></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">UserId</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) : Comparable&lt;UserId&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">UserId</span>)</span></span>: <span class="built_in">Int</span> = id.compareTo(other.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> userId = UserId(<span class="number">42</span>)</span><br><span class="line">    println(userId.id) <span class="comment">// 输出 42</span></span><br><span class="line">    println(userId &gt; UserId(<span class="number">40</span>)) <span class="comment">// 输出 true</span></span><br><span class="line">    <span class="comment">// 编译后，userId 被替换为 Int，支持接口方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="无符号整数">25. 无符号整数</h1>
<ul>
<li><code>UInt</code>：32 位无符号整数，<code>ULong</code>：64 位，加
<code>u</code> 或 <code>U</code> 后缀。</li>
<li>编译为有符号整数，运行时模拟无符号行为。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> uint: UInt = 42u</span><br><span class="line">    <span class="keyword">val</span> ulong: ULong = 123UL</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$uint</span>, <span class="variable">$ulong</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sam-转换改进">26. SAM 转换改进</h1>
<p>单方法接口支持 Lambda 转换</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> action = Action &#123; println(<span class="string">&quot;Run&quot;</span>) &#125;</span><br><span class="line">    action.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="密封接口和密封类">27. 密封接口和密封类</h1>
<ul>
<li><code>sealed</code> 修饰符表示
<code>Expr</code>接口（或类）只能在同一模块（通常是同一文件或项目）内被实现。</li>
<li>外部代码无法创建新的<code>Expr</code>子类，确保<code>Expr</code>的所有可能实现（如<code>Num</code>）是已知的。</li>
<li>对比普通接口，<code>sealed</code> 减少了运行时类型转换（如 as
Num）的需要。</li>
<li>意义：保证类型系统的封闭性，防止意外扩展，适合建模有限的类型集合（如表达式树）。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">Expr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Num</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) : Expr &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Num</span>)</span></span> = Num(value + other.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Add</span>(<span class="keyword">val</span> left: Num, <span class="keyword">val</span> right: Num) : Expr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> expr1: Expr = Num(<span class="number">42</span>)</span><br><span class="line">    println((expr1 <span class="keyword">as</span> Num).value) <span class="comment">// 不够优雅</span></span><br><span class="line">    <span class="keyword">val</span> expr2: Expr = Add(Num(<span class="number">2</span>), Num(<span class="number">3</span>))</span><br><span class="line">    println(</span><br><span class="line">        <span class="keyword">when</span> (expr2) &#123;</span><br><span class="line">            <span class="keyword">is</span> Add -&gt; (expr2.left + expr2.right)</span><br><span class="line">            <span class="keyword">is</span> Num -&gt; expr2.value</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin 的 <strong>密封类（sealed class）</strong>
是一种用于表示<strong>受限继承结构</strong>的类，适合用来表达有限状态、事件、指令等类型的场景。<code>sealed class</code>
表示一个<strong>封闭的类层次结构</strong>，所有子类必须定义在同一个文件中。它是
<strong>抽象类</strong> 的一种变体，用于<strong>替代 enum 或 if/else
的分支判断</strong>，且能结合 <code>when</code>
表达式使用，非常强大。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Success</span>&lt;<span class="type">out T</span>&gt;(<span class="keyword">val</span> <span class="keyword">data</span>: T) : Result&lt;T&gt;()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> exception: Throwable) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">    <span class="keyword">object</span> Loading : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span>: Result&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> result = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">        Result.Success(result)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        Result.Error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handle</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (result) &#123;</span><br><span class="line">        <span class="keyword">is</span> Result.Success -&gt; println(<span class="string">&quot;Got data: <span class="subst">$&#123;result.data&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> Result.Error -&gt; println(<span class="string">&quot;Error: <span class="subst">$&#123;result.exception.message&#125;</span>&quot;</span>)</span><br><span class="line">        Result.Loading -&gt; println(<span class="string">&quot;Loading...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Result<span class="type">&lt;T&gt;</span>.<span class="title">onSuccess</span><span class="params">(action: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: Result&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> Result.Success) action(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Result<span class="type">&lt;T&gt;</span>.<span class="title">onError</span><span class="params">(action: (<span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)</span></span>: Result&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> Result.Error) action(exception)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchData()</span><br><span class="line">    .onSuccess &#123; println(<span class="string">&quot;Success: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">    .onError &#123; println(<span class="string">&quot;Error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>👉 由于 <code>Result</code> 是密封类，<code>when</code>
表达式<strong>必须覆盖所有子类</strong>，否则编译报错（如果没有
<code>else</code> 分支）。</p>
<h1 id="io">28. IO</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    File(<span class="string">&quot;test.txt&quot;</span>).writeText(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    println(File(<span class="string">&quot;test.txt&quot;</span>).readText())  <span class="comment">// Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反射和运行时">29. 反射和运行时</h1>
<p>需要在<code>build.gradle.kts</code>文件中添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	implementation(kotlin(<span class="string">&quot;reflect&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ref1 = String::<span class="keyword">class</span> <span class="comment">// 类引用</span></span><br><span class="line">    println(ref1.simpleName)  <span class="comment">// String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> ref2 = ::hello <span class="comment">// 函数引用，仅限顶层或成员函数</span></span><br><span class="line">    ref2()  <span class="comment">// Hello</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> props = Person::<span class="keyword">class</span>.members</span><br><span class="line">    println(props.map &#123; it.name &#125;)  <span class="comment">// [name]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="属性委托">30. 属性委托</h1>
<ul>
<li>使用<code>by</code>将属性委托给代理对象</li>
<li><code>lazy</code>首次访问时初始化，不可重新赋值。默认同步，需明确模式（如
<code>LazyThreadSafetyMode.NONE</code>）。</li>
<li><code>Delegates.observable</code>：属性变化监听。</li>
<li><code>lazy</code> 和 <code>observable</code> 是 <code>Kotlin</code>
提供的内置委托。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// lazy</span></span><br><span class="line">    <span class="keyword">val</span> lazyVal: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">&quot;Computed&quot;</span>)</span><br><span class="line">        <span class="string">&quot;Lazy&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(lazyVal)  <span class="comment">// Computed, Lazy</span></span><br><span class="line">    println(lazyVal)  <span class="comment">// Lazy（不再计算）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// observable</span></span><br><span class="line">    <span class="keyword">var</span> obsVal: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;Init&quot;</span>) &#123;</span><br><span class="line">        property, old, new -&gt; println(<span class="string">&quot;<span class="subst">$&#123;property.name&#125;</span>: <span class="variable">$old</span> -&gt; <span class="variable">$new</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    obsVal = <span class="string">&quot;New&quot;</span>  <span class="comment">// obsVal: Init -&gt; New</span></span><br><span class="line">    obsVal = <span class="string">&quot;Final&quot;</span>  <span class="comment">// obsVal: New -&gt; Final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类委托">31. 类委托</h1>
<ul>
<li>使用<code>by</code>将接口实现委托给对象</li>
<li>组合优于继承，使用委托组合多个对象的行为</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">(message: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsolePrinter</span> : <span class="type">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">(message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Console: <span class="variable">$message</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelegatingPrinter</span>(<span class="keyword">private</span> <span class="keyword">val</span> printer: Printer) : Printer <span class="keyword">by</span> printer &#123;</span><br><span class="line">    <span class="comment">// 可选择重写部分方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">(message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Delegating: <span class="variable">$message</span>&quot;</span>) <span class="comment">// 这里是装饰器模式，包装现有实现，添加额外功能（如日志、验证）</span></span><br><span class="line">        printer.printMessage(message) <span class="comment">// 调用委托对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> consolePrinter = ConsolePrinter()</span><br><span class="line">    <span class="comment">// 这里可以通过更换委托对象，动态改变行为。例如：切换 Printer 实现为文件打印或网络打印</span></span><br><span class="line">    <span class="keyword">val</span> delegatingPrinter = DelegatingPrinter(consolePrinter)</span><br><span class="line">    delegatingPrinter.printMessage(<span class="string">&quot;Hello, Kotlin!&quot;</span>) <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// Delegating: Hello, Kotlin!</span></span><br><span class="line">    <span class="comment">// Console: Hello, Kotlin!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="作用域函数">32. 作用域函数</h1>
<p>Kotlin 的<strong>作用域函数（Scope
Functions）</strong>是让你能更优雅地处理对象初始化、配置、临时作用域和链式调用的语法工具。常用的有以下
5 个：</p>
<table>
<thead>
<tr class="header">
<th>函数</th>
<th>用途简记</th>
<th>返回值</th>
<th>引用名</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>let</code></td>
<td>null安全、链式处理</td>
<td>Lambda结果</td>
<td><code>it</code></td>
</tr>
<tr class="even">
<td><code>run</code></td>
<td>初始化 + 返回值</td>
<td>Lambda结果</td>
<td><code>this</code></td>
</tr>
<tr class="odd">
<td><code>with</code></td>
<td>多操作 + 返回值</td>
<td>Lambda结果</td>
<td><code>this</code></td>
</tr>
<tr class="even">
<td><code>apply</code></td>
<td>初始化 + 返回对象</td>
<td>原对象</td>
<td><code>this</code></td>
</tr>
<tr class="odd">
<td><code>also</code></td>
<td>调试副作用 + 返回对象</td>
<td>原对象</td>
<td><code>it</code></td>
</tr>
</tbody>
</table>
<hr />
<p>🔹 1. <code>let</code>：用 <code>it</code> 作为对象引用</p>
<p>适合做<strong>null 检查</strong>和链式操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">name?.let &#123;</span><br><span class="line">    println(<span class="string">&quot;名字是 <span class="variable">$it</span>&quot;</span>)  <span class="comment">// it 指向 name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>🔹 2. <code>run</code>：用 <code>this</code>
引用对象，返回表达式结果</p>
<p>适合<strong>对象初始化 + 返回值计算</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> length = <span class="string">&quot;Kotlin&quot;</span>.run &#123;</span><br><span class="line">    println(<span class="string">&quot;字符串是 <span class="variable">$this</span>&quot;</span>)</span><br><span class="line">    length  <span class="comment">// 返回最后一行，即 length 的值</span></span><br><span class="line">&#125;</span><br><span class="line">println(length) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<hr />
<p>🔹 3. <code>with</code>：不是扩展函数，作用于已有对象</p>
<p>适合对对象做多个操作但<strong>不返回原对象</strong>，而是返回表达式值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line"><span class="keyword">val</span> result = with(sb) &#123;</span><br><span class="line">    append(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">    append(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result) <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure>
<hr />
<p>🔹 4. <code>apply</code>：用 <code>this</code>，返回对象自身</p>
<p>适合<strong>构造对象并链式设置属性</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User().apply &#123;</span><br><span class="line">        name = <span class="string">&quot;124&quot;</span></span><br><span class="line">        age = <span class="number">25</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>🔹 5. <code>also</code>：用 <code>it</code>，返回对象自身</p>
<p>适合用于链式调用中插入<strong>副作用逻辑</strong>（如日志、调试）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    .also &#123; println(<span class="string">&quot;原始列表: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">    .apply &#123; add(<span class="number">4</span>) &#125;</span><br><span class="line">    .also &#123; println(<span class="string">&quot;添加元素后: <span class="variable">$it</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<h1 id="内联函数">33. 内联函数</h1>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>关键字</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>inline</code></td>
<td>函数和 lambda 代码都在编译期被“展开复制”到调用处，提高性能</td>
</tr>
<tr class="even">
<td><code>noinline</code></td>
<td><strong>在 inline 函数中</strong>，禁止某个 lambda 被内联</td>
</tr>
<tr class="odd">
<td><code>crossinline</code></td>
<td><strong>在 inline 函数中</strong>，禁止 lambda 使用
<code>return</code> 非局部返回</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="inline">inline</h2>
<p>✅ 1. <code>inline</code>：让函数和 lambda <strong>“展开”</strong>
到调用处，提高性能</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Before block&quot;</span>)</span><br><span class="line">    block() <span class="comment">// 会被“复制粘贴”到调用处</span></span><br><span class="line">    println(<span class="string">&quot;After block&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doSomething &#123;</span><br><span class="line">        println(<span class="string">&quot;Doing work&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后近似于 👇：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Before block&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Doing work&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;After block&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>✅ 优点：<strong>消除函数调用开销、避免创建 Function
对象（尤其在频繁调用的 lambda 中）</strong></p>
</blockquote>
<hr />
<h2 id="noinline">noinline</h2>
<p>⚠️ 2. <code>noinline</code>：阻止某个 lambda
被内联（因为你可能要传递它）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doOps</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    inlineBlock: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">noinline</span> logging: () -&gt; <span class="type">Unit</span>  <span class="comment">// ❗ 禁止内联</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    inlineBlock()   <span class="comment">// 内联</span></span><br><span class="line">    <span class="keyword">val</span> func = logging  <span class="comment">// ❗ 如果不加 noinline 会编译错误，因为不能传递被内联的 lambda</span></span><br><span class="line">    func()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你必须加 <code>noinline</code>，否则无法将 lambda
存成变量或传给其他函数。</p>
<hr />
<h2 id="crossinline">crossinline</h2>
<p>🚫 3. <code>crossinline</code>：禁止 lambda 用 <code>return</code>
做“非局部返回”</p>
<p>🔸 默认情况下，内联 lambda 可以直接
<code>return</code>，但有风险。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">higherOrder</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">    block()</span><br><span class="line">    println(<span class="string">&quot;After&quot;</span>) <span class="comment">// ⚠️ 如果 block 里直接 return，这行永远不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    higherOrder &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">// 🚫 这是“非局部返回”：会从 test() 函数直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要禁止这种“跳出上层函数”的行为，加 <code>crossinline</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">higherOrder</span><span class="params">(<span class="keyword">crossinline</span> block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> r = Runnable &#123;</span><br><span class="line">        block()  <span class="comment">// ✅ 现在 block() 里面不能写 return 了</span></span><br><span class="line">    &#125;</span><br><span class="line">    r.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>✅ 总结对照表</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>关键字</th>
<th>用途说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>inline</code></td>
<td>将函数和 lambda 在调用处展开，提升性能、支持非局部 return</td>
</tr>
<tr class="even">
<td><code>noinline</code></td>
<td>禁止某个 lambda 被内联（可传递为变量）</td>
</tr>
<tr class="odd">
<td><code>crossinline</code></td>
<td>禁止 lambda 使用非局部
<code>return</code>（可用在回调、线程等）</td>
</tr>
</tbody>
</table>
<hr />
<p>📌 什么时候用它们？</p>
<table>
<thead>
<tr class="header">
<th>场景</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>高频调用、性能敏感的高阶函数</td>
<td><code>inline</code></td>
</tr>
<tr class="even">
<td>lambda 需要传递或存为变量</td>
<td><code>noinline</code></td>
</tr>
<tr class="odd">
<td>lambda 不能用 return（如线程、回调）</td>
<td><code>crossinline</code></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/Kotlin.html</url>
    <content><![CDATA[<h1 id="语法树">语法树</h1>
<pre><code class="highlight mermaid">graph LR
    A[Kotlin 语法概览]

    %% 1. 基础语法特性
    A --&gt; B[基础语法特性]
    B --&gt; B1[基本数据类型]
    B1 --&gt; B1a[&quot;整型: Byte, Short, Int, Long&quot;]
    B1 --&gt; B1b[&quot;浮点型: Float, Double&quot;]
    B1 --&gt; B1c[&quot;字符型: Char&quot;]
    B1 --&gt; B1d[&quot;布尔型: Boolean&quot;]
    
    B --&gt; B2[变量与常量]
    B2 --&gt; B2a[&quot;变量: var&quot;]
    B2 --&gt; B2b[&quot;常量: val&quot;]
    
    B --&gt; B3[运算符]
    B3 --&gt; B3a[&quot;算术运算符: +, -, *, /, %&quot;]
    B3 --&gt; B3b[&quot;关系运算符: ==, !=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=&quot;]
    B3 --&gt; B3c[&quot;逻辑运算符: &amp;amp;&amp;amp;, ||, !&quot;]
    B3 --&gt; B3d[&quot;位运算符: and, or, xor, shl, shr&quot;]
    B3 --&gt; B3e[&quot;赋值运算符: =, +=, -=, *=, /=&quot;]
    B3 --&gt; B3f[&quot;其他: Elvis ?:, Safe Call ?., !!, in&quot;]
    
    B --&gt; B4[控制结构]
    B4 --&gt; B4a[&quot;条件语句: if, else&quot;]
    B4 --&gt; B4b[&quot;分支语句: when&quot;]
    B4 --&gt; B4c[&quot;循环: for, while, do-while&quot;]
    B4 --&gt; B4d[&quot;跳转: break, continue, return&quot;]
    
    B --&gt; B5[函数]
    B5 --&gt; B5a[&quot;函数定义: fun&quot;]
    B5 --&gt; B5b[&quot;参数: 默认参数, 可变参数 vararg&quot;]
    B5 --&gt; B5c[&quot;单表达式函数: =&quot;]
    B5 --&gt; B5d[&quot;匿名函数&quot;]
    B5 --&gt; B5e[&quot;高阶函数&quot;]
    
    B --&gt; B6[类与对象]
    B6 --&gt; B6a[&quot;类定义: class&quot;]
    B6 --&gt; B6b[&quot;构造函数: constructor&quot;]
    B6 --&gt; B6c[&quot;属性: var, val&quot;]
    B6 --&gt; B6d[&quot;访问控制: public, private, protected, internal&quot;]
    B6 --&gt; B6e[&quot;继承: open, :&quot;]
    B6 --&gt; B6f[&quot;接口: interface&quot;]
    B6 --&gt; B6g[&quot;抽象类: abstract&quot;]
    B6 --&gt; B6h[&quot;数据类: data&quot;]
    B6 --&gt; B6i[&quot;对象声明: object&quot;]
    B6 --&gt; B6j[&quot;伴生对象: companion object&quot;]
    
    B --&gt; B7[包与导入]
    B7 --&gt; B7a[&quot;包定义: package&quot;]
    B7 --&gt; B7b[&quot;导入: import&quot;]
    
    B --&gt; B8[异常处理]
    B8 --&gt; B8a[&quot;try, catch, finally&quot;]
    B8 --&gt; B8b[&quot;throw&quot;]
    
    B --&gt; B9[泛型]
    B9 --&gt; B9a[&quot;泛型类: &amp;lt;T&amp;gt;&quot;]
    B9 --&gt; B9b[&quot;泛型函数&quot;]
    B9 --&gt; B9c[&quot;协变: out&quot;]
    B9 --&gt; B9d[&quot;逆变: in&quot;]
    B9 --&gt; B9e[&quot;通配符: *&quot;]
    
	B --&gt; B10[空安全]
    B10 --&gt; B10a[&quot;可空类型: ?&quot;]
    B10 --&gt; B10b[&quot;安全调用: ?.&quot;]
    B10 --&gt; B10c[&quot;Elvis 操作符: ?:&quot;]
    B10 --&gt; B10d[&quot;非空断言: !!&quot;]
    
    B --&gt; B11[注解]
    B11 --&gt; B11a[&quot;内置注解: @Deprecated, @Suppress&quot;]
    B11 --&gt; B11b[&quot;自定义注解: annotation&quot;]

    %% 2. 现代 Kotlin 新特性
    A --&gt; C[现代 Kotlin 新特性]
    
    C --&gt; C1[Kotlin 1.0+]
    C1 --&gt; C1a[&quot;Lambda 表达式: &#123; x -&gt; x * 2 &#125;&quot;]
    C1 --&gt; C1b[&quot;扩展函数&quot;]
    C1 --&gt; C1c[&quot;中缀函数: infix&quot;]
    C1 --&gt; C1d[&quot;运算符重载: operator&quot;]
    
    C --&gt; C2[Kotlin 1.1]
    C2 --&gt; C2a[&quot;协程: suspend, launch&quot;]
    
    C --&gt; C3[Kotlin 1.3]
    C3 --&gt; C3a[&quot;内联类: inline class&quot;]
    C3 --&gt; C3b[&quot;无符号整数: UInt, ULong&quot;]
    
    C --&gt; C4[Kotlin 1.4]
    C4 --&gt; C4a[&quot;SAM 转换改进&quot;]
    C4 --&gt; C4b[&quot;尾随逗号&quot;]
    
    C --&gt; C5[Kotlin 1.5]
    C5 --&gt; C5a[&quot;密封接口: sealed interface&quot;]
    C5 --&gt; C5b[&quot;内联值类: value class&quot;]
    
    C --&gt; C6[Kotlin 1.6]
    C6 --&gt; C6a[&quot;挂起函数类型: suspend () -&gt; Unit&quot;]
    
    C --&gt; C7[Kotlin 1.8]
    C7 --&gt; C7a[&quot;上下文接收者: context&quot;]
    
    C --&gt; C8[Kotlin 1.9+]
    C8 --&gt; C8a[&quot;多平台改进&quot;]
    C8 --&gt; C8b[&quot;K2 编译器特性&quot;]

    %% 3. 其他特性
    A --&gt; D[其他特性]
    D --&gt; D1[标准库扩展]
    D1 --&gt; D1a[&quot;集合: List, Set, Map&quot;]
    D1 --&gt; D1b[&quot;字符串: String, StringBuilder&quot;]
    D1 --&gt; D1c[&quot;IO: java.io&quot;]
    D1 --&gt; D1d[&quot;并发: kotlin.coroutines&quot;]
    
    D --&gt; D2[反射与运行时]
    D2 --&gt; D2a[&quot;类引用: ::class&quot;]
    D2 --&gt; D2b[&quot;函数引用: ::function&quot;]
    D2 --&gt; D2c[&quot;反射库: kotlin.reflect&quot;]
    
    D --&gt; D3[委托]
    D3 --&gt; D3a[&quot;属性委托: by lazy, by Delegates&quot;]
    D3 --&gt; D3b[&quot;类委托: by&quot;]</code></pre>
<h1 id="详解">详解</h1>
<h2 id="一基础语法特性">一、基础语法特性</h2>
<h3 id="基本数据类型">1. 基本数据类型</h3>
<h4 id="整型byte-short-int-long">1.1 整型：<code>Byte</code>,
<code>Short</code>, <code>Int</code>, <code>Long</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>Byte</code>：8 位有符号整数，范围 <code>-128</code> 到
<code>127</code>，显式声明为 <code>Byte</code>。</li>
<li><code>Short</code>：16 位有符号整数，范围 <code>-32768</code> 到
<code>32767</code>，显式声明为 <code>Short</code>。</li>
<li><code>Int</code>：32 位有符号整数，范围 <code>-2,147,483,648</code>
到 <code>2,147,483,647</code>，默认整数类型。</li>
<li><code>Long</code>：64 位有符号整数，范围
<code>-9,223,372,036,854,775,808</code> 到
<code>9,223,372,036,854,775,807</code>，需加 <code>L</code> 后缀。</li>
<li>支持类型推断，如 <code>val x = 42</code> 推断为
<code>Int</code>。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li><code>Byte</code>：节省内存，适用于小型数据（如网络协议中的标志位、图像像素值）。</li>
<li><code>Short</code>：较少使用，适用于特定硬件接口或与旧系统交互。</li>
<li><code>Int</code>：日常计数、数组索引、循环变量。</li>
<li><code>Long</code>：大范围数据，如时间戳（毫秒）、文件大小、数据库
ID。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>在 JVM 上，分别映射为 Java 的
<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>，为原始类型以优化性能。</li>
<li>当声明为可空类型（如 <code>Int?</code>）或用于泛型时，装箱为
<code>java.lang.Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>。</li>
<li>编译器优化字面量，例如 <code>val x = 42</code> 使用
<code>int</code>，避免不必要的对象创建。</li>
<li>类型转换需显式调用方法（如
<code>toInt()</code>），避免隐式转换错误。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> byte: <span class="built_in">Byte</span> = <span class="number">127</span></span><br><span class="line">    <span class="keyword">val</span> short: <span class="built_in">Short</span> = <span class="number">32_767</span></span><br><span class="line">    <span class="keyword">val</span> int: <span class="built_in">Int</span> = <span class="number">2_147_483_647</span></span><br><span class="line">    <span class="keyword">val</span> long: <span class="built_in">Long</span> = <span class="number">9_223_372_036_854_775_807L</span></span><br><span class="line">    println(<span class="string">&quot;Byte: <span class="variable">$byte</span>, Short: <span class="variable">$short</span>, Int: <span class="variable">$int</span>, Long: <span class="variable">$long</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换</span></span><br><span class="line">    <span class="keyword">val</span> byteToInt: <span class="built_in">Int</span> = byte.toInt()</span><br><span class="line">    println(<span class="string">&quot;Byte to Int: <span class="variable">$byteToInt</span>&quot;</span>)  <span class="comment">// 127</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出示例</span></span><br><span class="line">    <span class="keyword">val</span> overflow: <span class="built_in">Byte</span> = (byte + <span class="number">1</span>).toByte()  <span class="comment">// 127 + 1 = -128（溢出）</span></span><br><span class="line">    println(<span class="string">&quot;Overflow Byte: <span class="variable">$overflow</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可空类型</span></span><br><span class="line">    <span class="keyword">val</span> nullableLong: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">    println(<span class="string">&quot;Nullable Long: <span class="variable">$nullableLong</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>溢出风险</strong>：<code>Byte</code> 和 <code>Short</code>
操作超出范围不会自动提升类型，需手动转换（如
<code>(byte + 1).toByte()</code>），否则溢出（如 127 + 1 = -128）。</li>
<li><strong>类型转换</strong>：必须显式转换（如
<code>toInt()</code>），否则编译错误，避免隐式转换导致的意外。</li>
<li><strong>性能</strong>：优先使用 <code>Int</code>，因为它是 JVM
的默认整数类型，<code>Byte</code> 和 <code>Short</code>
在某些场景可能因装箱而降低性能。</li>
<li><strong><code>L</code> 后缀</strong>：<code>Long</code> 字面量忘记加
<code>L</code> 会默认推断为 <code>Int</code>，可能导致溢出。</li>
</ul></li>
</ul>
<h4 id="浮点型float-double">1.2 浮点型：<code>Float</code>,
<code>Double</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>Float</code>：32 位单精度浮点数，约 6-7 位有效数字，需加
<code>f</code> 或 <code>F</code> 后缀（如 <code>3.14f</code>）。</li>
<li><code>Double</code>：64 位双精度浮点数，约 15-16
位有效数字，默认浮点类型（如 <code>3.14</code>）。</li>
<li>支持科学计数法（如 <code>1.23e-4</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li><code>Float</code>：节省内存，适用于图形渲染（如 OpenGL
坐标）、低精度计算。</li>
<li><code>Double</code>：高精度计算，如科学计算、财务数据处理、地理坐标。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>遵循 IEEE 754 标准，包含 1 位符号、指数位（<code>Float</code> 8
位，<code>Double</code> 11 位）和尾数位（<code>Float</code> 23
位，<code>Double</code> 52 位）。</li>
<li>在 JVM 上，<code>Float</code> 映射为
<code>float</code>，<code>Double</code> 映射为
<code>double</code>，可空时装箱为 <code>java.lang.Float</code> 和
<code>Double</code>。</li>
<li>运算结果可能因舍入而有微小误差。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> float: <span class="built_in">Float</span> = <span class="number">3.14159f</span></span><br><span class="line">    <span class="keyword">val</span> double: <span class="built_in">Double</span> = <span class="number">3.141592653589793</span></span><br><span class="line">    println(<span class="string">&quot;Float: <span class="variable">$float</span>, Double: <span class="variable">$double</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 科学计数法</span></span><br><span class="line">    <span class="keyword">val</span> sciFloat: <span class="built_in">Float</span> = <span class="number">1.23e2f</span>  <span class="comment">// 123.0</span></span><br><span class="line">    println(<span class="string">&quot;Scientific Float: <span class="variable">$sciFloat</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 精度问题</span></span><br><span class="line">    <span class="keyword">val</span> sumFloat = <span class="number">0.1f</span> + <span class="number">0.2f</span></span><br><span class="line">    println(<span class="string">&quot;Float 0.1 + 0.2 = <span class="variable">$sumFloat</span>&quot;</span>)  <span class="comment">// 0.300000004（误差）</span></span><br><span class="line">    <span class="keyword">val</span> sumDouble = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line">    println(<span class="string">&quot;Double 0.1 + 0.2 = <span class="variable">$sumDouble</span>&quot;</span>)  <span class="comment">// 0.30000000000000004（更高精度）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换</span></span><br><span class="line">    <span class="keyword">val</span> floatToDouble: <span class="built_in">Double</span> = float.toDouble()</span><br><span class="line">    println(<span class="string">&quot;Float to Double: <span class="variable">$floatToDouble</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>精度问题</strong>：浮点运算可能有舍入误差（如
<code>0.1 + 0.2 != 0.3</code>），避免直接用 <code>==</code>
比较，建议用范围检查（如 <code>abs(a - b) &lt; 0.0001</code>）。</li>
<li><strong><code>f</code> 后缀</strong>：<code>Float</code>
字面量忘记加 <code>f</code> 会推断为
<code>Double</code>，导致类型不匹配。</li>
<li><strong>性能与内存</strong>：<code>Float</code>
节省内存，但精度低，<code>Double</code> 更适合高精度需求。</li>
<li><strong>溢出与无穷</strong>：除以 0 返回 <code>Infinity</code>
而非异常，需检查结果。</li>
</ul></li>
</ul>
<h4 id="字符型char">1.3 字符型：<code>Char</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>表示 16 位 Unicode 字符，使用单引号定义（如
<code>'A'</code>）。</li>
<li>支持转义字符（如 <code>\n</code>, <code>\t</code>）和 Unicode
码点（如 <code>\u0041</code> 表示 <code>'A'</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>文本解析（如逐字符处理字符串）。</li>
<li>表示单个按键输入或编码转换。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>映射到 JVM 的 <code>char</code>，存储为 16 位无符号整数（0 到
65535）。</li>
<li>可空时装箱为 <code>java.lang.Character</code>。</li>
<li>支持与整数运算，基于 Unicode 码点。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> char: <span class="built_in">Char</span> = <span class="string">&#x27;K&#x27;</span></span><br><span class="line">    <span class="keyword">val</span> unicodeChar: <span class="built_in">Char</span> = <span class="string">&#x27;\u004B&#x27;</span>  <span class="comment">// &#x27;K&#x27;</span></span><br><span class="line">    println(<span class="string">&quot;Char: <span class="variable">$char</span>, Unicode: <span class="variable">$unicodeChar</span>, Code: <span class="subst">$&#123;char.code&#125;</span>&quot;</span>)  <span class="comment">// K, K, 75</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转义字符</span></span><br><span class="line">    <span class="keyword">val</span> newline: <span class="built_in">Char</span> = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;Line1<span class="subst">$&#123;newline&#125;</span>Line2&quot;</span>)  <span class="comment">// Line1换行Line2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符运算</span></span><br><span class="line">    <span class="keyword">val</span> nextChar = char + <span class="number">1</span>  <span class="comment">// &#x27;L&#x27;</span></span><br><span class="line">    println(<span class="string">&quot;Next Char: <span class="variable">$nextChar</span>&quot;</span>)  <span class="comment">// L</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可空类型</span></span><br><span class="line">    <span class="keyword">val</span> nullableChar: <span class="built_in">Char</span>? = <span class="literal">null</span></span><br><span class="line">    println(<span class="string">&quot;Nullable Char: <span class="variable">$nullableChar</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>与数字区分</strong>：<code>Char</code>
不能直接当作整数使用，需用 <code>.code</code> 转换。</li>
<li><strong>单引号</strong>：使用双引号（如 <code>"A"</code>）会推断为
<code>String</code>，导致类型错误。</li>
<li><strong>范围限制</strong>：超出 Unicode 范围（如 <code>\uFFFF</code>
以上）无效。</li>
<li><strong>运算结果</strong>：<code>Char</code> 加减返回
<code>Int</code>，需转换回 <code>Char</code>。</li>
</ul></li>
</ul>
<h4 id="布尔型boolean">1.4 布尔型：<code>Boolean</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>表示 <code>true</code> 或 <code>false</code>，用于逻辑判断。</li>
<li>可声明为可空类型（如 <code>Boolean?</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>条件判断（如 <code>if</code> 语句）。</li>
<li>状态标志（如 <code>isActive</code>）。</li>
<li>三态逻辑（true, false, null）。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>映射到 JVM 的 <code>boolean</code>，占用 1 位（实际实现可能占 1
字节）。</li>
<li>可空时装箱为 <code>java.lang.Boolean</code>。</li>
<li>逻辑运算基于短路求值。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> isDone: <span class="built_in">Boolean</span>? = <span class="literal">null</span></span><br><span class="line">    println(<span class="string">&quot;isActive: <span class="variable">$isActive</span>, isDone: <span class="variable">$isDone</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑运算</span></span><br><span class="line">    <span class="keyword">val</span> result = isActive &amp;&amp; (isDone ?: <span class="literal">false</span>)</span><br><span class="line">    println(<span class="string">&quot;Result: <span class="variable">$result</span>&quot;</span>)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三态逻辑</span></span><br><span class="line">    <span class="keyword">val</span> status = <span class="keyword">when</span> (isDone) &#123;</span><br><span class="line">        <span class="literal">true</span> -&gt; <span class="string">&quot;Completed&quot;</span></span><br><span class="line">        <span class="literal">false</span> -&gt; <span class="string">&quot;Pending&quot;</span></span><br><span class="line">        <span class="literal">null</span> -&gt; <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Status: <span class="variable">$status</span>&quot;</span>)  <span class="comment">// Unknown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>可空处理</strong>：<code>Boolean?</code> 在逻辑运算中需配合
<code>?:</code> 或 <code>!!</code>，否则编译错误。</li>
<li><strong>短路求值</strong>：<code>&amp;&amp;</code> 和
<code>||</code> 是短路的，避免在右边放入副作用代码。</li>
<li><strong>性能</strong>：避免不必要的装箱（如
<code>Boolean?</code>），影响效率。</li>
</ul></li>
</ul>
<hr />
<h3 id="变量与常量">2. 变量与常量</h3>
<h4 id="变量var">2.1 变量：<code>var</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>var</code> 关键字声明可变变量，可多次赋值。</li>
<li>支持类型推断（如 <code>var x = 10</code> 推断为
<code>Int</code>），或显式声明（如 <code>var x: Int = 10</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>循环计数器、临时状态存储。</li>
<li>用户输入或动态数据处理。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 的普通局部变量或字段，分配内存后可自由修改。</li>
<li>类型推断在编译时完成，生成对应的字节码类型（如
<code>int</code>）。</li>
<li>不涉及运行时开销。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">10</span></span><br><span class="line">    println(<span class="string">&quot;Initial: <span class="variable">$count</span>&quot;</span>)  <span class="comment">// 10</span></span><br><span class="line">    count = <span class="number">20</span></span><br><span class="line">    println(<span class="string">&quot;Updated: <span class="variable">$count</span>&quot;</span>)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型显式声明</span></span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    name = <span class="string">&quot;Java&quot;</span></span><br><span class="line">    println(<span class="string">&quot;Name: <span class="variable">$name</span>&quot;</span>)  <span class="comment">// Java</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 作用域示例</span></span><br><span class="line">    run &#123;</span><br><span class="line">        <span class="keyword">var</span> local = <span class="number">5</span></span><br><span class="line">        local += <span class="number">1</span></span><br><span class="line">        println(<span class="string">&quot;Local: <span class="variable">$local</span>&quot;</span>)  <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>过度使用</strong>：滥用 <code>var</code>
增加可变性，降低代码安全性，建议优先用 <code>val</code>。</li>
<li><strong>类型一致性</strong>：赋值时类型必须匹配，否则编译错误。</li>
<li><strong>作用域</strong>：局部变量未初始化不会报错，但使用前需赋值。</li>
</ul></li>
</ul>
<h4 id="常量val">2.2 常量：<code>val</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>val</code> 关键字声明只读变量，赋值后不可更改引用。</li>
<li>支持类型推断和显式声明。</li>
<li>可用于表达式返回值。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>常量定义（如数学常数 <code>PI</code>）。</li>
<li>函数结果缓存、不可变配置。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 的 <code>final</code> 变量，确保引用不可变。</li>
<li>对于对象，<code>val</code>
只限制引用，对象内部状态可通过方法修改。</li>
<li>若为基本类型，编译器可能内联值以优化性能。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pi = <span class="number">3.14</span></span><br><span class="line">    <span class="comment">// pi = 3.15  // 错误：val 不可重新赋值</span></span><br><span class="line">    println(<span class="string">&quot;Pi: <span class="variable">$pi</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变对象</span></span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    list.add(<span class="number">3</span>)</span><br><span class="line">    println(<span class="string">&quot;List: <span class="variable">$list</span>&quot;</span>)  <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表达式赋值</span></span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">5</span></span><br><span class="line">    <span class="keyword">val</span> max = <span class="keyword">if</span> (x &gt; <span class="number">0</span>) x <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    println(<span class="string">&quot;Max: <span class="variable">$max</span>&quot;</span>)  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>引用 vs 对象</strong>：<code>val</code>
只限制引用，对象内容可变，需区分。</li>
<li><strong>初始化</strong>：必须初始化或在 <code>init</code>
块中赋值，否则编译错误。</li>
<li><strong>性能</strong>：编译器可能内联
<code>val</code>，但复杂表达式不会。</li>
</ul></li>
</ul>
<hr />
<h3 id="运算符">3. 运算符</h3>
<h4 id="算术运算符--">3.1 算术运算符：<code>+</code>, <code>-</code>,
<code>*</code>, <code>/</code>, <code>%</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>+</code>：加法或字符串拼接。</li>
<li><code>-</code>：减法。</li>
<li><code>*</code>：乘法。</li>
<li><code>/</code>：除法（整数除法结果为整数，浮点除法为浮点数）。</li>
<li><code>%</code>：取模。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>数学计算（如统计、物理模拟）。</li>
<li>字符串拼接（如日志生成）。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>映射到 JVM 的数学指令（如 <code>iadd</code>,
<code>fdiv</code>）。</li>
<li>字符串 <code>+</code> 编译为 <code>StringBuilder</code> 操作。</li>
<li>除法对整数和浮点分开处理。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> b = <span class="number">3</span></span><br><span class="line">    println(<span class="string">&quot;a + b = <span class="subst">$&#123;a + b&#125;</span>&quot;</span>)  <span class="comment">// 13</span></span><br><span class="line">    println(<span class="string">&quot;a - b = <span class="subst">$&#123;a - b&#125;</span>&quot;</span>)  <span class="comment">// 7</span></span><br><span class="line">    println(<span class="string">&quot;a * b = <span class="subst">$&#123;a * b&#125;</span>&quot;</span>)  <span class="comment">// 30</span></span><br><span class="line">    println(<span class="string">&quot;a / b = <span class="subst">$&#123;a / b&#125;</span>&quot;</span>)  <span class="comment">// 3 (整数除法)</span></span><br><span class="line">    println(<span class="string">&quot;a % b = <span class="subst">$&#123;a % b&#125;</span>&quot;</span>)  <span class="comment">// 1</span></span><br><span class="line">    println(<span class="string">&quot;Hello &quot;</span> + <span class="string">&quot;World&quot;</span>)  <span class="comment">// Hello World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>除以零</strong>：整数除以 0 抛
<code>ArithmeticException</code>，浮点返回 <code>Infinity</code>。</li>
<li><strong>类型提升</strong>：操作数类型不同时提升到更高精度（如
<code>Int + Double</code> 结果为 <code>Double</code>）。</li>
<li><strong>字符串拼接性能</strong>：大量 <code>+</code>
操作效率低，建议用模板或 <code>StringBuilder</code>。</li>
</ul></li>
</ul>
<h4 id="关系运算符">3.2 关系运算符：<code>==</code>, <code>!=</code>,
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
<code>&gt;=</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>==</code>：值相等。</li>
<li><code>!=</code>：值不等。</li>
<li><code>&lt;</code>, <code>&gt;</code>：小于、大于。</li>
<li><code>&lt;=</code>, <code>&gt;=</code>：小于等于、大于等于。</li>
<li><code>===</code>, <code>!==</code>：引用相等/不等。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>条件判断、排序算法。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li><code>==</code> 调用 <code>equals()</code>，<code>===</code>
检查对象引用。</li>
<li>其他运算符映射到 JVM 比较指令（如 <code>if_icmplt</code>）。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">5</span></span><br><span class="line">    <span class="keyword">val</span> y = <span class="number">10</span></span><br><span class="line">    println(<span class="string">&quot;x == y: <span class="subst">$&#123;x == y&#125;</span>&quot;</span>)  <span class="comment">// false</span></span><br><span class="line">    println(<span class="string">&quot;x &lt; y: <span class="subst">$&#123;x &lt; y&#125;</span>&quot;</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> str1 = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    <span class="keyword">val</span> str2 = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    println(<span class="string">&quot;str1 === str2: <span class="subst">$&#123;str1 === str2&#125;</span>&quot;</span>)  <span class="comment">// true (字符串池)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>浮点比较</strong>：避免直接用
<code>==</code>，因精度误差可能导致错误。</li>
<li><strong><code>===</code>
使用</strong>：仅适用于对象引用，基本类型始终用 <code>==</code>。</li>
<li><strong>自定义类</strong>：<code>==</code> 需要重写
<code>equals()</code>。</li>
</ul></li>
</ul>
<h4 id="逻辑运算符">3.3 逻辑运算符：<code>&amp;&amp;</code>,
<code>||</code>, <code>!</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>&amp;&amp;</code>：逻辑与，短路求值。</li>
<li><code>||</code>：逻辑或，短路求值。</li>
<li><code>!</code>：逻辑非。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>多条件组合判断。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>短路求值优化性能，映射到 JVM 逻辑指令。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> b = <span class="literal">false</span></span><br><span class="line">    println(<span class="string">&quot;a &amp;&amp; b: <span class="subst">$&#123;a &amp;&amp; b&#125;</span>&quot;</span>)  <span class="comment">// false</span></span><br><span class="line">    println(<span class="string">&quot;a || b: <span class="subst">$&#123;a || b&#125;</span>&quot;</span>)  <span class="comment">// true</span></span><br><span class="line">    println(<span class="string">&quot;!a: <span class="subst">$&#123;!a&#125;</span>&quot;</span>)  <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>副作用</strong>：短路求值可能跳过右边代码，注意逻辑顺序。</li>
<li><strong>可空类型</strong>：<code>Boolean?</code> 需处理
<code>null</code>。</li>
</ul></li>
</ul>
<h4 id="位运算符and-or-xor-shl-shr">3.4 位运算符：<code>and</code>,
<code>or</code>, <code>xor</code>, <code>shl</code>,
<code>shr</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>and</code>：按位与。</li>
<li><code>or</code>：按位或。</li>
<li><code>xor</code>：按位异或。</li>
<li><code>shl</code>：左移。</li>
<li><code>shr</code>：右移（带符号）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>权限标志、位掩码、低级优化。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>映射到 JVM 位操作指令（如 <code>iand</code>,
<code>ishl</code>）。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">5</span>  <span class="comment">// 101</span></span><br><span class="line">    <span class="keyword">val</span> y = <span class="number">3</span>  <span class="comment">// 011</span></span><br><span class="line">    println(<span class="string">&quot;x and y: <span class="subst">$&#123;x and y&#125;</span>&quot;</span>)  <span class="comment">// 1 (001)</span></span><br><span class="line">    println(<span class="string">&quot;x or y: <span class="subst">$&#123;x or y&#125;</span>&quot;</span>)  <span class="comment">// 7 (111)</span></span><br><span class="line">    println(<span class="string">&quot;x xor y: <span class="subst">$&#123;x xor y&#125;</span>&quot;</span>)  <span class="comment">// 6 (110)</span></span><br><span class="line">    println(<span class="string">&quot;x shl 1: <span class="subst">$&#123;x shl <span class="number">1</span>&#125;</span>&quot;</span>)  <span class="comment">// 10 (1010)</span></span><br><span class="line">    println(<span class="string">&quot;x shr 1: <span class="subst">$&#123;x shr <span class="number">1</span>&#125;</span>&quot;</span>)  <span class="comment">// 2 (010)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>符号位</strong>：<code>shr</code>
是带符号右移，负数需注意。</li>
<li><strong>溢出</strong>：移位不检查范围，可能导致意外结果。</li>
</ul></li>
</ul>
<h4 id="赋值运算符--">3.5 赋值运算符：<code>=</code>, <code>+=</code>,
<code>-=</code>, <code>*=</code>, <code>/=</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>=</code>：简单赋值。</li>
<li><code>+=</code>, <code>-=</code>, <code>*=</code>,
<code>/=</code>：组合赋值。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>累加操作、状态更新。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为赋值和计算的组合指令。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    x += <span class="number">5</span></span><br><span class="line">    println(<span class="string">&quot;x += 5: <span class="variable">$x</span>&quot;</span>)  <span class="comment">// 15</span></span><br><span class="line">    x *= <span class="number">2</span></span><br><span class="line">    println(<span class="string">&quot;x *= 2: <span class="variable">$x</span>&quot;</span>)  <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>不可变变量</strong>：<code>val</code>
不支持赋值运算符。</li>
<li><strong>类型匹配</strong>：右边类型需与左边兼容。</li>
</ul></li>
</ul>
<h4 id="其他运算符-.-in">3.6 其他运算符：<code>?:</code>,
<code>?.</code>, <code>!!</code>, <code>in</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>?:</code>（Elvis）：若左边为
<code>null</code>，返回右边值。</li>
<li><code>?.</code>：安全调用，若对象为 <code>null</code> 返回
<code>null</code>。</li>
<li><code>!!</code>：非空断言，若为 <code>null</code> 抛异常。</li>
<li><code>in</code>：检查是否在范围或集合中。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>空安全处理、范围检查。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器插入 <code>null</code> 检查和跳转逻辑。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str: String? = <span class="literal">null</span></span><br><span class="line">    println(<span class="string">&quot;Safe call: <span class="subst">$&#123;str?.length&#125;</span>&quot;</span>)  <span class="comment">// null</span></span><br><span class="line">    println(<span class="string">&quot;Elvis: <span class="subst">$&#123;str?.length ?: <span class="number">0</span>&#125;</span>&quot;</span>)  <span class="comment">// 0</span></span><br><span class="line">    println(<span class="string">&quot;In range: <span class="subst">$&#123;<span class="number">3</span> in <span class="number">1.</span><span class="number">.5</span>&#125;</span>&quot;</span>)  <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// println(str!!.length)  // 抛 NPE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong><code>!!</code> 风险</strong>：滥用可能抛
<code>NullPointerException</code>，尽量避免。</li>
<li><strong>性能</strong>：<code>?.</code> 和 <code>?:</code>
增加分支检查，频繁使用可能影响性能。</li>
<li><strong><code>in</code> 范围</strong>：范围对象需实现
<code>contains</code>。</li>
</ul></li>
</ul>
<hr />
<h3 id="控制结构">4. 控制结构</h3>
<h4 id="条件语句if-else">4.1 条件语句：<code>if</code>,
<code>else</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>基本形式：<code>if (condition) { ... } else { ... }</code>。</li>
<li>可作为表达式，返回值由最后一行决定。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>简单条件分支、返回值计算。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 的 <code>if</code> 指令（如
<code>ifne</code>），表达式形式生成临时变量。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">5</span></span><br><span class="line">    <span class="keyword">val</span> result = <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Positive&quot;</span>)</span><br><span class="line">        <span class="string">&quot;Positive&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="string">&quot;Zero&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Negative&quot;</span>)</span><br><span class="line">        <span class="string">&quot;Negative&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Result: <span class="variable">$result</span>&quot;</span>)  <span class="comment">// Positive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>完整性</strong>：作为表达式时必须有
<code>else</code>，否则编译错误。</li>
<li><strong>嵌套</strong>：过多嵌套降低可读性，考虑用
<code>when</code>。</li>
</ul></li>
</ul>
<h4 id="分支语句when">4.2 分支语句：<code>when</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>替代
<code>switch</code>，支持多种条件（如值匹配、范围检查、<code>is</code>
类型检查）。</li>
<li>可作为表达式。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>多条件分支、模式匹配。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为条件跳转或表查找（类似 <code>switch</code>）。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> desc = <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; <span class="string">&quot;One&quot;</span></span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span> -&gt; <span class="string">&quot;Two or Three&quot;</span></span><br><span class="line">        <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; <span class="string">&quot;In range&quot;</span></span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; <span class="string">&quot;Integer&quot;</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">&quot;Other&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Description: <span class="variable">$desc</span>&quot;</span>)  <span class="comment">// Two or Three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>覆盖性</strong>：作为表达式时需覆盖所有情况或加
<code>else</code>。</li>
<li><strong>性能</strong>：复杂条件可能生成较多字节码。</li>
</ul></li>
</ul>
<h4 id="循环for-while-do-while">4.3 循环：<code>for</code>,
<code>while</code>, <code>do-while</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>for</code>：<code>for (item in collection/range) { ... }</code>，支持范围、步长。</li>
<li><code>while</code>：<code>while (condition) { ... }</code>。</li>
<li><code>do-while</code>：<code>do { ... } while (condition)</code>。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>数据遍历、重复执行。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li><code>for</code> 编译为迭代器调用，<code>while</code>
为条件跳转。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span> step <span class="number">2</span>) print(<span class="string">&quot;<span class="variable">$i</span> &quot;</span>)  <span class="comment">// 1 3 5</span></span><br><span class="line">    println()</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (x &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="variable">$x</span> &quot;</span>)</span><br><span class="line">        x++</span><br><span class="line">    &#125;  <span class="comment">// 0 1 2</span></span><br><span class="line">    println()</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="variable">$x</span> &quot;</span>)</span><br><span class="line">        x--</span><br><span class="line">    &#125; <span class="keyword">while</span> (x &gt; <span class="number">0</span>)  <span class="comment">// 3 2 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>范围对象</strong>：<code>for</code> 需可迭代对象。</li>
<li><strong>无限循环</strong>：<code>while (true)</code>
需确保退出条件。</li>
</ul></li>
</ul>
<h4 id="跳转break-continue-return">4.4 跳转：<code>break</code>,
<code>continue</code>, <code>return</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>break</code>：退出循环。</li>
<li><code>continue</code>：跳到下一次迭代。</li>
<li><code>return</code>：返回函数结果。</li>
<li>支持标签（如 <code>break@label</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>控制循环流程。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 <code>goto</code> 或返回指令。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="symbol">outer@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">2</span>) <span class="keyword">break</span><span class="symbol">@outer</span></span><br><span class="line">            print(<span class="string">&quot;<span class="variable">$i</span><span class="variable">$j</span> &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// 11</span></span><br><span class="line">    println()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">&quot;<span class="variable">$i</span> &quot;</span>)  <span class="comment">// 1 2 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>标签</strong>：多重循环需正确使用标签，避免跳错。</li>
<li><strong>可读性</strong>：过多跳转降低代码清晰度。</li>
</ul></li>
</ul>
<hr />
<h3 id="函数">5. 函数</h3>
<h4 id="函数定义fun">5.1 函数定义：<code>fun</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>格式：<code>fun name(params): ReturnType { ... }</code>。</li>
<li>返回类型可选（类型推断）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>代码复用、逻辑封装。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 方法，参数和返回值类型静态绑定。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(add(<span class="number">3</span>, <span class="number">4</span>))  <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>返回类型</strong>：复杂函数建议显式声明返回类型。</li>
<li><strong>命名</strong>：遵循清晰命名规范。</li>
</ul></li>
</ul>
<h4 id="参数默认参数-vararg">5.2 参数：默认参数,
<code>vararg</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>默认参数：<code>param: Type = defaultValue</code>。</li>
<li><code>vararg</code>：可变参数，接收任意数量参数。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>简化函数调用、可变参数处理。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>默认参数生成重载方法。</li>
<li><code>vararg</code> 编译为数组参数。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printItems</span><span class="params">(<span class="keyword">vararg</span> items: <span class="type">String</span>, prefix: <span class="type">String</span> = <span class="string">&quot;&gt;&quot;</span>)</span></span> &#123;</span><br><span class="line">    items.forEach &#123; println(<span class="string">&quot;<span class="variable">$prefix</span> <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printItems(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, prefix = <span class="string">&quot;#&quot;</span>)  <span class="comment">// # A, # B</span></span><br><span class="line">    printItems(<span class="string">&quot;X&quot;</span>)  <span class="comment">// &gt; X</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>顺序</strong>：默认参数应放在 <code>vararg</code> 后。</li>
<li><strong>唯一性</strong>：一个函数只能有一个
<code>vararg</code>。</li>
</ul></li>
</ul>
<h4 id="单表达式函数">5.3 单表达式函数：<code>=</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>=</code> 替代 <code>{}</code> 和
<code>return</code>，适用于简单函数。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>简洁计算、工具函数。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为普通方法，表达式直接作为返回值。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiply</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a * b</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(multiply(<span class="number">2</span>, <span class="number">3</span>))  <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>可读性</strong>：复杂逻辑不适合单表达式。</li>
<li><strong>类型推断</strong>：返回值类型需明确。</li>
</ul></li>
</ul>
<h4 id="匿名函数">5.4 匿名函数</h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>格式：<code>fun(params) = expression</code>，无函数名。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>临时逻辑定义、函数变量。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为函数对象。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> anon = <span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>)</span></span> = x * <span class="number">2</span></span><br><span class="line">    println(anon(<span class="number">5</span>))  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>性能</strong>：频繁创建可能增加开销。</li>
<li><strong>使用范围</strong>：适合局部使用。</li>
</ul></li>
</ul>
<h4 id="高阶函数">5.5 高阶函数</h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>函数参数或返回值为函数类型（如 <code>(Int) -&gt; Int</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>回调、函数式编程。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为函数接口（如 <code>Function1</code>），若加
<code>inline</code> 则内联。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(x: <span class="type">Int</span>, op: (<span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span> = op(x)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(apply(<span class="number">5</span>) &#123; it * <span class="number">2</span> &#125;)  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>性能</strong>：未加 <code>inline</code>
会生成对象，影响效率。</li>
<li><strong>类型复杂性</strong>：参数类型需清晰定义。</li>
</ul></li>
</ul>
<hr />
<h3 id="类与对象">6. 类与对象</h3>
<h4 id="类定义class">6.1 类定义：<code>class</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>格式：<code>class Name(params) { ... }</code>，主构造函数在类头。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>数据建模、面向对象设计。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 类，构造函数生成 <code>init</code> 块。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">()</span></span> = println(<span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p = Person(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">    p.greet()  <span class="comment">// Hello, Alice</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>主构造函数</strong>：参数需明确作用（<code>val</code>/<code>var</code>）。</li>
</ul></li>
</ul>
<h4 id="构造函数constructor">6.2 构造函数：<code>constructor</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>主构造函数在类头，次构造函数使用 <code>constructor</code>。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>对象初始化多样性。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>次构造函数委托给主构造函数，编译为多个构造方法。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        println(<span class="string">&quot;Age: <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)  <span class="comment">// Age: 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>委托</strong>：次构造函数必须调用主构造函数。</li>
<li><strong>复杂度</strong>：过多构造函数降低可读性。</li>
</ul></li>
</ul>
<h4 id="属性var-val">6.3 属性：<code>var</code>, <code>val</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>var</code> 定义可变属性，<code>val</code> 定义只读属性。</li>
<li>可自定义 <code>get</code>/<code>set</code>。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>对象状态管理。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为字段和访问器方法。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">get</span>() = field</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> box = Box()</span><br><span class="line">    box.size = <span class="number">5</span></span><br><span class="line">    println(box.size)  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>自定义访问器</strong>：避免无限递归（如
<code>get() = size</code>）。</li>
<li><strong>初始化</strong>：必须初始化或延迟。</li>
</ul></li>
</ul>
<h4 id="访问控制public-private-protected-internal">6.4
访问控制：<code>public</code>, <code>private</code>,
<code>protected</code>, <code>internal</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>public</code>：默认，公开。</li>
<li><code>private</code>：类内可见。</li>
<li><code>protected</code>：类及子类可见。</li>
<li><code>internal</code>：模块内可见。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>封装性控制。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 访问修饰符。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> secret = <span class="number">42</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> subclassVisible = <span class="string">&quot;Protected&quot;</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> moduleVisible = <span class="string">&quot;Internal&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong><code>internal</code></strong>：模块定义需明确。</li>
<li><strong>过度限制</strong>：影响扩展性。</li>
</ul></li>
</ul>
<h4 id="继承open">6.5 继承：<code>open</code>, <code>:</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>open</code> 允许继承，<code>:</code> 表示继承关系。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>类层次设计。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 继承结构。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(name: String) : Animal(name)</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong><code>open</code> 必要性</strong>：类默认不可继承。</li>
<li><strong>单一继承</strong>：Kotlin 不支持多重继承。</li>
</ul></li>
</ul>
<h4 id="接口interface">6.6 接口：<code>interface</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>定义方法和属性，使用 <code>override</code> 实现。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>多态、行为契约。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 接口。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="type">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> = println(<span class="string">&quot;Flying&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>实现冲突</strong>：多接口需处理方法冲突。</li>
<li><strong>默认实现</strong>：避免过度依赖。</li>
</ul></li>
</ul>
<h4 id="抽象类abstract">6.7 抽象类：<code>abstract</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>abstract</code> 定义抽象成员。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>提供部分实现。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为抽象类。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>: <span class="built_in">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="keyword">val</span> radius: <span class="built_in">Double</span>) : Shape() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span> = Math.PI * radius * radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>抽象成员</strong>：必须被子类实现。</li>
<li><strong>实例化</strong>：不可直接实例化。</li>
</ul></li>
</ul>
<h4 id="数据类data">6.8 数据类：<code>data</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>data</code> 自动生成 <code>toString()</code>,
<code>equals()</code>, <code>copy()</code> 等。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>DTO、简单数据容器。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器生成额外方法。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">    println(user.copy(name = <span class="string">&quot;Bob&quot;</span>))  <span class="comment">// User(id=1, name=Bob)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>主构造函数</strong>：至少一个参数。</li>
<li><strong>继承限制</strong>：不可被 <code>open</code>。</li>
</ul></li>
</ul>
<h4 id="对象声明object">6.9 对象声明：<code>object</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>object</code> 创建单例。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>单例模式、工具类。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为静态实例。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Singleton.hello()  <span class="comment">// Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>状态管理</strong>：单例需注意线程安全。</li>
<li><strong>滥用</strong>：不适合频繁创建的对象。</li>
</ul></li>
</ul>
<h4 id="伴生对象companion-object">6.10
伴生对象：<code>companion object</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>在类中使用 <code>companion object</code> 定义静态成员。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>工厂方法、静态工具。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为类的静态字段。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span> = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> instance = MyClass.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>命名</strong>：可命名以提高可读性。</li>
<li><strong>访问</strong>：外部需通过类名访问。</li>
</ul></li>
</ul>
<hr />
<h3 id="包与导入">7. 包与导入</h3>
<h4 id="包定义package">7.1 包定义：<code>package</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>package</code> 定义命名空间。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>代码组织、避免命名冲突。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 包结构。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hello()  <span class="comment">// Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>一致性</strong>：包名应与目录结构一致。</li>
<li><strong>冲突</strong>：避免与其他包名冲突。</li>
</ul></li>
</ul>
<h4 id="导入import">7.2 导入：<code>import</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>import</code>
引入类或函数，支持别名（<code>as</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>使用外部库、简化代码。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译时解析导入路径。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.PI <span class="keyword">as</span> MathPI</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(MathPI)  <span class="comment">// 3.141592653589793</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>命名冲突</strong>：使用 <code>as</code> 解决。</li>
<li><strong>冗余导入</strong>：IDE 可优化。</li>
</ul></li>
</ul>
<hr />
<h3 id="异常处理">8. 异常处理</h3>
<h4 id="try-catch-finally">8.1 <code>try</code>, <code>catch</code>,
<code>finally</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>try</code> 定义可能抛异常的代码，<code>catch</code>
处理异常，<code>finally</code> 确保执行。</li>
<li>可作为表达式。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>错误处理、资源清理。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 的异常表。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">        <span class="string">&quot;Success&quot;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error: <span class="subst">$&#123;e.message&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="string">&quot;Failed&quot;</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Cleanup&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Result: <span class="variable">$result</span>&quot;</span>)  <span class="comment">// Failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>异常类型</strong>：捕获具体异常，避免用
<code>Exception</code>。</li>
<li><strong><code>finally</code>
执行</strong>：总是执行，注意资源释放。</li>
</ul></li>
</ul>
<h4 id="throw">8.2 <code>throw</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>throw</code> 抛出异常对象。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>自定义错误条件。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>映射到 JVM 的 <code>athrow</code> 指令。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Negative not allowed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        validate(-<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IllegalArgumentException) &#123;</span><br><span class="line">        println(e.message)  <span class="comment">// Negative not allowed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>异常信息</strong>：提供清晰描述。</li>
<li><strong>滥用</strong>：不应用作流程控制。</li>
</ul></li>
</ul>
<hr />
<h3 id="泛型">9. 泛型</h3>
<h4 id="泛型类t">9.1 泛型类：<code>&lt;T&gt;</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>&lt;T&gt;</code> 定义类型参数。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>类型安全的容器。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 的泛型擦除，使用 <code>Object</code>
并插入类型检查。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> value: T)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intBox = Box(<span class="number">42</span>)</span><br><span class="line">    <span class="keyword">val</span> strBox = Box(<span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;intBox.value&#125;</span>, <span class="subst">$&#123;strBox.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>类型约束</strong>：可用 <code>where</code> 限制。</li>
<li><strong>运行时</strong>：无法直接获取 <code>T</code> 类型。</li>
</ul></li>
</ul>
<h4 id="泛型函数">9.2 泛型函数</h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>在函数名前加 <code>&lt;T&gt;</code>。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>通用算法。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>同泛型类，类型擦除。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">printItem</span><span class="params">(item: <span class="type">T</span>)</span></span> = println(item)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printItem(<span class="number">42</span>)  <span class="comment">// 42</span></span><br><span class="line">    printItem(<span class="string">&quot;Kotlin&quot;</span>)  <span class="comment">// Kotlin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>类型推断</strong>：复杂场景需显式指定类型。</li>
<li><strong>性能</strong>：避免过度泛化。</li>
</ul></li>
</ul>
<h4 id="协变out">9.3 协变：<code>out</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>out</code> 限制类型只能作为返回值。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>生产者模式。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器确保类型安全。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Producer</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringProducer</span> : <span class="type">Producer</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> producer: Producer&lt;Any&gt; = StringProducer()</span><br><span class="line">    println(producer.produce())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>限制</strong>：不能用作输入参数。</li>
<li><strong>理解</strong>：需掌握协变概念。</li>
</ul></li>
</ul>
<h4 id="逆变in">9.4 逆变：<code>in</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>in</code> 限制类型只能作为参数。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>消费者模式。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器检查逆变规则。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnyConsumer</span> : <span class="type">Consumer</span>&lt;<span class="type">Any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">Any</span>)</span></span> = println(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> consumer: Consumer&lt;String&gt; = AnyConsumer()</span><br><span class="line">    consumer.consume(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>限制</strong>：不能用作返回值。</li>
<li><strong>复杂性</strong>：与协变配合需小心。</li>
</ul></li>
</ul>
<h4 id="通配符">9.5 通配符：<code>*</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>表示未知类型，类似 Java 的 <code>?</code>。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>类型无关操作。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为泛型上限 <code>Any?</code>。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList</span><span class="params">(list: <span class="type">List</span>&lt;*&gt;)</span></span> = println(list)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printList(listOf(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>))  <span class="comment">// [1, A]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>限制</strong>：无法访问具体类型方法。</li>
<li><strong>替代</strong>：可用具体类型替换。</li>
</ul></li>
</ul>
<hr />
<h3 id="空安全">10. 空安全</h3>
<h4 id="可空类型">10.1 可空类型：<code>?</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>在类型后加 <code>?</code> 表示可为 <code>null</code>。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>处理潜在的 <code>null</code> 值。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器强制类型检查。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str: String? = <span class="literal">null</span></span><br><span class="line">    println(str)  <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>过度使用</strong>：过多 <code>?</code> 增加空检查负担。</li>
<li><strong>初始化</strong>：尽量推迟到确定非空。</li>
</ul></li>
</ul>
<h4 id="安全调用.">10.2 安全调用：<code>?.</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>若对象为 <code>null</code>，返回
<code>null</code>，否则调用方法。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>避免空指针异常。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为条件跳转。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str: String? = <span class="literal">null</span></span><br><span class="line">    println(str?.length)  <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>链式调用</strong>：多级 <code>?.</code>
返回类型可能是嵌套可空。</li>
<li><strong>性能</strong>：频繁使用增加分支。</li>
</ul></li>
</ul>
<h4 id="elvis-操作符">10.3 Elvis 操作符：<code>?:</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>若左边为 <code>null</code>，返回右边值。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>提供默认值。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为条件表达式。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> length = str?.length ?: -<span class="number">1</span></span><br><span class="line">    println(length)  <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>类型一致</strong>：左右类型需匹配。</li>
<li><strong>副作用</strong>：右边避免复杂逻辑。</li>
</ul></li>
</ul>
<h4 id="非空断言">10.4 非空断言：<code>!!</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>强制解包，若为 <code>null</code> 抛异常。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>确信非空时使用。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为直接访问，若 <code>null</code> 抛
<code>NullPointerException</code>。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str: String? = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    println(str!!.length)  <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>风险</strong>：滥用导致运行时异常。</li>
<li><strong>替代</strong>：优先用 <code>?.</code> 或
<code>?:</code>。</li>
</ul></li>
</ul>
<hr />
<h3 id="注解">11. 注解</h3>
<h4 id="内置注解">11.1 内置注解</h4>
<p>Kotlin 提供了一系列内置注解，主要用于控制编译器行为、与 JVM
平台交互或增强代码语义。以下是所有内置注解的完整列表，涵盖标准库中定义的注解（基于
Kotlin 1.9 及之前版本）：</p>
<hr />
<h5 id="deprecated"><code>@Deprecated</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>标记代码元素（类、函数、属性等）为废弃状态。</li>
<li>参数：<code>message: String</code>（必填，废弃原因），<code>replaceWith: ReplaceWith</code>（可选，替代方案），<code>level: DeprecationLevel</code>（可选，废弃级别：<code>WARNING</code>
或 <code>ERROR</code>，默认 <code>WARNING</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>API 维护：提示用户停止使用旧 API。</li>
<li>代码迁移：引导开发者转向新实现。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器在编译时发出警告或错误（取决于
<code>level</code>），并在生成的 JVM 字节码中添加
<code>@java.lang.Deprecated</code>。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;Use newFunc instead&quot;</span>, ReplaceWith(<span class="string">&quot;newFunc()&quot;</span>), DeprecationLevel.WARNING)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">oldFunc</span><span class="params">()</span></span> = println(<span class="string">&quot;Old&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newFunc</span><span class="params">()</span></span> = println(<span class="string">&quot;New&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    oldFunc()  <span class="comment">// 编译器警告：&#x27;oldFunc&#x27; is deprecated</span></span><br><span class="line">    newFunc()  <span class="comment">// New</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>信息</strong>：<code>message</code>
应清晰说明废弃原因。</li>
<li><strong>替代方案</strong>：<code>ReplaceWith</code>
提供可直接替换的代码，提升迁移效率。</li>
<li><strong>级别</strong>：使用 <code>ERROR</code>
时调用处会编译失败，谨慎使用。</li>
</ul></li>
</ul>
<hr />
<h5 id="suppress"><code>@Suppress</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>抑制特定的编译器警告或错误。</li>
<li>参数：可变字符串数组（如
<code>"DEPRECATION"</code>），指定要抑制的警告类型。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>临时忽略无关警告（如使用废弃 API）。</li>
<li>清理代码时避免过多告警干扰。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器在分析代码时跳过指定警告的检查，不影响生成的字节码。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;Use newFunc instead&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">oldFunc</span><span class="params">()</span></span> = println(<span class="string">&quot;Old&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newFunc</span><span class="params">()</span></span> = println(<span class="string">&quot;New&quot;</span>)</span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    oldFunc()  <span class="comment">// 无警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>范围</strong>：尽量具体到最小作用域，避免隐藏重要问题。</li>
<li><strong>警告类型</strong>：需查阅文档确认有效的警告名称（如
<code>"UNUSED_VARIABLE"</code>）。</li>
</ul></li>
</ul>
<hr />
<h5 id="jvmoverloads"><code>@JvmOverloads</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>为带有默认参数的函数或构造函数生成 JVM 重载方法。</li>
<li>无参数，直接标注在函数或构造函数上。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>与 Java 互操作：使 Kotlin 默认参数对 Java 调用者可见。</li>
<li>简化 API：提供多种调用方式。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器为每个默认参数生成重载方法，JVM 字节码中表现为独立方法。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">(name: <span class="type">String</span> = <span class="string">&quot;Guest&quot;</span>, greeting: <span class="type">String</span> = <span class="string">&quot;Hello&quot;</span>)</span></span> = <span class="string">&quot;<span class="variable">$greeting</span>, <span class="variable">$name</span>!&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(greet())           <span class="comment">// Hello, Guest!</span></span><br><span class="line">    println(greet(<span class="string">&quot;Alice&quot;</span>))    <span class="comment">// Hello, Alice!</span></span><br><span class="line">    println(greet(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Hi&quot;</span>)) <span class="comment">// Hi, Bob!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>参数顺序</strong>：默认参数需连续靠后，否则生成不完整。</li>
<li><strong>性能</strong>：参数过多时增加字节码大小。</li>
<li><strong>平台限制</strong>：仅对 JVM 有效。</li>
</ul></li>
</ul>
<hr />
<h5 id="jvmstatic"><code>@JvmStatic</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>将伴生对象中的函数或属性标记为静态，生成 JVM 静态方法或字段。</li>
<li>应用于伴生对象成员。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>与 Java 互操作：使伴生对象成员可通过类名直接调用。</li>
<li>工具类设计：模拟 Java 静态方法。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器在类中生成静态方法，绕过伴生对象实例，直接映射到 JVM
静态调用。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> = println(<span class="string">&quot;Hello from static&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Utils.sayHello()  <span class="comment">// Kotlin 调用</span></span><br><span class="line">    <span class="comment">// Java: Utils.sayHello();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>适用范围</strong>：仅限伴生对象。</li>
<li><strong>冗余</strong>：非 Java 交互时无需使用。</li>
</ul></li>
</ul>
<hr />
<h5 id="jvmfield"><code>@JvmField</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>将属性暴露为 JVM 的公共字段，跳过 getter/setter。</li>
<li>应用于属性声明。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>与 Java 互操作：直接访问字段而非通过方法。</li>
<li>性能优化：避免访问器开销。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器生成 public 字段而非封装属性，移除 Kotlin 的属性封装。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">val</span> id = <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> d = Data()</span><br><span class="line">    println(d.id)  <span class="comment">// 42</span></span><br><span class="line">    <span class="comment">// Java: int value = new Data().id;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>封装性</strong>：丧失 getter/setter 控制。</li>
<li><strong>限制</strong>：不能与 <code>private</code>
或自定义访问器共用。</li>
</ul></li>
</ul>
<hr />
<h5 id="throws"><code>@Throws</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>指定函数可能抛出的异常，生成 JVM 的 <code>throws</code> 声明。</li>
<li>参数：异常类的 <code>KClass</code> 列表（如
<code>@Throws(IOException::class)</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>与 Java 互操作：告知 Java 调用者异常类型。</li>
<li>文档化：明确异常行为。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器在字节码中添加 <code>throws</code> 子句，与 Java
的异常声明一致。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException</span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">riskyOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> IOException(<span class="string">&quot;Something went wrong&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        riskyOperation()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        println(e.message)  <span class="comment">// Something went wrong</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>必要性</strong>：Kotlin 不强制异常声明，仅为 Java
兼容。</li>
<li><strong>类型</strong>：需使用 <code>::class</code> 指定。</li>
</ul></li>
</ul>
<hr />
<h5 id="jvmname"><code>@JvmName</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>指定函数或属性在 JVM 中的名称，避免命名冲突。</li>
<li>参数：字符串，表示 JVM 名称。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>解决签名冲突：如与 Java 方法名冲突。</li>
<li>美化 API：自定义 Java 可见名称。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器修改生成的 JVM 方法或字段名称。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmName(<span class="string">&quot;customGreet&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">()</span></span> = println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    greet()  <span class="comment">// Hello</span></span><br><span class="line">    <span class="comment">// Java: MyClass.customGreet();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>唯一性</strong>：新名称需避免冲突。</li>
<li><strong>范围</strong>：仅影响 JVM 签名。</li>
</ul></li>
</ul>
<hr />
<h5 id="jvmmultifileclass"><code>@JvmMultifileClass</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>将多个文件中的顶层函数合并为单个 JVM 类。</li>
<li>与 <code>@file:JvmName</code> 配合使用。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>模块化开发：将分散的顶层函数整合为一个类。</li>
<li>Java 互操作：统一访问入口。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器将多个文件中的函数合并到一个类文件中。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File1.kt</span></span><br><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;Utils&quot;</span>)</span><br><span class="line"><span class="meta">@file:JvmMultifileClass</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">util1</span><span class="params">()</span></span> = println(<span class="string">&quot;Util 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.kt</span></span><br><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;Utils&quot;</span>)</span><br><span class="line"><span class="meta">@file:JvmMultifileClass</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">util2</span><span class="params">()</span></span> = println(<span class="string">&quot;Util 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    util1()  <span class="comment">// Util 1</span></span><br><span class="line">    util2()  <span class="comment">// Util 2</span></span><br><span class="line">    <span class="comment">// Java: Utils.util1(); Utils.util2();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>配合使用</strong>：必须与 <code>@file:JvmName</code>
一起使用。</li>
<li><strong>一致性</strong>：所有文件需相同 <code>JvmName</code>。</li>
</ul></li>
</ul>
<hr />
<h5 id="synchronized"><code>@Synchronized</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>标记函数为同步，类似 Java 的 <code>synchronized</code> 方法。</li>
<li>应用于函数。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>多线程编程：确保线程安全。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器生成 JVM 的 <code>synchronized</code>
块，锁定函数所属对象。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> counter = Counter()</span><br><span class="line">    counter.increment()</span><br><span class="line">    println(counter.count)  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>性能</strong>：同步降低并发性，谨慎使用。</li>
<li><strong>范围</strong>：仅锁定当前实例。</li>
</ul></li>
</ul>
<hr />
<h5 id="volatile"><code>@Volatile</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>标记属性为 volatile，确保线程间可见性。</li>
<li>应用于属性。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>多线程编程：避免线程缓存问题。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>映射到 JVM 的 <code>volatile</code> 修饰符，保证内存一致性。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ts = ThreadSafe()</span><br><span class="line">    ts.flag = <span class="literal">true</span></span><br><span class="line">    println(ts.flag)  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>限制</strong>：仅适用于
<code>var</code>，不可用于局部变量。</li>
<li><strong>开销</strong>：增加内存屏障，影响性能。</li>
</ul></li>
</ul>
<hr />
<h5 id="strictfp"><code>@Strictfp</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>标记函数或类使用严格浮点运算，遵循 IEEE 754 标准。</li>
<li>应用于函数或类。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>高精度浮点计算：确保跨平台一致性。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器生成 JVM 的 <code>strictfp</code> 修饰符，禁用浮点优化。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Strictfp</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(x: <span class="type">Double</span>)</span></span>: <span class="built_in">Double</span> = x * <span class="number">2.0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(compute(<span class="number">3.14</span>))  <span class="comment">// 6.28</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>使用场景</strong>：极少使用，除非明确要求一致性。</li>
<li><strong>兼容性</strong>：仅 JVM 有效。</li>
</ul></li>
</ul>
<hr />
<h5 id="publishedapi"><code>@PublishedApi</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>标记 <code>internal</code> 函数或属性为公开
API，可被内联函数间接访问。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>库开发：在模块内隐藏实现细节，同时允许内联函数使用。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器将 <code>internal</code> 元素提升为
<code>public</code>，但仍限制模块外直接访问。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">internalFunc</span><span class="params">()</span></span> = <span class="string">&quot;Internal&quot;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">publicFunc</span><span class="params">()</span></span> = internalFunc()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(publicFunc())  <span class="comment">// Internal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>限制</strong>：仅与 <code>inline</code> 配合。</li>
<li><strong>封装性</strong>：谨慎使用，避免泄露实现。</li>
</ul></li>
</ul>
<hr />
<h5 id="sincekotlin"><code>@SinceKotlin</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>标记代码元素自某个 Kotlin 版本起可用。</li>
<li>参数：版本号字符串（如 <code>"1.3"</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>API 文档化：提示最低支持版本。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>仅用于元数据记录，不影响编译或运行。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.3&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">modernFeature</span><span class="params">()</span></span> = println(<span class="string">&quot;Available since 1.3&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    modernFeature()  <span class="comment">// Available since 1.3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>版本检查</strong>：仅提示，不强制执行。</li>
<li><strong>文档</strong>：建议与版本控制结合。</li>
</ul></li>
</ul>
<hr />
<h5 id="optin"><code>@OptIn</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>声明使用实验性或不稳定的 API。</li>
<li>参数：注解类的 <code>KClass</code>（如
<code>@OptIn(ExperimentalTime::class)</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>使用实验性特性：如协程、时间 API。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器检查是否标记，未标记时发出警告或错误。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.time.ExperimentalTime</span><br><span class="line"><span class="keyword">import</span> kotlin.time.measureTime</span><br><span class="line"><span class="meta">@OptIn(ExperimentalTime::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">measure</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> duration = measureTime &#123; Thread.sleep(<span class="number">100</span>) &#125;</span><br><span class="line">    println(duration)  <span class="comment">// ~100ms</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    measure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>风险</strong>：实验性 API 可能变更。</li>
<li><strong>范围</strong>：可用于文件或模块级别。</li>
</ul></li>
</ul>
<hr />
<h5 id="filejvmname"><code>@file:JvmName</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>指定文件编译后在 JVM 中的类名。</li>
<li>参数：字符串，表示类名。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>顶层函数命名：避免默认的 <code>FileKt</code> 类名。</li>
<li>与 <code>@JvmMultifileClass</code> 配合。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器修改生成类的名称。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;MyUtils&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">util</span><span class="params">()</span></span> = println(<span class="string">&quot;Utility&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    util()  <span class="comment">// Utility</span></span><br><span class="line">    <span class="comment">// Java: MyUtils.util();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>冲突</strong>：确保名称唯一。</li>
<li><strong>范围</strong>：仅文件级有效。</li>
</ul></li>
</ul>
<hr />
<h5 id="filesuppress"><code>@file:Suppress</code></h5>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>在文件级别抑制警告。</li>
<li>参数：警告类型字符串数组。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>文件级警告清理。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>同 <code>@Suppress</code>，作用于整个文件。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@file:Suppress</span>(<span class="string">&quot;UNUSED_VARIABLE&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> unused = <span class="number">42</span>  <span class="comment">// 无警告</span></span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>范围</strong>：影响整个文件，谨慎使用。</li>
<li><strong>替代</strong>：局部 <code>@Suppress</code> 更精准。</li>
</ul></li>
</ul>
<hr />
<h5 id="完整示例整合">完整示例整合</h5>
<p>以下是一个综合示例，展示部分内置注解的协同使用： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;Demo&quot;</span>)</span><br><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;Use newApi instead&quot;</span>, ReplaceWith(<span class="string">&quot;newApi()&quot;</span>))</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">oldApi</span><span class="params">()</span></span> = println(<span class="string">&quot;Old API&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newApi</span><span class="params">(message: <span class="type">String</span> = <span class="string">&quot;New&quot;</span>, count: <span class="type">Int</span> = <span class="number">1</span>)</span></span> = println(<span class="string">&quot;<span class="variable">$message</span> repeated <span class="variable">$count</span> times&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">staticMethod</span><span class="params">()</span></span> = println(<span class="string">&quot;Static&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">syncMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalTime::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">measureTime</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> duration = kotlin.time.measureTime &#123; Thread.sleep(<span class="number">100</span>) &#125;</span><br><span class="line">    println(<span class="string">&quot;Took <span class="variable">$duration</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    oldApi()          <span class="comment">// Old API (警告被抑制)</span></span><br><span class="line">    newApi()          <span class="comment">// New repeated 1 times</span></span><br><span class="line">    newApi(<span class="string">&quot;Hi&quot;</span>)      <span class="comment">// Hi repeated 1 times</span></span><br><span class="line">    Example.staticMethod()  <span class="comment">// Static</span></span><br><span class="line">    measureTime()     <span class="comment">// Took ~100ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="自定义注解annotation">11.2
自定义注解：<code>annotation</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>annotation class</code> 定义。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>元编程、框架开发。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为 JVM 注解。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">MyAnnotation</span>(<span class="keyword">val</span> priority: <span class="built_in">Int</span>)</span><br><span class="line"><span class="meta">@MyAnnotation(1)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">annotated</span><span class="params">()</span></span> = println(<span class="string">&quot;Annotated&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    annotated()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>运行时</strong>：需加 <code>@Retention</code>
指定保留级别。</li>
<li><strong>参数</strong>：仅支持基本类型和枚举。</li>
</ul></li>
</ul>
<hr />
<h2 id="二现代-kotlin-新特性">二、现代 Kotlin 新特性</h2>
<h3 id="kotlin-1.0">1. Kotlin 1.0+</h3>
<h4 id="lambda-表达式-x---x-2">1.1 Lambda
表达式：<code>{ x -&gt; x * 2 }</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>格式：<code>{ params -&gt; expression }</code>，简化为
<code>{ it }</code>（单参数）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>集合操作、事件处理。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为匿名类或内联代码（若加 <code>inline</code>）。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> doubled = list.map &#123; x -&gt; x * <span class="number">2</span> &#125;</span><br><span class="line">    println(doubled)  <span class="comment">// [2, 4, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>性能</strong>：未内联时生成对象。</li>
<li><strong>可读性</strong>：复杂逻辑不适合。</li>
</ul></li>
</ul>
<h4 id="扩展函数">1.2 扩展函数</h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>在类外定义方法，格式：<code>fun ReceiverType.name() { ... }</code>。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>扩展标准库、工具函数。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为静态方法，接收者作为参数。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">addExclamation</span><span class="params">()</span></span> = <span class="string">&quot;<span class="variable">$this</span>!&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>.addExclamation())  <span class="comment">// Hello!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>冲突</strong>：与类方法冲突时优先类内方法。</li>
<li><strong>访问</strong>：不能访问私有成员。</li>
</ul></li>
</ul>
<h4 id="中缀函数infix">1.3 中缀函数：<code>infix</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>infix</code> 修饰，允许中缀调用。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>提高代码可读性。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为普通方法调用。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">plus</span><span class="params">(x: <span class="type">Int</span>)</span></span> = <span class="keyword">this</span> + x</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="number">5</span> plus <span class="number">3</span>)  <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>限制</strong>：需单一参数。</li>
<li><strong>滥用</strong>：影响代码一致性。</li>
</ul></li>
</ul>
<h4 id="运算符重载operator">1.4 运算符重载：<code>operator</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>operator</code> 定义运算符行为。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>自定义数学对象。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为方法调用。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span> = Point(x + other.x, y + other.y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    println(p1 + p2)  <span class="comment">// Point(x=4, y=6)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>语义</strong>：保持运算符直观含义。</li>
<li><strong>一致性</strong>：与标准库一致。</li>
</ul></li>
</ul>
<hr />
<h3 id="kotlin-1.1">2. Kotlin 1.1</h3>
<h4 id="协程suspend-launch">2.1 协程：<code>suspend</code>,
<code>launch</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>suspend</code>：标记挂起函数。</li>
<li><code>launch</code>：启动协程。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>异步编程、网络请求。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>基于状态机和续体（continuation），编译器生成回调逻辑。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>依赖</strong>：需引入 <code>kotlinx-coroutines</code>。</li>
<li><strong>作用域</strong>：需在协程作用域内调用。</li>
</ul></li>
</ul>
<hr />
<h3 id="kotlin-1.3">3. Kotlin 1.3</h3>
<h4 id="内联类inline-class">3.1 内联类：<code>inline class</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>inline class</code> 定义单值包装类。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>类型安全、性能优化。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译时展开为原始类型。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> value: String)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = Name(<span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">    println(name.value)  <span class="comment">// Kotlin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>限制</strong>：仅限单一属性。</li>
<li><strong>兼容性</strong>：早期版本不支持。</li>
</ul></li>
</ul>
<h4 id="无符号整数uint-ulong">3.2 无符号整数：<code>UInt</code>,
<code>ULong</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>UInt</code>：32 位无符号整数，<code>ULong</code>：64 位，加
<code>u</code> 或 <code>U</code> 后缀。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>正整数计算。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为有符号整数，运行时模拟无符号行为。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> uint: UInt = 42u</span><br><span class="line">    <span class="keyword">val</span> ulong: ULong = 123UL</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$uint</span>, <span class="variable">$ulong</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>运算</strong>：需注意类型匹配。</li>
<li><strong>范围</strong>：超出需转换。</li>
</ul></li>
</ul>
<hr />
<h3 id="kotlin-1.4">4. Kotlin 1.4</h3>
<h4 id="sam-转换改进">4.1 SAM 转换改进</h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>单方法接口支持 Lambda 转换。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>简化 Java 接口调用。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为接口实现。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> action = Action &#123; println(<span class="string">&quot;Run&quot;</span>) &#125;</span><br><span class="line">    action.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>单一方法</strong>：仅限单抽象方法。</li>
<li><strong>明确性</strong>：避免歧义。</li>
</ul></li>
</ul>
<h4 id="尾随逗号">4.2 尾随逗号</h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>参数列表、集合末尾允许逗号。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>代码格式化。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>语法糖，无运行时影响。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>兼容性</strong>：旧版本不支持。</li>
<li><strong>一致性</strong>：团队需统一风格。</li>
</ul></li>
</ul>
<hr />
<h3 id="kotlin-1.5">5. Kotlin 1.5</h3>
<h4 id="密封接口sealed-interface">5.1
密封接口：<code>sealed interface</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>sealed interface</code> 限制实现类。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>模式匹配。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器检查实现。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">Expr</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Num</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) : Expr</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> expr: Expr = Num(<span class="number">42</span>)</span><br><span class="line">    println((expr <span class="keyword">as</span> Num).value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>范围</strong>：实现类需在同一模块。</li>
<li><strong>版本</strong>：需 1.5+。</li>
</ul></li>
</ul>
<h4 id="内联值类value-class">5.2 内联值类：<code>value class</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>value class</code> 定义单值类。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>类型安全。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译时展开。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">value <span class="keyword">class</span> <span class="title class_">Password</span>(<span class="keyword">val</span> value: String)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pwd = Password(<span class="string">&quot;secret&quot;</span>)</span><br><span class="line">    println(pwd.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>限制</strong>：单一属性。</li>
<li><strong>兼容性</strong>：需 1.5+。</li>
</ul></li>
</ul>
<hr />
<h3 id="kotlin-1.6">6. Kotlin 1.6</h3>
<h4 id="挂起函数类型suspend---unit">6.1
挂起函数类型：<code>suspend () -&gt; Unit</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>定义挂起函数类型。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>协程回调。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为续体类型。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> suspendFunc: <span class="keyword">suspend</span> () -&gt; <span class="built_in">Unit</span> = &#123; println(<span class="string">&quot;Suspended&quot;</span>) &#125;</span><br><span class="line">    <span class="comment">// 需要协程作用域调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>调用</strong>：需协程作用域。</li>
<li><strong>版本</strong>：需 1.6+。</li>
</ul></li>
</ul>
<hr />
<h3 id="kotlin-1.8">7. Kotlin 1.8</h3>
<h4 id="上下文接收者context">7.1 上下文接收者：<code>context</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>context(Type)</code> 指定接收者。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>DSL 设计。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为隐式参数。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">context(String)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printWithContext</span><span class="params">()</span></span> = println(<span class="keyword">this</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    with(<span class="string">&quot;Hello&quot;</span>) &#123; printWithContext() &#125;  <span class="comment">// Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>实验性</strong>：需启用特性。</li>
<li><strong>复杂度</strong>：增加理解难度。</li>
</ul></li>
</ul>
<hr />
<h3 id="kotlin-1.9">8. Kotlin 1.9+</h3>
<h4 id="多平台改进">8.1 多平台改进</h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>expect</code> 和 <code>actual</code>
定义跨平台代码。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>多平台开发。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译器生成平台特定代码。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">expect</span> <span class="keyword">class</span> <span class="title class_">Platform</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">name</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">actual</span> <span class="keyword">class</span> <span class="title class_">Platform</span> <span class="title">actual</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="title">name</span><span class="params">()</span></span> = <span class="string">&quot;JVM&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(Platform().name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>配置</strong>：需多平台项目设置。</li>
<li><strong>一致性</strong>：实现需匹配。</li>
</ul></li>
</ul>
<h4 id="k2-编译器特性">8.2 K2 编译器特性</h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>K2 是新编译器，提升性能。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>更快编译、更严格检查。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>重写编译流程。</li>
</ul></li>
<li><strong>示例代码</strong>：
<ul>
<li>无特定语法，仅编译器特性。</li>
</ul></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>稳定性</strong>：仍在完善。</li>
<li><strong>启用</strong>：需配置。</li>
</ul></li>
</ul>
<hr />
<h2 id="三其他特性">三、其他特性</h2>
<h3 id="标准库扩展">1. 标准库扩展</h3>
<h4 id="集合list-set-map">1.1 集合：<code>List</code>, <code>Set</code>,
<code>Map</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>listOf()</code>：不可变列表。</li>
<li><code>setOf()</code>：不可变集合。</li>
<li><code>mapOf()</code>：不可变映射。</li>
<li>可变版本：<code>mutableListOf()</code>, <code>mutableSetOf()</code>,
<code>mutableMapOf()</code>。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>数据存储、查询。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>基于 Java 集合类（如 <code>ArrayList</code>, <code>HashSet</code>,
<code>HashMap</code>）。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span> = setOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)  <span class="comment">// [1, 2]</span></span><br><span class="line">    <span class="keyword">val</span> map = mapOf(<span class="string">&quot;a&quot;</span> to <span class="number">1</span>, <span class="string">&quot;b&quot;</span> to <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> mutableList = mutableListOf(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    mutableList.add(<span class="number">3</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$list</span>, <span class="variable">$set</span>, <span class="variable">$map</span>, <span class="variable">$mutableList</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>不可变性</strong>：<code>listOf()</code> 不支持修改。</li>
<li><strong>性能</strong>：选择合适集合类型。</li>
</ul></li>
</ul>
<h4 id="字符串string-stringbuilder">1.2 字符串：<code>String</code>,
<code>StringBuilder</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li><code>String</code>：不可变字符串。</li>
<li><code>StringBuilder</code>：可变字符串缓冲区。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>文本处理、动态拼接。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li><code>String</code> 映射到 <code>java.lang.String</code>。</li>
<li><code>StringBuilder</code> 使用
<code>java.lang.StringBuilder</code>。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder().append(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot; World&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$str</span>, <span class="subst">$&#123;sb.toString()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>性能</strong>：大量拼接用 <code>StringBuilder</code>。</li>
<li><strong>不可变性</strong>：<code>String</code> 修改生成新对象。</li>
</ul></li>
</ul>
<h4 id="iojava.io">1.3 IO：<code>java.io</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 Java 的 IO 类（如 <code>File</code>）。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>文件读写。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>直接调用 Java IO 库。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    File(<span class="string">&quot;test.txt&quot;</span>).writeText(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    println(File(<span class="string">&quot;test.txt&quot;</span>).readText())  <span class="comment">// Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>异常</strong>：需处理 IO 异常。</li>
<li><strong>资源</strong>：确保关闭流。</li>
</ul></li>
</ul>
<h4 id="并发kotlin.coroutines">1.4
并发：<code>kotlin.coroutines</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>kotlinx.coroutines</code> 提供协程支持。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>异步任务、并发处理。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>基于状态机和续体。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>依赖</strong>：需添加库。</li>
<li><strong>取消</strong>：注意协程生命周期。</li>
</ul></li>
</ul>
<hr />
<h3 id="反射与运行时">2. 反射与运行时</h3>
<h4 id="类引用class">2.1 类引用：<code>::class</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>获取类的 <code>KClass</code> 对象。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>反射、元编程。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>返回运行时类引用。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ref = String::<span class="keyword">class</span></span><br><span class="line">    <span class="title class_">println</span>(ref.simpleName)  <span class="comment">// String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>性能</strong>：反射开销大。</li>
<li><strong>类型</strong>：区分 <code>::class</code> 和
<code>::class.java</code>。</li>
</ul></li>
</ul>
<h4 id="函数引用function">2.2 函数引用：<code>::function</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>获取函数引用。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>函数式编程。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为函数对象。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ref = ::hello</span><br><span class="line">    ref()  <span class="comment">// Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>适用性</strong>：仅限顶层或成员函数。</li>
<li><strong>性能</strong>：避免频繁创建。</li>
</ul></li>
</ul>
<h4 id="反射库kotlin.reflect">2.3
反射库：<code>kotlin.reflect</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>kotlin.reflect</code> 访问类、属性等。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>动态检查。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>基于 JVM 反射。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.full.memberProperties</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> props = Person::<span class="keyword">class</span>.memberProperties</span><br><span class="line">    println(props.map &#123; it.name &#125;)  <span class="comment">// [name]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>依赖</strong>：需添加 <code>kotlin-reflect</code>。</li>
<li><strong>开销</strong>：避免在性能敏感处使用。</li>
</ul></li>
</ul>
<hr />
<h3 id="委托">3. 委托</h3>
<h4 id="属性委托by-lazy-by-delegates">3.1
属性委托：<code>by lazy</code>, <code>by Delegates</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>by</code> 将属性委托给代理对象。</li>
<li><code>lazy</code>：延迟初始化，线程安全。</li>
<li><code>Delegates.observable</code>：属性变化监听。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li><code>lazy</code>：延迟加载资源。</li>
<li><code>observable</code>：状态监听（如 UI 更新）。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li><code>lazy</code>：编译为 <code>Lazy</code>
对象，首次访问时初始化。</li>
<li><code>observable</code>：使用 <code>ObservableProperty</code>
包装，调用回调。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// lazy</span></span><br><span class="line">    <span class="keyword">val</span> lazyVal: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">&quot;Computed&quot;</span>)</span><br><span class="line">        <span class="string">&quot;Lazy&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(lazyVal)  <span class="comment">// Computed, Lazy</span></span><br><span class="line">    println(lazyVal)  <span class="comment">// Lazy（不再计算）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// observable</span></span><br><span class="line">    <span class="keyword">var</span> obsVal: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;Init&quot;</span>) &#123; property, old, new -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;property.name&#125;</span>: <span class="variable">$old</span> -&gt; <span class="variable">$new</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    obsVal = <span class="string">&quot;New&quot;</span>  <span class="comment">// obsVal: Init -&gt; New</span></span><br><span class="line">    obsVal = <span class="string">&quot;Final&quot;</span>  <span class="comment">// obsVal: New -&gt; Final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong><code>lazy</code>
线程安全</strong>：默认同步，需明确模式（如
<code>LazyThreadSafetyMode.NONE</code>）。</li>
<li><strong><code>observable</code>
开销</strong>：每次赋值触发回调，注意性能。</li>
<li><strong>初始化</strong>：<code>lazy</code> 不可重新赋值。</li>
</ul></li>
</ul>
<h4 id="类委托by">3.2 类委托：<code>by</code></h4>
<ul>
<li><strong>语法说明</strong>：
<ul>
<li>使用 <code>by</code> 将接口实现委托给对象。</li>
</ul></li>
<li><strong>应用场景</strong>：
<ul>
<li>组合优于继承、代理模式。</li>
</ul></li>
<li><strong>底层原理</strong>：
<ul>
<li>编译为代理调用。</li>
</ul></li>
<li><strong>示例代码</strong>： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrinterImpl</span> : <span class="type">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> = println(<span class="string">&quot;Printing&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delegator</span>(printer: Printer) : Printer <span class="keyword">by</span> printer</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> delegator = Delegator(PrinterImpl())</span><br><span class="line">    delegator.print()  <span class="comment">// Printing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>：
<ul>
<li><strong>覆盖</strong>：委托后仍可重写方法。</li>
<li><strong>依赖</strong>：确保委托对象可靠。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>ExoPlayer 中的 Timeline、Period 和 Window</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/ExoPlayer/ExoPlayer-%E4%B8%AD%E7%9A%84-Timeline%E3%80%81Period-%E5%92%8C-Window.html</url>
    <content><![CDATA[<p>ExoPlayer 的 <code>Timeline</code>、<code>Timeline.Period</code> 和
<code>Timeline.Window</code>
是其核心组件，用于描述媒体内容的结构和时间信息，特别是在处理直播、点播和复杂播放列表（如多段内容或动态窗口）时。这些类共同定义了媒体的时间轴（Timeline），帮助
ExoPlayer 管理播放位置、导航和内容切换。</p>
<hr />
<h1 id="概述">1. 概述</h1>
<p>ExoPlayer 的 <code>Timeline</code>
系统设计用于抽象化媒体内容的组织方式，无论是点播视频、直播流还是多内容播放列表。<code>Timeline</code>
提供了一个统一的方式来描述内容的时间范围、结构和元数据，而
<code>Timeline.Period</code> 和 <code>Timeline.Window</code>
分别是其更细粒度的子结构。</p>
<ul>
<li><strong><code>Timeline</code></strong>：表示整个媒体内容的全局时间轴，包含一个或多个窗口（<code>Window</code>）和周期（<code>Period</code>）。</li>
<li><strong><code>Timeline.Window</code></strong>：表示时间轴上的一个逻辑窗口，通常对应一个播放内容的持续时间段（如直播流的当前可用窗口或点播视频的整个时长）。</li>
<li><strong><code>Timeline.Period</code></strong>：表示窗口内的更小时间段，通常对应内容的逻辑分段（如
DASH 的周期或 HLS 的片段组）。</li>
</ul>
<h2 id="timelines-for-various-use-cases">Timelines for various use
cases</h2>
<p>Single media file or on-demand stream</p>
<p><img
src="https://developer.android.com/static/images/reference/androidx/media3/common/timeline-single-file.svg" /></p>
<p>Playlist of media files or on-demand streams</p>
<p><img
src="https://developer.android.com/static/images/reference/androidx/media3/common/timeline-playlist.svg" /></p>
<p>Live stream with limited availability</p>
<p><img
src="https://developer.android.com/static/images/reference/androidx/media3/common/timeline-live-limited.svg" /></p>
<p>Live stream with indefinite availability</p>
<p><img
src="https://developer.android.com/static/images/reference/androidx/media3/common/timeline-live-indefinite.svg" /></p>
<p>Live stream with multiple periods</p>
<p><img
src="https://developer.android.com/static/images/reference/androidx/media3/common/timeline-live-multi-period.svg" /></p>
<p>On-demand stream followed by live stream</p>
<p><img
src="https://developer.android.com/static/images/reference/androidx/media3/common/timeline-advanced.svg" /></p>
<p>On-demand stream with mid-roll ads</p>
<p><img
src="https://developer.android.com/static/images/reference/androidx/media3/common/timeline-single-file-midrolls.svg" /></p>
<p>The figure below shows some of the information defined by a period,
as well as how this information relates to a corresponding
<code>Window</code> in the timeline.</p>
<p><img
src="https://developer.android.com/static/images/reference/androidx/media3/common/timeline-window.svg" /></p>
<p>这些类在 ExoPlayer 中广泛用于： - 确定当前播放位置和内容边界。 -
支持直播流的滑动窗口（动态更新）。 -
管理多内容播放列表（如广告插入或拼接视频）。 - 处理时间相关逻辑。</p>
<hr />
<h1 id="详细讲解">2. 详细讲解</h1>
<h2 id="timeline">2.1 <code>Timeline</code></h2>
<ul>
<li><strong>定义</strong>：
<ul>
<li><code>Timeline</code> 是 ExoPlayer
的抽象基类，表示媒体内容的整体时间轴结构。</li>
<li>它包含一组窗口（<code>Window</code>）和周期（<code>Period</code>），每个窗口可能包含一个或多个周期。</li>
<li><code>Timeline</code>
可以是静态的（如点播视频，固定时长）或动态的（如直播流，窗口随时间滑动）。</li>
</ul></li>
<li><strong>主要方法</strong>：
<ul>
<li><code>getWindowCount()</code>：返回时间轴中的窗口数量。</li>
<li><code>getWindow(int windowIndex, Timeline.Window window)</code>：获取指定索引的窗口信息，填充到提供的
<code>Timeline.Window</code> 对象。</li>
<li><code>getPeriodCount()</code>：返回时间轴中的周期数量。</li>
<li><code>getPeriod(int periodIndex, Timeline.Period period)</code>：获取指定索引的周期信息。</li>
<li><code>getLastWindowIndex(boolean shuffleModeEnabled)</code>：返回最后一个窗口的索引（在直播中通常是当前可用窗口）。</li>
<li><code>getIndexOfPeriod(Object uid)</code>：根据周期的唯一 ID
查找其索引。</li>
</ul></li>
<li><strong>作用</strong>：
<ul>
<li>提供媒体内容的全局视图，描述窗口和周期的组织方式。</li>
<li>支持导航（如跳转到特定窗口或周期）。</li>
<li>在直播场景中，<code>Timeline</code>
会动态更新以反映滑动窗口的变化。</li>
</ul></li>
<li><strong>典型场景</strong>：
<ul>
<li>点播：一个 <code>Timeline</code>
包含一个窗口（整个视频）和一个或多个周期（章节或广告）。</li>
<li>直播：一个 <code>Timeline</code>
包含一个动态窗口（当前可用的直播内容）和多个周期（流的分段）。</li>
<li>播放列表：一个 <code>Timeline</code>
包含多个窗口（每个视频）和对应的周期。</li>
</ul></li>
<li><strong>代码示例</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Timeline</span> <span class="variable">timeline</span> <span class="operator">=</span> player.getCurrentTimeline();</span><br><span class="line"><span class="keyword">if</span> (!timeline.isEmpty()) &#123;</span><br><span class="line">    Timeline.<span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timeline</span>.Window();</span><br><span class="line">    timeline.getWindow(timeline.getLastWindowIndex(<span class="literal">false</span>), window);</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;Window duration: &quot;</span> + window.getDurationMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="timeline.window">2.2 <code>Timeline.Window</code></h2>
<ul>
<li><strong>定义</strong>：
<ul>
<li><code>Timeline.Window</code>
表示时间轴上的一个逻辑时间窗口，通常对应一个连续的播放内容段。</li>
<li>每个窗口有自己的时间范围（开始时间、持续时间）和元数据（如是否动态、是否可寻址）。</li>
</ul></li>
<li><strong>关键字段</strong>：
<ul>
<li><code>long presentationStartTimeMs</code>：窗口内容的“呈现”开始时间（以毫秒为单位），通常是内容的逻辑开始时间（例如，直播流的节目开始时间）。如果未知，设为
<code>C.TIME_UNSET</code>。</li>
<li><code>long windowStartTimeMs</code>：窗口在时间轴上的实际开始时间（以毫秒为单位），通常用于直播流的时间计算。如果未知，设为
<code>C.TIME_UNSET</code>。</li>
<li><code>long durationUs</code>：窗口的持续时间（以微秒为单位）。如果是直播流，可能是当前窗口的可用时长。</li>
<li><code>boolean isDynamic</code>：指示窗口是否动态（即内容可能随时间更新，如直播流的滑动窗口）。</li>
<li><code>boolean isSeekable</code>：指示窗口是否支持寻址（seek），通常点播为
<code>true</code>，直播可能为 <code>false</code>。</li>
<li><code>long defaultPositionUs</code>：窗口的默认播放起始位置（以微秒为单位），用于初始化播放。</li>
</ul></li>
<li><strong>作用</strong>：
<ul>
<li>描述媒体内容的宏观时间范围（如直播流的当前窗口或点播视频的总时长）。</li>
<li>提供时间基准，用于计算播放位置（如你的
<code>currentPositionMs</code>）。</li>
<li>支持直播流的动态更新（<code>isDynamic = true</code>
时，窗口内容随时间变化）。</li>
</ul></li>
<li><strong>典型场景</strong>：
<ul>
<li>直播：窗口表示当前可用的直播内容（滑动窗口），<code>windowStartTimeMs</code>
和 <code>durationUs</code> 定义其时间范围。</li>
<li>点播：窗口表示整个视频，<code>durationUs</code> 是视频总时长。</li>
<li>广告：窗口可能表示主内容或广告段。</li>
</ul></li>
<li><strong>代码示例</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Timeline.<span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timeline</span>.Window();</span><br><span class="line">timeline.getWindow(timeline.getLastWindowIndex(<span class="literal">false</span>), window);</span><br><span class="line"><span class="keyword">if</span> (window.isDynamic) &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;Live window, duration: &quot;</span> + C.usToMs(window.durationUs) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="timeline.period">2.3 <code>Timeline.Period</code></h2>
<ul>
<li><strong>定义</strong>：
<ul>
<li><code>Timeline.Period</code>
表示窗口内的一个逻辑分段，通常对应媒体内容的子部分（如 DASH 的一个
Period 或 HLS 的一个片段组）。</li>
<li>周期是窗口的更细粒度划分，可能包含多个媒体片段（chunk）。</li>
</ul></li>
<li><strong>关键字段</strong>：
<ul>
<li><code>Object id</code>：周期的唯一标识符，用于区分不同的周期。</li>
<li><code>long durationUs</code>：周期的持续时间（以微秒为单位）。如果未知，设为
<code>C.TIME_UNSET</code>。</li>
<li><code>long positionInWindowUs</code>：周期相对于窗口开始的偏移量（以微秒为单位）。</li>
<li><code>int windowIndex</code>：周期所属的窗口索引。</li>
<li><code>boolean isAd</code>：指示周期是否为广告内容。</li>
</ul></li>
<li><strong>作用</strong>：
<ul>
<li>描述窗口内的内容分段，允许 ExoPlayer 精确导航到特定周期。</li>
<li>提供周期级别的元数据（如广告标记或内容切换点）。</li>
<li>在直播场景中，周期通常对应流的分段，动态添加或移除。</li>
</ul></li>
<li><strong>典型场景</strong>：
<ul>
<li>直播：周期表示 HLS 或 DASH 流中的一个时间段（例如，10
秒的媒体片段）。</li>
<li>点播：周期可能表示视频的章节或广告插入点。</li>
<li>播放列表：每个窗口的子内容可能由多个周期组成。</li>
</ul></li>
<li><strong>代码示例</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Timeline.<span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timeline</span>.Period();</span><br><span class="line">timeline.getPeriod(timeline.getCurrentPeriodIndex(), period);</span><br><span class="line">Log.d(TAG, <span class="string">&quot;Period duration: &quot;</span> + C.usToMs(period.durationUs) + <span class="string">&quot;ms&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h1 id="关系与工作流程">3. 关系与工作流程</h1>
<p><code>Timeline</code>、<code>Timeline.Window</code> 和
<code>Timeline.Period</code> 的关系可以用以下结构表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Timeline</span><br><span class="line">├── Window 0</span><br><span class="line">│   ├── Period 0</span><br><span class="line">│   ├── Period 1</span><br><span class="line">│   └── ...</span><br><span class="line">├── Window 1</span><br><span class="line">│   ├── Period 0</span><br><span class="line">│   └── ...</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>层级关系</strong>：
<ul>
<li>一个 <code>Timeline</code> 包含多个 <code>Window</code>，每个
<code>Window</code> 包含一个或多个 <code>Period</code>。</li>
<li><code>Window</code>
定义宏观时间范围（如直播流的当前窗口），<code>Period</code>
定义窗口内的细粒度分段（如流的一个片段）。</li>
</ul></li>
<li><strong>时间映射</strong>：
<ul>
<li><code>Window</code> 的 <code>windowStartTimeMs</code> 和
<code>durationUs</code> 定义全局时间范围。</li>
<li><code>Period</code> 的 <code>positionInWindowUs</code>
表示其在窗口中的相对位置。</li>
<li>播放位置（<code>positionUs</code>）通常相对于某个周期，通过
<code>Period</code> 映射到窗口时间，再通过 <code>Window</code>
映射到全局时间。</li>
</ul></li>
<li><strong>动态更新</strong>：
<ul>
<li>在直播场景中，<code>Timeline</code>
是动态的（<code>isDynamic = true</code>），新窗口或周期会随时间添加，旧周期可能被移除（滑动窗口）。</li>
<li>ExoPlayer 通过 <code>Player.EventListener</code> 的
<code>onTimelineChanged</code> 事件通知 <code>Timeline</code>
更新。</li>
</ul></li>
<li><strong>工作流程</strong>：
<ol type="1">
<li>ExoPlayer 从 <code>MediaSource</code>（如
<code>DashMediaSource</code> 或 <code>HlsMediaSource</code>）加载
<code>Timeline</code>。</li>
<li><code>Timeline</code> 提供窗口和周期信息，ExoPlayer
使用它们确定播放位置（<code>player.getCurrentPosition()</code>）和内容边界。</li>
<li>直播流的 <code>Timeline</code>
定期更新，反映新的窗口或周期（例如，HLS 播放列表刷新）。</li>
<li>播放器通过 <code>Timeline</code> 导航内容（如
<code>seekTo(windowIndex, positionMs)</code>）。</li>
</ol></li>
</ul>
<hr />
<h1 id="典型用法与注意事项">4. 典型用法与注意事项</h1>
<h2 id="典型用法">4.1 典型用法</h2>
<ul>
<li><p><strong>获取当前播放位置</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Timeline</span> <span class="variable">timeline</span> <span class="operator">=</span> player.getCurrentTimeline();</span><br><span class="line">Timeline.<span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timeline</span>.Window();</span><br><span class="line">Timeline.<span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timeline</span>.Period();</span><br><span class="line">timeline.getWindow(player.getCurrentWindowIndex(), window);</span><br><span class="line">timeline.getPeriod(player.getCurrentPeriodIndex(), period);</span><br><span class="line"><span class="type">long</span> <span class="variable">positionMs</span> <span class="operator">=</span> player.getCurrentPosition();</span><br><span class="line">Log.d(TAG, <span class="string">&quot;Window: &quot;</span> + window.windowStartTimeMs + <span class="string">&quot;, Period: &quot;</span> + period.positionInWindowUs + <span class="string">&quot;, Position: &quot;</span> + positionMs);</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>处理直播滑动窗口</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">player.addListener(<span class="keyword">new</span> <span class="title class_">Player</span>.Listener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTimelineChanged</span><span class="params">(Timeline timeline, <span class="type">int</span> reason)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeline.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        Timeline.<span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timeline</span>.Window();</span><br><span class="line">        timeline.getWindow(timeline.getLastWindowIndex(<span class="literal">false</span>), window);</span><br><span class="line">        <span class="keyword">if</span> (window.isDynamic) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;Live window updated, duration: &quot;</span> + C.usToMs(window.durationUs));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>跳转到直播边缘</strong>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Timeline</span> <span class="variable">timeline</span> <span class="operator">=</span> player.getCurrentTimeline();</span><br><span class="line">Timeline.<span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timeline</span>.Window();</span><br><span class="line">timeline.getWindow(timeline.getLastWindowIndex(<span class="literal">false</span>), window);</span><br><span class="line">player.seekTo(window.windowIndex, window.getDefaultPositionUs());</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="注意事项">4.2 注意事项</h2>
<ul>
<li><strong>动态更新</strong>：
<ul>
<li>直播流的 <code>Timeline</code> 是动态的，需通过
<code>onTimelineChanged</code>
监听更新，避免使用过时的窗口或周期数据。</li>
</ul></li>
<li><strong>时间戳准确性</strong>：
<ul>
<li><code>windowStartTimeMs</code> 和
<code>presentationStartTimeMs</code> 依赖直播流的元数据（如 DASH MPD 或
HLS 播放列表），可能因流提供商错误导致不准确。</li>
<li>在你的代码中，负值 <code>currentLatencyMs</code>
可能与时间戳超前有关，需验证元数据。</li>
</ul></li>
<li><strong>周期与窗口映射</strong>：
<ul>
<li>确保 <code>periodPositionUsToWindowPositionMs</code>
正确处理周期切换，特别是在直播流中周期频繁更新时。</li>
</ul></li>
<li><strong>性能考虑</strong>：
<ul>
<li>频繁调用 <code>getWindow</code> 或 <code>getPeriod</code>
可能影响性能，建议缓存 <code>Timeline</code> 数据或在必要时更新。</li>
</ul></li>
<li><strong>错误处理</strong>：
<ul>
<li>检查 <code>C.TIME_UNSET</code>
的情况，确保代码对未知时间戳有回退逻辑（如你的代码中对
<code>presentationStartTimeMs</code> 和 <code>windowStartTimeMs</code>
的检查）。</li>
</ul></li>
</ul>
<hr />
<h1 id="总结">5. 总结</h1>
<ul>
<li><strong><code>Timeline</code></strong>：全局时间轴，管理窗口和周期，提供媒体内容的结构化视图。</li>
<li><strong><code>Timeline.Window</code></strong>：表示一个播放窗口，定义时间范围（<code>windowStartTimeMs</code>、<code>durationUs</code>）和动态性（<code>isDynamic</code>），在直播中表示滑动窗口。</li>
<li><strong><code>Timeline.Period</code></strong>：窗口内的细粒度分段，定义周期时间（<code>durationUs</code>）和位置（<code>positionInWindowUs</code>），用于精确导航。</li>
<li><strong>关系</strong>：<code>Timeline</code> 包含多个
<code>Window</code>，每个 <code>Window</code> 包含多个
<code>Period</code>，共同映射播放位置和时间。</li>
</ul>
<h1 id="参考链接">6. 参考链接</h1>
<p><a
href="https://developer.android.com/reference/androidx/media3/common/Timeline">Timeline</a></p>
<p><a
href="https://developer.android.com/reference/androidx/media3/common/Timeline.Window">Timeline.Window</a></p>
<p><a
href="https://developer.android.com/reference/androidx/media3/common/Timeline.Period">Timeline.Period</a></p>
]]></content>
      <categories>
        <category>音视频</category>
        <category>ExoPlayer</category>
      </categories>
  </entry>
  <entry>
    <title>ExoPlayer 二次开发的方向</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/ExoPlayer/ExoPlayer-%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%96%B9%E5%90%91.html</url>
    <content><![CDATA[<p>ExoPlayer 是 Google
官方推出的可扩展媒体播放器框架，它<strong>设计上就鼓励二次开发和模块化扩展</strong>，所以你问的这个问题非常有价值。如果你想基于
ExoPlayer 做二次开发或改进，可以从以下几个方向入手：</p>
<hr />
<h2 id="一览exoplayer-可二次开发的核心模块">✅ 一览：ExoPlayer
可二次开发的核心模块</h2>
<table>
<colgroup>
<col style="width: 61%" />
<col style="width: 17%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>可扩展组件</th>
<th>说明</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>自定义数据源（<code>DataSource</code>）</strong></td>
<td>改写数据读取方式</td>
<td>支持 P2P、加密流、离线缓存等</td>
</tr>
<tr class="even">
<td><strong>自定义解码器（<code>Renderer</code>）</strong></td>
<td>替换音视频渲染流程</td>
<td>插入 AI 降噪、滤镜、特效渲染</td>
</tr>
<tr class="odd">
<td><strong>自定义播放器控制器</strong></td>
<td>自定义 UI 控件与事件交互</td>
<td>全屏播放、倍速、手势控制</td>
</tr>
<tr class="even">
<td><strong>自定义缓存逻辑（<code>CacheDataSource</code>）</strong></td>
<td>控制缓存策略</td>
<td>预缓存、断点续播、自定义清理逻辑</td>
</tr>
<tr class="odd">
<td><strong>自定义 <code>MediaSource</code></strong></td>
<td>支持新的媒体协议</td>
<td>比如支持新的私有流、虚拟流合并</td>
</tr>
<tr class="even">
<td><strong>广告系统拓展（IMA SDK or 自定义）</strong></td>
<td>拓展广告播放能力</td>
<td>插播、悬浮广告、交互广告</td>
</tr>
<tr class="odd">
<td><strong>音频/视频处理（<code>AudioProcessor</code> /
<code>VideoProcessor</code>）</strong></td>
<td>音效处理、图像处理</td>
<td>EQ、滤镜、美颜、图像识别</td>
</tr>
<tr class="even">
<td><strong>自定义 <code>TrackSelector</code></strong></td>
<td>控制清晰度、音轨选择</td>
<td>限速、语言切换、自适应逻辑</td>
</tr>
<tr class="odd">
<td><strong>事件监听封装（<code>AnalyticsListener</code>,
<code>EventLogger</code>）</strong></td>
<td>数据采集、日志埋点</td>
<td>播放失败、卡顿、用户行为统计</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="开发者常做的二次开发方向top-8">🔧 开发者常做的二次开发方向（Top
8）</h2>
<h3 id="自定义播放-ui-控件">1. <strong>自定义播放 UI 控件</strong></h3>
<ul>
<li>替换 <code>PlayerControlView</code></li>
<li>加入：手势调节音量亮度、清晰度选择、弹幕按钮、投屏按钮</li>
<li>提供一套统一 UI 适配所有业务场景（短视频 / 长视频）</li>
</ul>
<hr />
<h3 id="自定义数据源p2pcdnhls-token加密">2.
<strong>自定义数据源（P2P/CDN/HLS Token/加密）</strong></h3>
<ul>
<li>自定义 <code>DataSource.Factory</code></li>
<li>实现 token 鉴权、签名 URL、私有协议</li>
<li>示例：播放私有加密 HLS 流时拦截并解密</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomDataSource</span>(...) : BaseDataSource(...) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(buffer: <span class="type">ByteArray</span>, offset: <span class="type">Int</span>, readLength: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encryptedData = upstream.read(buffer, offset, readLength)</span><br><span class="line">        decryptInPlace(buffer, offset, readLength)</span><br><span class="line">        <span class="keyword">return</span> readLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="自定义缓存策略预下载-离线播放">3. <strong>自定义缓存策略（预下载
/ 离线播放）</strong></h3>
<ul>
<li>使用 <code>SimpleCache</code>, <code>CacheDataSource</code>,
<code>CacheWriter</code></li>
<li>控制缓存文件大小/清理机制</li>
<li>离线缓存和播放历史进度结合</li>
</ul>
<hr />
<h3 id="自定义清晰度和码率选择逻辑">4.
<strong>自定义清晰度和码率选择逻辑</strong></h3>
<ul>
<li>通过 <code>TrackSelector</code> 手动控制质量</li>
<li>可根据网络变化、用户偏好动态调整</li>
</ul>
<hr />
<h3 id="多路流合并播放-多音轨切换">5. <strong>多路流合并播放 /
多音轨切换</strong></h3>
<ul>
<li>使用 <code>MergingMediaSource</code></li>
<li>比如：一个视频画面多个音轨切换（多语言）</li>
</ul>
<hr />
<h3 id="封装播放器为组件sdk">6.
<strong>封装播放器为组件/SDK</strong></h3>
<ul>
<li>用统一接口封装 <code>ExoPlayer</code> 实例，统一管理生命周期</li>
<li>加入内部状态管理、日志采集、配置注入等</li>
<li>SDK 接口屏蔽底层细节，便于业务方集成</li>
</ul>
<hr />
<h3 id="播放统计与日志采集analyticslistener">7.
<strong>播放统计与日志采集（AnalyticsListener）</strong></h3>
<ul>
<li>收集卡顿、seek、缓冲时间、播放失败等事件</li>
<li>自定义事件结构 + 上报逻辑</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">player.addAnalyticsListener(<span class="keyword">object</span> : AnalyticsListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPlaybackStateChanged</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        log(<span class="string">&quot;state changed: <span class="variable">$state</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="滤镜美颜视频处理opengl-自定义-renderer">8.
<strong>滤镜/美颜/视频处理（OpenGL + 自定义 Renderer）</strong></h3>
<ul>
<li>替换/扩展视频渲染流程，插入 OpenGL Filter 或 GPU 图像处理</li>
<li>用例：短视频 App 增加实时美颜、背景虚化等</li>
</ul>
<hr />
<h2 id="进阶拓展思路可结合-ffmpeg-等">📌 进阶拓展思路（可结合 FFmpeg
等）</h2>
<ul>
<li>ExoPlayer 不支持某种格式？→ 自定义 <code>Extractor</code> 或接
FFmpeg</li>
<li>想在播放前做一次流格式转换？→ 使用中间层 <code>MediaSource</code>
预处理</li>
<li>低延迟直播？→ 调整 <code>LoadControl</code>、buffer 配置、或优化
CDN</li>
</ul>
<hr />
<h2 id="总结">✅ 总结</h2>
<table>
<thead>
<tr class="header">
<th>类别</th>
<th>可改进点</th>
<th>用于</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>播放体验</td>
<td>UI、控制器、事件处理</td>
<td>个性化播放器</td>
</tr>
<tr class="even">
<td>网络/协议</td>
<td>数据源、MediaSource</td>
<td>支持私有协议、加密</td>
</tr>
<tr class="odd">
<td>音视频质量</td>
<td>TrackSelector、Renderer</td>
<td>清晰度、美颜</td>
</tr>
<tr class="even">
<td>日志采集</td>
<td>AnalyticsListener、事件封装</td>
<td>监控、埋点</td>
</tr>
<tr class="odd">
<td>播放稳定性</td>
<td>LoadControl、缓存逻辑</td>
<td>卡顿恢复、预加载</td>
</tr>
</tbody>
</table>
<hr />
<p>如果你有更具体的需求（比如做一个“加密视频播放器”、“支持局域网流”、“添加美颜”），我可以给你定制一套
ExoPlayer 改造方案，要不要？</p>
]]></content>
      <categories>
        <category>音视频</category>
        <category>ExoPlayer</category>
      </categories>
  </entry>
  <entry>
    <title>ExoPlayer 如何实现音画同步</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/ExoPlayer/ExoPlayer-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9F%B3%E7%94%BB%E5%90%8C%E6%AD%A5.html</url>
    <content><![CDATA[<p>在解释这个问题之前，先讲一下 ExoPlayer 中音频播放的三种输出模式。</p>
<p>第一种是PCM模式（普通播放模式）。这是最基本的播放模式，音频以PCM（脉冲编码调制）数据形式处理，可以通过音频处理器进行各种处理。在<code>DefaultAudioSink</code>中，这种模式被定义为<code>OUTPUT_MODE_PCM</code>：<code>DefaultAudioSink.java:474</code>。</p>
<p>第二种是直通模式（Passthrough
Mode），对于编码音频格式（如杜比数字、DTS），编码音频直接传递给兼容的音频硬件，无需解码。这种模式保留了环绕声系统的最高音频质量。在<code>DefaultAudioSink</code>中，这种模式被定义为<code>OUTPUT_MODE_PASSTHROUGH</code>：
<code>DefaultAudioSink.java:475</code>。</p>
<p>第三种是卸载模式（Offload
Mode），音频处理卸载到专用硬件，减少CPU使用和功耗，非常适合后台播放。在<code>DefaultAudioSink</code>中，这种模式被定义为<code>OUTPUT_MODE_OFFLOAD</code>：
<code>DefaultAudioSink.java:476</code>。</p>
<p>还有一种模式是隧道模式（Tunnel
Mode），它是一种特殊的播放方式，它使用AV同步标头来确保音视频同步。这不是一个独立的输出模式，而是一种在上述模式中可以启用的特性。在<code>DefaultAudioSink</code>中，我们可以看到隧道模式下使用AV同步标头的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">writeNonBlockingWithAvSync</span><span class="params">(</span></span><br><span class="line"><span class="params">      AudioTrack audioTrack, ByteBuffer buffer, <span class="type">int</span> size, <span class="type">long</span> presentationTimeUs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">      <span class="comment">// The underlying platform AudioTrack writes AV sync headers directly.</span></span><br><span class="line">      <span class="keyword">return</span> audioTrack.write(</span><br><span class="line">          buffer, size, AudioTrack.WRITE_NON_BLOCKING, presentationTimeUs * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avSyncHeader == <span class="literal">null</span>) &#123;</span><br><span class="line">      avSyncHeader = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">      avSyncHeader.order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">      avSyncHeader.putInt(<span class="number">0x55550001</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bytesUntilNextAvSync == <span class="number">0</span>) &#123;</span><br><span class="line">      avSyncHeader.putInt(<span class="number">4</span>, size);</span><br><span class="line">      avSyncHeader.putLong(<span class="number">8</span>, presentationTimeUs * <span class="number">1000</span>);</span><br><span class="line">      avSyncHeader.position(<span class="number">0</span>);</span><br><span class="line">      bytesUntilNextAvSync = size;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>DefaultAudioSink.java:1890-1907</code></p>
<p>系统会根据以下因素选择合适的模式：输入音频格式，设备硬件能力，应用程序配置，性能需求。这些模式共同构成了
ExoPlayer
灵活的音频处理架构，能够适应各种播放场景和设备能力。此外，还有其他一些特性如跳过静音、速度调整等，但这些是音频处理的功能，而不是基本的输出模式。</p>
<p>接下来讲音画同步。</p>
<p>ExoPlayer 使用音频轨道作为主时钟(master
clock)。<code>MediaCodecAudioRenderer</code>实现了<code>MediaClock</code>接口，负责提供准确的播放位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getPositionUs</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (getState() == STATE_STARTED) &#123;  </span><br><span class="line">        updateCurrentPosition();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> currentPositionUs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MediaCodecAudioRenderer.java:767-773</code></p>
<p>播放位置通过<code>AudioSink</code>的<code>getCurrentPositionUs</code>方法获取，这是同步机制的基础：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateCurrentPosition</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">long</span> <span class="variable">newCurrentPositionUs</span> <span class="operator">=</span> audioSink.getCurrentPositionUs(isEnded());  </span><br><span class="line">    <span class="keyword">if</span> (newCurrentPositionUs != AudioSink.CURRENT_POSITION_NOT_SET) &#123;  </span><br><span class="line">        currentPositionUs =  </span><br><span class="line">            allowPositionDiscontinuity  </span><br><span class="line">                ? newCurrentPositionUs  </span><br><span class="line">                : max(currentPositionUs, newCurrentPositionUs);  </span><br><span class="line">        allowPositionDiscontinuity = <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MediaCodecAudioRenderer.java:1062-1071</code></p>
<p><code>AudioTrackPositionTracker</code>负责精确跟踪音频播放位置，通过<code>AudioTrack</code>的<code>getPlaybackHeadPosition()</code>和<code>getTimestamp()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Wraps an &#123;<span class="doctag">@link</span> AudioTrack&#125;, exposing a position based on &#123;<span class="doctag">@link</span>  </span></span><br><span class="line"><span class="comment"> * AudioTrack#getPlaybackHeadPosition()&#125; and &#123;<span class="doctag">@link</span> AudioTrack#getTimestamp(AudioTimestamp)&#125;.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="comment">/* package */</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AudioTrackPositionTracker</span> &#123;</span><br></pre></td></tr></table></figure>
<p><code>AudioTrackPositionTracker.java:41-51</code></p>
<p><code>VideoFrameReleaseControl</code>根据视频帧的PTS(Presentation
Timestamp)与当前音频位置的比较，决定何时释放视频帧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@VideoFrameReleaseControl</span>.FrameReleaseAction  </span><br><span class="line"><span class="type">int</span> <span class="variable">frameReleaseAction</span> <span class="operator">=</span>  </span><br><span class="line">    videoFrameReleaseControl.getFrameReleaseAction(  </span><br><span class="line">        bufferPresentationTimeUs,  </span><br><span class="line">        positionUs,  </span><br><span class="line">        elapsedRealtimeUs,  </span><br><span class="line">        getOutputStreamStartPositionUs(),  </span><br><span class="line">        isDecodeOnlyBuffer,  </span><br><span class="line">        isLastBuffer,  </span><br><span class="line">        videoFrameReleaseInfo);</span><br></pre></td></tr></table></figure>
<p><code>MediaCodecVideoRenderer.java:721-729</code></p>
<p>根据返回的<code>frameReleaseAction</code>，视频渲染器决定立即渲染、按计划渲染、丢弃或跳过当前帧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (frameReleaseAction) &#123;  </span><br><span class="line">  <span class="keyword">case</span> VideoFrameReleaseControl.FRAME_RELEASE_IMMEDIATELY:  </span><br><span class="line">    <span class="type">long</span> <span class="variable">releaseTimeNs</span> <span class="operator">=</span> getClock().nanoTime();  </span><br><span class="line">    notifyFrameMetadataListener(presentationTimeUs, releaseTimeNs, format);  </span><br><span class="line">    renderOutputBuffer(codec, bufferIndex, presentationTimeUs, releaseTimeNs);  </span><br><span class="line">    updateVideoFrameProcessingOffsetCounters(videoFrameReleaseInfo.getEarlyUs());  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">  <span class="keyword">case</span> VideoFrameReleaseControl.FRAME_RELEASE_SKIP:  </span><br><span class="line">    skipOutputBuffer(codec, bufferIndex, presentationTimeUs);  </span><br><span class="line">    updateVideoFrameProcessingOffsetCounters(videoFrameReleaseInfo.getEarlyUs());  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">  <span class="keyword">case</span> VideoFrameReleaseControl.FRAME_RELEASE_DROP:  </span><br><span class="line">    dropOutputBuffer(codec, bufferIndex, presentationTimeUs);  </span><br><span class="line">    updateVideoFrameProcessingOffsetCounters(videoFrameReleaseInfo.getEarlyUs());  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p><code>MediaCodecVideoRenderer.java:730-744</code></p>
<p>在隧道播放模式下，<code>DefaultAudioSink</code>使用AV同步标头(AV Sync
Headers)来确保音视频同步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">writeNonBlockingWithAvSync</span><span class="params">(  </span></span><br><span class="line"><span class="params">    AudioTrack audioTrack, ByteBuffer buffer, <span class="type">int</span> size, <span class="type">long</span> presentationTimeUs)</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span> (Util.SDK_INT &gt;= <span class="number">26</span>) &#123;  </span><br><span class="line">    <span class="comment">// The underlying platform AudioTrack writes AV sync headers directly.  </span></span><br><span class="line">    <span class="keyword">return</span> audioTrack.write(  </span><br><span class="line">        buffer, size, AudioTrack.WRITE_NON_BLOCKING, presentationTimeUs * <span class="number">1000</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (avSyncHeader == <span class="literal">null</span>) &#123;  </span><br><span class="line">    avSyncHeader = ByteBuffer.allocate(<span class="number">16</span>);  </span><br><span class="line">    avSyncHeader.order(ByteOrder.BIG_ENDIAN);  </span><br><span class="line">    avSyncHeader.putInt(<span class="number">0x55550001</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (bytesUntilNextAvSync == <span class="number">0</span>) &#123;  </span><br><span class="line">    avSyncHeader.putInt(<span class="number">4</span>, size);  </span><br><span class="line">    avSyncHeader.putLong(<span class="number">8</span>, presentationTimeUs * <span class="number">1000</span>);  </span><br><span class="line">    avSyncHeader.position(<span class="number">0</span>);  </span><br><span class="line">    bytesUntilNextAvSync = size;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>DefaultAudioSink.java:1890-1907</code></p>
<p>系统通过计算帧的”早期时间”(early
time)，即帧应该播放时间与当前播放位置的差值，来确定视频帧的处理方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">calculateEarlyTimeUs</span><span class="params">(  </span></span><br><span class="line"><span class="params">    <span class="type">long</span> positionUs, <span class="type">long</span> elapsedRealtimeUs, <span class="type">long</span> framePresentationTimeUs)</span> &#123;  </span><br><span class="line">  <span class="comment">// Calculate how early we are. In other words, the realtime duration that needs to elapse whilst  </span></span><br><span class="line">  <span class="comment">// the renderer is started before the frame should be rendered. A negative value means that  </span></span><br><span class="line">  <span class="comment">// we&#x27;re already late.  </span></span><br><span class="line">  <span class="comment">// Note: Use of double rather than float is intentional for accuracy in the calculations below.  </span></span><br><span class="line">  <span class="type">long</span> <span class="variable">earlyUs</span> <span class="operator">=</span> (<span class="type">long</span>) ((framePresentationTimeUs - positionUs) / (<span class="type">double</span>) playbackSpeed);  </span><br><span class="line">  <span class="keyword">if</span> (started) &#123;  </span><br><span class="line">    <span class="comment">// Account for the elapsed time since the start of this iteration of the rendering loop.  </span></span><br><span class="line">    earlyUs -= Util.msToUs(clock.elapsedRealtime()) - elapsedRealtimeUs;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> earlyUs;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>VideoFrameReleaseControl.java:458-471</code></p>
<p>ExoPlayer
的音画同步实现采用音频作为主时钟，通过精确计算视频帧与音频位置的时间差来决定视频帧的处理方式。系统会根据不同的播放情况(正常播放、隧道模式等)选择合适的同步策略，并支持各种特殊情况如播放速度变化、跳转等。整个同步机制考虑了精确度和性能的平衡，确保在各种设备和播放条件下都能提供流畅的音视频同步体验。</p>
]]></content>
      <categories>
        <category>音视频</category>
        <category>ExoPlayer</category>
      </categories>
  </entry>
  <entry>
    <title>如何从播放器构造角度研究 ExoPlayer 源码</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/ExoPlayer/%E5%A6%82%E4%BD%95%E4%BB%8E%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%84%E9%80%A0%E8%A7%92%E5%BA%A6%E7%A0%94%E7%A9%B6-ExoPlayer-%E6%BA%90%E7%A0%81.html</url>
    <content><![CDATA[<p>ExoPlayer 的核心组件包括：</p>
<ul>
<li><code>ExoPlayer</code>：播放器核心，负责协调媒体播放。</li>
<li><code>MediaSource</code>：定义媒体来源（如
DASH、HLS、Progressive）。</li>
<li><code>TrackSelector</code>：管理音视频轨道选择。</li>
<li><code>Renderer</code>：负责音视频解码和渲染。</li>
<li><code>DataSource</code>：处理数据加载（如网络或本地文件）。</li>
</ul>
<p>构建一个播放器，通常需要加载媒体源、解码、渲染、播放控制这几个关键环节。ExoPlayer
通过构建一个 ExoPlayer 实例来协调这些环节。</p>
<p>管理播放器的生命周期和组件：通过入口类<code>ExoPlayerImpl</code>，实现
<code>ExoPlayer</code> 接口。研究点：</p>
<ul>
<li>在构造方法中，<code>ExoPlayerImpl</code> 如何初始化
<code>Renderers</code>、<code>TrackSelector</code>、<code>LoadControl</code>
等组件？</li>
<li><code>setMediaSource</code> 和
<code>prepare</code>方法如何加载媒体并进入准备状态？</li>
<li><code>Player</code> 接口定义了播放器的通用
API，<code>ExoPlayerImpl</code> 如何实现这些方法？</li>
<li>组件如何通过依赖注入（如 <code>ExoPlayer.Builder</code>）组合？</li>
<li><code>ExoPlayer</code> 如何在主线程和播放线程间切换（涉及
<code>Handler</code> 和 <code>Looper</code>）？</li>
</ul>
<p>解码和渲染：ExoPlayer 中通过<code>Renderer</code>
接口来实现。具体实现为<code>MediaCodecVideoRenderer</code>（视频解码）和
<code>MediaCodecAudioRenderer</code>（音频解码）。研究点：</p>
<ul>
<li><code>Renderer</code> 的初始化流程：如何配置
<code>MediaCodec</code>（Android 的硬件解码器）？</li>
<li>从读取媒体数据到解码、输出到 <code>Surface</code> 或
<code>AudioTrack</code> 的完整渲染管道流程？</li>
<li>轨道选择：<code>TrackSelector</code> 如何与 <code>Renderer</code>
协作选择合适的音视频轨道？</li>
<li>查看 <code>MediaCodecRenderer</code> 的 <code>render</code>
方法，理解解码和渲染的细节。</li>
<li>关注 <code>onInputFormatChanged</code> 和
<code>onOutputFormatChanged</code>，分析格式切换的处理。</li>
</ul>
<p>数据加载：<code>MediaSource</code>
接口负责抽象不同类型的数据。具体实现如
<code>DashMediaSource</code>、<code>HlsMediaSource</code>、<code>ProgressiveMediaSource</code>。<code>DataSource</code>负责从不同渠道获取数据。研究点：</p>
<ul>
<li><code>MediaSource</code> 如何解析媒体（例如，解析 DASH 的 MPD 文件或
HLS 的 M3U8 文件）？</li>
<li>数据加载流程：<code>DataSource</code>
如何从网络或本地获取数据？</li>
<li>缓冲管理：<code>LoadControl</code> 和 <code>DefaultAllocator</code>
如何控制缓冲区大小和加载策略？</li>
<li>查看 <code>DashMediaSource.Factory</code> 和
<code>ChunkSource</code> 的实现，理解分段加载逻辑。</li>
<li>关注 <code>SampleStream</code> 和
<code>SampleQueue</code>，分析媒体样本的读取和解码。</li>
</ul>
<p>播放控制与状态管理：核心类是<code>PlaybackInfo</code> 和
<code>PlayerState</code>（在 <code>ExoPlayerImpl</code>
中管理）。研究点：</p>
<ul>
<li>播放器状态机：从 <code>STATE_IDLE</code> 到
<code>STATE_READY</code>、<code>STATE_BUFFERING</code> 和
<code>STATE_ENDED</code> 的转换逻辑。</li>
<li>事件分发：<code>Player.Listener</code>
如何接收播放进度、错误等事件？</li>
<li>错误处理：<code>ExoPlaybackException</code> 的捕获和处理机制。</li>
<li>查看
<code>ExoPlayerImpl#updatePlaybackInfo</code>，理解状态更新的核心逻辑。</li>
<li>分析 <code>InternalListener</code>
如何处理内部事件并通知外部监听器。</li>
</ul>
<p>ExoPlayer 的模块化设计和扩展能力。研究点：</p>
<ul>
<li>ExoPlayer 的模块化设计如何支持自定义组件（如自定义
<code>DataSource</code> 或 <code>Renderer</code>）？</li>
<li><code>ExoPlayer.Builder</code> 如何通过链式调用配置播放器？</li>
<li>扩展点：如何实现自定义加密（DRM）、字幕解析或网络协议？</li>
<li>查看 <code>DefaultRenderersFactory</code> 和
<code>DefaultMediaSourceFactory</code>，理解默认实现的构造。</li>
<li>分析 <code>Extension</code> 模块（如
<code>media3-transformer</code>），学习如何扩展功能。</li>
</ul>
<p>特定场景： - 自适应流媒体：分析 <code>DashMediaSource</code> 和
<code>HlsMediaSource</code> 的自适应切换逻辑（涉及
<code>AdaptiveTrackSelection</code>）。 - DRM 保护：研究
<code>DrmSessionManager</code> 和 <code>DefaultDrmSession</code>
的加密解密流程。 - 低延迟播放：查看
<code>LowLatencyHlsMediaSource</code> 或 WebRTC 相关的扩展。 - UI
集成：分析 <code>media3-ui</code> 模块中的 <code>PlayerView</code> 和
<code>StyledPlayerView</code>，理解与播放器的绑定。 - 性能优化：研究
<code>LoadControl</code> 和 <code>BufferManager</code>
的实现，理解如何优化缓冲和内存使用。</p>
<p>学习资源：</p>
<ul>
<li><a href="https://github.com/androidx/media">Media3 GitHub
仓库</a></li>
<li><a
href="https://developer.android.com/jetpack/androidx/releases/media3">Media3
发布文档</a></li>
<li><a
href="https://developer.android.com/media/media3/exoplayer?hl=zh-cn">Media3
开发者指南</a></li>
</ul>
<p>学习路径建议：</p>
<ul>
<li>熟悉 API：通过官方文档和 Demo 快速上手 ExoPlayer。</li>
<li>剖析核心类：从 <code>ExoPlayerImpl</code> 和 <code>Renderer</code>
入手，理解构造和渲染流程。</li>
<li>跟踪数据流：分析从 <code>DataSource</code> 到
<code>MediaSource</code> 再到 <code>Renderer</code>
的数据处理路径。</li>
<li>实现扩展：尝试编写自定义 <code>Renderer</code> 或
<code>DataSource</code>，加深对架构的理解。</li>
<li>阅读测试用例：通过单元测试学习组件的预期行为和边缘情况。</li>
</ul>
]]></content>
      <categories>
        <category>音视频</category>
        <category>ExoPlayer</category>
      </categories>
  </entry>
  <entry>
    <title>Android OpenGL 定义着色器</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/OpenGL/Android-OpenGL-%E5%AE%9A%E4%B9%89%E7%9D%80%E8%89%B2%E5%99%A8.html</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>音视频</category>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title>Android 创建一个 OpenGL 程序</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/OpenGL/Android-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-OpenGL-%E7%A8%8B%E5%BA%8F.html</url>
    <content><![CDATA[<p>这是在 Android 设备上构建 OpenGL
程序系列文章的第一篇，本文的主要目的是说明如何构建一个简单的 OpenGL
程序。使用 OpenGL ES 2.0 进行开发。</p>
<p>本系列文章的示例代码地址：https://github.com/cmder/Demos/tree/main/OpenGLProject</p>
<p>这个程序非常简单：初始化 OpenGL 并不停地清空屏幕。</p>
<p>为什么要不停地清空屏幕呢？因为在每一帧中，我们都需要重新绘制场景。如果不清空屏幕，上一帧的内容会残留在屏幕上，导致视觉上的混乱。通过不断地清空屏幕，我们可以确保每一帧都是干净的，避免了这种问题。</p>
<p>使用 GLSurfaceView 初始化 OpenGL。GLSurfaceView 会处理 OpenGL
初始化过程中比较基本的操作，如配置显示设备(display)
以及在后台线程中渲染，渲染是在显示设备中一个称为 “surface”
的特定区域完成的，有时也成为视口（viewport）。</p>
<p>GLSurfaceView 提供了很多方法和 Android Activity
的生命周期方法关联，例如在 Activity 的 onPause() 方法中暂停渲染，在
onResume() 方法中恢复渲染等。</p>
<p>GLSurfaceView 实际上为自己创建了一个窗口(Window),并在视图层次（View
Hierarchy）上穿了个“洞”，让底层的 OpenGL Surface
显示出来。对于大多数应用程序来说，这种方式足够简单且有效。但是
GLSurfaceView 与常规视图（view）不同，它没有动画或者变形特效，因为
GLSurfaceView 是窗口（Window）的一部分。</p>
<p>从 Android 4.0 Ice Cream Sandwich 开始，Android
提供了一个纹理视图（TextureView），它可以渲染 OpenGL
内容而不用创建单独的窗口或打洞了，这就意味着，TextureView
可以与其他视图（如 ImageView、Button
等）一起使用，支持动画和变形效果。但是，TextureView 没有内置的 OpenGL
初始化操作，想要使用 TextureView，一种方法是执行自定义的 OpenGL
初始化，并在 TextureView 的 Surface 中进行渲染,另一种方法是把
GLSurfaceView 的源代码拿出来，把它适配到 TextureView 中。</p>
<p>创建 GLSurfaceView 实例： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">glSurfaceView = GLSurfaceView(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></p>
<p>检查系统是否支持 OpenGL ES 2.0： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> activityManager: ActivityManager = getSystemService(ACTIVITY_SERVICE) <span class="keyword">as</span> ActivityManager</span><br><span class="line"><span class="keyword">val</span> configurationInfo: ConfigurationInfo = activityManager.deviceConfigurationInfo</span><br><span class="line"><span class="keyword">val</span> supportsEs2: <span class="built_in">Boolean</span> =</span><br><span class="line">    configurationInfo.reqGlEsVersion &gt;= <span class="number">0x20000</span></span><br><span class="line">            || (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1</span><br><span class="line">            &amp;&amp; (Build.FINGERPRINT.startsWith(<span class="string">&quot;generic&quot;</span>)</span><br><span class="line">            || Build.FINGERPRINT.startsWith(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">            || Build.MODEL.contains(<span class="string">&quot;google_sdk&quot;</span>)</span><br><span class="line">            || Build.MODEL.contains(<span class="string">&quot;Emulator&quot;</span>)</span><br><span class="line">            || Build.MODEL.contains(<span class="string">&quot;Android SDK built for x86&quot;</span>)))</span><br></pre></td></tr></table></figure></p>
<p>为 OpenGL ES 2.0 配置渲染表面： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (supportsEs2) &#123;</span><br><span class="line">    glSurfaceView.setEGLContextClientVersion(<span class="number">2</span>)</span><br><span class="line">    glSurfaceView.setRenderer(OpenGLProjectRenderer())</span><br><span class="line">    rendererSet = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;This device does not support OpenGL ES 2.0.&quot;</span>,</span><br><span class="line">        Toast.LENGTH_LONG).show();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setContentView(glSurfaceView)</span><br></pre></td></tr></table></figure> 当 surface
创建或者发生变化的时候，以及要绘制一幅新帧时，渲染器都会被 GLSurfaceView
调用。</p>
<p>处理 Android Activity 生命周期的事件: <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause()</span><br><span class="line">    <span class="keyword">if</span> (rendererSet) &#123;</span><br><span class="line">        glSurfaceView.onPause()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    <span class="keyword">if</span> (rendererSet) &#123;</span><br><span class="line">        glSurfaceView.onResume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这两个方法用于处理 Activity 的生命周期，当 Activity
暂停或恢复时，GLSurfaceView
也会相应地暂停或恢复渲染。这确保了在应用程序不在前台时，OpenGL
上下文被释放和恢复。</p>
<p>创建 Render 类: <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OpenGLProjectRenderer</span> : <span class="type">GLSurfaceView.Renderer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 程序第一次被运行的时候，Surface 被创建, GLSurfaceView 会调用这个方法。</span></span><br><span class="line"><span class="comment">     * 当设备被唤醒或者用户从其他 Activity 切换回来时，也会调用这个方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceCreated</span><span class="params">(gl: <span class="type">GL10</span>?, config: <span class="type">EGLConfig</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 设置清空屏幕用的颜色</span></span><br><span class="line">        glClearColor(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Surface 创建后，每次 Surface 尺寸发生变化时，GLSurfaceView 会调用这个方法。</span></span><br><span class="line"><span class="comment">     * 横屏、竖屏来回切换的时候，Surface 的宽高会发生变化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceChanged</span><span class="params">(gl: <span class="type">GL10</span>?, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 设置视口大小，告诉 OpenGL 可以用来渲染的 surface 的大小</span></span><br><span class="line">        glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当绘制一帧的时候，GLSurfaceView 会调用这个方法。在这个方法中，我们一定要绘制一些东西，</span></span><br><span class="line"><span class="comment">     * 即使没有任何可绘制的内容，也要调用 glClear() 方法清空颜色缓冲区。因为在这个方法返会后，</span></span><br><span class="line"><span class="comment">     * 渲染缓冲区会被交换并显示在屏幕上，如果什么都不绘制，屏幕上会残留上一帧的内容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDrawFrame</span><span class="params">(gl: <span class="type">GL10</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 擦除屏幕的所有颜色，并用 glClearColor 定义的颜色填充</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GLSurfaceView
会在一个单独的线程中调用渲染器的方法。默认情况下，GLSurfaceView
会以显示设备的刷新率不断进行渲染。它也可以配置为按请求渲染，只需要用调用<code>GLSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY)</code>即可。</p>
<p>GLSurfaceView
在后台线程中执行渲染，就必须要小心，只能在这个线程中进行 OpenGL
的绘制操作，不能在主线程中进行。两个线程间的通信可以用如下方法：在主线程中的
GLSurfaceView.queueEvent() 方法中提交一个 Runnable
任务，在后台渲染线程中执行。渲染线程可以调用 Activity.runOnUiThread()
方法来传递事件（event）给主线程。</p>
<p>总结 ：本文介绍了如何在 Android 中创建一个 OpenGL
程序和清空屏幕的操作。</p>
]]></content>
      <categories>
        <category>音视频</category>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title>OpenGL</title>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91/OpenGL/OpenGL.html</url>
    <content><![CDATA[<h1 id="知识树">知识树</h1>
<pre><code class="highlight mermaid">graph LR
    A[OpenGL] --&gt; B(基础)
    A --&gt; C(渲染管线)
    A --&gt; D(核心概念)
    A --&gt; E(常用功能)
    A --&gt; F(工具与扩展)

    B --&gt; B1[跨平台图形API]
    B --&gt; B2[固定功能 vs 可编程管线]

    C --&gt; C1[顶点数据输入]
    C --&gt; C2[顶点着色器]
    C --&gt; C3[图元组装]
    C --&gt; C4[光栅化]
    C --&gt; C5[片段着色器]
    C --&gt; C6[测试与混合]
    C --&gt; C7[输出]

    C1 --&gt; C2 --&gt; C3 --&gt; C4 --&gt; C5 --&gt; C6 --&gt; C7

    D --&gt; D1[缓冲区]
    D --&gt; D2[着色器]
    D --&gt; D3[纹理]
    D --&gt; D4[变换]
    D --&gt; D5[状态机]

    D1 --&gt; D1a[VBO]
    D1 --&gt; D1b[VAO]
    D1 --&gt; D1c[EBO]
    D1 --&gt; D1d[FBO]

    D2 --&gt; D2a[顶点着色器]
    D2 --&gt; D2b[片段着色器]
    D2 --&gt; D2c[几何着色器]

    D3 --&gt; D3a[2D纹理]
    D3 --&gt; D3b[3D纹理]
    D3 --&gt; D3c[立方体贴图]

    D4 --&gt; D4a[模型变换]
    D4 --&gt; D4b[视图变换]
    D4 --&gt; D4c[投影变换]

    E --&gt; E1[绘制调用]
    E --&gt; E2[清屏与缓冲区]
    E --&gt; E3[混合与深度]

    E1 --&gt; E1a[glDrawArrays]
    E1 --&gt; E1b[glDrawElements]

    F --&gt; F1[GLFW/GLUT]
    F --&gt; F2[GLEW]
    F --&gt; F3[调试]</code></pre>
<h1 id="详解">详解</h1>
<h2 id="opengl基础">1. OpenGL基础</h2>
<h3 id="定义与特点">1.1 定义与特点</h3>
<ul>
<li><strong>功能作用</strong>: OpenGL（Open Graphics
Library）是一个跨平台的图形编程接口，用于创建高性能的2D和3D图形应用程序。它通过与GPU交互，提供硬件加速的渲染能力，开发者可以直接操作底层图形硬件。</li>
<li><strong>使用场景</strong>:
<ul>
<li>游戏开发（如Unity、Unreal Engine底层依赖OpenGL）。</li>
<li>CAD软件（如AutoCAD的3D建模）。</li>
<li>虚拟现实（VR）和增强现实（AR）应用。</li>
<li>科学可视化（如分子结构渲染）。</li>
</ul></li>
<li><strong>底层原理</strong>:
OpenGL通过驱动程序与GPU通信，开发者调用API函数（如<code>glDrawArrays</code>），这些命令被翻译为GPU可执行的指令。它是一个状态机，函数调用会修改全局状态（如启用深度测试、绑定缓冲区），状态会影响后续操作。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化GLFW</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;OpenGL Window&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window) &#123;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前上下文</span></span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line">        <span class="comment">// 清空颜色缓冲区</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">// 交换缓冲区</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        <span class="comment">// 处理事件</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理并退出</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>需要配合窗口管理库（如GLFW或GLUT）创建上下文，单独的OpenGL无法直接显示图形。</li>
<li>确保显卡驱动支持目标OpenGL版本（如4.6），否则可能需要降级版本。</li>
<li>检查返回值（如<code>glfwCreateWindow</code>）以避免初始化失败。</li>
</ul></li>
</ul>
<h3 id="固定功能管线-vs-可编程管线">1.2 固定功能管线 vs 可编程管线</h3>
<ul>
<li><strong>功能作用</strong>:
<ul>
<li><strong>固定功能管线</strong>:
老版本（如1.x-2.x）提供预定义的功能（如光照、纹理映射），开发者只需调用函数，无需编写着色器。</li>
<li><strong>可编程管线</strong>:
现代版本（如3.x-4.x）允许开发者通过GLSL（OpenGL Shading
Language）编写着色器，全面控制渲染过程。</li>
</ul></li>
<li><strong>使用场景</strong>:
<ul>
<li>固定功能管线: 适用于简单应用（如早期教学示例、小型2D游戏）。</li>
<li>可编程管线:
适用于现代复杂图形应用（如实时光影效果、物理渲染）。</li>
</ul></li>
<li><strong>底层原理</strong>:
<ul>
<li>固定功能管线依赖GPU内置的算法（如Phong光照模型），开发者无法修改其实现。</li>
<li>可编程管线将渲染任务交给开发者编写的GLSL程序，这些程序在GPU上并行执行，提供更高灵活性。</li>
</ul></li>
<li><strong>示例代码</strong> (固定功能管线绘制三角形):
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    glBegin(GL_TRIANGLES); <span class="comment">// 开始绘制三角形</span></span><br><span class="line">    glColor3f(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>); <span class="comment">// 红色</span></span><br><span class="line">    glVertex3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    glColor3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>); <span class="comment">// 绿色</span></span><br><span class="line">    glVertex3f(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    glColor3f(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// 蓝色</span></span><br><span class="line">    glVertex3f(<span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    glEnd(); <span class="comment">// 结束绘制</span></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    glutInit(&amp;argc, argv);</span><br><span class="line">    glutCreateWindow(<span class="string">&quot;Fixed Pipeline Triangle&quot;</span>);</span><br><span class="line">    glutDisplayFunc(display);</span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例代码</strong> (可编程管线基础框架): <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 见后续缓冲区和着色器部分</span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>固定功能管线在现代OpenGL（3.0+）中已被废弃，建议学习可编程管线。</li>
<li>可编程管线需要手动管理着色器和缓冲区，入门门槛较高。</li>
</ul></li>
</ul>
<hr />
<h2 id="渲染管线rendering-pipeline">2. 渲染管线（Rendering
Pipeline）</h2>
<h3 id="顶点数据输入-vertex-data">2.1 顶点数据输入 (Vertex Data)</h3>
<ul>
<li><strong>功能作用</strong>:
定义几何体的顶点属性（如位置、颜色、法线、纹理坐标），作为渲染的起点。</li>
<li><strong>使用场景</strong>:
绘制任何图形对象（如三角形、立方体、复杂网格模型）。</li>
<li><strong>底层原理</strong>:
顶点数据最初存储在CPU内存，通过缓冲区对象（VBO）传输到GPU显存，供后续管线阶段使用。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置          // 颜色</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 右下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>  <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO); <span class="comment">// 生成缓冲区对象</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO); <span class="comment">// 绑定到GL_ARRAY_BUFFER目标</span></span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW); <span class="comment">// 传输数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>数据格式（如位置+颜色）需与着色器输入匹配。</li>
<li><code>GL_STATIC_DRAW</code>表示数据不频繁修改，<code>GL_DYNAMIC_DRAW</code>适用于动态更新。</li>
<li>绑定后需解绑（<code>glBindBuffer(GL_ARRAY_BUFFER, 0)</code>）以避免误操作。</li>
</ul></li>
</ul>
<h3 id="顶点着色器-vertex-shader">2.2 顶点着色器 (Vertex Shader)</h3>
<ul>
<li><strong>功能作用</strong>:
处理每个顶点，执行位置变换、光照计算、传递属性给后续阶段。</li>
<li><strong>使用场景</strong>:
实现模型动画（如骨骼动画）、视角变换（如摄像机移动）。</li>
<li><strong>底层原理</strong>:
GPU并行执行GLSL代码，每个顶点独立处理，输出变换后的顶点数据（如<code>gl_Position</code>）。</li>
<li><strong>示例代码</strong>: <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;   <span class="comment">// 顶点位置</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor; <span class="comment">// 顶点颜色</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> vertexColor; <span class="comment">// 传递给片段着色器</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> MVP;     <span class="comment">// 模型-视图-投影矩阵</span></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = MVP * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 变换位置</span></span><br><span class="line">    vertexColor = aColor;                <span class="comment">// 传递颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* vertexShaderSource = <span class="comment">/* GLSL代码 */</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br><span class="line">glUseProgram(shaderProgram);</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li><code>gl_Position</code>是内置输出变量，必须赋值，表示裁剪空间坐标。</li>
<li>使用<code>uniform</code>传递外部数据（如矩阵）。</li>
<li>检查编译和链接状态（<code>glGetShaderiv</code>、<code>glGetProgramiv</code>）。</li>
</ul></li>
</ul>
<h3 id="图元组装-primitive-assembly">2.3 图元组装 (Primitive
Assembly)</h3>
<ul>
<li><strong>功能作用</strong>:
将顶点连接成图元（如点、线、三角形），为光栅化准备数据。</li>
<li><strong>使用场景</strong>:
定义绘制方式（如三角形网格、线框视图）。</li>
<li><strong>底层原理</strong>:
GPU根据绘制模式（<code>GL_TRIANGLES</code>、<code>GL_LINES</code>）和顶点顺序组装图元，确定正面/背面。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBindVertexArray(VAO); <span class="comment">// 假设VAO已设置</span></span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 绘制一个三角形</span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>顶点顺序影响面剔除（默认逆时针为正面）。</li>
<li>图元类型需与顶点数据匹配（如3的倍数顶点用于<code>GL_TRIANGLES</code>）。</li>
</ul></li>
</ul>
<h3 id="光栅化-rasterization">2.4 光栅化 (Rasterization)</h3>
<ul>
<li><strong>功能作用</strong>:
将图元转换为片段（像素候选），为片段着色器提供输入。</li>
<li><strong>使用场景</strong>: 任何可见图形的生成。</li>
<li><strong>底层原理</strong>:
GPU插值顶点属性（如颜色、纹理坐标），将图元分解为离散的片段，每个片段对应屏幕上的潜在像素。</li>
<li><strong>示例代码</strong>: 无需显式调用，由硬件自动完成。</li>
<li><strong>注意事项</strong>:
<ul>
<li>不可直接控制，依赖硬件实现。</li>
<li>视口设置（<code>glViewport</code>）影响光栅化范围。</li>
</ul></li>
</ul>
<h3 id="片段着色器-fragment-shader">2.5 片段着色器 (Fragment
Shader)</h3>
<ul>
<li><strong>功能作用</strong>:
为每个片段计算最终颜色，可处理纹理、光照等效果。</li>
<li><strong>使用场景</strong>:
实现复杂材质（如金属反射）、阴影、后处理。</li>
<li><strong>底层原理</strong>:
GPU并行执行GLSL代码，处理每个片段，输出颜色值到帧缓冲区。</li>
<li><strong>示例代码</strong>: <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> vertexColor; <span class="comment">// 从顶点着色器接收</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;  <span class="comment">// 输出颜色</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(vertexColor * lightColor, <span class="number">1.0</span>); <span class="comment">// 简单光照</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource = <span class="comment">/* GLSL代码 */</span>;</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>输出变量需声明为<code>out</code>，通常命名为<code>FragColor</code>。</li>
<li>避免过多计算，片段着色器开销大。</li>
</ul></li>
</ul>
<h3 id="测试与混合-testing-and-blending">2.6 测试与混合 (Testing and
Blending)</h3>
<ul>
<li><strong>功能作用</strong>:
执行深度测试、模板测试和颜色混合，决定片段是否写入帧缓冲区。</li>
<li><strong>使用场景</strong>:
<ul>
<li>深度测试: 遮挡剔除（如绘制不透明物体）。</li>
<li>模板测试: 掩模效果（如轮廓线）。</li>
<li>混合: 透明物体（如玻璃）。</li>
</ul></li>
<li><strong>底层原理</strong>:
GPU根据状态（如深度缓冲区值）丢弃或混合片段，混合公式由<code>glBlendFunc</code>定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用深度测试</span></span><br><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line"><span class="comment">// 启用混合</span></span><br><span class="line">glEnable(GL_BLEND);</span><br><span class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); <span class="comment">// 标准透明混合</span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>混合时需先绘制不透明物体，再绘制透明物体（按深度排序）。</li>
<li>深度缓冲区需清空（<code>glClear(GL_DEPTH_BUFFER_BIT)</code>）。</li>
</ul></li>
</ul>
<h3 id="输出-output">2.7 输出 (Output)</h3>
<ul>
<li><strong>功能作用</strong>:
将渲染结果写入帧缓冲区，最终显示到屏幕。</li>
<li><strong>使用场景</strong>: 每帧渲染的最后步骤。</li>
<li><strong>底层原理</strong>:
GPU将颜色缓冲区数据传输到显示设备，双缓冲机制（前后缓冲）避免闪烁。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>); <span class="comment">// 默认帧缓冲区</span></span><br><span class="line">glfwSwapBuffers(window); <span class="comment">// 交换前后缓冲</span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>双缓冲需显式交换（<code>glfwSwapBuffers</code>）。</li>
<li>确保帧缓冲区完整。</li>
</ul></li>
</ul>
<hr />
<h2 id="核心概念">3. 核心概念</h2>
<h3 id="缓冲区">3.1 缓冲区</h3>
<h4 id="vbo-vertex-buffer-object">3.1.1 VBO (Vertex Buffer Object)</h4>
<ul>
<li><strong>功能作用</strong>:
在GPU存储顶点数据（如位置、颜色），提高渲染效率。</li>
<li><strong>使用场景</strong>: 绘制复杂模型（如3D角色）。</li>
<li><strong>底层原理</strong>:
数据从CPU复制到GPU显存，避免每次绘制都传输。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>绑定后解绑以避免误操作。</li>
<li>数据大小单位为字节。</li>
</ul></li>
</ul>
<h4 id="vao-vertex-array-object">3.1.2 VAO (Vertex Array Object)</h4>
<ul>
<li><strong>功能作用</strong>:
封装顶点数据的状态（如VBO绑定、属性指针），简化绘制调用。</li>
<li><strong>使用场景</strong>: 多对象渲染（如场景中多个模型）。</li>
<li><strong>底层原理</strong>:
VAO记录顶点属性的布局和绑定状态，减少重复配置。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>); <span class="comment">// 解绑</span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>绘制时只需绑定VAO。</li>
<li>属性索引（如0）需与着色器<code>layout(location)</code>一致。</li>
</ul></li>
</ul>
<h4 id="ebo-element-buffer-object">3.1.3 EBO (Element Buffer
Object)</h4>
<ul>
<li><strong>功能作用</strong>: 存储顶点索引，优化重复顶点的绘制。</li>
<li><strong>使用场景</strong>: 网格模型（如立方体）。</li>
<li><strong>底层原理</strong>:
使用索引引用VBO中的顶点，减少数据冗余。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>索引类型（如<code>GL_UNSIGNED_INT</code>）需匹配数据。</li>
<li>EBO绑定到VAO中。</li>
</ul></li>
</ul>
<h4 id="fbo-framebuffer-object">3.1.4 FBO (Framebuffer Object)</h4>
<ul>
<li><strong>功能作用</strong>:
实现离屏渲染，将结果存储到纹理而非屏幕。</li>
<li><strong>使用场景</strong>: 后处理（如模糊、HDR）。</li>
<li><strong>底层原理</strong>:
FBO重定向渲染目标，包含颜色、深度等附件。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> FBO;</span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;FBO);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, FBO);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Framebuffer incomplete!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>检查FBO完整性。</li>
<li>解绑时恢复默认帧缓冲（<code>glBindFramebuffer(GL_FRAMEBUFFER, 0)</code>）。</li>
</ul></li>
</ul>
<h3 id="着色器">3.2 着色器</h3>
<h4 id="顶点着色器">3.2.1 顶点着色器</h4>
<ul>
<li><strong>功能作用</strong>: 处理顶点变换和属性传递。</li>
<li><strong>使用场景</strong>: 动画、摄像机变换。</li>
<li><strong>底层原理</strong>: GPU并行执行。</li>
<li><strong>示例代码</strong>: 同2.2。</li>
<li><strong>注意事项</strong>: 确保输出<code>gl_Position</code>。</li>
</ul>
<h4 id="片段着色器">3.2.2 片段着色器</h4>
<ul>
<li><strong>功能作用</strong>: 计算片段颜色。</li>
<li><strong>使用场景</strong>: 材质效果。</li>
<li><strong>底层原理</strong>: GPU并行执行。</li>
<li><strong>示例代码</strong>: 同2.5。</li>
<li><strong>注意事项</strong>: 输出变量需定义。</li>
</ul>
<h4 id="几何着色器-geometry-shader">3.2.3 几何着色器 (Geometry
Shader)</h4>
<ul>
<li><strong>功能作用</strong>: 在图元级别操作，可生成或修改图元。</li>
<li><strong>使用场景</strong>: 粒子系统、轮廓扩展。</li>
<li><strong>底层原理</strong>:
在顶点和片段阶段之间运行，处理整个图元。</li>
<li><strong>示例代码</strong>: <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">triangles</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">triangle_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">3</span>) <span class="keyword">out</span>;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[i].<span class="built_in">gl_Position</span>;</span><br><span class="line">        <span class="built_in">EmitVertex</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>可选阶段，性能开销较大。</li>
</ul></li>
</ul>
<h3 id="纹理">3.3 纹理</h3>
<h4 id="d纹理">3.3.1 2D纹理</h4>
<ul>
<li><strong>功能作用</strong>: 为表面添加图像细节。</li>
<li><strong>使用场景</strong>: 贴图（如地形）。</li>
<li><strong>底层原理</strong>: 纹理数据存储在GPU，片段着色器采样。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>设置过滤和环绕模式。</li>
</ul></li>
</ul>
<h4 id="d纹理-1">3.3.2 3D纹理</h4>
<ul>
<li><strong>功能作用</strong>: 存储三维纹理数据。</li>
<li><strong>使用场景</strong>: 体视化（如医学成像）。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glTexImage3D(GL_TEXTURE_3D, <span class="number">0</span>, GL_RGB, width, height, depth, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>数据量大，需优化。</li>
</ul></li>
</ul>
<h4 id="立方体贴图">3.3.3 立方体贴图</h4>
<ul>
<li><strong>功能作用</strong>: 实现环境映射。</li>
<li><strong>使用场景</strong>: 天空盒、反射。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>:
<ul>
<li>需要6张图。</li>
</ul></li>
</ul>
<h3 id="变换">3.4 变换</h3>
<h4 id="模型变换">3.4.1 模型变换</h4>
<ul>
<li><strong>功能作用</strong>: 移动、旋转、缩放物体。</li>
<li><strong>使用场景</strong>: 物体动画。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::mat4 model = glm::rotate(glm::mat4(<span class="number">1.0f</span>), glm::radians(<span class="number">45.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>: 使用GLM库。</li>
</ul>
<h4 id="视图变换">3.4.2 视图变换</h4>
<ul>
<li><strong>功能作用</strong>: 定义摄像机视角。</li>
<li><strong>使用场景</strong>: 场景漫游。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::mat4 view = glm::lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="投影变换">3.4.3 投影变换</h4>
<ul>
<li><strong>功能作用</strong>: 将3D场景投影到2D屏幕。</li>
<li><strong>使用场景</strong>: 透视/正交投影。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::mat4 projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="状态机">3.5 状态机</h3>
<ul>
<li><strong>功能作用</strong>: 管理OpenGL的全局状态。</li>
<li><strong>使用场景</strong>: 所有操作。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glDisable(GL_BLEND);</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>: 状态需手动重置。</li>
</ul>
<hr />
<h2 id="常用功能">4. 常用功能</h2>
<h3 id="绘制调用">4.1 绘制调用</h3>
<h4 id="gldrawarrays">4.1.1 glDrawArrays</h4>
<ul>
<li><strong>功能作用</strong>: 顺序绘制顶点。</li>
<li><strong>使用场景</strong>: 简单几何体。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>: 不使用索引。</li>
</ul>
<h4 id="gldrawelements">4.1.2 glDrawElements</h4>
<ul>
<li><strong>功能作用</strong>: 使用索引绘制。</li>
<li><strong>使用场景</strong>: 复杂网格。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="清屏与缓冲区操作">4.2 清屏与缓冲区操作</h3>
<ul>
<li><strong>功能作用</strong>: 清空缓冲区，准备新帧。</li>
<li><strong>使用场景</strong>: 每帧开始。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure></li>
<li><strong>注意事项</strong>: 指定缓冲区类型。</li>
</ul>
<h3 id="混合与深度">4.3 混合与深度</h3>
<ul>
<li><strong>功能作用</strong>: 控制渲染效果。</li>
<li><strong>使用场景</strong>: 透明、遮挡。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glEnable(GL_BLEND);</span><br><span class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h2 id="工具与扩展">5. 工具与扩展</h2>
<h3 id="glfwglut">5.1 GLFW/GLUT</h3>
<ul>
<li><strong>功能作用</strong>: 管理窗口和输入。</li>
<li><strong>使用场景</strong>: 创建OpenGL上下文。</li>
<li><strong>示例代码</strong>: 同1.1。</li>
</ul>
<h3 id="glew">5.2 GLEW</h3>
<ul>
<li><strong>功能作用</strong>: 加载OpenGL扩展函数。</li>
<li><strong>使用场景</strong>: 现代OpenGL。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glewInit();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="调试">5.3 调试</h3>
<ul>
<li><strong>功能作用</strong>: 检查错误。</li>
<li><strong>使用场景</strong>: 开发调试。</li>
<li><strong>示例代码</strong>: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLenum error = glGetError();</span><br><span class="line"><span class="keyword">if</span> (error != GL_NO_ERROR) <span class="built_in">printf</span>(<span class="string">&quot;Error: %d\n&quot;</span>, error);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="问题研究">问题研究</h1>
<h2 id="android-使用-opengl">Android 使用 OpenGL</h2>
<h3
id="方式1使用glsurfaceview"><strong>方式1：使用GLSurfaceView</strong></h3>
<p><code>GLSurfaceView</code> 是 Android 提供的封装类，内置了 EGL
管理和渲染线程，适合快速实现 OpenGL 渲染。</p>
<h4 id="流程概述"><strong>流程概述</strong></h4>
<ol type="1">
<li>创建并配置 <code>GLSurfaceView</code>。</li>
<li>实现 <code>GLSurfaceView.Renderer</code> 接口，定义渲染逻辑。</li>
<li>编写顶点和片段着色器，加载顶点数据。</li>
<li>在 Activity 中管理生命周期。</li>
<li><strong>新增</strong>：使用矩阵变换实现旋转，添加纹理映射渲染图片。</li>
</ol>
<h4 id="关键代码片段"><strong>关键代码片段</strong></h4>
<h5
id="步骤1创建glsurfaceview"><strong>步骤1：创建GLSurfaceView</strong></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> GLSurfaceView glSurfaceView; <span class="comment">// GLSurfaceView 对象，用于显示 OpenGL 渲染内容</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 创建 GLSurfaceView 实例</span></span><br><span class="line">        glSurfaceView = <span class="keyword">new</span> <span class="title class_">GLSurfaceView</span>(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 设置 OpenGL ES 版本，这里使用 2.0</span></span><br><span class="line">        glSurfaceView.setEGLContextClientVersion(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 设置渲染器，MyRenderer 包含具体的渲染逻辑</span></span><br><span class="line">        glSurfaceView.setRenderer(<span class="keyword">new</span> <span class="title class_">MyRenderer</span>(<span class="built_in">this</span>));</span><br><span class="line">        <span class="comment">// 将 GLSurfaceView 设置为 Activity 的内容视图</span></span><br><span class="line">        setContentView(glSurfaceView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        <span class="comment">// 暂停 GLSurfaceView 的渲染线程，避免后台运行浪费资源</span></span><br><span class="line">        glSurfaceView.onPause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        <span class="comment">// 恢复 GLSurfaceView 的渲染线程，继续渲染</span></span><br><span class="line">        glSurfaceView.onResume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5
id="步骤2实现renderer含矩阵变换和纹理映射"><strong>步骤2：实现Renderer（含矩阵变换和纹理映射）</strong></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</span><br><span class="line"><span class="keyword">import</span> android.opengl.GLES20;</span><br><span class="line"><span class="keyword">import</span> android.opengl.GLUtils;</span><br><span class="line"><span class="keyword">import</span> android.opengl.GLSurfaceView;</span><br><span class="line"><span class="keyword">import</span> android.opengl.Matrix;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder;</span><br><span class="line"><span class="keyword">import</span> java.nio.FloatBuffer;</span><br><span class="line"><span class="keyword">import</span> javax.microedition.khronos.egl.EGLConfig;</span><br><span class="line"><span class="keyword">import</span> javax.microedition.khronos.opengles.GL10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRenderer</span> <span class="keyword">implements</span> <span class="title class_">GLSurfaceView</span>.Renderer &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> program; <span class="comment">// OpenGL 程序对象，链接顶点和片段着色器</span></span><br><span class="line">    <span class="keyword">private</span> FloatBuffer vertexBuffer; <span class="comment">// 存储顶点数据的缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> FloatBuffer textureBuffer; <span class="comment">// 存储纹理坐标的缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> textureId; <span class="comment">// 纹理 ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context context; <span class="comment">// 用于加载图片资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span>[] mvpMatrix = <span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">16</span>]; <span class="comment">// 模型-视图-投影矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">angle</span> <span class="operator">=</span> <span class="number">0.0f</span>; <span class="comment">// 旋转角度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义矩形顶点坐标 (x, y, z)，用于纹理映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span>[] rectCoords = &#123;</span><br><span class="line">        -<span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左上</span></span><br><span class="line">        -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下</span></span><br><span class="line">         <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 右下</span></span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// 右上</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义纹理坐标 (s, t)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span>[] textureCoords = &#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左上</span></span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 左下</span></span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 右下</span></span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">0.0f</span>  <span class="comment">// 右上</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRenderer</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> &#123;</span><br><span class="line">        <span class="comment">// 当渲染表面创建时调用，通常用于初始化 OpenGL 环境</span></span><br><span class="line">        GLES20.glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// 设置清屏颜色为黑色 (R, G, B, A)</span></span><br><span class="line">        initShaders(); <span class="comment">// 初始化着色器程序</span></span><br><span class="line">        initBuffers(); <span class="comment">// 初始化顶点和纹理缓冲区</span></span><br><span class="line">        initTexture(); <span class="comment">// 初始化纹理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// 当表面大小改变时调用，例如屏幕旋转</span></span><br><span class="line">        GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height); <span class="comment">// 设置视口大小，匹配屏幕分辨率</span></span><br><span class="line">        <span class="comment">// 设置正交投影矩阵</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">aspectRatio</span> <span class="operator">=</span> (<span class="type">float</span>) width / height;</span><br><span class="line">        Matrix.setIdentityM(mvpMatrix, <span class="number">0</span>);</span><br><span class="line">        Matrix.orthoM(mvpMatrix, <span class="number">0</span>, -aspectRatio, aspectRatio, -<span class="number">1.0f</span>, <span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawFrame</span><span class="params">(GL10 gl)</span> &#123;</span><br><span class="line">        <span class="comment">// 每帧渲染时调用，绘制图形内容</span></span><br><span class="line">        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); <span class="comment">// 清除颜色缓冲区，使用预设的黑色填充</span></span><br><span class="line">        drawTexturedRect(); <span class="comment">// 绘制带纹理的矩形</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新旋转角度，实现动画效果</span></span><br><span class="line">        angle += <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">if</span> (angle &gt;= <span class="number">360.0f</span>) angle = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initShaders</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义顶点着色器代码，包含矩阵变换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">vertexShaderCode</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;uniform mat4 uMVPMatrix;\n&quot;</span> + <span class="comment">// 模型-视图-投影矩阵</span></span><br><span class="line">            <span class="string">&quot;attribute vec4 aPosition;\n&quot;</span> + <span class="comment">// 定义输入的顶点位置属性</span></span><br><span class="line">            <span class="string">&quot;attribute vec2 aTexCoord;\n&quot;</span> + <span class="comment">// 定义输入的纹理坐标属性</span></span><br><span class="line">            <span class="string">&quot;varying vec2 vTexCoord;\n&quot;</span> + <span class="comment">// 传递给片段着色器的纹理坐标</span></span><br><span class="line">            <span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    gl_Position = uMVPMatrix * aPosition;\n&quot;</span> + <span class="comment">// 应用矩阵变换</span></span><br><span class="line">            <span class="string">&quot;    vTexCoord = aTexCoord;\n&quot;</span> + <span class="comment">// 传递纹理坐标</span></span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义片段着色器代码，支持纹理映射</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fragmentShaderCode</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;precision mediump float;\n&quot;</span> + <span class="comment">// 设置浮点精度为中等</span></span><br><span class="line">            <span class="string">&quot;varying vec2 vTexCoord;\n&quot;</span> + <span class="comment">// 从顶点着色器接收纹理坐标</span></span><br><span class="line">            <span class="string">&quot;uniform sampler2D uTexture;\n&quot;</span> + <span class="comment">// 纹理采样器</span></span><br><span class="line">            <span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    gl_FragColor = texture2D(uTexture, vTexCoord);\n&quot;</span> + <span class="comment">// 从纹理采样颜色</span></span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译顶点着色器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vertexShader</span> <span class="operator">=</span> loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode);</span><br><span class="line">        <span class="comment">// 编译片段着色器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fragmentShader</span> <span class="operator">=</span> loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderCode);</span><br><span class="line">        <span class="comment">// 创建 OpenGL 程序对象</span></span><br><span class="line">        program = GLES20.glCreateProgram();</span><br><span class="line">        <span class="comment">// 将顶点着色器附加到程序</span></span><br><span class="line">        GLES20.glAttachShader(program, vertexShader);</span><br><span class="line">        <span class="comment">// 将片段着色器附加到程序</span></span><br><span class="line">        GLES20.glAttachShader(program, fragmentShader);</span><br><span class="line">        <span class="comment">// 链接程序，生成可执行的着色器程序</span></span><br><span class="line">        GLES20.glLinkProgram(program);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">loadShader</span><span class="params">(<span class="type">int</span> type, String shaderCode)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建指定类型的着色器对象（顶点或片段）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shader</span> <span class="operator">=</span> GLES20.glCreateShader(type);</span><br><span class="line">        <span class="comment">// 将着色器源代码上传到 GPU</span></span><br><span class="line">        GLES20.glShaderSource(shader, shaderCode);</span><br><span class="line">        <span class="comment">// 编译着色器代码</span></span><br><span class="line">        GLES20.glCompileShader(shader);</span><br><span class="line">        <span class="keyword">return</span> shader; <span class="comment">// 返回编译后的着色器 ID</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initBuffers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 为顶点数据分配直接字节缓冲区，每个 float 占 4 字节</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(rectCoords.length * <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 设置字节顺序为本地硬件的顺序</span></span><br><span class="line">        bb.order(ByteOrder.nativeOrder());</span><br><span class="line">        <span class="comment">// 将字节缓冲区转换为浮点缓冲区</span></span><br><span class="line">        vertexBuffer = bb.asFloatBuffer();</span><br><span class="line">        <span class="comment">// 将矩形顶点数据写入缓冲区</span></span><br><span class="line">        vertexBuffer.put(rectCoords);</span><br><span class="line">        <span class="comment">// 将缓冲区位置重置为 0，准备读取</span></span><br><span class="line">        vertexBuffer.position(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为纹理坐标分配缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">tb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(textureCoords.length * <span class="number">4</span>);</span><br><span class="line">        tb.order(ByteOrder.nativeOrder());</span><br><span class="line">        textureBuffer = tb.asFloatBuffer();</span><br><span class="line">        textureBuffer.put(textureCoords);</span><br><span class="line">        textureBuffer.position(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initTexture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建纹理对象</span></span><br><span class="line">        <span class="type">int</span>[] textures = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        GLES20.glGenTextures(<span class="number">1</span>, textures, <span class="number">0</span>);</span><br><span class="line">        textureId = textures[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定纹理</span></span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);</span><br><span class="line">        <span class="comment">// 设置纹理参数</span></span><br><span class="line">        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载图片（假设在 res/drawable 中有一张图片 texture.png）</span></span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeResource(context.getResources(), android.R.drawable.star_big_on);</span><br><span class="line">        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, bitmap, <span class="number">0</span>); <span class="comment">// 将 Bitmap 上传到纹理</span></span><br><span class="line">        bitmap.recycle(); <span class="comment">// 释放 Bitmap 资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawTexturedRect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用已编译和链接的着色器程序</span></span><br><span class="line">        GLES20.glUseProgram(program);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取矩阵、顶点和纹理坐标的句柄</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mvpMatrixHandle</span> <span class="operator">=</span> GLES20.glGetUniformLocation(program, <span class="string">&quot;uMVPMatrix&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">positionHandle</span> <span class="operator">=</span> GLES20.glGetAttribLocation(program, <span class="string">&quot;aPosition&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">texCoordHandle</span> <span class="operator">=</span> GLES20.glGetAttribLocation(program, <span class="string">&quot;aTexCoord&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">textureHandle</span> <span class="operator">=</span> GLES20.glGetUniformLocation(program, <span class="string">&quot;uTexture&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用顶点属性数组</span></span><br><span class="line">        GLES20.glEnableVertexAttribArray(positionHandle);</span><br><span class="line">        GLES20.glEnableVertexAttribArray(texCoordHandle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置顶点数据</span></span><br><span class="line">        GLES20.glVertexAttribPointer(positionHandle, <span class="number">3</span>, GLES20.GL_FLOAT, <span class="literal">false</span>, <span class="number">0</span>, vertexBuffer);</span><br><span class="line">        <span class="comment">// 设置纹理坐标数据</span></span><br><span class="line">        GLES20.glVertexAttribPointer(texCoordHandle, <span class="number">2</span>, GLES20.GL_FLOAT, <span class="literal">false</span>, <span class="number">0</span>, textureBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用旋转矩阵</span></span><br><span class="line">        <span class="type">float</span>[] rotationMatrix = <span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">16</span>];</span><br><span class="line">        Matrix.setIdentityM(rotationMatrix, <span class="number">0</span>);</span><br><span class="line">        Matrix.rotateM(rotationMatrix, <span class="number">0</span>, angle, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// 绕 Z 轴旋转</span></span><br><span class="line">        <span class="type">float</span>[] finalMatrix = <span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">16</span>];</span><br><span class="line">        Matrix.multiplyMM(finalMatrix, <span class="number">0</span>, mvpMatrix, <span class="number">0</span>, rotationMatrix, <span class="number">0</span>); <span class="comment">// 组合投影和旋转矩阵</span></span><br><span class="line">        GLES20.glUniformMatrix4fv(mvpMatrixHandle, <span class="number">1</span>, <span class="literal">false</span>, finalMatrix, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定纹理</span></span><br><span class="line">        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);</span><br><span class="line">        GLES20.glUniform1i(textureHandle, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制矩形（使用三角形条带）</span></span><br><span class="line">        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_FAN, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁用顶点属性数组，清理状态</span></span><br><span class="line">        GLES20.glDisableVertexAttribArray(positionHandle);</span><br><span class="line">        GLES20.glDisableVertexAttribArray(texCoordHandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5
id="步骤3androidmanifest配置"><strong>步骤3：AndroidManifest配置</strong></h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明应用需要 OpenGL ES 2.0 支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:glEsVersion</span>=<span class="string">&quot;0x00020000&quot;</span> <span class="attr">android:required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<hr />
<h3
id="方式2使用surfaceview-自己构建egl环境"><strong>方式2：使用SurfaceView
+ 自己构建EGL环境</strong></h3>
<p>这种方式需要手动管理 EGL
和渲染线程，提供更高的灵活性，适合复杂场景。</p>
<h4 id="流程概述-1"><strong>流程概述</strong></h4>
<ol type="1">
<li>创建 <code>SurfaceView</code> 并监听表面变化。</li>
<li>初始化 EGL（显示、上下文、表面）。</li>
<li>在独立线程中运行渲染循环。</li>
<li>编写着色器并绘制图形。</li>
<li>清理资源。</li>
<li><strong>新增</strong>：使用矩阵变换实现旋转，添加纹理映射渲染图片。</li>
</ol>
<h4 id="关键代码片段-1"><strong>关键代码片段</strong></h4>
<h5
id="步骤1创建surfaceview和渲染线程"><strong>步骤1：创建SurfaceView和渲染线程</strong></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EGLSurfaceView eglSurfaceView; <span class="comment">// 自定义 SurfaceView，用于手动管理 EGL</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 创建自定义 SurfaceView</span></span><br><span class="line">        eglSurfaceView = <span class="keyword">new</span> <span class="title class_">EGLSurfaceView</span>(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 设置为 Activity 的内容视图</span></span><br><span class="line">        setContentView(eglSurfaceView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EGLSurfaceView</span> <span class="keyword">extends</span> <span class="title class_">SurfaceView</span> <span class="keyword">implements</span> <span class="title class_">SurfaceHolder</span>.Callback &#123;</span><br><span class="line">    <span class="keyword">private</span> RenderThread renderThread; <span class="comment">// 渲染线程对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EGLSurfaceView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">        <span class="comment">// 为 SurfaceHolder 添加回调，监听表面生命周期</span></span><br><span class="line">        getHolder().addCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">        <span class="comment">// 表面创建时，启动渲染线程</span></span><br><span class="line">        renderThread = <span class="keyword">new</span> <span class="title class_">RenderThread</span>(holder, getContext());</span><br><span class="line">        renderThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="type">int</span> format, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// 表面大小改变时，更新渲染线程的宽高</span></span><br><span class="line">        renderThread.setSize(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">        <span class="comment">// 表面销毁时，停止渲染线程</span></span><br><span class="line">        renderThread.stopRendering();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5
id="步骤2构建egl环境和渲染线程含矩阵变换和纹理映射"><strong>步骤2：构建EGL环境和渲染线程（含矩阵变换和纹理映射）</strong></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</span><br><span class="line"><span class="keyword">import</span> android.opengl.GLES20;</span><br><span class="line"><span class="keyword">import</span> android.opengl.GLUtils;</span><br><span class="line"><span class="keyword">import</span> android.opengl.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.view.SurfaceHolder;</span><br><span class="line"><span class="keyword">import</span> android.opengl.EGL14;</span><br><span class="line"><span class="keyword">import</span> android.opengl.EGLConfig;</span><br><span class="line"><span class="keyword">import</span> android.opengl.EGLContext;</span><br><span class="line"><span class="keyword">import</span> android.opengl.EGLDisplay;</span><br><span class="line"><span class="keyword">import</span> android.opengl.EGLSurface;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder;</span><br><span class="line"><span class="keyword">import</span> java.nio.FloatBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RenderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SurfaceHolder surfaceHolder; <span class="comment">// SurfaceView 的表面持有者</span></span><br><span class="line">    <span class="keyword">private</span> EGLDisplay eglDisplay; <span class="comment">// EGL 显示对象</span></span><br><span class="line">    <span class="keyword">private</span> EGLContext eglContext; <span class="comment">// EGL 上下文对象</span></span><br><span class="line">    <span class="keyword">private</span> EGLSurface eglSurface; <span class="comment">// EGL 表面对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width, height; <span class="comment">// 渲染表面宽高</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 控制渲染循环的标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> program; <span class="comment">// OpenGL 程序对象</span></span><br><span class="line">    <span class="keyword">private</span> FloatBuffer vertexBuffer; <span class="comment">// 顶点数据缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> FloatBuffer textureBuffer; <span class="comment">// 纹理坐标缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> textureId; <span class="comment">// 纹理 ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context context; <span class="comment">// 用于加载图片资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span>[] mvpMatrix = <span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">16</span>]; <span class="comment">// 模型-视图-投影矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">angle</span> <span class="operator">=</span> <span class="number">0.0f</span>; <span class="comment">// 旋转角度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义矩形顶点坐标 (x, y, z)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span>[] rectCoords = &#123;</span><br><span class="line">        -<span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左上</span></span><br><span class="line">        -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下</span></span><br><span class="line">         <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 右下</span></span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// 右上</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义纹理坐标 (s, t)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span>[] textureCoords = &#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左上</span></span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 左下</span></span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 右下</span></span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">0.0f</span>  <span class="comment">// 右上</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RenderThread</span><span class="params">(SurfaceHolder holder, Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.surfaceHolder = holder; <span class="comment">// 初始化时传入 SurfaceHolder</span></span><br><span class="line">        <span class="built_in">this</span>.context = context; <span class="comment">// 初始化时传入 Context</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置渲染表面的宽高</span></span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="comment">// 设置正交投影矩阵</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">aspectRatio</span> <span class="operator">=</span> (<span class="type">float</span>) width / height;</span><br><span class="line">        Matrix.setIdentityM(mvpMatrix, <span class="number">0</span>);</span><br><span class="line">        Matrix.orthoM(mvpMatrix, <span class="number">0</span>, -aspectRatio, aspectRatio, -<span class="number">1.0f</span>, <span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopRendering</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 停止渲染循环</span></span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程主循环</span></span><br><span class="line">        initEGL(); <span class="comment">// 初始化 EGL 环境</span></span><br><span class="line">        initGL(); <span class="comment">// 初始化 OpenGL 环境</span></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            drawFrame(); <span class="comment">// 绘制一帧</span></span><br><span class="line">            EGL14.eglSwapBuffers(eglDisplay, eglSurface); <span class="comment">// 交换缓冲区，显示渲染结果</span></span><br><span class="line">            <span class="comment">// 更新旋转角度</span></span><br><span class="line">            angle += <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">if</span> (angle &gt;= <span class="number">360.0f</span>) angle = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cleanup(); <span class="comment">// 清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initEGL</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取默认显示设备（通常是屏幕）</span></span><br><span class="line">        eglDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);</span><br><span class="line">        <span class="comment">// 初始化 EGL，返回主次版本号</span></span><br><span class="line">        <span class="type">int</span>[] version = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        EGL14.eglInitialize(eglDisplay, version, <span class="number">0</span>, version, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置 EGL 属性，支持 OpenGL ES 2.0 和 RGB8 颜色</span></span><br><span class="line">        <span class="type">int</span>[] configAttribs = &#123;</span><br><span class="line">            EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT, <span class="comment">// 支持 OpenGL ES 2.0</span></span><br><span class="line">            EGL14.EGL_RED_SIZE, <span class="number">8</span>,   <span class="comment">// 红色分量 8 位</span></span><br><span class="line">            EGL14.EGL_GREEN_SIZE, <span class="number">8</span>, <span class="comment">// 绿色分量 8 位</span></span><br><span class="line">            EGL14.EGL_BLUE_SIZE, <span class="number">8</span>,  <span class="comment">// 蓝色分量 8 位</span></span><br><span class="line">            EGL14.EGL_NONE           <span class="comment">// 属性列表结束</span></span><br><span class="line">        &#125;;</span><br><span class="line">        EGLConfig[] configs = <span class="keyword">new</span> <span class="title class_">EGLConfig</span>[<span class="number">1</span>]; <span class="comment">// 存储选择的配置</span></span><br><span class="line">        <span class="type">int</span>[] numConfigs = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>]; <span class="comment">// 存储配置数量</span></span><br><span class="line">        <span class="comment">// 选择符合条件的 EGL 配置</span></span><br><span class="line">        EGL14.eglChooseConfig(eglDisplay, configAttribs, <span class="number">0</span>, configs, <span class="number">0</span>, <span class="number">1</span>, numConfigs, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 EGL 上下文，指定 OpenGL ES 2.0</span></span><br><span class="line">        <span class="type">int</span>[] contextAttribs = &#123; EGL14.EGL_CONTEXT_CLIENT_VERSION, <span class="number">2</span>, EGL14.EGL_NONE &#125;;</span><br><span class="line">        eglContext = EGL14.eglCreateContext(eglDisplay, configs[<span class="number">0</span>], EGL14.EGL_NO_CONTEXT, contextAttribs, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建与 SurfaceHolder 关联的窗口表面</span></span><br><span class="line">        <span class="type">int</span>[] surfaceAttribs = &#123; EGL14.EGL_NONE &#125;;</span><br><span class="line">        eglSurface = EGL14.eglCreateWindowSurface(eglDisplay, configs[<span class="number">0</span>], surfaceHolder, surfaceAttribs, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将 EGL 上下文和表面绑定到当前线程</span></span><br><span class="line">        EGL14.eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initGL</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置 OpenGL 清屏颜色为黑色</span></span><br><span class="line">        GLES20.glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        initShaders(); <span class="comment">// 初始化着色器</span></span><br><span class="line">        initBuffers(); <span class="comment">// 初始化顶点缓冲区</span></span><br><span class="line">        initTexture(); <span class="comment">// 初始化纹理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置视口大小</span></span><br><span class="line">        GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="comment">// 清除颜色缓冲区</span></span><br><span class="line">        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);</span><br><span class="line">        drawTexturedRect(); <span class="comment">// 绘制带纹理的矩形</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initShaders</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义顶点着色器代码，包含矩阵变换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">vertexShaderCode</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;uniform mat4 uMVPMatrix;\n&quot;</span> + <span class="comment">// 模型-视图-投影矩阵</span></span><br><span class="line">            <span class="string">&quot;attribute vec4 aPosition;\n&quot;</span> + <span class="comment">// 输入的顶点位置属性</span></span><br><span class="line">            <span class="string">&quot;attribute vec2 aTexCoord;\n&quot;</span> + <span class="comment">// 输入的纹理坐标属性</span></span><br><span class="line">            <span class="string">&quot;varying vec2 vTexCoord;\n&quot;</span> + <span class="comment">// 传递给片段着色器的纹理坐标</span></span><br><span class="line">            <span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    gl_Position = uMVPMatrix * aPosition;\n&quot;</span> + <span class="comment">// 应用矩阵变换</span></span><br><span class="line">            <span class="string">&quot;    vTexCoord = aTexCoord;\n&quot;</span> + <span class="comment">// 传递纹理坐标</span></span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义片段着色器代码，支持纹理映射</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fragmentShaderCode</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;precision mediump float;\n&quot;</span> + <span class="comment">// 设置中等精度</span></span><br><span class="line">            <span class="string">&quot;varying vec2 vTexCoord;\n&quot;</span> + <span class="comment">// 从顶点着色器接收纹理坐标</span></span><br><span class="line">            <span class="string">&quot;uniform sampler2D uTexture;\n&quot;</span> + <span class="comment">// 纹理采样器</span></span><br><span class="line">            <span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    gl_FragColor = texture2D(uTexture, vTexCoord);\n&quot;</span> + <span class="comment">// 从纹理采样颜色</span></span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译顶点和片段着色器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vertexShader</span> <span class="operator">=</span> loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fragmentShader</span> <span class="operator">=</span> loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderCode);</span><br><span class="line">        <span class="comment">// 创建并链接 OpenGL 程序</span></span><br><span class="line">        program = GLES20.glCreateProgram();</span><br><span class="line">        GLES20.glAttachShader(program, vertexShader);</span><br><span class="line">        GLES20.glAttachShader(program, fragmentShader);</span><br><span class="line">        GLES20.glLinkProgram(program);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">loadShader</span><span class="params">(<span class="type">int</span> type, String shaderCode)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并编译着色器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shader</span> <span class="operator">=</span> GLES20.glCreateShader(type);</span><br><span class="line">        GLES20.glShaderSource(shader, shaderCode);</span><br><span class="line">        GLES20.glCompileShader(shader);</span><br><span class="line">        <span class="keyword">return</span> shader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initBuffers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化顶点缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(rectCoords.length * <span class="number">4</span>);</span><br><span class="line">        bb.order(ByteOrder.nativeOrder());</span><br><span class="line">        vertexBuffer = bb.asFloatBuffer();</span><br><span class="line">        vertexBuffer.put(rectCoords);</span><br><span class="line">        vertexBuffer.position(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化纹理坐标缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">tb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(textureCoords.length * <span class="number">4</span>);</span><br><span class="line">        tb.order(ByteOrder.nativeOrder());</span><br><span class="line">        textureBuffer = tb.asFloatBuffer();</span><br><span class="line">        textureBuffer.put(textureCoords);</span><br><span class="line">        textureBuffer.position(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initTexture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建纹理对象</span></span><br><span class="line">        <span class="type">int</span>[] textures = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        GLES20.glGenTextures(<span class="number">1</span>, textures, <span class="number">0</span>);</span><br><span class="line">        textureId = textures[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定纹理</span></span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);</span><br><span class="line">        <span class="comment">// 设置纹理参数</span></span><br><span class="line">        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载图片（假设在 res/drawable 中有一张图片 texture.png）</span></span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeResource(context.getResources(), android.R.drawable.star_big_on);</span><br><span class="line">        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, bitmap, <span class="number">0</span>); <span class="comment">// 将 Bitmap 上传到纹理</span></span><br><span class="line">        bitmap.recycle(); <span class="comment">// 释放 Bitmap 资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawTexturedRect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用着色器程序并绘制带纹理的矩形</span></span><br><span class="line">        GLES20.glUseProgram(program);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取矩阵、顶点和纹理坐标的句柄</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mvpMatrixHandle</span> <span class="operator">=</span> GLES20.glGetUniformLocation(program, <span class="string">&quot;uMVPMatrix&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">positionHandle</span> <span class="operator">=</span> GLES20.glGetAttribLocation(program, <span class="string">&quot;aPosition&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">texCoordHandle</span> <span class="operator">=</span> GLES20.glGetAttribLocation(program, <span class="string">&quot;aTexCoord&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">textureHandle</span> <span class="operator">=</span> GLES20.glGetUniformLocation(program, <span class="string">&quot;uTexture&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用顶点属性数组</span></span><br><span class="line">        GLES20.glEnableVertexAttribArray(positionHandle);</span><br><span class="line">        GLES20.glEnableVertexAttribArray(texCoordHandle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置顶点数据</span></span><br><span class="line">        GLES20.glVertexAttribPointer(positionHandle, <span class="number">3</span>, GLES20.GL_FLOAT, <span class="literal">false</span>, <span class="number">0</span>, vertexBuffer);</span><br><span class="line">        <span class="comment">// 设置纹理坐标数据</span></span><br><span class="line">        GLES20.glVertexAttribPointer(texCoordHandle, <span class="number">2</span>, GLES20.GL_FLOAT, <span class="literal">false</span>, <span class="number">0</span>, textureBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用旋转矩阵</span></span><br><span class="line">        <span class="type">float</span>[] rotationMatrix = <span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">16</span>];</span><br><span class="line">        Matrix.setIdentityM(rotationMatrix, <span class="number">0</span>);</span><br><span class="line">        Matrix.rotateM(rotationMatrix, <span class="number">0</span>, angle, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// 绕 Z 轴旋转</span></span><br><span class="line">        <span class="type">float</span>[] finalMatrix = <span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">16</span>];</span><br><span class="line">        Matrix.multiplyMM(finalMatrix, <span class="number">0</span>, mvpMatrix, <span class="number">0</span>, rotationMatrix, <span class="number">0</span>); <span class="comment">// 组合投影和旋转矩阵</span></span><br><span class="line">        GLES20.glUniformMatrix4fv(mvpMatrixHandle, <span class="number">1</span>, <span class="literal">false</span>, finalMatrix, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定纹理</span></span><br><span class="line">        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);</span><br><span class="line">        GLES20.glUniform1i(textureHandle, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制矩形（使用三角形条带）</span></span><br><span class="line">        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_FAN, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁用顶点属性数组</span></span><br><span class="line">        GLES20.glDisableVertexAttribArray(positionHandle);</span><br><span class="line">        GLES20.glDisableVertexAttribArray(texCoordHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 清理 EGL 资源</span></span><br><span class="line">        EGL14.eglMakeCurrent(eglDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_CONTEXT);</span><br><span class="line">        EGL14.eglDestroySurface(eglDisplay, eglSurface); <span class="comment">// 销毁表面</span></span><br><span class="line">        EGL14.eglDestroyContext(eglDisplay, eglContext); <span class="comment">// 销毁上下文</span></span><br><span class="line">        EGL14.eglTerminate(eglDisplay); <span class="comment">// 终止 EGL 显示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5
id="步骤3androidmanifest配置-1"><strong>步骤3：AndroidManifest配置</strong></h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明需要 OpenGL ES 2.0 支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:glEsVersion</span>=<span class="string">&quot;0x00020000&quot;</span> <span class="attr">android:required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="两种方式对比"><strong>两种方式对比</strong></h3>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>GLSurfaceView</th>
<th>SurfaceView + EGL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>易用性</strong></td>
<td>高，封装完善</td>
<td>低，手动管理</td>
</tr>
<tr class="even">
<td><strong>灵活性</strong></td>
<td>较低，受限于封装</td>
<td>高，可自定义EGL和线程</td>
</tr>
<tr class="odd">
<td><strong>代码量</strong></td>
<td>较少</td>
<td>较多</td>
</tr>
<tr class="even">
<td><strong>适用场景</strong></td>
<td>简单2D/3D渲染</td>
<td>复杂渲染或多上下文需求</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="新增功能说明"><strong>新增功能说明</strong></h3>
<h4 id="矩阵变换"><strong>矩阵变换</strong></h4>
<ul>
<li><strong>实现</strong>：在顶点着色器中添加
<code>uniform mat4 uMVPMatrix</code>，用于接收模型-视图-投影矩阵。</li>
<li><strong>旋转效果</strong>：
<ul>
<li>使用 <code>Matrix.rotateM</code> 实现绕 Z 轴的旋转，角度
<code>angle</code> 在每帧递增。</li>
<li>在 <code>onSurfaceChanged</code>
中初始化正交投影矩阵，结合旋转矩阵生成最终变换矩阵。</li>
</ul></li>
<li><strong>应用</strong>：通过 <code>glUniformMatrix4fv</code>
传递矩阵到着色器，顶点位置经过变换后渲染。</li>
</ul>
<h4 id="纹理映射"><strong>纹理映射</strong></h4>
<ul>
<li><strong>顶点和纹理坐标</strong>：
<ul>
<li>将三角形改为矩形，使用 <code>GL_TRIANGLE_FAN</code> 绘制。</li>
<li>添加纹理坐标缓冲区，映射到矩形的四个顶点。</li>
</ul></li>
<li><strong>纹理加载</strong>：
<ul>
<li>在 <code>initTexture</code> 中加载一张图片（这里使用系统资源
<code>star_big_on</code> 作为示例）。</li>
<li>使用 <code>GLUtils.texImage2D</code> 将 Bitmap 上传到 OpenGL
纹理。</li>
</ul></li>
<li><strong>着色器支持</strong>：
<ul>
<li>顶点着色器传递纹理坐标给片段着色器。</li>
<li>片段着色器使用 <code>sampler2D</code> 从纹理采样颜色。</li>
</ul></li>
<li><strong>渲染</strong>：
<ul>
<li>在 <code>drawTexturedRect</code> 中绑定纹理并绘制。</li>
</ul></li>
</ul>
<h4 id="运行效果"><strong>运行效果</strong></h4>
<ul>
<li>两种方式都会渲染一个旋转的矩形，矩形上贴有一张纹理图片（例如星星）。</li>
<li>GLSurfaceView 使用内置渲染线程，SurfaceView + EGL
使用自定义线程。</li>
</ul>
<h2 id="android-使用-camerax-采集-glsurfaceview-渲染">Android 使用
CameraX 采集 GLSurfaceView 渲染</h2>
<h3 id="流程概述-2"><strong>流程概述</strong></h3>
<ol type="1">
<li><strong>配置 CameraX</strong>：使用 CameraX 绑定摄像头预览，输出到
<code>SurfaceTexture</code>。</li>
<li><strong>设置 GLSurfaceView</strong>：创建并配置 GLSurfaceView，使用
OpenGL ES 渲染纹理。</li>
<li><strong>处理纹理</strong>：将 CameraX 提供的
<code>SurfaceTexture</code> 数据转换为 OpenGL 纹理。</li>
<li><strong>添加滤镜</strong>：在片段着色器中实现灰度滤镜。</li>
<li><strong>调整方向</strong>：根据设备方向动态调整纹理坐标。</li>
<li><strong>渲染到屏幕</strong>：在 GLSurfaceView 的 Renderer
中绘制纹理。</li>
<li><strong>管理生命周期</strong>：确保 CameraX 和 GLSurfaceView 与
Activity 生命周期同步。</li>
</ol>
<hr />
<h3 id="前置条件"><strong>前置条件</strong></h3>
<ul>
<li><p>在 <code>build.gradle</code> 中添加 CameraX 依赖：
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.camera:camera-core:1.3.2&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-camera2:1.3.2&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-lifecycle:1.3.2&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>在 <code>AndroidManifest.xml</code> 中添加权限：
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:glEsVersion</span>=<span class="string">&quot;0x00020000&quot;</span> <span class="attr">android:required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h3 id="关键代码片段-2"><strong>关键代码片段</strong></h3>
<h4
id="步骤1activity-配置-camerax-和-glsurfaceview"><strong>步骤1：Activity
配置 CameraX 和 GLSurfaceView</strong></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.Manifest;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> androidx.camera.core.Camera;</span><br><span class="line"><span class="keyword">import</span> androidx.camera.core.CameraSelector;</span><br><span class="line"><span class="keyword">import</span> androidx.camera.core.Preview;</span><br><span class="line"><span class="keyword">import</span> androidx.camera.lifecycle.ProcessCameraProvider;</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat;</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.ContextCompat;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.ListenableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> GLSurfaceView glSurfaceView; <span class="comment">// GLSurfaceView 用于显示 OpenGL 渲染结果</span></span><br><span class="line">    <span class="keyword">private</span> CameraRenderer cameraRenderer; <span class="comment">// 自定义 Renderer，处理摄像头纹理渲染</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST_CAMERA_PERMISSION</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 权限请求码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 GLSurfaceView</span></span><br><span class="line">        glSurfaceView = <span class="keyword">new</span> <span class="title class_">GLSurfaceView</span>(<span class="built_in">this</span>);</span><br><span class="line">        glSurfaceView.setEGLContextClientVersion(<span class="number">2</span>); <span class="comment">// 设置 OpenGL ES 2.0</span></span><br><span class="line">        cameraRenderer = <span class="keyword">new</span> <span class="title class_">CameraRenderer</span>(<span class="built_in">this</span>); <span class="comment">// 创建渲染器实例</span></span><br><span class="line">        glSurfaceView.setRenderer(cameraRenderer); <span class="comment">// 设置渲染器</span></span><br><span class="line">        setContentView(glSurfaceView); <span class="comment">// 设置为 Activity 的视图</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并请求摄像头权限</span></span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.CAMERA) </span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(<span class="built_in">this</span>, </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.CAMERA&#125;, </span><br><span class="line">                    REQUEST_CAMERA_PERMISSION);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startCamera(); <span class="comment">// 已授权，直接启动摄像头</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequestPermissionsResult</span><span class="params">(<span class="type">int</span> requestCode, String[] permissions, <span class="type">int</span>[] grantResults)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CAMERA_PERMISSION &amp;&amp; grantResults.length &gt; <span class="number">0</span> </span><br><span class="line">                &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            startCamera(); <span class="comment">// 权限通过后启动摄像头</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startCamera</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 CameraX 的 ProcessCameraProvider 实例</span></span><br><span class="line">        ListenableFuture&lt;ProcessCameraProvider&gt; cameraProviderFuture = </span><br><span class="line">                ProcessCameraProvider.getInstance(<span class="built_in">this</span>);</span><br><span class="line">        cameraProviderFuture.addListener(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ProcessCameraProvider</span> <span class="variable">cameraProvider</span> <span class="operator">=</span> cameraProviderFuture.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 配置预览用例</span></span><br><span class="line">                <span class="type">Preview</span> <span class="variable">preview</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Preview</span>.Builder().build();</span><br><span class="line">                <span class="comment">// 将预览输出绑定到 SurfaceTexture，由 Renderer 提供</span></span><br><span class="line">                preview.setSurfaceProvider(cameraRenderer.getSurfaceProvider());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 选择后置摄像头</span></span><br><span class="line">                <span class="type">CameraSelector</span> <span class="variable">cameraSelector</span> <span class="operator">=</span> CameraSelector.DEFAULT_BACK_CAMERA;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 绑定摄像头生命周期</span></span><br><span class="line">                cameraProvider.unbindAll(); <span class="comment">// 先解绑所有用例</span></span><br><span class="line">                <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> cameraProvider.bindToLifecycle(</span><br><span class="line">                        <span class="built_in">this</span>, cameraSelector, preview); <span class="comment">// 绑定预览到 Activity 生命周期</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ContextCompat.getMainExecutor(<span class="built_in">this</span>)); <span class="comment">// 在主线程执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        glSurfaceView.onPause(); <span class="comment">// 暂停 GLSurfaceView 渲染</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        glSurfaceView.onResume(); <span class="comment">// 恢复 GLSurfaceView 渲染</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="步骤2实现-camerarenderer含滤镜和方向调整"><strong>步骤2：实现
CameraRenderer（含滤镜和方向调整）</strong></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.SurfaceTexture;</span><br><span class="line"><span class="keyword">import</span> android.opengl.GLES11Ext;</span><br><span class="line"><span class="keyword">import</span> android.opengl.GLES20;</span><br><span class="line"><span class="keyword">import</span> android.opengl.GLSurfaceView;</span><br><span class="line"><span class="keyword">import</span> android.view.Display;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager;</span><br><span class="line"><span class="keyword">import</span> androidx.camera.core.Preview;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder;</span><br><span class="line"><span class="keyword">import</span> java.nio.FloatBuffer;</span><br><span class="line"><span class="keyword">import</span> javax.microedition.khronos.egl.EGLConfig;</span><br><span class="line"><span class="keyword">import</span> javax.microedition.khronos.opengles.GL10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CameraRenderer</span> <span class="keyword">implements</span> <span class="title class_">GLSurfaceView</span>.Renderer &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> SurfaceTexture surfaceTexture; <span class="comment">// 从 CameraX 接收图像数据的 SurfaceTexture</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> textureId; <span class="comment">// OpenGL 纹理 ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> program; <span class="comment">// OpenGL 着色器程序</span></span><br><span class="line">    <span class="keyword">private</span> FloatBuffer vertexBuffer; <span class="comment">// 顶点坐标缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> FloatBuffer textureBuffer; <span class="comment">// 纹理坐标缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enableGrayscale</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 是否启用灰度滤镜，默认为 true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">rotation</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 设备旋转角度 (0, 90, 180, 270)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全屏矩形的顶点坐标 (x, y, z)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span>[] vertices = &#123;</span><br><span class="line">        -<span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左上</span></span><br><span class="line">        -<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下</span></span><br><span class="line">         <span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 右下</span></span><br><span class="line">         <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>  <span class="comment">// 右上</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基础纹理坐标 (s, t)，后续根据方向调整</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span>[] baseTextureCoords = &#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左上</span></span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 左下</span></span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 右下</span></span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">0.0f</span>  <span class="comment">// 右上</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CameraRenderer</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">        <span class="comment">// 初始化顶点缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">vb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(vertices.length * <span class="number">4</span>);</span><br><span class="line">        vb.order(ByteOrder.nativeOrder());</span><br><span class="line">        vertexBuffer = vb.asFloatBuffer();</span><br><span class="line">        vertexBuffer.put(vertices);</span><br><span class="line">        vertexBuffer.position(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化纹理坐标缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">tb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(baseTextureCoords.length * <span class="number">4</span>);</span><br><span class="line">        tb.order(ByteOrder.nativeOrder());</span><br><span class="line">        textureBuffer = tb.asFloatBuffer();</span><br><span class="line">        updateTextureCoords(); <span class="comment">// 根据初始方向设置纹理坐标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置清屏颜色为黑色</span></span><br><span class="line">        GLES20.glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// 初始化着色器程序</span></span><br><span class="line">        initShaders();</span><br><span class="line">        <span class="comment">// 创建并绑定外部纹理 (OES 纹理，用于摄像头数据)</span></span><br><span class="line">        textureId = createTexture();</span><br><span class="line">        <span class="comment">// 将 SurfaceTexture 与 OpenGL 纹理绑定</span></span><br><span class="line">        surfaceTexture = <span class="keyword">new</span> <span class="title class_">SurfaceTexture</span>(textureId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置视口大小</span></span><br><span class="line">        GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="comment">// 更新设备旋转角度</span></span><br><span class="line">        updateRotation();</span><br><span class="line">        updateTextureCoords(); <span class="comment">// 根据旋转调整纹理坐标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawFrame</span><span class="params">(GL10 gl)</span> &#123;</span><br><span class="line">        <span class="comment">// 清除颜色缓冲区</span></span><br><span class="line">        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">// 更新 SurfaceTexture 中的摄像头数据</span></span><br><span class="line">        surfaceTexture.updateTexImage();</span><br><span class="line">        <span class="comment">// 使用着色器程序</span></span><br><span class="line">        GLES20.glUseProgram(program);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取顶点位置和纹理坐标的句柄</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">positionHandle</span> <span class="operator">=</span> GLES20.glGetAttribLocation(program, <span class="string">&quot;aPosition&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">textureCoordHandle</span> <span class="operator">=</span> GLES20.glGetAttribLocation(program, <span class="string">&quot;aTextureCoord&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">textureHandle</span> <span class="operator">=</span> GLES20.glGetUniformLocation(program, <span class="string">&quot;uTexture&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">grayscaleHandle</span> <span class="operator">=</span> GLES20.glGetUniformLocation(program, <span class="string">&quot;uGrayscale&quot;</span>); <span class="comment">// 灰度开关句柄</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用顶点属性</span></span><br><span class="line">        GLES20.glEnableVertexAttribArray(positionHandle);</span><br><span class="line">        GLES20.glEnableVertexAttribArray(textureCoordHandle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置顶点数据</span></span><br><span class="line">        GLES20.glVertexAttribPointer(positionHandle, <span class="number">3</span>, GLES20.GL_FLOAT, <span class="literal">false</span>, <span class="number">0</span>, vertexBuffer);</span><br><span class="line">        <span class="comment">// 设置纹理坐标数据</span></span><br><span class="line">        GLES20.glVertexAttribPointer(textureCoordHandle, <span class="number">2</span>, GLES20.GL_FLOAT, <span class="literal">false</span>, <span class="number">0</span>, textureBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定纹理</span></span><br><span class="line">        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line">        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textureId);</span><br><span class="line">        GLES20.glUniform1i(textureHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置灰度滤镜开关</span></span><br><span class="line">        GLES20.glUniform1i(grayscaleHandle, enableGrayscale ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制矩形（两个三角形组成）</span></span><br><span class="line">        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_FAN, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁用顶点属性</span></span><br><span class="line">        GLES20.glDisableVertexAttribArray(positionHandle);</span><br><span class="line">        GLES20.glDisableVertexAttribArray(textureCoordHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">createTexture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建外部 OES 纹理</span></span><br><span class="line">        <span class="type">int</span>[] textures = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        GLES20.glGenTextures(<span class="number">1</span>, textures, <span class="number">0</span>);</span><br><span class="line">        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textures[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 设置纹理参数</span></span><br><span class="line">        GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">        GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">        GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">        GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">        <span class="keyword">return</span> textures[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initShaders</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 顶点着色器代码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">vertexShaderCode</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;attribute vec4 aPosition;\n&quot;</span> + <span class="comment">// 顶点位置属性</span></span><br><span class="line">            <span class="string">&quot;attribute vec2 aTextureCoord;\n&quot;</span> + <span class="comment">// 纹理坐标属性</span></span><br><span class="line">            <span class="string">&quot;varying vec2 vTextureCoord;\n&quot;</span> + <span class="comment">// 传递给片段着色器的纹理坐标</span></span><br><span class="line">            <span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    gl_Position = aPosition;\n&quot;</span> + <span class="comment">// 设置顶点位置</span></span><br><span class="line">            <span class="string">&quot;    vTextureCoord = aTextureCoord;\n&quot;</span> + <span class="comment">// 传递纹理坐标</span></span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 片段着色器代码，支持外部 OES 纹理和灰度滤镜</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fragmentShaderCode</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;#extension GL_OES_EGL_image_external : require\n&quot;</span> + <span class="comment">// 启用 OES 纹理扩展</span></span><br><span class="line">            <span class="string">&quot;precision mediump float;\n&quot;</span> + <span class="comment">// 设置中等精度</span></span><br><span class="line">            <span class="string">&quot;varying vec2 vTextureCoord;\n&quot;</span> + <span class="comment">// 从顶点着色器接收纹理坐标</span></span><br><span class="line">            <span class="string">&quot;uniform samplerExternalOES uTexture;\n&quot;</span> + <span class="comment">// 外部纹理采样器</span></span><br><span class="line">            <span class="string">&quot;uniform int uGrayscale;\n&quot;</span> + <span class="comment">// 灰度滤镜开关 (0: 关闭, 1: 开启)</span></span><br><span class="line">            <span class="string">&quot;void main() &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    vec4 color = texture2D(uTexture, vTextureCoord);\n&quot;</span> + <span class="comment">// 从纹理采样颜色</span></span><br><span class="line">            <span class="string">&quot;    if (uGrayscale == 1) &#123;\n&quot;</span> + </span><br><span class="line">            <span class="string">&quot;        float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));\n&quot;</span> + <span class="comment">// 计算灰度值</span></span><br><span class="line">            <span class="string">&quot;        gl_FragColor = vec4(gray, gray, gray, color.a);\n&quot;</span> + <span class="comment">// 应用灰度滤镜</span></span><br><span class="line">            <span class="string">&quot;    &#125; else &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        gl_FragColor = color;\n&quot;</span> + <span class="comment">// 保持原始颜色</span></span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译顶点和片段着色器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vertexShader</span> <span class="operator">=</span> loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fragmentShader</span> <span class="operator">=</span> loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并链接程序</span></span><br><span class="line">        program = GLES20.glCreateProgram();</span><br><span class="line">        GLES20.glAttachShader(program, vertexShader);</span><br><span class="line">        GLES20.glAttachShader(program, fragmentShader);</span><br><span class="line">        GLES20.glLinkProgram(program);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">loadShader</span><span class="params">(<span class="type">int</span> type, String shaderCode)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并编译着色器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shader</span> <span class="operator">=</span> GLES20.glCreateShader(type);</span><br><span class="line">        GLES20.glShaderSource(shader, shaderCode);</span><br><span class="line">        GLES20.glCompileShader(shader);</span><br><span class="line">        <span class="keyword">return</span> shader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Preview.SurfaceProvider <span class="title function_">getSurfaceProvider</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 提供 SurfaceTexture 给 CameraX</span></span><br><span class="line">        <span class="keyword">return</span> request -&gt; &#123;</span><br><span class="line">            android.util.<span class="type">Size</span> <span class="variable">resolution</span> <span class="operator">=</span> request.getResolution();</span><br><span class="line">            surfaceTexture.setDefaultBufferSize(resolution.getWidth(), resolution.getHeight());</span><br><span class="line">            request.provideSurface(<span class="keyword">new</span> <span class="title class_">android</span>.view.Surface(surfaceTexture), </span><br><span class="line">                    ContextCompat.getMainExecutor(context), result -&gt; &#123;&#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRotation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取设备当前旋转角度</span></span><br><span class="line">        <span class="type">WindowManager</span> <span class="variable">windowManager</span> <span class="operator">=</span> (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        <span class="type">Display</span> <span class="variable">display</span> <span class="operator">=</span> windowManager.getDefaultDisplay();</span><br><span class="line">        rotation = display.getRotation() * <span class="number">90</span>; <span class="comment">// 转换为 0, 90, 180, 270</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateTextureCoords</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 根据设备旋转角度调整纹理坐标</span></span><br><span class="line">        <span class="type">float</span>[] adjustedCoords = <span class="keyword">new</span> <span class="title class_">float</span>[baseTextureCoords.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">s</span> <span class="operator">=</span> baseTextureCoords[i * <span class="number">2</span>];</span><br><span class="line">            <span class="type">float</span> <span class="variable">t</span> <span class="operator">=</span> baseTextureCoords[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">switch</span> (rotation) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 正常方向</span></span><br><span class="line">                    adjustedCoords[i * <span class="number">2</span>] = s;</span><br><span class="line">                    adjustedCoords[i * <span class="number">2</span> + <span class="number">1</span>] = t;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">90</span>: <span class="comment">// 顺时针旋转 90 度</span></span><br><span class="line">                    adjustedCoords[i * <span class="number">2</span>] = <span class="number">1.0f</span> - t;</span><br><span class="line">                    adjustedCoords[i * <span class="number">2</span> + <span class="number">1</span>] = s;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">180</span>: <span class="comment">// 旋转 180 度</span></span><br><span class="line">                    adjustedCoords[i * <span class="number">2</span>] = <span class="number">1.0f</span> - s;</span><br><span class="line">                    adjustedCoords[i * <span class="number">2</span> + <span class="number">1</span>] = <span class="number">1.0f</span> - t;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">270</span>: <span class="comment">// 顺时针旋转 270 度</span></span><br><span class="line">                    adjustedCoords[i * <span class="number">2</span>] = t;</span><br><span class="line">                    adjustedCoords[i * <span class="number">2</span> + <span class="number">1</span>] = <span class="number">1.0f</span> - s;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新纹理缓冲区</span></span><br><span class="line">        textureBuffer.clear();</span><br><span class="line">        textureBuffer.put(adjustedCoords);</span><br><span class="line">        textureBuffer.position(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：外部调用以切换滤镜状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toggleGrayscale</span><span class="params">(<span class="type">boolean</span> enable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.enableGrayscale = enable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="代码详细说明"><strong>代码详细说明</strong></h3>
<h4 id="mainactivity"><strong>MainActivity</strong></h4>
<ul>
<li><strong>GLSurfaceView 初始化</strong>：创建 GLSurfaceView
并绑定自定义 <code>CameraRenderer</code>。</li>
<li><strong>CameraX 配置</strong>：
<ul>
<li>使用 <code>ProcessCameraProvider</code> 获取摄像头实例。</li>
<li>配置 <code>Preview</code> 用例，将输出绑定到
<code>CameraRenderer</code> 提供的 <code>SurfaceTexture</code>。</li>
<li>通过 <code>CameraSelector</code> 选择后置摄像头。</li>
<li>将摄像头绑定到 Activity 的生命周期。</li>
</ul></li>
<li><strong>权限管理</strong>：动态请求摄像头权限。</li>
<li><strong>生命周期管理</strong>：同步 GLSurfaceView
的暂停和恢复。</li>
</ul>
<h4 id="camerarenderer"><strong>CameraRenderer</strong></h4>
<ul>
<li><strong>顶点和纹理坐标</strong>：
<ul>
<li>定义一个全屏矩形（由两个三角形组成），使用
<code>GL_TRIANGLE_FAN</code> 绘制。</li>
<li>纹理坐标通过 <code>updateTextureCoords()</code>
根据设备旋转动态调整。</li>
</ul></li>
<li><strong>SurfaceTexture</strong>：
<ul>
<li>在 <code>onSurfaceCreated</code> 中创建并绑定到 OpenGL 的 OES
纹理。</li>
<li>通过 <code>updateTexImage()</code> 更新每一帧的摄像头数据。</li>
</ul></li>
<li><strong>着色器</strong>：
<ul>
<li><strong>顶点着色器</strong>：传递位置和纹理坐标。</li>
<li><strong>片段着色器</strong>：支持灰度滤镜，通过
<code>uGrayscale</code>
控制是否应用。灰度计算使用标准公式：<code>gray = 0.299R + 0.587G + 0.114B</code>。</li>
</ul></li>
<li><strong>渲染流程</strong>：
<ul>
<li><code>onDrawFrame</code> 中更新纹理、绑定数据并绘制矩形。</li>
<li>通过 Uniform 变量 <code>uGrayscale</code> 控制滤镜开关。</li>
</ul></li>
<li><strong>方向调整</strong>：
<ul>
<li><code>updateRotation()</code> 获取设备旋转角度。</li>
<li><code>updateTextureCoords()</code>
根据旋转角度调整纹理坐标，确保图像方向正确。</li>
</ul></li>
<li><strong>滤镜控制</strong>：
<ul>
<li>添加 <code>toggleGrayscale()</code>
方法，允许外部切换滤镜状态（默认启用灰度）。</li>
</ul></li>
</ul>
<hr />
<h3 id="运行效果-1"><strong>运行效果</strong></h3>
<ul>
<li>启动应用后，GLSurfaceView 显示后置摄像头的实时预览图像。</li>
<li><strong>方向调整</strong>：图像会根据设备旋转自动调整为正确方向。</li>
<li><strong>滤镜效果</strong>：默认显示灰度图像，可通过调用
<code>cameraRenderer.toggleGrayscale(false)</code> 切换为彩色。</li>
</ul>
<hr />
<h3 id="注意事项"><strong>注意事项</strong></h3>
<ol type="1">
<li><strong>性能</strong>：确保 <code>SurfaceTexture</code>
的分辨率与摄像头输出匹配，避免性能问题。</li>
<li><strong>方向调整</strong>：纹理坐标调整基于后置摄像头，针对前置摄像头可能需要镜像处理。</li>
<li><strong>滤镜扩展</strong>：灰度滤镜只是示例，可修改片段着色器实现其他效果（如亮度、对比度调整）。</li>
<li><strong>错误检查</strong>：实际开发中可添加 OpenGL 错误检查（如
<code>GLES20.glGetError()</code>）。</li>
</ol>
<hr />
<h3 id="扩展建议"><strong>扩展建议</strong></h3>
<ul>
<li><strong>更多滤镜</strong>：可添加 Uniform
变量控制亮度、对比度等，或实现边缘检测等复杂效果。</li>
<li><strong>动态切换</strong>：通过 UI 按钮调用
<code>toggleGrayscale()</code>，实现实时切换。</li>
<li><strong>前置摄像头支持</strong>：调整纹理坐标以支持前置摄像头的镜像效果。</li>
</ul>
]]></content>
      <categories>
        <category>音视频</category>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title>RxJava 语法速览</title>
    <url>/Android/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/RxJava/RxJava-%E8%AF%AD%E6%B3%95%E9%80%9F%E8%A7%88.html</url>
    <content><![CDATA[<h1 id="创建操作符creating-observables">📦 1. 创建操作符（Creating
Observables）</h1>
<h2 id="just---发射固定的数据序列"><code>just</code> -
发射固定的数据序列</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fromarray-fromiterable"><code>fromArray</code> /
<code>fromIterable</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.fromArray(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="create---手动发射"><code>create</code> - 手动发射</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.ObservableEmitter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> observable = Observable.create&lt;String&gt; &#123; emitter: ObservableEmitter&lt;String&gt; -&gt;</span><br><span class="line">        emitter.onNext(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        emitter.onNext(<span class="string">&quot;RxJava&quot;</span>)</span><br><span class="line">        emitter.onComplete()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    observable.subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="转换操作符transforming-observables">🔄 2.
转换操作符（Transforming Observables）</h1>
<h2 id="map"><code>map</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .map &#123; it * <span class="number">10</span> &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="flatmap"><code>flatMap</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">        .flatMap &#123; letter -&gt; Observable.just(<span class="string">&quot;<span class="variable">$letter</span>-1&quot;</span>, <span class="string">&quot;<span class="variable">$letter</span>-2&quot;</span>) &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="concatmap保持顺序"><code>concatMap</code>（保持顺序）</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">        .concatMap &#123; letter -&gt; Observable.just(<span class="string">&quot;<span class="variable">$letter</span>-1&quot;</span>, <span class="string">&quot;<span class="variable">$letter</span>-2&quot;</span>) &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="过滤操作符filtering">🎛️ 3. 过滤操作符（Filtering）</h1>
<h2 id="filter"><code>filter</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="take-skip"><code>take</code>, <code>skip</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="distinct-distinctuntilchanged"><code>distinct</code>,
<code>distinctUntilChanged</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .distinctUntilChanged()</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="时间相关操作符">⏱️ 4. 时间相关操作符</h1>
<h2 id="interval-timer"><code>interval</code>, <code>timer</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .take(<span class="number">3</span>)</span><br><span class="line">        .subscribe &#123; println(<span class="string">&quot;Tick <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">4000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="组合操作符combining-observables">📋 5. 组合操作符（Combining
Observables）</h1>
<h2 id="merge-concat"><code>merge</code>, <code>concat</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> o1 = Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> o2 = Observable.just(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Observable.merge(o1, o2)</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="zip"><code>zip</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> o1 = Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> o2 = Observable.just(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Observable.zip(o1, o2) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span><span class="variable">$b</span>&quot;</span> &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="重试与重复">🔁 6. 重试与重复</h1>
<h2 id="repeat-retry"><code>repeat</code>, <code>retry</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        .repeat(<span class="number">3</span>)</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="线程调度schedulers">🧵 7. 线程调度（Schedulers）</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.schedulers.Schedulers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(Schedulers.computation())</span><br><span class="line">        .subscribe &#123; println(<span class="string">&quot;Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>, Value: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="观察者写法observer-consumer">✅ 8. 观察者写法（Observer /
Consumer）</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observer</span><br><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.disposables.Disposable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> observable = Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> observer = <span class="keyword">object</span> : Observer&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribe</span><span class="params">(d: <span class="type">Disposable</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Subscribed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNext</span><span class="params">(t: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Received: <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Error: <span class="subst">$&#123;e.message&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onComplete</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Completed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    observable.subscribe(observer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="错误处理">🧹 9. 错误处理</h1>
<h2 id="onerrorreturn"><code>onErrorReturn</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">        .map &#123; <span class="number">10</span> / it &#125;</span><br><span class="line">        .onErrorReturn &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="onerrorresumenext"><code>onErrorResumeNext</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.error&lt;<span class="built_in">Int</span>&gt;(Throwable(<span class="string">&quot;Oops&quot;</span>))</span><br><span class="line">        .onErrorResumeNext(Observable.just(<span class="number">100</span>))</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="flowable处理背压-backpressure">🧪 10. Flowable（处理背压
Backpressure）</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.BackpressureStrategy</span><br><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Flowable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Flowable.create&lt;String&gt;(&#123; emitter -&gt;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">            emitter.onNext(<span class="string">&quot;Item <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        emitter.onComplete()</span><br><span class="line">    &#125;, BackpressureStrategy.BUFFER)</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="disposable-清理资源">⛓️ 11. Disposable &amp; 清理资源</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.disposables.CompositeDisposable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> disposables = CompositeDisposable()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> d = Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line">    disposables.add(d)</span><br><span class="line">    disposables.clear() <span class="comment">// 清理所有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="subject桥接-observer-与-observable">⛳ 12. Subject（桥接
Observer 与 Observable）</h1>
<h2 id="publishsubject"><code>PublishSubject</code></h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.subjects.PublishSubject</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> subject = PublishSubject.create&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    subject.subscribe &#123; println(<span class="string">&quot;Subscriber 1: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    subject.onNext(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    subject.onNext(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line">    subject.subscribe &#123; println(<span class="string">&quot;Subscriber 2: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    subject.onNext(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="常用类型对比">🧠 常用类型对比</h1>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Observable</code></td>
<td>无背压处理，适用于少量数据</td>
</tr>
<tr class="even">
<td><code>Flowable</code></td>
<td>可处理大量数据，支持背压</td>
</tr>
<tr class="odd">
<td><code>Single</code></td>
<td>发射一个值或错误</td>
</tr>
<tr class="even">
<td><code>Maybe</code></td>
<td>发射一个值、无值或错误</td>
</tr>
<tr class="odd">
<td><code>Completable</code></td>
<td>只关心完成或出错，不发射任何值</td>
</tr>
</tbody>
</table>
<hr />
<p>继续为你整理 <strong>RxJava 全部语法</strong>，使用
<strong>Kotlin</strong>
编写、可直接运行的代码示例。这部分涵盖的是中级到高级语法：</p>
<hr />
<h1 id="flatmap将每个-item-映射为另一个-observable">🔄 8.
<code>flatMap()</code>：将每个 item 映射为另一个 Observable</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">        .flatMap &#123; letter -&gt;</span><br><span class="line">            Observable.fromArray(<span class="string">&quot;<span class="variable">$letter</span>-1&quot;</span>, <span class="string">&quot;<span class="variable">$letter</span>-2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A-1</span><br><span class="line">A-2</span><br><span class="line">B-1</span><br><span class="line">B-2</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="concatmap与-flatmap-相似但保持顺序">🧷 9.
<code>concatMap()</code>：与 flatMap 相似，但保持顺序</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">        .concatMap &#123; letter -&gt;</span><br><span class="line">            Observable.fromArray(<span class="string">&quot;<span class="variable">$letter</span>-1&quot;</span>, <span class="string">&quot;<span class="variable">$letter</span>-2&quot;</span>).delay(<span class="number">100</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">        &#125;</span><br><span class="line">        .blockingSubscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="filter过滤数据">🔍 10. <code>filter()</code>：过滤数据</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125; <span class="comment">// 输出 2, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="reduce归约操作返回一个-single">🧮 11.
<code>reduce()</code>：归约操作，返回一个 Single</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .reduce &#123; t1, t2 -&gt; t1 + t2 &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125; <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="scan类似-reduce但会发出每一步的结果">📦 12.
<code>scan()</code>：类似 reduce，但会发出每一步的结果</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .scan &#123; acc, next -&gt; acc + next &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="delay延迟发射">⌛ 13. <code>delay()</code>：延迟发射</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        .delay(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .blockingSubscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="take只取前-n-个数据">🧪 14. <code>take()</code>：只取前 N
个数据</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        .take(<span class="number">3</span>)</span><br><span class="line">        .subscribe &#123; println(it) &#125; <span class="comment">// 输出 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="repeat重复整个流">🔁 15. <code>repeat()</code>：重复整个流</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        .repeat(<span class="number">3</span>)</span><br><span class="line">        .subscribe &#123; println(it) &#125; <span class="comment">// 输出 A A A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="retry出错时重试">💥 16. <code>retry()</code>：出错时重试</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> attempt = <span class="number">0</span></span><br><span class="line">    Observable.create&lt;String&gt; &#123; emitter -&gt;</span><br><span class="line">        <span class="keyword">if</span> (++attempt &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            emitter.onError(RuntimeException(<span class="string">&quot;fail&quot;</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            emitter.onNext(<span class="string">&quot;Success&quot;</span>)</span><br><span class="line">            emitter.onComplete()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        .retry(<span class="number">2</span>)</span><br><span class="line">        .subscribe(&#123; println(it) &#125;, &#123; println(<span class="string">&quot;Error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="timeout超时控制">⏳ 17. <code>timeout()</code>：超时控制</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        .delay(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">        .timeout(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscribe(</span><br><span class="line">            &#123; println(it) &#125;,</span><br><span class="line">            &#123; println(<span class="string">&quot;Timeout error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>继续为你整理 <strong>RxJava 全部语法</strong>（Kotlin
示例，可直接运行），现在进入组合、错误处理与调度等高级主题：</p>
<hr />
<h1 id="zip组合多个-observable逐个配对">🔗 18.
<code>zip()</code>：组合多个 Observable，逐个配对</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> letters = Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Observable.zip(numbers, letters) &#123; number, letter -&gt;</span><br><span class="line">        <span class="string">&quot;<span class="variable">$number</span>-<span class="variable">$letter</span>&quot;</span></span><br><span class="line">    &#125;.subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1-A</span><br><span class="line">2-B</span><br><span class="line">3-C</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="combinelatest任意一个-observable-发射数据就组合最新值">🔄 19.
<code>combineLatest()</code>：任意一个 Observable
发射数据就组合最新值</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> obs1 = Observable.interval(<span class="number">100</span>, TimeUnit.MILLISECONDS).map &#123; <span class="string">&quot;A<span class="variable">$it</span>&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> obs2 = Observable.interval(<span class="number">150</span>, TimeUnit.MILLISECONDS).map &#123; <span class="string">&quot;B<span class="variable">$it</span>&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    Observable.combineLatest(obs1, obs2) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span>:<span class="variable">$b</span>&quot;</span> &#125;</span><br><span class="line">        .take(<span class="number">5</span>)</span><br><span class="line">        .blockingSubscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1
id="withlatestfrom当主-observable-发射时结合最近另一个-observable-的数据">🔄
20. <code>withLatestFrom()</code>：当主 Observable
发射时，结合最近另一个 Observable 的数据</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> main = Observable.interval(<span class="number">200</span>, TimeUnit.MILLISECONDS).map &#123; <span class="string">&quot;Main-<span class="variable">$it</span>&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> other = Observable.interval(<span class="number">100</span>, TimeUnit.MILLISECONDS).map &#123; <span class="string">&quot;Other-<span class="variable">$it</span>&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    main.withLatestFrom(other) &#123; m, o -&gt; <span class="string">&quot;<span class="variable">$m</span> + <span class="variable">$o</span>&quot;</span> &#125;</span><br><span class="line">        .take(<span class="number">5</span>)</span><br><span class="line">        .blockingSubscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="onerrorreturn发生错误时返回一个默认值">⚠️ 21.
<code>onErrorReturn()</code>：发生错误时返回一个默认值</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        it.onError(Exception(<span class="string">&quot;Boom&quot;</span>))</span><br><span class="line">    &#125;.onErrorReturn &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>)</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;.subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="onerrorresumenext出错后切换到备用流">🛠 22.
<code>onErrorResumeNext()</code>：出错后切换到备用流</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.error&lt;<span class="built_in">Int</span>&gt;(Exception(<span class="string">&quot;Oops&quot;</span>))</span><br><span class="line">        .onErrorResumeNext(Observable.just(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="doonerror处理但不拦截错误">🧯 23.
<code>doOnError()</code>：处理但不拦截错误</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        it.onError(Exception(<span class="string">&quot;Boom&quot;</span>))</span><br><span class="line">    &#125;.doOnError &#123;</span><br><span class="line">        println(<span class="string">&quot;Logging error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;.subscribe(</span><br><span class="line">        &#123; println(<span class="string">&quot;Next: <span class="variable">$it</span>&quot;</span>) &#125;,</span><br><span class="line">        &#123; println(<span class="string">&quot;Final error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="调度器schedulers">⚙️ 24. 调度器（Schedulers）</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.schedulers.Schedulers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.create&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;Emitting on thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        it.onNext(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        it.onComplete()</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.computation())</span><br><span class="line">    .subscribe &#123;</span><br><span class="line">        println(<span class="string">&quot;Received on thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span> -&gt; <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">500</span>) <span class="comment">// 保证异步线程有时间执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="flowable-与背压处理backpressure">📥 25. Flowable
与背压处理（Backpressure）</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Flowable</span><br><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.schedulers.Schedulers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Flowable.range(<span class="number">1</span>, <span class="number">1_000_000</span>)</span><br><span class="line">        .onBackpressureDrop()</span><br><span class="line">        .observeOn(Schedulers.computation(), <span class="literal">false</span>, <span class="number">10</span>)</span><br><span class="line">        .subscribe(&#123; println(<span class="string">&quot;Received: <span class="variable">$it</span>&quot;</span>) &#125;,</span><br><span class="line">            &#123; println(<span class="string">&quot;Error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;)</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="single-用法发射一个值或错误">✅ 26. <code>Single</code>
用法（发射一个值或错误）</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Single</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Single.just(<span class="string">&quot;Single Result&quot;</span>)</span><br><span class="line">        .subscribe &#123; value -&gt; println(<span class="string">&quot;Received: <span class="variable">$value</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="maybe-用法可能发射一个值也可能什么都不发">✅ 27.
<code>Maybe</code> 用法（可能发射一个值，也可能什么都不发）</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Maybe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Maybe.just(<span class="string">&quot;Maybe Result&quot;</span>)</span><br><span class="line">        .subscribe(</span><br><span class="line">            &#123; println(<span class="string">&quot;Success: <span class="variable">$it</span>&quot;</span>) &#125;,</span><br><span class="line">            &#123; println(<span class="string">&quot;Error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;,</span><br><span class="line">            &#123; println(<span class="string">&quot;Completed with no item&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="completable-用法只发射完成或错误">✅ 28.
<code>Completable</code> 用法（只发射完成或错误）</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Completable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Completable.fromRunnable &#123;</span><br><span class="line">        println(<span class="string">&quot;Doing something...&quot;</span>)</span><br><span class="line">    &#125;.subscribe(</span><br><span class="line">        &#123; println(<span class="string">&quot;Completed!&quot;</span>) &#125;,</span><br><span class="line">        &#123; println(<span class="string">&quot;Error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>好的，继续补充 <strong>RxJava 全部语法（Kotlin
可运行示例）</strong>，进入进阶部分：自定义操作符、冷/热
Observable、多播、以及与 Retrofit 配合使用的实战示例。</p>
<hr />
<h1 id="compose封装通用操作链">🧰 29.
<code>compose()</code>：封装通用操作链</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.ObservableTransformer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">applyCommonSchedulers</span><span class="params">()</span></span>: ObservableTransformer&lt;T, T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> ObservableTransformer &#123; upstream -&gt;</span><br><span class="line">        upstream.doOnNext &#123; println(<span class="string">&quot;Logging: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">            .filter &#123; it != <span class="literal">null</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>)</span><br><span class="line">        .compose(applyCommonSchedulers())</span><br><span class="line">        .subscribe &#123; println(<span class="string">&quot;Received: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="lift自定义操作符不推荐常用">🔨 30.
<code>lift()</code>：自定义操作符（不推荐常用）</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> customOperator = Observable.lift&lt;String, String&gt; &#123; observer -&gt;</span><br><span class="line">        <span class="keyword">object</span> : Observer&lt;String&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribe</span><span class="params">(d: <span class="type">Disposable</span>)</span></span> &#123;</span><br><span class="line">                observer.onSubscribe(d)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNext</span><span class="params">(t: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                observer.onNext(<span class="string">&quot;[<span class="variable">$t</span>]&quot;</span>) <span class="comment">// 自定义包装输出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                observer.onError(e)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onComplete</span><span class="params">()</span></span> &#123;</span><br><span class="line">                observer.onComplete()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">        .lift(customOperator)</span><br><span class="line">        .subscribe &#123; println(<span class="string">&quot;Result: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="冷-vs-热-observable">🔥 31. 冷 vs 热 Observable</h1>
<h2
id="冷coldobservable每次订阅都会重新执行">冷（Cold）Observable：每次订阅都会重新执行</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cold = Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;Generating...&quot;</span>)</span><br><span class="line">        it.onNext((<span class="number">1.</span><span class="number">.100</span>).random())</span><br><span class="line">        it.onComplete()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cold.subscribe &#123; println(<span class="string">&quot;Observer 1: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">    cold.subscribe &#123; println(<span class="string">&quot;Observer 2: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="热hotobservable共享事件流不重复发射">热（Hot）Observable：共享事件流，不重复发射</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.subjects.PublishSubject</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hot = PublishSubject.create&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    hot.subscribe &#123; println(<span class="string">&quot;Observer 1: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    hot.onNext(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    hot.onNext(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hot.subscribe &#123; println(<span class="string">&quot;Observer 2: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    hot.onNext(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Observer 1: A</span><br><span class="line">Observer 1: B</span><br><span class="line">Observer 1: C</span><br><span class="line">Observer 2: C</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="多播操作符publish-connect-refcount">📡 32.
多播操作符：<code>publish()</code>, <code>connect()</code>,
<code>refCount()</code></h1>
<h2 id="使用-publish.connect-构建热-observable">使用
<code>publish().connect()</code> 构建热 Observable</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> source = Observable.interval(<span class="number">500</span>, java.util.concurrent.TimeUnit.MILLISECONDS)</span><br><span class="line">        .take(<span class="number">5</span>)</span><br><span class="line">        .publish()</span><br><span class="line"></span><br><span class="line">    source.subscribe &#123; println(<span class="string">&quot;Observer 1: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">    source.connect()</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1200</span>)</span><br><span class="line"></span><br><span class="line">    source.subscribe &#123; println(<span class="string">&quot;Observer 2: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="retrofit-rxjava-实战示例">🌐 33. Retrofit + RxJava 实战示例</h1>
<p>Gradle 添加依赖：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;com.squareup.retrofit2:adapter-rxjava3:2.9.0&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;io.reactivex.rxjava3:rxjava:3.1.6&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>接口定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Single</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.GET</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Post</span>(<span class="keyword">val</span> userId: <span class="built_in">Int</span>, <span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> title: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;posts/1&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPost</span><span class="params">()</span></span>: Single&lt;Post&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retrofit 配置与调用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> retrofit2.Retrofit</span><br><span class="line"><span class="keyword">import</span> retrofit2.converter.gson.GsonConverterFactory</span><br><span class="line"><span class="keyword">import</span> retrofit2.adapter.rxjava3.RxJava3CallAdapterFactory</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">&quot;https://jsonplaceholder.typicode.com/&quot;</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .addCallAdapterFactory(RxJava3CallAdapterFactory.create())</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> api = retrofit.create(ApiService::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    api.getPost()</span><br><span class="line">        .subscribe(</span><br><span class="line">            &#123; println(<span class="string">&quot;Title: <span class="subst">$&#123;it.title&#125;</span>&quot;</span>) &#125;,</span><br><span class="line">            &#123; println(<span class="string">&quot;Error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>继续为你整理 <strong>RxJava 全部语法（Kotlin
可运行示例）</strong>，本节重点：<code>Subject</code>
系列、错误处理、调度器详解、测试工具等。</p>
<hr />
<h1 id="subject-类型比较">🎯 34. <code>Subject</code> 类型比较</h1>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>PublishSubject</code></td>
<td>仅发送订阅之后的数据</td>
</tr>
<tr class="even">
<td><code>BehaviorSubject</code></td>
<td>发送最新的一个数据 + 后续数据</td>
</tr>
<tr class="odd">
<td><code>ReplaySubject</code></td>
<td>发送所有历史数据 + 后续数据</td>
</tr>
<tr class="even">
<td><code>AsyncSubject</code></td>
<td>只发送最后一个数据（在 <code>onComplete</code> 时发送）</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="publishsubject-示例">🔊 <code>PublishSubject</code> 示例</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.subjects.PublishSubject</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> subject = PublishSubject.create&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    subject.subscribe &#123; println(<span class="string">&quot;Observer1: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    subject.onNext(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    subject.onNext(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line">    subject.subscribe &#123; println(<span class="string">&quot;Observer2: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    subject.onNext(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Observer1: A</span><br><span class="line">Observer1: B</span><br><span class="line">Observer1: C</span><br><span class="line">Observer2: C</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="behaviorsubject-示例">🧭 <code>BehaviorSubject</code> 示例</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.subjects.BehaviorSubject</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> subject = BehaviorSubject.createDefault(<span class="string">&quot;Initial&quot;</span>)</span><br><span class="line"></span><br><span class="line">    subject.onNext(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    subject.subscribe &#123; println(<span class="string">&quot;Observer1: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    subject.onNext(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Observer1: A</span><br><span class="line">Observer1: B</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="replaysubject-示例">🔁 <code>ReplaySubject</code> 示例</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.subjects.ReplaySubject</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> subject = ReplaySubject.create&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    subject.onNext(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    subject.onNext(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line">    subject.subscribe &#123; println(<span class="string">&quot;Observer: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Observer: A</span><br><span class="line">Observer: B</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="asyncsubject-示例">🕘 <code>AsyncSubject</code> 示例</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.subjects.AsyncSubject</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> subject = AsyncSubject.create&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    subject.onNext(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    subject.onNext(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    subject.subscribe &#123; println(<span class="string">&quot;Observer: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    subject.onNext(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    subject.onComplete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Observer: C</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="错误处理相关操作符">🚨 35. 错误处理相关操作符</h1>
<h2
id="onerrorreturn错误时返回默认值"><code>onErrorReturn</code>：错误时返回默认值</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">        .map &#123; <span class="number">10</span> / it &#125;</span><br><span class="line">        .onErrorReturn &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2
id="onerrorresumenext错误时切换-observable"><code>onErrorResumeNext</code>：错误时切换
Observable</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        it.onNext(<span class="number">1</span>)</span><br><span class="line">        it.onError(RuntimeException(<span class="string">&quot;Oops&quot;</span>))</span><br><span class="line">    &#125;.onErrorResumeNext(Observable.just(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">        .subscribe &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="retry失败后重试"><code>retry()</code>：失败后重试</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">3</span>) it.onError(Exception(<span class="string">&quot;Fail <span class="variable">$count</span>&quot;</span>))</span><br><span class="line">        <span class="keyword">else</span> it.onNext(<span class="number">100</span>)</span><br><span class="line">    &#125;.retry(<span class="number">3</span>)</span><br><span class="line">        .subscribe(&#123; println(<span class="string">&quot;Success: <span class="variable">$it</span>&quot;</span>) &#125;, &#123; println(<span class="string">&quot;Error: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="调度器详解schedulers">🧵 36. 调度器详解（Schedulers）</h1>
<table>
<colgroup>
<col style="width: 52%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>Scheduler 类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Schedulers.io()</code></td>
<td>IO 密集型，如网络请求、文件读写</td>
</tr>
<tr class="even">
<td><code>Schedulers.computation()</code></td>
<td>CPU 密集型操作，如事件计算、算法</td>
</tr>
<tr class="odd">
<td><code>Schedulers.newThread()</code></td>
<td>每次创建一个新线程</td>
</tr>
<tr class="even">
<td><code>Schedulers.single()</code></td>
<td>单线程</td>
</tr>
<tr class="odd">
<td><code>AndroidSchedulers.mainThread()</code></td>
<td>Android UI 主线程（需引入 RxAndroid）</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="调度器示例">调度器示例</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.schedulers.Schedulers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(Schedulers.computation())</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            println(<span class="string">&quot;Received <span class="variable">$it</span> on thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="单元测试testobserver">✅ 37.
单元测试：<code>TestObserver</code></h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.observers.TestObserver</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> observable = Observable.just(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> testObserver = TestObserver&lt;String&gt;()</span><br><span class="line">    observable.subscribe(testObserver)</span><br><span class="line"></span><br><span class="line">    testObserver.assertComplete()</span><br><span class="line">    testObserver.assertValues(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;All assertions passed.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="自定义操作符扩展函数">✅ 38. 自定义操作符（扩展函数）</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Observable<span class="type">&lt;T&gt;</span>.<span class="title">logEach</span><span class="params">()</span></span>: Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doOnNext &#123; println(<span class="string">&quot;Logging: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .logEach()</span><br><span class="line">        .subscribe &#123; println(<span class="string">&quot;Received: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>继续为你补充 <strong>RxJava 全部语法（Kotlin
示例）</strong>，本节将涵盖：</p>
<ul>
<li><code>Flowable</code> 与背压</li>
<li><code>ConnectableObservable</code></li>
<li><code>Debounce</code>/<code>Throttle</code>/<code>Buffer</code>
等时间控制操作符</li>
<li><code>RxJava + Room</code> 数据响应</li>
<li><code>RxBinding</code> 防抖示例（如 EditText）</li>
</ul>
<hr />
<h1 id="flowable-与背压backpressure">🚰 39. <code>Flowable</code>
与背压（Backpressure）</h1>
<p>当发射数据速度远快于消费速度时，使用 <code>Flowable</code> 替代
<code>Observable</code>，并指定背压策略。</p>
<h2 id="示例快速发射-背压处理">示例：快速发射 + 背压处理</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.BackpressureStrategy</span><br><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Flowable</span><br><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.schedulers.Schedulers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> flowable = Flowable.create&lt;<span class="built_in">Int</span>&gt;(&#123; emitter -&gt;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.1_000_000</span>) &#123;</span><br><span class="line">            emitter.onNext(i)</span><br><span class="line">        &#125;</span><br><span class="line">        emitter.onComplete()</span><br><span class="line">    &#125;, BackpressureStrategy.BUFFER) <span class="comment">// DROP/MISSING/LATEST/ERROR</span></span><br><span class="line"></span><br><span class="line">    flowable</span><br><span class="line">        .observeOn(Schedulers.io())</span><br><span class="line">        .subscribe(</span><br><span class="line">            &#123; println(<span class="string">&quot;Received: <span class="variable">$it</span>&quot;</span>) &#125;,</span><br><span class="line">            &#123; it.printStackTrace() &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="connectableobservable控制发射时机">🔁 40.
<code>ConnectableObservable</code>：控制发射时机</h1>
<p>使多个订阅者共享同一个数据源，并延迟开始发送数据。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.observables.ConnectableObservable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> source = ConnectableObservable.interval(<span class="number">1</span>, java.util.concurrent.TimeUnit.SECONDS).publish()</span><br><span class="line"></span><br><span class="line">    source.subscribe &#123; println(<span class="string">&quot;Observer 1: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    source.subscribe &#123; println(<span class="string">&quot;Observer 2: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    source.connect() <span class="comment">// 开始发射</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="防抖debounce节流throttlefirst">⏳ 41.
防抖（<code>debounce</code>）、节流（<code>throttleFirst</code>）</h1>
<h2 id="debounce-停止输入一段时间后才发射"><code>debounce</code>:
停止输入一段时间后才发射</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.reactivex.rxjava3.core.Observable</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.create&lt;String&gt; &#123; emitter -&gt;</span><br><span class="line">        emitter.onNext(<span class="string">&quot;H&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">100</span>)</span><br><span class="line">        emitter.onNext(<span class="string">&quot;He&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">400</span>)</span><br><span class="line">        emitter.onNext(<span class="string">&quot;Hel&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">600</span>)</span><br><span class="line">        emitter.onNext(<span class="string">&quot;Hell&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        emitter.onComplete()</span><br><span class="line">    &#125;.debounce(<span class="number">500</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">        .subscribe &#123; println(<span class="string">&quot;Final Input: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="throttlefirst-一段时间内只取第一个"><code>throttleFirst</code>:
一段时间内只取第一个</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.interval(<span class="number">100</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">        .throttleFirst(<span class="number">300</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">        .take(<span class="number">10</span>)</span><br><span class="line">        .subscribe &#123; println(<span class="string">&quot;Throttled: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="buffer收集成批次">📦 42. <code>buffer</code>：收集成批次</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        .buffer(<span class="number">3</span>)</span><br><span class="line">        .subscribe &#123; println(<span class="string">&quot;Buffer: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Buffer: [1, 2, 3]</span><br><span class="line">Buffer: [4, 5, 6]</span><br><span class="line">Buffer: [7, 8, 9]</span><br><span class="line">Buffer: [10]</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="rxjava-room示例结构">🏠 43. RxJava + Room（示例结构）</h1>
<p>Room DAO 支持返回 <code>Flowable</code> 或 <code>Observable</code>
类型。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;SELECT * FROM user&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllUsers</span><span class="params">()</span></span>: Flowable&lt;List&lt;User&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">userDao.getAllUsers()</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe &#123; users -&gt; show(users) &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="rxbinding-防抖点击">🎯 44. <code>RxBinding</code> 防抖点击</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// implementation &quot;com.jakewharton.rxbinding4:rxbinding:4.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jakewharton.rxbinding4.view.clicks</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">button.clicks()</span><br><span class="line">    .throttleFirst(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">    .subscribe &#123; showToast(<span class="string">&quot;Clicked!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="intervaltimer-使用">✅ 45.
<code>interval</code>、<code>timer</code> 使用</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每秒发射一个值</span></span><br><span class="line">Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">    .subscribe &#123; println(<span class="string">&quot;Tick: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟 3 秒发射</span></span><br><span class="line">Observable.timer(<span class="number">3</span>, TimeUnit.SECONDS)</span><br><span class="line">    .subscribe &#123; println(<span class="string">&quot;Time&#x27;s up!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="dispose-资源释放">🧰 46. <code>dispose</code> / 资源释放</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> disposable = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">    .subscribe &#123; println(<span class="string">&quot;Tick: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">3000</span>)</span><br><span class="line">disposable.dispose() <span class="comment">// 停止订阅</span></span><br></pre></td></tr></table></figure>
<hr />
<p>我们继续补充 <strong>RxJava 高级用法（Kotlin
示例）</strong>，涵盖以下几个实用主题：</p>
<hr />
<h1 id="rxjava-线程切换全流程">🔀 47. RxJava 线程切换全流程</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">    .subscribeOn(Schedulers.io()) <span class="comment">// 上游开始在 IO 线程</span></span><br><span class="line">    .doOnNext &#123; println(<span class="string">&quot;doOnNext 1 on <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>) &#125;</span><br><span class="line">    .observeOn(Schedulers.computation())</span><br><span class="line">    .doOnNext &#123; println(<span class="string">&quot;doOnNext 2 on <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>) &#125;</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// Android 专用</span></span><br><span class="line">    .subscribe &#123; println(<span class="string">&quot;Subscribe on <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不是 Android 平台，可将
<code>AndroidSchedulers.mainThread()</code> 替换为
<code>Schedulers.trampoline()</code>。</p>
</blockquote>
<hr />
<h1 id="rxjava-kotlin-flow-对照表">🔁 48. RxJava → Kotlin Flow
对照表</h1>
<table>
<thead>
<tr class="header">
<th>RxJava</th>
<th>Kotlin Flow</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Observable.create</code></td>
<td><code>flow { emit(...) }</code></td>
</tr>
<tr class="even">
<td><code>subscribeOn</code>/<code>observeOn</code></td>
<td><code>flowOn</code>, <code>withContext</code> in collectors</td>
</tr>
<tr class="odd">
<td><code>map</code></td>
<td><code>map</code></td>
</tr>
<tr class="even">
<td><code>flatMap</code></td>
<td><code>flatMapConcat</code>, <code>flatMapMerge</code></td>
</tr>
<tr class="odd">
<td><code>zip</code></td>
<td><code>zip</code></td>
</tr>
<tr class="even">
<td><code>debounce</code></td>
<td><code>debounce</code></td>
</tr>
<tr class="odd">
<td><code>filter</code></td>
<td><code>filter</code></td>
</tr>
<tr class="even">
<td><code>onErrorResumeNext</code></td>
<td><code>catch { ... emit(...) }</code></td>
</tr>
<tr class="odd">
<td><code>retry</code></td>
<td><code>retry()</code></td>
</tr>
<tr class="even">
<td><code>Disposable.dispose()</code></td>
<td><code>Job.cancel()</code></td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RxJava</span></span><br><span class="line">Observable.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">    .subscribe &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin Flow</span></span><br><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">    .collect &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="retrofit-rxjava-实战">🌐 49. Retrofit + RxJava 实战</h1>
<h2 id="添加依赖">添加依赖</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;</span></span><br><span class="line">implementation <span class="string">&quot;com.squareup.retrofit2:adapter-rxjava3:2.9.0&quot;</span></span><br><span class="line">implementation <span class="string">&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="定义-api">定义 API</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;users&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUsers</span><span class="params">()</span></span>: Observable&lt;List&lt;User&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-rxjava-retrofit">使用 RxJava + Retrofit</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.example.com/&quot;</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .addCallAdapterFactory(RxJava3CallAdapterFactory.create())</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> api = retrofit.create(ApiService::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">api.getUsers()</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(&#123; users -&gt; println(users) &#125;, &#123; error -&gt; error.printStackTrace() &#125;)</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="自定义操作符">⚙️ 50. 自定义操作符</h1>
<p>通过扩展函数封装复杂逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Observable<span class="type">&lt;T&gt;</span>.<span class="title">debugTag</span><span class="params">(tag: <span class="type">String</span>)</span></span>: Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doOnNext &#123; println(<span class="string">&quot;[<span class="variable">$tag</span>] <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.range(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    .debugTag(<span class="string">&quot;MyLog&quot;</span>)</span><br><span class="line">    .subscribe()</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="异常恢复链retrywhen-delay">🔁 51.
异常恢复链：<code>retryWhen + delay</code></h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.create&lt;String&gt; &#123; emitter -&gt;</span><br><span class="line">    println(<span class="string">&quot;Trying...&quot;</span>)</span><br><span class="line">    emitter.onError(RuntimeException(<span class="string">&quot;Network error&quot;</span>))</span><br><span class="line">&#125;.retryWhen &#123; errors -&gt;</span><br><span class="line">    errors.zipWith(Observable.range(<span class="number">1</span>, <span class="number">3</span>)) &#123; e, i -&gt;</span><br><span class="line">        println(<span class="string">&quot;Retry <span class="variable">$i</span> after error: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        i</span><br><span class="line">    &#125;.flatMap &#123;</span><br><span class="line">        Observable.timer(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.subscribe(</span><br><span class="line">    &#123; println(<span class="string">&quot;Success: <span class="variable">$it</span>&quot;</span>) &#125;,</span><br><span class="line">    &#123; println(<span class="string">&quot;Failed after retries: <span class="subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="流程终止处理takeuntil-takewhile">✅ 52.
流程终止处理：<code>takeUntil</code>, <code>takeWhile</code></h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">    .takeUntil &#123; it &gt;= <span class="number">5</span> &#125;</span><br><span class="line">    .subscribe &#123; println(<span class="string">&quot;takeUntil: <span class="variable">$it</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">    .takeWhile &#123; it &lt; <span class="number">5</span> &#125;</span><br><span class="line">    .subscribe &#123; println(<span class="string">&quot;takeWhile: <span class="variable">$it</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>继续为你补充 <strong>RxJava 高级用法（Kotlin
示例）</strong>，包括并发执行、流合并、生命周期绑定、登录实战、RxJava →
Flow 迁移技巧。</p>
<hr />
<h1 id="concatmapeager并发执行顺序输出">🚀 53.
<code>concatMapEager</code>：并发执行、顺序输出</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    .concatMapEager &#123; id -&gt;</span><br><span class="line">        Observable.fromCallable &#123;</span><br><span class="line">            println(<span class="string">&quot;Start job <span class="variable">$id</span> on <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span> - id * <span class="number">200</span>)</span><br><span class="line">            <span class="string">&quot;Result <span class="variable">$id</span>&quot;</span></span><br><span class="line">        &#125;.subscribeOn(Schedulers.io())</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; println(<span class="string">&quot;Received: <span class="variable">$it</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>✅ 并发执行任务，但结果按原始顺序发射。</p>
</blockquote>
<hr />
<h1 id="多流合并策略">🔗 54. 多流合并策略</h1>
<h2 id="merge同时发射无序"><code>merge</code>：同时发射（无序）</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.merge(</span><br><span class="line">    Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS).map &#123; <span class="string">&quot;A<span class="variable">$it</span>&quot;</span> &#125;,</span><br><span class="line">    Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS).map &#123; <span class="string">&quot;B<span class="variable">$it</span>&quot;</span> &#125;</span><br><span class="line">)</span><br><span class="line">    .take(<span class="number">5</span>)</span><br><span class="line">    .subscribe &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>
<h2
id="concat按顺序发射一个结束后下一个"><code>concat</code>：按顺序发射（一个结束后下一个）</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.concat(</span><br><span class="line">    Observable.just(<span class="string">&quot;First&quot;</span>),</span><br><span class="line">    Observable.just(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line">).subscribe &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>
<h2
id="zip配对发射两个都准备好"><code>zip</code>：配对发射（两个都准备好）</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.zip(</span><br><span class="line">    Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>),</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span><span class="variable">$b</span>&quot;</span> &#125;</span><br><span class="line">.subscribe &#123; println(it) &#125; <span class="comment">// 输出：A1, B2, C3</span></span><br></pre></td></tr></table></figure>
<h2
id="combinelatest任一源更新即组合最新值"><code>combineLatest</code>：任一源更新即组合最新值</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.combineLatest(</span><br><span class="line">    Observable.interval(<span class="number">100</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">    Observable.interval(<span class="number">250</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">) &#123; a, b -&gt; <span class="string">&quot;Latest A=<span class="variable">$a</span>, B=<span class="variable">$b</span>&quot;</span> &#125;</span><br><span class="line">    .take(<span class="number">5</span>)</span><br><span class="line">    .subscribe &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="与-android-lifecycle-管理绑定rxlifecycle">📱 55. 与 Android
Lifecycle 管理绑定（RxLifecycle）</h1>
<p>依赖：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;com.trello.rxlifecycle4:rxlifecycle-android-lifecycle-kotlin:4.0.2&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(), LifecycleProvider&lt;Lifecycle.Event&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lifecycleSubject = BehaviorSubject.create&lt;Lifecycle.Event&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">lifecycle</span><span class="params">()</span></span>: Observable&lt;Lifecycle.Event&gt; = lifecycleSubject.hide()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        lifecycleSubject.onNext(Lifecycle.Event.ON_CREATE)</span><br><span class="line"></span><br><span class="line">        Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">            .compose(bindUntilEvent(Lifecycle.Event.ON_DESTROY))</span><br><span class="line">            .subscribe &#123; println(<span class="string">&quot;tick: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        lifecycleSubject.onNext(Lifecycle.Event.ON_DESTROY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="登录请求实战防抖-接口-错误恢复">🧪 56. 登录请求实战：防抖 + 接口
+ 错误恢复</h1>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> loginClicks = PublishSubject.create&lt;Pair&lt;String, String&gt;&gt;()</span><br><span class="line"></span><br><span class="line">loginClicks</span><br><span class="line">    .debounce(<span class="number">300</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .switchMapSingle &#123; (username, password) -&gt;</span><br><span class="line">        loginApi.login(username, password)</span><br><span class="line">            .retryWhen &#123; errors -&gt;</span><br><span class="line">                errors.take(<span class="number">3</span>).delay(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">            &#125;</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(&#123; result -&gt;</span><br><span class="line">        println(<span class="string">&quot;Login success: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;, &#123; error -&gt;</span><br><span class="line">        println(<span class="string">&quot;Login failed: <span class="subst">$&#123;error.message&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="rxjava-kotlin-flow-实际迁移技巧">🔄 57. RxJava → Kotlin Flow
实际迁移技巧</h1>
<h2 id="原始-rxjava">原始 RxJava：</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">    .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">    .filter &#123; it % <span class="number">3</span> == <span class="number">0</span> &#125;</span><br><span class="line">    .subscribe &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="kotlin-flow-改写">Kotlin Flow 改写：</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">flowExample</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Long</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0L</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        emit(i++)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runBlocking &#123;</span><br><span class="line">    flowExample()</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .filter &#123; it % <span class="number">3</span> == <span class="number">0L</span> &#125;</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迁移小贴士">迁移小贴士：</h2>
<table>
<thead>
<tr class="header">
<th>RxJava</th>
<th>Kotlin Flow</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Observable</code>/<code>Flowable</code></td>
<td><code>Flow</code></td>
</tr>
<tr class="even">
<td><code>subscribe()</code></td>
<td><code>collect()</code></td>
</tr>
<tr class="odd">
<td><code>Schedulers.io()</code></td>
<td><code>withContext(Dispatchers.IO)</code></td>
</tr>
<tr class="even">
<td><code>retryWhen</code>, <code>onErrorResumeNext</code></td>
<td><code>retry</code>, <code>catch</code></td>
</tr>
<tr class="odd">
<td><code>debounce</code></td>
<td><code>debounce()</code></td>
</tr>
<tr class="even">
<td><code>switchMap</code></td>
<td><code>flatMapLatest</code></td>
</tr>
<tr class="odd">
<td><code>Disposable.dispose()</code></td>
<td><code>Job.cancel()</code></td>
</tr>
</tbody>
</table>
<hr />
]]></content>
      <categories>
        <category>Android</category>
        <category>第三方库</category>
        <category>RxJava</category>
      </categories>
  </entry>
</search>
