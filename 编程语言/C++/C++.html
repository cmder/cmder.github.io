<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cmder.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="语法树">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="https://cmder.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++.html">
<meta property="og:site_name" content="说码解字">
<meta property="og:description" content="语法树">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-29T03:02:52.000Z">
<meta property="article:modified_time" content="2025-10-14T14:00:23.768Z">
<meta property="article:author" content="Bruce Yao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://cmder.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++.html">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://cmder.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++.html","path":"编程语言/C++/C++.html","title":"C++"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ | 说码解字</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"forest","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">说码解字</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">语法树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7c9803%E5%8F%8A%E4%B9%8B%E5%89%8D"><span class="nav-number">2.1.</span> <span class="nav-text">1.
基础语法特性（C++98&#x2F;03及之前）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">字符型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">布尔型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="nav-number">2.1.2.</span> <span class="nav-text">变量与常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.1.3.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.1.3.6.</span> <span class="nav-text">其他运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.4.</span> <span class="nav-text">控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">条件语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%85%B3%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">开关语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">跳转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.5.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">2.1.6.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">1. 什么是指针？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">2.1.6.1.1.</span> <span class="nav-text">指针的声明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">2. 指针的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F%E5%9C%B0%E5%9D%80"><span class="nav-number">2.1.6.2.1.</span> <span class="nav-text">（1）获取变量地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%80%BC"><span class="nav-number">2.1.6.2.2.</span> <span class="nav-text">（2）解引用（访问指针指向的值）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.6.2.3.</span> <span class="nav-text">（3）指针的初始化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-number">2.1.6.3.</span> <span class="nav-text">3. 指针与数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.1.6.3.1.</span> <span class="nav-text">数组与指针的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-number">2.1.6.3.2.</span> <span class="nav-text">数组下标与指针</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">2.1.6.4.</span> <span class="nav-text">4. 动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">2.1.6.4.1.</span> <span class="nav-text">动态分配内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E6%95%B0%E7%BB%84"><span class="nav-number">2.1.6.4.2.</span> <span class="nav-text">动态分配数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.6.5.</span> <span class="nav-text">5. 指针与函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F"><span class="nav-number">2.1.6.5.1.</span> <span class="nav-text">（1）通过指针修改变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.1.6.5.2.</span> <span class="nav-text">（2）指针作为函数返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9C%B0%E5%9D%80"><span class="nav-number">2.1.6.5.3.</span> <span class="nav-text">（3）避免返回局部变量地址</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95"><span class="nav-number">2.1.6.6.</span> <span class="nav-text">6. 指针的进阶用法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88"><span class="nav-number">2.1.6.6.1.</span> <span class="nav-text">（1）指针的指针（多级指针）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-number">2.1.6.6.2.</span> <span class="nav-text">（2）常量指针与指针常量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">2.1.6.6.3.</span> <span class="nav-text">（3）函数指针</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.1.6.7.</span> <span class="nav-text">7. 常见问题与注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88c11-%E5%8F%8A%E4%BB%A5%E4%B8%8A"><span class="nav-number">2.1.6.8.</span> <span class="nav-text">8. 智能指针（C++11
及以上）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.6.9.</span> <span class="nav-text">9. 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">2.1.7.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">1. 什么是引用？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.7.1.1.</span> <span class="nav-text">基本示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">2. 引用的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.7.2.1.</span> <span class="nav-text">（1）必须初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8D%E6%98%AF%E7%8B%AC%E7%AB%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.7.2.2.</span> <span class="nav-text">（2）引用不是独立对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%BC%95%E7%94%A8%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">2.1.7.2.3.</span> <span class="nav-text">（3）不能创建引用的引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">2.1.7.2.4.</span> <span class="nav-text">（4）不能创建数组的引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94"><span class="nav-number">2.1.7.3.</span> <span class="nav-text">3. 引用的主要用途</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">2.1.7.3.1.</span> <span class="nav-text">（1）函数参数传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.1.7.3.2.</span> <span class="nav-text">（2）函数返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="nav-number">2.1.7.3.3.</span> <span class="nav-text">（3）简化代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8const-reference"><span class="nav-number">2.1.7.4.</span> <span class="nav-text">4. 常量引用（const
Reference）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.1.7.4.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.7.4.2.</span> <span class="nav-text">常量引用与临时对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="nav-number">2.1.7.4.3.</span> <span class="nav-text">函数参数中的常量引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c11-%E5%BC%95%E5%85%A5%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8rvalue-reference"><span class="nav-number">2.1.7.5.</span> <span class="nav-text">5. C++11
引入的右值引用（Rvalue Reference）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">2.1.7.5.1.</span> <span class="nav-text">移动构造函数和移动语义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.1.7.6.</span> <span class="nav-text">6. 引用与指针的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.1.7.7.</span> <span class="nav-text">7. 注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.1.7.8.</span> <span class="nav-text">8. 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.8.</span> <span class="nav-text">类与对象（面向对象特性）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89class-%E5%92%8C-struct"><span class="nav-number">2.1.8.1.</span> <span class="nav-text">类定义（class 和
struct）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6publicprivateprotected"><span class="nav-number">2.1.8.2.</span> <span class="nav-text">访问控制（public、private、protected）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.8.3.</span> <span class="nav-text">构造函数与析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.8.4.</span> <span class="nav-text">拷贝构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-number">2.1.8.5.</span> <span class="nav-text">成员函数与数据成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98static"><span class="nav-number">2.1.8.6.</span> <span class="nav-text">静态成员（static）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83friend"><span class="nav-number">2.1.8.7.</span> <span class="nav-text">友元（friend）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%8D%95%E7%BB%A7%E6%89%BF%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">2.1.8.8.</span> <span class="nav-text">继承（单继承、多继承）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%E8%99%9A%E5%87%BD%E6%95%B0-virtual%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-0"><span class="nav-number">2.1.8.9.</span> <span class="nav-text">多态性（虚函数
virtual，纯虚函数 &#x3D; 0）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.8.10.</span> <span class="nav-text">抽象类与接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.1.9.</span> <span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.1.9.1.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.1.9.2.</span> <span class="nav-text">类模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">2.1.10.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trycatchthrow"><span class="nav-number">2.1.10.1.</span> <span class="nav-text">try、catch、throw</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%A6%82-stdexception"><span class="nav-number">2.1.10.2.</span> <span class="nav-text">标准异常类（如
std::exception）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">2.1.11.</span> <span class="nav-text">命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89namespace"><span class="nav-number">2.1.11.1.</span> <span class="nav-text">定义（namespace）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8using"><span class="nav-number">2.1.11.2.</span> <span class="nav-text">使用（using）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.1.12.</span> <span class="nav-text">动态内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#new-%E5%92%8C-delete"><span class="nav-number">2.1.12.1.</span> <span class="nav-text">new 和
delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84new-%E5%92%8C-delete"><span class="nav-number">2.1.12.2.</span> <span class="nav-text">数组（new[] 和
delete[]）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">2.1.13.</span> <span class="nav-text">预处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89define"><span class="nav-number">2.1.13.1.</span> <span class="nav-text">宏定义（#define）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91ifdefifndefendif"><span class="nav-number">2.1.13.2.</span> <span class="nav-text">条件编译（#ifdef、#ifndef、#endif）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%ABinclude"><span class="nav-number">2.1.13.3.</span> <span class="nav-text">文件包含（#include）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3-c-%E6%96%B0%E7%89%B9%E6%80%A7c11-%E5%8F%8A%E4%B9%8B%E5%90%8E"><span class="nav-number">2.2.</span> <span class="nav-text">2. 现代 C++ 新特性（C++11
及之后）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c11"><span class="nav-number">2.2.1.</span> <span class="nav-text">C++11</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#raii"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">RAII</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-raii"><span class="nav-number">2.2.1.1.1.</span> <span class="nav-text">什么是 RAII？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#raii-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.1.1.2.</span> <span class="nav-text">RAII 的工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#raii-%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.2.1.1.3.</span> <span class="nav-text">RAII 的代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#raii-%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="nav-number">2.2.1.1.4.</span> <span class="nav-text">RAII 的典型应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#raii-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">2.2.1.1.5.</span> <span class="nav-text">RAII 的优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#raii-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.2.1.1.6.</span> <span class="nav-text">RAII 的注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#raii-%E4%B8%8E%E4%BD%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">2.2.1.1.7.</span> <span class="nav-text">RAII 与你的线程代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">2.2.1.1.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">自动类型推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4-for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">范围 for 循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nullptr"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">nullptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">2.2.1.6.</span> <span class="nav-text">移动语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">2.2.1.7.</span> <span class="nav-text">完美转发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.2.1.8.</span> <span class="nav-text">Lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">2.2.1.8.1.</span> <span class="nav-text">1. Lambda
表达式的基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.2.1.8.2.</span> <span class="nav-text">2. 捕获列表详解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%89%E5%80%BC%E6%8D%95%E8%8E%B7-x"><span class="nav-number">2.2.1.8.2.1.</span> <span class="nav-text">(1) 按值捕获 [x]</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%89%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7-x"><span class="nav-number">2.2.1.8.2.2.</span> <span class="nav-text">(2) 按引用捕获
[&amp;x]</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E6%8D%95%E8%8E%B7"><span class="nav-number">2.2.1.8.2.3.</span> <span class="nav-text">(3) 全局捕获</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7-this"><span class="nav-number">2.2.1.8.2.4.</span> <span class="nav-text">(4) 捕获 this</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lambda-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.1.8.3.</span> <span class="nav-text">3. Lambda 的工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lambda-%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E9%80%94"><span class="nav-number">2.2.1.8.4.</span> <span class="nav-text">4. Lambda 的常见用途</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-number">2.2.1.8.5.</span> <span class="nav-text">5. 注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%94%B9%E8%BF%9B"><span class="nav-number">2.2.1.9.</span> <span class="nav-text">模板改进</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%94%B9%E8%BF%9B"><span class="nav-number">2.2.1.10.</span> <span class="nav-text">初始化改进</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%94%AF%E6%8C%81"><span class="nav-number">2.2.1.11.</span> <span class="nav-text">并发支持</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">2.2.1.11.1.</span> <span class="nav-text">1. 并发控制的核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8Bthreads"><span class="nav-number">2.2.1.11.1.1.</span> <span class="nav-text">(1) 线程（Threads）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89data-race"><span class="nav-number">2.2.1.11.1.2.</span> <span class="nav-text">(2) 数据竞争（Data
Race）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%ADsynchronization-primitives"><span class="nav-number">2.2.1.11.1.3.</span> <span class="nav-text">(3)
同步原语（Synchronization Primitives）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B7%A5%E5%85%B7"><span class="nav-number">2.2.1.11.2.</span> <span class="nav-text">2. C++
并发控制的主要工具</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81mutex"><span class="nav-number">2.2.1.11.2.1.</span> <span class="nav-text">(1)
互斥锁（&lt;mutex&gt;）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable"><span class="nav-number">2.2.1.11.2.2.</span> <span class="nav-text">(2)
条件变量（&lt;condition_variable&gt;）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic"><span class="nav-number">2.2.1.11.2.3.</span> <span class="nav-text">(3)
原子操作（&lt;atomic&gt;）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%AA%E6%9D%A5%E5%92%8C%E6%89%BF%E8%AF%BAfuture"><span class="nav-number">2.2.1.11.2.4.</span> <span class="nav-text">(4)
未来和承诺（&lt;future&gt;）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8thread"><span class="nav-number">2.2.1.11.2.5.</span> <span class="nav-text">(5)
线程局部存储（&lt;thread&gt;）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c17-%E5%92%8C-c20-%E7%9A%84%E5%B9%B6%E5%8F%91%E6%94%B9%E8%BF%9B"><span class="nav-number">2.2.1.11.3.</span> <span class="nav-text">3. C++17 和 C++20
的并发改进</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c17"><span class="nav-number">2.2.1.11.3.1.</span> <span class="nav-text">C++17</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c20"><span class="nav-number">2.2.1.11.3.2.</span> <span class="nav-text">C++20</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="nav-number">2.2.1.11.4.</span> <span class="nav-text">4. 注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">2.2.1.11.5.</span> <span class="nav-text">5. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr"><span class="nav-number">2.2.1.12.</span> <span class="nav-text">constexpr</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c14"><span class="nav-number">2.2.2.</span> <span class="nav-text">C++14</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B-lambda"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">泛型 Lambda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">返回类型推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr-%E6%89%A9%E5%B1%95"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">constexpr 扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">变量模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c17-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">C++17</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">结构化绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if-%E5%92%8C-switch-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">if 和 switch 初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">折叠表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdoptional"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">std::optional</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdvariant"><span class="nav-number">2.2.3.5.</span> <span class="nav-text">std::variant</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdany"><span class="nav-number">2.2.3.6.</span> <span class="nav-text">std::any</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BA%93stdfilesystem"><span class="nav-number">2.2.3.7.</span> <span class="nav-text">文件系统库（std::filesystem）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.3.8.</span> <span class="nav-text">并行算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inline-%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.3.9.</span> <span class="nav-text">inline 变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c20-1"><span class="nav-number">2.2.4.</span> <span class="nav-text">C++20</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5concepts"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">概念（Concepts）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ranges-%E5%BA%93"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">Ranges 库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8Bcoroutines"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">协程（Coroutines）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97modules"><span class="nav-number">2.2.4.4.</span> <span class="nav-text">模块（Modules）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.2.4.5.</span> <span class="nav-text">三路比较运算符（&lt;&#x3D;&gt;）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#consteval-%E5%92%8C-constinit"><span class="nav-number">2.2.4.6.</span> <span class="nav-text">consteval 和
constinit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%B7%A5%E5%85%B7"><span class="nav-number">2.2.4.7.</span> <span class="nav-text">新工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%8E%86%E5%92%8C%E6%97%B6%E5%8C%BA%E6%94%AF%E6%8C%81stdchrono-%E6%89%A9%E5%B1%95"><span class="nav-number">2.2.4.8.</span> <span class="nav-text">日历和时区支持（std::chrono
扩展）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93"><span class="nav-number">2.3.</span> <span class="nav-text">3. 其他特性总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">标准库扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%89%B9%E6%80%A7"><span class="nav-number">2.3.2.</span> <span class="nav-text">编译器特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%A0%94%E7%A9%B6"><span class="nav-number">3.</span> <span class="nav-text">问题研究</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="nav-number">3.1.</span> <span class="nav-text">C++ 如何实现多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%A4%9A%E6%80%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">3.1.1.</span> <span class="nav-text">1. C++ 多态的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.
运行时多态的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">关键字和语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">基本示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8vtable"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.
多态的底层原理：虚函数表（vtable）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">3.1 虚函数表的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88vptr"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">3.2 虚表指针（vptr）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%86%E6%B4%BE%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">3.3 运行时分派的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-number">3.1.3.4.</span> <span class="nav-text">内存布局示意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">3.1.3.5.</span> <span class="nav-text">3.4 编译器如何处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B%E4%B8%8E%E9%AA%8C%E8%AF%81"><span class="nav-number">3.1.4.</span> <span class="nav-text">4. 详细示例与验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E9%99%90%E5%88%B6"><span class="nav-number">3.1.5.</span> <span class="nav-text">5. 注意事项与限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.6.</span> <span class="nav-text">6. 多态的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">3.1.7.</span> <span class="nav-text">7. 总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-number">3.1.8.</span> <span class="nav-text">8. 示意图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE-1%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.1.8.1.</span> <span class="nav-text">图
1：类层次结构和虚函数表的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A"><span class="nav-number">3.1.8.1.1.</span> <span class="nav-text">解释</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE-2%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.8.2.</span> <span class="nav-text">图
2：对象内存布局和调用流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%A4%BA%E6%84%8F%E5%9B%BE-1"><span class="nav-number">3.1.8.2.1.</span> <span class="nav-text">内存布局示意图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="nav-number">3.1.8.2.2.</span> <span class="nav-text">解释</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81"><span class="nav-number">3.1.8.3.</span> <span class="nav-text">代码验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-number">3.1.8.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%92%8C-java-%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="nav-number">3.2.</span> <span class="nav-text">C++ 的模板和 Java 的泛型比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. 基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. 实现机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%81%B5%E6%B4%BB%E6%80%A7%E4%B8%8E%E7%BA%A6%E6%9D%9F"><span class="nav-number">3.2.3.</span> <span class="nav-text">3. 灵活性与约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">3.2.4.</span> <span class="nav-text">4. 性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.2.5.</span> <span class="nav-text">5. 使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-number">3.2.6.</span> <span class="nav-text">6. 优缺点总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90%E5%AF%B9%E6%AF%94"><span class="nav-number">3.2.7.</span> <span class="nav-text">7. 实际例子对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">3.2.8.</span> <span class="nav-text">8. 结论</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Yao"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Yao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cmder" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cmder" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cmd100000@gmail.com" title="E-Mail → mailto:cmd100000@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cmder.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Bruce Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="说码解字">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ | 说码解字">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-29 11:02:52" itemprop="dateCreated datePublished" datetime="2024-11-29T11:02:52+08:00">2024-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-14 22:00:23" itemprop="dateModified" datetime="2025-10-14T22:00:23+08:00">2025-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="语法树">语法树</h1>
<pre><code class="highlight mermaid">graph LR
    A[&quot;C++ 语法概览&quot;]

    %% 1. 基础语法特性 (C++98/03 及之前)
    A --&gt; B[&quot;基础语法特性&lt;br&gt;C++98/03&quot;]
    B --&gt; B1[&quot;基本数据类型&quot;]
    B1 --&gt; B1a[&quot;整型: int, short, long&quot;]
    B1 --&gt; B1b[&quot;浮点型: float, double&quot;]
    B1 --&gt; B1c[&quot;字符型: char, wchar_t&quot;]
    B1 --&gt; B1d[&quot;布尔型: bool&quot;]
    B1 --&gt; B1e[&quot;修饰符: signed, unsigned&quot;]
    
    B --&gt; B2[&quot;变量与常量&quot;]
    B2 --&gt; B2a[&quot;变量声明与定义&quot;]
    B2 --&gt; B2b[&quot;常量: const&quot;]
    
    B --&gt; B3[&quot;运算符&quot;]
    B3 --&gt; B3a[&quot;算术运算符: +, -, *, /, %&quot;]
    B3 --&gt; B3b[&quot;关系运算符: ==, !=, &amp;lt;, &amp;gt;&quot;]
    B3 --&gt; B3c[&quot;逻辑运算符: &amp;amp;&amp;amp;, ||, !&quot;]
    B3 --&gt; B3d[&quot;位运算符: &amp;amp;, |, ^, ~, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;&quot;]
    B3 --&gt; B3e[&quot;赋值运算符: =, +=, -=&quot;]
    B3 --&gt; B3f[&quot;其他: sizeof, typeid&quot;]
         
    B --&gt; B4[&quot;控制结构&quot;]
    B4 --&gt; B4a[&quot;条件语句: if, else&quot;]
    B4 --&gt; B4b[&quot;开关语句: switch, case&quot;]
    B4 --&gt; B4c[&quot;循环: for, while, do-while&quot;]
    B4 --&gt; B4d[&quot;跳转: break, continue, return, goto&quot;]
    
    B --&gt; B5[&quot;函数&quot;]
    B5 --&gt; B5a[&quot;函数声明与定义&quot;]
    B5 --&gt; B5b[&quot;参数传递: 值, 引用&quot;]
    B5 --&gt; B5c[&quot;默认参数&quot;]
    B5 --&gt; B5d[&quot;函数重载&quot;]
    B5 --&gt; B5e[&quot;内联函数: inline&quot;]
    
    B --&gt; B6[&quot;指针与引用&quot;]
    B6 --&gt; B6a[&quot;指针: *&quot;]
    B6 --&gt; B6b[&quot;引用: &amp;amp;&quot;]
    B6 --&gt; B6c[&quot;空指针: NULL&quot;]
    
    B --&gt; B7[&quot;类与对象&quot;]
    B7 --&gt; B7a[&quot;类定义: class, struct&quot;]
    B7 --&gt; B7b[&quot;访问控制: public, private&quot;]
    B7 --&gt; B7c[&quot;构造函数与析构函数&quot;]
    B7 --&gt; B7d[&quot;拷贝构造函数&quot;]
    B7 --&gt; B7e[&quot;静态成员: static&quot;]
    B7 --&gt; B7f[&quot;友元: friend&quot;]
    B7 --&gt; B7g[&quot;继承&quot;]
    B7 --&gt; B7h[&quot;多态性: virtual, =0&quot;]
    
    B --&gt; B8[&quot;模板&quot;]
    B8 --&gt; B8a[&quot;函数模板&quot;]
    B8 --&gt; B8b[&quot;类模板&quot;]
    
    B --&gt; B9[&quot;异常处理&quot;]
    B9 --&gt; B9a[&quot;try, catch, throw&quot;]
    B9 --&gt; B9b[&quot;标准异常类&quot;]
    
    B --&gt; B10[&quot;命名空间&quot;]
    B10 --&gt; B10a[&quot;定义与使用&quot;]
    
    B --&gt; B11[&quot;动态内存管理&quot;]
    B11 --&gt; B11a[&quot;new, delete&quot;]
    
    B --&gt; B12[&quot;预处理器&quot;]
    B12 --&gt; B12a[&quot;宏定义: #define&quot;]
    B12 --&gt; B12b[&quot;条件编译: #ifdef&quot;]
    B12 --&gt; B12c[&quot;文件包含: #include&quot;]

    %% 2. 现代 C++ 新特性
    A --&gt; C[&quot;现代 C++ 新特性&quot;]
    
    C --&gt; C1[&quot;C++11&quot;]
    C1 --&gt; C1a[&quot;自动类型推导: auto, decltype&quot;]
    C1 --&gt; C1b[&quot;范围 for 循环&quot;]
    C1 --&gt; C1c[&quot;nullptr&quot;]
    C1 --&gt; C1d[&quot;智能指针: unique_ptr, shared_ptr&quot;]
    C1 --&gt; C1e[&quot;移动语义: &amp;amp;&amp;amp;, std::move&quot;]
    C1 --&gt; C1f[&quot;完美转发: std::forward&quot;]
    C1 --&gt; C1g[&quot;Lambda 表达式&quot;]
    C1 --&gt; C1h[&quot;模板改进: 可变参数模板&quot;]
    C1 --&gt; C1i[&quot;初始化改进: &#123;&#125;&quot;]
    C1 --&gt; C1j[&quot;并发支持: std::thread&quot;]
    C1 --&gt; C1k[&quot;新容器: array, unordered_map&quot;]
    C1 --&gt; C1l[&quot;constexpr, static_assert&quot;]
    
    C --&gt; C2[&quot;C++14&quot;]
    C2 --&gt; C2a[&quot;泛型 Lambda&quot;]
    C2 --&gt; C2b[&quot;返回类型推导: auto&quot;]
    C2 --&gt; C2c[&quot;constexpr 扩展&quot;]
    C2 --&gt; C2d[&quot;变量模板&quot;]
    
    C --&gt; C3[&quot;C++17&quot;]
    C3 --&gt; C3a[&quot;结构化绑定&quot;]
    C3 --&gt; C3b[&quot;if/switch 初始化&quot;]
    C3 --&gt; C3c[&quot;折叠表达式&quot;]
    C3 --&gt; C3d[&quot;std::optional, variant, any&quot;]
    C3 --&gt; C3e[&quot;文件系统库: std::filesystem&quot;]
    C3 --&gt; C3f[&quot;并行算法&quot;]
    
    C --&gt; C4[&quot;C++20&quot;]
    C4 --&gt; C4a[&quot;概念: Concepts&quot;]
    C4 --&gt; C4b[&quot;Ranges 库&quot;]
    C4 --&gt; C4c[&quot;协程: co_await, co_yield&quot;]
    C4 --&gt; C4d[&quot;模块: import&quot;]
    C4 --&gt; C4e[&quot;三路比较: &amp;lt;=&amp;gt;&quot;]
    C4 --&gt; C4f[&quot;consteval, constinit&quot;]
    C4 --&gt; C4g[&quot;std::span, bit_cast&quot;]

    %% 3. 其他特性
    A --&gt; D[&quot;其他特性&quot;]
    D --&gt; D1[&quot;标准库扩展&lt;br&gt;C++98+&quot;]
    D1 --&gt; D1a[&quot;STL: vector, map&quot;]
    D1 --&gt; D1b[&quot;输入输出: iostream&quot;]
    D1 --&gt; D1c[&quot;字符串: string, string_view&quot;]
    D1 --&gt; D1d[&quot;正则表达式: regex&quot;]
    
    D --&gt; D2[&quot;编译器特性&lt;br&gt;C++11+&quot;]
    D2 --&gt; D2a[&quot;属性: [[nodiscard]]&quot;]
    D2 --&gt; D2b[&quot;对齐控制: alignas&quot;]</code></pre>
<h1 id="详解">详解</h1>
<h2 id="基础语法特性c9803及之前"><strong>1.
基础语法特性（C++98/03及之前）</strong></h2>
<h3 id="基本数据类型"><strong>基本数据类型</strong></h3>
<p>C++
的基本数据类型是语言的核心，用于定义变量以存储不同种类的数据。这些类型的具体大小和范围依赖于编译器和硬件平台，但
C++ 标准提供了一些基本保证。以下是对每种数据类型的详细讲解。</p>
<h4 id="整型"><strong>整型</strong></h4>
<p>整型用于存储整数值，根据大小和符号性分为以下几种：</p>
<ul>
<li><strong><code>int</code></strong>
<ul>
<li><strong>功能</strong>：表示基本的整数类型，通常是平台上最自然的大小（一般
4 字节，32 位）。</li>
<li><strong>范围</strong>：有符号时，范围通常为
<code>-2,147,483,648</code> 到
<code>2,147,483,647</code>（<code>-2^31</code> 到
<code>2^31-1</code>）。</li>
<li><strong>使用场景</strong>：适用于大多数整数计算，如循环计数器、数组索引等。</li>
<li><strong>底层原理</strong>：存储为二进制补码形式，符号位决定正负。</li>
<li><strong>注意事项</strong>：溢出时行为未定义（例如
<code>INT_MAX + 1</code>）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;  <span class="comment">// 普通整数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int value: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// -2147483648</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2147483647</span></span><br><span class="line">    i = INT_MAX;  <span class="comment">// 使用 limits 中的宏定义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// i = i + 1;  // 未定义行为，溢出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>short</code></strong>
<ul>
<li><strong>功能</strong>：短整型，比 <code>int</code> 小，通常 2
字节（16 位）。</li>
<li><strong>范围</strong>：有符号时，范围为 <code>-32,768</code> 到
<code>32,767</code>（<code>-2^15</code> 到 <code>2^15-1</code>）。</li>
<li><strong>使用场景</strong>：适合存储较小的整数，节省内存，如小型计数器。</li>
<li><strong>底层原理</strong>：同样使用二进制补码表示。</li>
<li><strong>注意事项</strong>：范围较小，需注意溢出。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">short</span> s = <span class="number">32767</span>;  <span class="comment">// 短整型最大值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short value: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// -32768</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 32767</span></span><br><span class="line">    <span class="comment">// s = 32768;  // 溢出，未定义行为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>long</code></strong>
<ul>
<li><strong>功能</strong>：长整型，至少与 <code>int</code>
大小相同，通常 4 字节或 8 字节（视平台）。</li>
<li><strong>范围</strong>：32 位系统上有符号时为 <code>-2^31</code> 到
<code>2^31-1</code>，64 位系统上可能更大。</li>
<li><strong>使用场景</strong>：需要更大范围的整数，如文件大小。</li>
<li><strong>底层原理</strong>：补码表示，长度由编译器定义。</li>
<li><strong>注意事项</strong>：建议使用 <code>long long</code> 以确保 64
位支持。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> l = <span class="number">123456L</span>;  <span class="comment">// 长整型，带 L 后缀</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long value: &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>long long</code></strong>
<ul>
<li><strong>功能</strong>：超长整型，至少 8 字节（64 位），C++11
正式标准化。</li>
<li><strong>范围</strong>：有符号时为 <code>-2^63</code> 到
<code>2^63-1</code>（约 ±9.2×10^18）。</li>
<li><strong>使用场景</strong>：非常大的整数，如科学计算或时间戳。</li>
<li><strong>底层原理</strong>：补码表示，保证 64 位。</li>
<li><strong>注意事项</strong>：较老的编译器可能不支持。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ll = <span class="number">123456789LL</span>;  <span class="comment">// 超长整型，带 LL 后缀</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long value: &quot;</span> &lt;&lt; ll &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>unsigned</code> 修饰符</strong>
<ul>
<li><strong>功能</strong>：将整型变为无符号，范围从 0
开始，最大值翻倍。</li>
<li><strong>范围</strong>：如 <code>unsigned int</code> 为 0 到
<code>4,294,967,295</code>（2^32-1）。</li>
<li><strong>使用场景</strong>：非负数场景，如计数器、数组大小。</li>
<li><strong>底层原理</strong>：直接存储二进制值，无符号位。</li>
<li><strong>注意事项</strong>：与有符号类型混合运算需小心（如比较时可能出错）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ui = <span class="number">4294967295U</span>;  <span class="comment">// 无符号整数，带 U 后缀</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int value: &quot;</span> &lt;&lt; ui &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 4294967295</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="浮点型"><strong>浮点型</strong></h4>
<p>浮点型用于存储小数，基于 IEEE 754 标准。</p>
<ul>
<li><strong><code>float</code></strong>
<ul>
<li><strong>功能</strong>：单精度浮点数，4 字节，约 7 位有效数字。</li>
<li><strong>范围</strong>：大约 ±3.4×10^38，精度有限。</li>
<li><strong>使用场景</strong>：需要小数但精度要求不高的场景，如图形计算。</li>
<li><strong>底层原理</strong>：分为符号位、指数和尾数，遵循 IEEE
754。</li>
<li><strong>注意事项</strong>：浮点运算可能有精度误差（如 0.1 + 0.2 !=
0.3）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">3.14f</span>;  <span class="comment">// 单精度，带 f 后缀</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float value: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 最小正值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0.1 + 0.2: &quot;</span> &lt;&lt; (<span class="number">0.1f</span> + <span class="number">0.2f</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0.30000001（精度误差）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>double</code></strong>
<ul>
<li><strong>功能</strong>：双精度浮点数，8 字节，约 15 位有效数字。</li>
<li><strong>范围</strong>：大约 ±1.8×10^308，精度更高。</li>
<li><strong>使用场景</strong>：需要较高精度的浮点计算，如科学计算。</li>
<li><strong>底层原理</strong>：IEEE 754，双倍尾数位。</li>
<li><strong>注意事项</strong>：仍可能有精度误差，但比 <code>float</code>
小。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.1415926535</span>;  <span class="comment">// 双精度</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double value: &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>long double</code></strong>
<ul>
<li><strong>功能</strong>：扩展精度浮点数，大小和精度视平台而定（常 10
或 16 字节）。</li>
<li><strong>范围</strong>：通常比 <code>double</code>
大，精度更高。</li>
<li><strong>使用场景</strong>：需要极高精度的计算，如数学库。</li>
<li><strong>底层原理</strong>：依赖编译器实现，可能非 IEEE 754。</li>
<li><strong>注意事项</strong>：移植性差，不同平台行为不同。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.141592653589793238L</span>;  <span class="comment">// 扩展精度，带 L 后缀</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long double value: &quot;</span> &lt;&lt; ld &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long double min: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">double</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long double max: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">double</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="字符型"><strong>字符型</strong></h4>
<p>字符型用于存储单个字符或宽字符。</p>
<ul>
<li><strong><code>char</code></strong>
<ul>
<li><strong>功能</strong>：存储单字节字符，1 字节（8 位）。</li>
<li><strong>范围</strong>：有符号时 <code>-128</code> 到
<code>127</code>，无符号时 <code>0</code> 到 <code>255</code>。</li>
<li><strong>使用场景</strong>：表示 ASCII 字符，如字母、数字。</li>
<li><strong>底层原理</strong>：直接存储字符的编码值（如 ASCII）。</li>
<li><strong>注意事项</strong>：默认是否带符号由编译器决定。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;  <span class="comment">// ASCII 值为 65</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char: &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ASCII value: &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 65</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>wchar_t</code></strong>
<ul>
<li><strong>功能</strong>：宽字符，用于存储多字节字符（如
Unicode），大小视平台（常 2 或 4 字节）。</li>
<li><strong>范围</strong>：依赖实现，通常支持更大的字符集。</li>
<li><strong>使用场景</strong>：国际化程序中支持非 ASCII 字符。</li>
<li><strong>底层原理</strong>：存储 Unicode 或其他宽字符编码。</li>
<li><strong>注意事项</strong>：需要宽字符流（如
<code>wcout</code>）输出。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">wchar_t</span> wc = <span class="string">L&#x27;中&#x27;</span>;  <span class="comment">// 宽字符，带 L 前缀</span></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">&quot;wchar_t: &quot;</span> &lt;&lt; wc &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="布尔型"><strong>布尔型</strong></h4>
<ul>
<li><strong><code>bool</code></strong>
<ul>
<li><strong>功能</strong>：表示逻辑值 <code>true</code>（1）或
<code>false</code>（0），通常 1 字节。</li>
<li><strong>使用场景</strong>：条件判断、标志位。</li>
<li><strong>底层原理</strong>：存储为整数，0 表示假，非 0 表示真。</li>
<li><strong>注意事项</strong>：可以隐式转换为整数。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> b1 = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> b2 = <span class="literal">false</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;true: &quot;</span> &lt;&lt; b1 &lt;&lt; <span class="string">&quot;, false: &quot;</span> &lt;&lt; b2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1 0</span></span><br><span class="line">    <span class="type">int</span> i = b1;  <span class="comment">// 隐式转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h3 id="变量与常量"><strong>变量与常量</strong></h3>
<p>变量是程序中可修改的数据存储单元，常量则是不可修改的固定值。</p>
<ul>
<li><strong>变量</strong>
<ul>
<li><strong>功能</strong>：通过类型声明创建变量，可随时修改其值。</li>
<li><strong>使用场景</strong>：存储临时数据、计算中间结果。</li>
<li><strong>底层原理</strong>：分配内存空间，变量名映射到地址。</li>
<li><strong>注意事项</strong>：未初始化变量的值未定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;         <span class="comment">// 声明，未初始化</span></span><br><span class="line">    x = <span class="number">10</span>;        <span class="comment">// 赋值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    x = <span class="number">20</span>;        <span class="comment">// 修改</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>常量</strong>
<ul>
<li><strong>功能</strong>：使用 <code>const</code>
修饰，值在初始化后不可修改。</li>
<li><strong>使用场景</strong>：定义不变的值，如数学常数 PI。</li>
<li><strong>底层原理</strong>：编译器确保常量不可写，可能优化为内联值。</li>
<li><strong>注意事项</strong>：必须初始化，否则编译错误。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y = <span class="number">30</span>;  <span class="comment">// 常量，必须初始化</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 30</span></span><br><span class="line">    <span class="comment">// y = 40;  // 错误：常量不可修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h3 id="运算符"><strong>运算符</strong></h3>
<p>C++
提供了丰富的运算符，用于执行算术、逻辑、位操作等。以下逐一详细讲解。</p>
<h4 id="算术运算符"><strong>算术运算符</strong></h4>
<p>用于基本的数学运算。</p>
<ul>
<li><strong><code>+</code>（加法）</strong>
<ul>
<li><strong>功能</strong>：将两个操作数相加。</li>
<li><strong>使用场景</strong>：数值计算。</li>
<li><strong>注意事项</strong>：整数溢出未定义，浮点数可能有精度误差。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> sum = a + b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 3 = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>-</code>（减法）</strong>
<ul>
<li><strong>功能</strong>：从第一个操作数减去第二个。</li>
<li><strong>使用场景</strong>：计算差值。</li>
<li><strong>注意事项</strong>：同加法，注意溢出。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> diff = a - b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 - 3 = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>*</code>（乘法）</strong>
<ul>
<li><strong>功能</strong>：两个操作数相乘。</li>
<li><strong>使用场景</strong>：面积、体积计算等。</li>
<li><strong>注意事项</strong>：溢出风险更大。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> prod = a * b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 * 3 = &quot;</span> &lt;&lt; prod &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>/</code>（除法）</strong>
<ul>
<li><strong>功能</strong>：第一个操作数除以第二个。</li>
<li><strong>使用场景</strong>：平均值计算。</li>
<li><strong>注意事项</strong>：整数除法结果截断，除以 0 未定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> div = a / b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 / 3 = &quot;</span> &lt;&lt; div &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3（截断）</span></span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a) / b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10.0 / 3 = &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3.33333</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>%</code>（取模）</strong>
<ul>
<li><strong>功能</strong>：返回除法后的余数，仅适用于整数。</li>
<li><strong>使用场景</strong>：判断奇偶、循环计数。</li>
<li><strong>注意事项</strong>：除以 0 未定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> mod = a % b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 % 3 = &quot;</span> &lt;&lt; mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="关系运算符"><strong>关系运算符</strong></h4>
<p>用于比较两个值，返回布尔结果。</p>
<ul>
<li><strong><code>==</code>（等于）</strong>
<ul>
<li><strong>功能</strong>：检查两个操作数是否相等。</li>
<li><strong>使用场景</strong>：条件判断。</li>
<li><strong>注意事项</strong>：浮点数比较需注意精度。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">bool</span> eq = (a == b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 == 5: &quot;</span> &lt;&lt; eq &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>!=</code>（不等于）</strong>
<ul>
<li><strong>功能</strong>：检查两个操作数是否不相等。</li>
<li><strong>使用场景</strong>：排除特定值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">bool</span> neq = (a != b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 != 3: &quot;</span> &lt;&lt; neq &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&lt;</code>（小于）</strong>
<ul>
<li><strong>功能</strong>：检查第一个操作数是否小于第二个。</li>
<li><strong>使用场景</strong>：排序、循环条件。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">bool</span> lt = (a &lt; b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3 &lt; 5: &quot;</span> &lt;&lt; lt &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&gt;</code>（大于）</strong>
<ul>
<li><strong>功能</strong>：检查第一个操作数是否大于第二个。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">bool</span> gt = (a &gt; b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &gt; 3: &quot;</span> &lt;&lt; gt &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&lt;=</code>（小于等于）</strong>
<ul>
<li><strong>功能</strong>：检查第一个操作数是否小于或等于第二个。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">bool</span> le = (a &lt;= b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &lt;= 5: &quot;</span> &lt;&lt; le &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&gt;=</code>（大于等于）</strong>
<ul>
<li><strong>功能</strong>：检查第一个操作数是否大于或等于第二个。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">bool</span> ge = (a &gt;= b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &gt;= 3: &quot;</span> &lt;&lt; ge &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="逻辑运算符"><strong>逻辑运算符</strong></h4>
<p>用于组合布尔表达式。</p>
<ul>
<li><strong><code>&amp;&amp;</code>（与）</strong>
<ul>
<li><strong>功能</strong>：两个操作数都为真时返回真。</li>
<li><strong>使用场景</strong>：多条件判断。</li>
<li><strong>注意事项</strong>：短路求值（左边为假不计算右边）。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">true</span>, b = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> result = (a &amp;&amp; b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;true &amp;&amp; false: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>||</code>（或）</strong>
<ul>
<li><strong>功能</strong>：任一操作数为真时返回真。</li>
<li><strong>注意事项</strong>：短路求值（左边为真不计算右边）。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">true</span>, b = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> result = (a || b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;true || false: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>!</code>（非）</strong>
<ul>
<li><strong>功能</strong>：反转布尔值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> result = !a;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;!true: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="位运算符"><strong>位运算符</strong></h4>
<p>按位操作，直接操作二进制位。</p>
<ul>
<li><strong><code>&amp;</code>（按位与）</strong>
<ul>
<li><strong>功能</strong>：逐位进行与运算。</li>
<li><strong>使用场景</strong>：提取特定位、掩码操作。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 0011</span></span><br><span class="line">    <span class="type">int</span> result = a &amp; b;  <span class="comment">// 0001</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &amp; 3 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>|</code>（按位或）</strong>
<ul>
<li><strong>功能</strong>：逐位进行或运算。</li>
<li><strong>使用场景</strong>：设置特定位。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 0011</span></span><br><span class="line">    <span class="type">int</span> result = a | b;  <span class="comment">// 0111</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 | 3 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>^</code>（按位异或）</strong>
<ul>
<li><strong>功能</strong>：逐位异或，相同为 0，不同为 1。</li>
<li><strong>使用场景</strong>：交换值、检测差异。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 0011</span></span><br><span class="line">    <span class="type">int</span> result = a ^ b;  <span class="comment">// 0110</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 ^ 3 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>~</code>（按位取反）</strong>
<ul>
<li><strong>功能</strong>：将所有位取反。</li>
<li><strong>注意事项</strong>：结果为补码形式。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> result = ~a;  <span class="comment">// 1010（补码表示为 -6）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~5 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// -6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&lt;&lt;</code>（左移）</strong>
<ul>
<li><strong>功能</strong>：将位向左移动，低位补 0。</li>
<li><strong>使用场景</strong>：快速乘以 2 的幂。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> result = a &lt;&lt; <span class="number">1</span>;  <span class="comment">// 1010</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &lt;&lt; 1 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>&gt;&gt;</code>（右移）</strong>
<ul>
<li><strong>功能</strong>：将位向右移动，符号位决定高位补 0 或 1。</li>
<li><strong>使用场景</strong>：快速除以 2 的幂。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">    <span class="type">int</span> result = a &gt;&gt; <span class="number">1</span>;  <span class="comment">// 0010</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 &gt;&gt; 1 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="赋值运算符"><strong>赋值运算符</strong></h4>
<p>用于修改变量值。</p>
<ul>
<li><strong><code>=</code>（赋值）</strong>
<ul>
<li><strong>功能</strong>：将右值赋给左值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>+=</code>（加赋值）</strong>
<ul>
<li><strong>功能</strong>：加后赋值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a += <span class="number">5</span>;  <span class="comment">// a = a + 5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a += 5: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>-=</code>（减赋值）</strong>
<ul>
<li><strong>功能</strong>：减后赋值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a -= <span class="number">3</span>;  <span class="comment">// a = a - 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a -= 3: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>其他赋值运算符</strong>（<code>*=</code>、<code>/=</code>、<code>%=</code>
等类似）
<ul>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a *= <span class="number">2</span>;  <span class="comment">// a = a * 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a *= 2: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="其他运算符"><strong>其他运算符</strong></h4>
<p>一些特殊运算符。</p>
<ul>
<li><strong><code>sizeof</code></strong>
<ul>
<li><strong>功能</strong>：返回类型或变量的字节大小。</li>
<li><strong>使用场景</strong>：内存分配、调试。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(int): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 通常 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(x): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>typeid</code></strong>
<ul>
<li><strong>功能</strong>：返回类型信息，需包含
<code>&lt;typeinfo&gt;</code>。</li>
<li><strong>使用场景</strong>：运行时类型检查。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Type of x: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// &quot;i&quot; (int)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>dynamic_cast</code></strong>
<ul>
<li><strong>功能</strong>：运行时类型转换，用于多态类型。</li>
<li><strong>使用场景</strong>：安全的向下转型。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b);</span><br><span class="line">    <span class="keyword">if</span> (d) std::cout &lt;&lt; <span class="string">&quot;Cast successful\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h3 id="控制结构"><strong>控制结构</strong></h3>
<p>控制结构用于管理程序的执行流程。</p>
<h4 id="条件语句"><strong>条件语句</strong></h4>
<ul>
<li><strong><code>if</code>、<code>else if</code>、<code>else</code></strong>
<ul>
<li><strong>功能</strong>：根据条件执行不同代码块。</li>
<li><strong>使用场景</strong>：分支逻辑。</li>
<li><strong>底层原理</strong>：条件表达式求值为真（非 0）时执行。</li>
<li><strong>注意事项</strong>：避免悬垂 else 问题。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Positive\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Zero\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Negative\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="开关语句"><strong>开关语句</strong></h4>
<ul>
<li><strong><code>switch</code>、<code>case</code>、<code>default</code></strong>
<ul>
<li><strong>功能</strong>：根据整数值跳转到对应分支。</li>
<li><strong>使用场景</strong>：多条件选择。</li>
<li><strong>底层原理</strong>：编译为跳转表或条件分支。</li>
<li><strong>注意事项</strong>：需要
<code>break</code>，否则会贯穿。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: std::cout &lt;&lt; <span class="string">&quot;One\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: std::cout &lt;&lt; <span class="string">&quot;Two\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: std::cout &lt;&lt; <span class="string">&quot;Other\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="循环"><strong>循环</strong></h4>
<ul>
<li><strong><code>for</code></strong>
<ul>
<li><strong>功能</strong>：固定次数循环，包含初始化、条件和增量。</li>
<li><strong>使用场景</strong>：数组遍历、计数。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>while</code></strong>
<ul>
<li><strong>功能</strong>：条件为真时重复执行。</li>
<li><strong>使用场景</strong>：不确定次数的循环。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>do-while</code></strong>
<ul>
<li><strong>功能</strong>：至少执行一次，后检查条件。</li>
<li><strong>使用场景</strong>：需要至少运行一次的循环。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="跳转"><strong>跳转</strong></h4>
<ul>
<li><strong><code>break</code></strong>
<ul>
<li><strong>功能</strong>：跳出当前循环或 switch。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>continue</code></strong>
<ul>
<li><strong>功能</strong>：跳过本次循环，继续下一次。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 3 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>return</code></strong>
<ul>
<li><strong>功能</strong>：退出函数并返回值。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// 返回并退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>goto</code></strong>
<ul>
<li><strong>功能</strong>：跳转到指定标签。</li>
<li><strong>使用场景</strong>：复杂控制流（不推荐）。</li>
<li><strong>注意事项</strong>：易导致代码混乱。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> label;</span><br><span class="line">    x = <span class="number">1</span>;  <span class="comment">// 被跳过</span></span><br><span class="line">label:</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h3 id="函数"><strong>函数</strong></h3>
<p>函数是可重用的代码块，支持多种特性。</p>
<ul>
<li><p><strong>函数声明与定义</strong></p>
<ul>
<li><strong>功能</strong>：声明指定函数签名，定义实现具体逻辑。</li>
<li><strong>使用场景</strong>：模块化编程。</li>
<li><strong>底层原理</strong>：声明生成符号，定义分配代码段。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;  <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;  <span class="comment">// 定义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function called\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>参数传递</strong></p>
<ul>
<li><strong>值传递</strong>：传递副本，修改不影响原值。
<ul>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">byValue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; x = <span class="number">20</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">byValue</span>(a);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>引用传递</strong>：传递别名，修改影响原值。
<ul>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">byReference</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; x = <span class="number">20</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">byReference</span>(a);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p><strong>默认参数</strong></p>
<ul>
<li><strong>功能</strong>：为参数提供默认值，未传参时使用。</li>
<li><strong>注意事项</strong>：默认参数必须从右向左定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>, <span class="type">int</span> y = <span class="number">20</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();      <span class="comment">// 10, 20</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>);     <span class="comment">// 5, 20</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>, <span class="number">15</span>); <span class="comment">// 5, 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>函数重载</strong></p>
<ul>
<li><strong>功能</strong>：同名函数根据参数不同区分。</li>
<li><strong>底层原理</strong>：编译器通过名字修饰区分。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.5</span>, <span class="number">2.5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>内联函数</strong></p>
<ul>
<li><strong>功能</strong>：使用 <code>inline</code>
建议编译器内联展开，减少调用开销。</li>
<li><strong>使用场景</strong>：小型函数提升性能。</li>
<li><strong>注意事项</strong>：仅建议，编译器可能忽略。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">square</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h3 id="指针">指针</h3>
<p>C++
中的指针（Pointer）是一个非常核心且强大的概念，它允许直接操作内存地址。理解指针对于编写高效的
C++
程序、动态内存管理以及底层操作至关重要。下面我会从基础到进阶，详细讲解
C++ 指针的方方面面。</p>
<hr />
<h4 id="什么是指针">1. <strong>什么是指针？</strong></h4>
<ul>
<li><strong>定义</strong>：指针是一个变量，它存储的是另一个变量的内存地址。</li>
<li><strong>内存地址</strong>：在计算机中，每个变量都有一个内存地址，指针通过存储这个地址来间接访问变量。</li>
<li><strong>用途</strong>：
<ul>
<li>动态内存分配（new/delete）。</li>
<li>数组操作。</li>
<li>函数参数传递（避免拷贝大对象）。</li>
<li>实现数据结构（如链表、树）。</li>
</ul></li>
</ul>
<h5 id="指针的声明"><strong>指针的声明</strong></h5>
<p>指针通过 <code>*</code> 符号声明，格式为： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 *指针名;</span><br></pre></td></tr></table></figure> -
<code>类型</code>：指针指向的数据类型。 -
<code>*</code>：表示这是一个指针。</p>
<p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr; <span class="comment">// 声明一个指向 int 类型的指针</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="指针的基本操作">2. <strong>指针的基本操作</strong></h4>
<h5 id="获取变量地址"><strong>（1）获取变量地址</strong></h5>
<p>使用 <code>&amp;</code> 操作符获取变量的地址： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;x; <span class="comment">// ptr 存储 x 的地址</span></span><br></pre></td></tr></table></figure> -
<code>&amp;x</code>：获取变量 <code>x</code> 的内存地址。 -
<code>ptr</code>：存储 <code>x</code> 的地址。</p>
<h5
id="解引用访问指针指向的值"><strong>（2）解引用（访问指针指向的值）</strong></h5>
<p>使用 <code>*</code> 操作符访问指针指向的值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x 的值: &quot;</span> &lt;&lt; x &lt;&lt; endl;         <span class="comment">// 输出: 10</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x 的地址: &quot;</span> &lt;&lt; &amp;x &lt;&lt; endl;      <span class="comment">// 输出: x 的地址（例如 0x7ffee4c0a4ac）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 存储的地址: &quot;</span> &lt;&lt; ptr &lt;&lt; endl; <span class="comment">// 输出: x 的地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 指向的值: &quot;</span> &lt;&lt; *ptr &lt;&lt; endl; <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改指针指向的值</span></span><br><span class="line">    *ptr = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;修改后 x 的值: &quot;</span> &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> -
<code>*ptr</code>：解引用，获取指针 <code>ptr</code> 指向的值。 - 修改
<code>*ptr</code> 会直接改变 <code>x</code>
的值，因为它们指向同一块内存。</p>
<h5 id="指针的初始化"><strong>（3）指针的初始化</strong></h5>
<p>未初始化的指针是危险的（野指针），可能指向随机内存。建议总是初始化指针：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">nullptr</span>; <span class="comment">// C++11 推荐，初始化为空指针</span></span><br></pre></td></tr></table></figure> - <code>nullptr</code>
表示指针不指向任何地址，避免野指针问题。</p>
<hr />
<h4 id="指针与数组">3. <strong>指针与数组</strong></h4>
<p>在 C++ 中，数组名本质上是一个指向数组第一个元素的指针。</p>
<h5 id="数组与指针的关系"><strong>数组与指针的关系</strong></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr = arr; <span class="comment">// arr 是一个指针，指向数组第一个元素</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数组第一个元素: &quot;</span> &lt;&lt; *ptr &lt;&lt; endl;        <span class="comment">// 输出: 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数组第二个元素: &quot;</span> &lt;&lt; *(ptr + <span class="number">1</span>) &lt;&lt; endl;  <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指针遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *(ptr + i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>arr</code> 等价于 <code>&amp;arr[0]</code>，是一个指针。</li>
<li><code>ptr + 1</code>：指针加 1，移动到下一个元素（偏移一个
<code>int</code> 的大小，通常是 4 字节）。</li>
<li><code>*(ptr + i)</code>：访问第 <code>i</code> 个元素。</li>
</ul>
<h5 id="数组下标与指针"><strong>数组下标与指针</strong></h5>
<p>数组下标操作 <code>arr[i]</code> 等价于 <code>*(arr + i)</code>：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">cout &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl;      <span class="comment">// 输出: 3</span></span><br><span class="line">cout &lt;&lt; *(arr + <span class="number">2</span>) &lt;&lt; endl;  <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="动态内存分配">4. <strong>动态内存分配</strong></h4>
<p>C++ 中可以使用 <code>new</code> 和 <code>delete</code>
动态分配和释放内存，指针是动态内存管理的核心。</p>
<h5 id="动态分配内存"><strong>动态分配内存</strong></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 分配一个 int 大小的内存</span></span><br><span class="line">*ptr = <span class="number">42</span>;</span><br><span class="line">cout &lt;&lt; *ptr &lt;&lt; endl; <span class="comment">// 输出: 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// 释放内存</span></span><br><span class="line">ptr = <span class="literal">nullptr</span>; <span class="comment">// 避免野指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>new</code>：分配内存并返回地址。</li>
<li><code>delete</code>：释放内存，避免内存泄漏。</li>
</ul>
<h5 id="动态分配数组"><strong>动态分配数组</strong></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 分配一个包含 5 个 int 的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; endl; <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] arr; <span class="comment">// 释放数组内存</span></span><br><span class="line">arr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>new int[5]</code>：分配数组。</li>
<li><code>delete[]</code>：释放数组内存（注意与 <code>delete</code>
的区别）。</li>
</ul>
<hr />
<h4 id="指针与函数">5. <strong>指针与函数</strong></h4>
<p>指针常用于函数参数传递，特别是在需要修改原始数据或避免拷贝大对象时。</p>
<h5 id="通过指针修改变量"><strong>（1）通过指针修改变量</strong></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(&amp;x, &amp;y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before swap: x = 10, y = 20</span><br><span class="line">After swap: x = 20, y = 10</span><br></pre></td></tr></table></figure></li>
<li>传递地址给函数，通过解引用修改原始变量。</li>
</ul>
<h5
id="指针作为函数返回值"><strong>（2）指针作为函数返回值</strong></h5>
<p>函数可以返回指针，但需要小心返回局部变量的地址（会导致未定义行为）：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">createArray</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="built_in">createArray</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl; <span class="comment">// 输出: 0 1 2 3 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 返回动态分配的内存，调用者负责释放。</p>
<h5
id="避免返回局部变量地址"><strong>（3）避免返回局部变量地址</strong></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">badFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;x; <span class="comment">// 错误！x 是局部变量，函数返回后 x 被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>局部变量的地址在函数返回后无效，访问会导致未定义行为。</li>
</ul>
<hr />
<h4 id="指针的进阶用法">6. <strong>指针的进阶用法</strong></h4>
<h5
id="指针的指针多级指针"><strong>（1）指针的指针（多级指针）</strong></h5>
<p>指针可以指向另一个指针，形成多级指针： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;x;</span><br><span class="line"><span class="type">int</span> **pptr = &amp;ptr; <span class="comment">// 指向指针的指针</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; **pptr &lt;&lt; endl; <span class="comment">// 输出: 10</span></span><br></pre></td></tr></table></figure> -
<code>**pptr</code>：解引用两次，访问 <code>x</code> 的值。</p>
<h5
id="常量指针与指针常量"><strong>（2）常量指针与指针常量</strong></h5>
<ul>
<li><strong>常量指针</strong>（<code>const int *ptr</code>）：指针指向的值是常量，不能修改。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;x;</span><br><span class="line"><span class="comment">// *ptr = 20; // 错误，不能修改值</span></span><br></pre></td></tr></table></figure></li>
<li><strong>指针常量</strong>（<code>int *const ptr</code>）：指针本身是常量，不能指向其他地址。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 可以修改值</span></span><br><span class="line"><span class="comment">// ptr = nullptr; // 错误，不能修改指针地址</span></span><br></pre></td></tr></table></figure></li>
<li><strong>常量指针常量</strong>（<code>const int *const ptr</code>）：既不能修改值，也不能修改地址。</li>
</ul>
<h5 id="函数指针"><strong>（3）函数指针</strong></h5>
<p>函数指针指向函数的地址，用于回调或动态调用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*funcPtr)() = sayHello; <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="built_in">funcPtr</span>(); <span class="comment">// 调用函数，输出: Hello!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="常见问题与注意事项">7. <strong>常见问题与注意事项</strong></h4>
<ul>
<li><strong>野指针</strong>：未初始化或已释放的指针，访问会导致未定义行为。
<ul>
<li>解决：始终初始化指针，释放后置为 <code>nullptr</code>。</li>
</ul></li>
<li><strong>内存泄漏</strong>：动态分配的内存未释放。
<ul>
<li>解决：使用 <code>delete</code> 释放内存，或者使用智能指针（如
<code>std::unique_ptr</code>、<code>std::shared_ptr</code>）。</li>
</ul></li>
<li><strong>悬空指针</strong>：指针指向的内存已被释放。
<ul>
<li>解决：释放后立即置为 <code>nullptr</code>。</li>
</ul></li>
<li><strong>指针越界</strong>：访问数组时超出范围。
<ul>
<li>解决：确保指针操作不越界，使用 <code>std::vector</code>
等容器更安全。</li>
</ul></li>
</ul>
<hr />
<h4 id="智能指针c11-及以上">8. <strong>智能指针（C++11
及以上）</strong></h4>
<p>C++11 引入了智能指针，简化了内存管理，推荐使用： -
<strong><code>std::unique_ptr</code></strong>：独占所有权，自动释放。 -
<strong><code>std::shared_ptr</code></strong>：共享所有权，引用计数。 -
<strong><code>std::weak_ptr</code></strong>：解决
<code>shared_ptr</code> 循环引用问题。</p>
<p><strong>示例：使用 <code>std::unique_ptr</code></strong>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; *ptr &lt;&lt; endl; <span class="comment">// 输出: 42</span></span><br><span class="line">    <span class="comment">// 离开作用域时，ptr 自动释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结">9. <strong>总结</strong></h4>
<ul>
<li><strong>指针基础</strong>：存储地址，使用 <code>*</code>
解引用，<code>&amp;</code> 取地址。</li>
<li><strong>指针与数组</strong>：数组名是指针，指针可以遍历数组。</li>
<li><strong>动态内存</strong>：使用 <code>new</code>
分配，<code>delete</code> 释放。</li>
<li><strong>函数指针</strong>：传递地址，避免拷贝或实现回调。</li>
<li><strong>注意事项</strong>：避免野指针、内存泄漏，使用智能指针更安全。</li>
</ul>
<h3 id="引用"><strong>引用</strong></h3>
<p>C++
中的引用（Reference）是一种非常重要的特性，它为变量提供了一个别名（alias），允许通过这个别名直接访问和操作原始变量。引用在
C++ 中广泛用于函数参数传递、避免拷贝开销、以及简化代码。以下我会详细讲解
C++ 引用的概念、用法、特点以及与指针的对比。</p>
<hr />
<h4 id="什么是引用">1. <strong>什么是引用？</strong></h4>
<ul>
<li><strong>定义</strong>：引用是某个变量的别名，操作引用等价于操作原始变量。</li>
<li><strong>语法</strong>：通过 <code>&amp;</code> 符号声明引用。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 &amp;引用名 = 变量名;</span><br></pre></td></tr></table></figure></li>
<li><strong>本质</strong>：引用并不是一个独立的变量，它只是已有变量的别名，编译器会将对引用的操作直接映射到原始变量上。</li>
</ul>
<h5 id="基本示例"><strong>基本示例</strong></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;ref = x; <span class="comment">// ref 是 x 的引用</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;     <span class="comment">// 输出: 10</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl; <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    ref = <span class="number">20</span>; <span class="comment">// 修改引用，实际修改 x</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;     <span class="comment">// 输出: 20</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int &amp;ref = x</code>：<code>ref</code> 是 <code>x</code>
的引用。</li>
<li>修改 <code>ref</code> 会直接修改
<code>x</code>，因为它们指向同一个内存地址。</li>
</ul>
<hr />
<h4 id="引用的特点">2. <strong>引用的特点</strong></h4>
<h5 id="必须初始化"><strong>（1）必须初始化</strong></h5>
<p>引用在声明时必须初始化，且不能改变指向（不能重新绑定到另一个变量）。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// int &amp;ref; // 错误！引用必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;ref = x;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">ref = y; <span class="comment">// 不是让 ref 指向 y，而是将 y 的值赋给 ref（即 x）</span></span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl; <span class="comment">// 输出: 20</span></span><br></pre></td></tr></table></figure> - <code>ref = y</code>：将 <code>y</code> 的值赋给
<code>x</code>，而不是让 <code>ref</code> 指向 <code>y</code>。</p>
<h5 id="引用不是独立对象"><strong>（2）引用不是独立对象</strong></h5>
<p>引用不占用额外的内存，它只是变量的别名。<code>ref</code> 和
<code>x</code> 的地址相同： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &amp;x &lt;&lt; endl;   <span class="comment">// 输出: x 的地址</span></span><br><span class="line">cout &lt;&lt; &amp;ref &lt;&lt; endl; <span class="comment">// 输出: 同一个地址</span></span><br></pre></td></tr></table></figure></p>
<h5
id="不能创建引用的引用"><strong>（3）不能创建引用的引用</strong></h5>
<p>引用本身不是对象，因此不能创建引用的引用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = x;</span><br><span class="line"><span class="comment">// int &amp;&amp;ref2 = ref; // 错误！不能创建引用的引用</span></span><br></pre></td></tr></table></figure> -
注：<code>&amp;&amp;</code> 在 C++11 中表示右值引用（稍后会讲到）。</p>
<h5
id="不能创建数组的引用"><strong>（4）不能创建数组的引用</strong></h5>
<p>数组的引用是合法的，但不能创建引用的数组： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (&amp;refArr)[<span class="number">3</span>] = arr; <span class="comment">// 合法，引用一个数组</span></span><br><span class="line"><span class="comment">// int &amp;refArr[3] = arr; // 错误，不能创建引用的数组</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="引用的主要用途">3. <strong>引用的主要用途</strong></h4>
<h5 id="函数参数传递"><strong>（1）函数参数传递</strong></h5>
<p>引用常用于函数参数，避免拷贝大对象，提高效率。</p>
<p><strong>示例：按值传递 vs 按引用传递</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值传递（会拷贝）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapByValue</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按引用传递（直接操作原始变量）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapByReference</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swapByValue: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swapByValue</span>(x, y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swapByValue: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swapByReference: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swapByReference</span>(x, y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swapByReference: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 输出：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before swapByValue: x = 10, y = 20</span><br><span class="line">After swapByValue: x = 10, y = 20</span><br><span class="line">Before swapByReference: x = 10, y = 20</span><br><span class="line">After swapByReference: x = 20, y = 10</span><br></pre></td></tr></table></figure> -
<code>swapByValue</code>：值传递，函数内的修改不影响原始变量。 -
<code>swapByReference</code>：引用传递，函数内的修改直接影响原始变量。</p>
<p><strong>效率优势</strong>：
对于大对象（如结构体、类对象），引用传递避免了拷贝开销：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printByValue</span><span class="params">(string s)</span> </span>&#123; <span class="comment">// 拷贝字符串，效率低</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printByReference</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123; <span class="comment">// 引用传递，无拷贝</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="函数返回值"><strong>（2）函数返回值</strong></h5>
<p>引用可以作为函数返回值，避免拷贝大对象： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index]; <span class="comment">// 返回数组元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">getElement</span>(arr, <span class="number">2</span>) = <span class="number">10</span>; <span class="comment">// 修改 arr[2]</span></span><br><span class="line">    cout &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl;  <span class="comment">// 输出: 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> -
返回引用允许直接修改数组元素。</p>
<p><strong>注意</strong>：不要返回局部变量的引用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">badFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 错误！x 是局部变量，函数返回后 x 被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="简化代码"><strong>（3）简化代码</strong></h5>
<p>引用可以让代码更简洁，避免频繁使用指针和解引用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = x;</span><br><span class="line">ref++; <span class="comment">// 直接操作引用，等价于 x++</span></span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl; <span class="comment">// 输出: 11</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="常量引用const-reference">4. <strong>常量引用（const
Reference）</strong></h4>
<p>常量引用常用于函数参数，防止意外修改原始数据，同时允许传递临时对象。</p>
<h5 id="基本用法"><strong>基本用法</strong></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref = x; <span class="comment">// 常量引用</span></span><br><span class="line"><span class="comment">// ref = 20; // 错误！不能通过常量引用修改 x</span></span><br></pre></td></tr></table></figure>
<h5 id="常量引用与临时对象"><strong>常量引用与临时对象</strong></h5>
<p>常量引用可以绑定到临时对象，而普通引用不行： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref = x + <span class="number">1</span>; <span class="comment">// 合法，绑定到临时对象</span></span><br><span class="line"><span class="comment">// int &amp;ref2 = x + 1; // 错误，非 const 引用不能绑定临时对象</span></span><br></pre></td></tr></table></figure></p>
<h5 id="函数参数中的常量引用"><strong>函数参数中的常量引用</strong></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;value)</span> </span>&#123; <span class="comment">// 常量引用，避免拷贝且防止修改</span></span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">print</span>(x);      <span class="comment">// 传递变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">20</span>);     <span class="comment">// 传递临时对象</span></span><br><span class="line">    <span class="built_in">print</span>(x + <span class="number">30</span>); <span class="comment">// 传递表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const int &amp;value</code>：既避免拷贝，又允许传递临时对象。</li>
</ul>
<hr />
<h4 id="c11-引入的右值引用rvalue-reference">5. <strong>C++11
引入的右值引用（Rvalue Reference）</strong></h4>
<p>C++11
引入了右值引用（<code>&amp;&amp;</code>），用于支持移动语义和完美转发，优化性能。</p>
<p><strong>左值与右值</strong></p>
<ul>
<li><strong>左值</strong>（Lvalue）：有固定内存地址，可以取地址的对象（比如变量）。</li>
<li><strong>右值</strong>（Rvalue）：临时对象或字面量，没有固定地址（比如
<code>x + 1</code>、字面量 <code>42</code>）。</li>
</ul>
<p><strong>右值引用</strong></p>
<p>右值引用可以绑定到右值，用于实现移动语义（避免拷贝）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> &amp;lvalue)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;左值: &quot;</span> &lt;&lt; lvalue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> &amp;&amp;rvalue)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;右值: &quot;</span> &lt;&lt; rvalue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">print</span>(x);      <span class="comment">// 调用左值版本</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">20</span>);     <span class="comment">// 调用右值版本</span></span><br><span class="line">    <span class="built_in">print</span>(x + <span class="number">30</span>); <span class="comment">// 调用右值版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
- 输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左值: 10</span><br><span class="line">右值: 20</span><br><span class="line">右值: 40</span><br></pre></td></tr></table></figure></p>
<p><strong>移动语义</strong></p>
<p>右值引用常用于移动构造和移动赋值，避免深拷贝： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 转移资源</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;析构: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString s2 = <span class="built_in">move</span>(s1); <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> -
输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造: Hello</span><br><span class="line">移动构造</span><br><span class="line">析构: Hello</span><br></pre></td></tr></table></figure> - <code>move</code>：将 <code>s1</code>
转换为右值，触发移动构造，避免拷贝。</p>
<h5 id="移动构造函数和移动语义">移动构造函数和移动语义</h5>
<p>这段代码展示了 C++11
引入的右值引用和移动语义，用于优化资源管理，避免不必要的拷贝。</p>
<hr />
<ol type="1">
<li><strong>代码整体结构</strong></li>
</ol>
<ul>
<li><p><strong>头文件</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;iostream&gt;</code>：用于输入输出（<code>cout</code>）。</li>
<li><code>&lt;string&gt;</code>：虽然代码中没有直接使用
<code>std::string</code>，但可能是为了后续扩展。</li>
<li><code>using namespace std;</code>：避免每次使用
<code>std::cout</code> 时写 <code>std::</code>。</li>
</ul></li>
<li><p><strong>类 <code>MyString</code></strong>：</p>
<ul>
<li>这是一个自定义字符串类，内部使用 <code>char*</code>
管理动态分配的字符数组。</li>
<li>包含构造函数、移动构造函数和析构函数。</li>
</ul></li>
<li><p><strong>主函数 <code>main</code></strong>：</p>
<ul>
<li>创建一个 <code>MyString</code> 对象 <code>s1</code>，然后通过
<code>move</code> 将其资源移动到 <code>s2</code>。</li>
</ul></li>
</ul>
<hr />
<ol start="2" type="1">
<li><strong>逐部分分析</strong></li>
</ol>
<p><strong>（1）类 <code>MyString</code> 的定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 转移资源</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;析构: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>成员变量</strong></p>
<ul>
<li><code>char *data</code>：一个指针，指向动态分配的字符数组，用于存储字符串。</li>
</ul>
<p><strong>构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：从一个 C
风格字符串（<code>const char*</code>）构造 <code>MyString</code>
对象。</li>
<li><strong>细节</strong>：
<ul>
<li><code>strlen(str) + 1</code>：计算字符串长度（包括结尾的
<code>\0</code>）。</li>
<li><code>new char[strlen(str) + 1]</code>：动态分配内存，存储字符串。</li>
<li><code>strcpy(data, str)</code>：将输入字符串复制到 <code>data</code>
中。</li>
<li><code>cout &lt;&lt; "构造: " &lt;&lt; data &lt;&lt; endl</code>：打印构造信息。</li>
</ul></li>
</ul>
<p><strong>移动构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyString</span>(MyString &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">    other.data = <span class="literal">nullptr</span>; <span class="comment">// 转移资源</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：这是 C++11
引入的移动构造函数，用于从一个右值（临时对象或被 <code>move</code>
的对象）转移资源。</li>
<li><strong>参数</strong>：
<ul>
<li><code>MyString &amp;&amp;other</code>：右值引用，表示
<code>other</code> 是一个右值（临时对象或即将销毁的对象）。</li>
</ul></li>
<li><strong>细节</strong>：
<ul>
<li><code>: data(other.data)</code>：初始化列表，将 <code>other</code>
的 <code>data</code> 指针直接赋值给当前对象的 <code>data</code>。</li>
<li><code>other.data = nullptr</code>：将 <code>other</code> 的
<code>data</code> 置为空，避免 <code>other</code>
析构时释放同一块内存。</li>
<li><code>noexcept</code>：表示这个函数不会抛出异常，移动构造函数通常需要是
<code>noexcept</code> 的，以便在标准库（如
<code>std::vector</code>）中使用时更安全。</li>
<li><code>cout &lt;&lt; "移动构造" &lt;&lt; endl</code>：打印移动构造信息。</li>
</ul></li>
</ul>
<p><strong>析构函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：在对象销毁时释放动态分配的内存。</li>
<li><strong>细节</strong>：
<ul>
<li><code>if (data)</code>：检查 <code>data</code>
是否为空指针（避免释放空指针）。</li>
<li><code>cout &lt;&lt; "析构: " &lt;&lt; data &lt;&lt; endl</code>：打印析构信息。</li>
<li><code>delete[] data</code>：释放 <code>data</code> 指向的内存。</li>
</ul></li>
</ul>
<p><strong>（2）主函数 <code>main</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString s2 = <span class="built_in">move</span>(s1); <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一行：创建 <code>s1</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>调用普通构造函数，构造一个 <code>MyString</code> 对象
<code>s1</code>。</p></li>
<li><p>内部：</p>
<ul>
<li><p>分配内存，存储字符串 “Hello”。</p></li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造: Hello</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p><strong>第二行：创建 <code>s2</code> 并移动
<code>s1</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyString s2 = <span class="built_in">move</span>(s1); <span class="comment">// 移动构造</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>作用</strong>：通过 <code>std::move</code> 将
<code>s1</code> 转换为右值，触发移动构造函数。</p></li>
<li><p><strong>细节</strong>：</p>
<ul>
<li><p><code>std::move(s1)</code>：将 <code>s1</code> 标记为右值（尽管
<code>s1</code> 是一个左值），告诉编译器可以“偷”它的资源。</p></li>
<li><p>调用移动构造函数：</p>
<ul>
<li><code>s2</code> 的 <code>data</code> 接管 <code>s1</code> 的
<code>data</code>（指向 “Hello” 的内存）。</li>
<li><code>s1</code> 的 <code>data</code> 被置为
<code>nullptr</code>。</li>
</ul></li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移动构造</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p><strong>程序结束：析构</strong></p>
<ul>
<li><p><code>main</code> 函数结束时，<code>s1</code> 和 <code>s2</code>
离开作用域，调用析构函数。</p></li>
<li><p><code>s2</code> 的 <code>data</code> 指向 “Hello”，正常析构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">析构: Hello</span><br></pre></td></tr></table></figure></li>
<li><p><code>s1</code> 的 <code>data</code> 是
<code>nullptr</code>，不会释放内存（避免重复释放）。</p></li>
</ul>
<p><strong>完整输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造: Hello</span><br><span class="line">移动构造</span><br><span class="line">析构: Hello</span><br></pre></td></tr></table></figure>
<hr />
<ol start="3" type="1">
<li><strong>为什么需要移动构造函数？</strong></li>
</ol>
<p><strong>（1）问题：拷贝的开销</strong></p>
<p>如果没有移动构造函数，<code>MyString s2 = s1</code>
会调用拷贝构造函数（这里没有定义，默认会执行深拷贝）：</p>
<ul>
<li>深拷贝会重新分配内存，复制 “Hello”，然后 <code>s1</code> 和
<code>s2</code> 各自管理自己的内存。</li>
<li>问题：如果 <code>s1</code>
即将销毁（比如临时对象），这种拷贝是浪费的。</li>
</ul>
<p><strong>（2）移动语义的优势</strong></p>
<ul>
<li>移动构造函数通过“偷”资源（将 <code>s1</code> 的 <code>data</code>
直接给 <code>s2</code>），避免了深拷贝。</li>
<li><code>s1</code> 的 <code>data</code> 被置为
<code>nullptr</code>，确保它不会重复释放内存。</li>
<li><strong>效率</strong>：移动操作（指针赋值）比拷贝（内存分配和复制）快得多。</li>
</ul>
<p><strong>（3）<code>std::move</code> 的作用</strong></p>
<ul>
<li><code>std::move</code>
并不真正“移动”数据，它只是将对象转换为右值，告诉编译器可以调用移动构造函数。</li>
<li>移动后，<code>s1</code> 进入“可销毁”状态（<code>data</code> 为
<code>nullptr</code>），但仍然可以安全析构。</li>
</ul>
<hr />
<ol start="4" type="1">
<li><strong>代码中需要注意的点</strong></li>
</ol>
<p><strong>（1）内存管理</strong></p>
<ul>
<li><code>MyString</code> 使用动态内存（<code>new</code> 和
<code>delete[]</code>），需要小心管理。</li>
<li>移动构造函数通过将 <code>other.data</code> 置为
<code>nullptr</code>，避免了重复释放内存（double-free）的问题。</li>
</ul>
<p><strong>（2）缺少拷贝构造函数</strong></p>
<ul>
<li>这段代码没有定义拷贝构造函数和拷贝赋值运算符。</li>
<li>如果直接拷贝（<code>MyString s2 = s1</code>），编译器会生成默认的拷贝构造函数，导致浅拷贝（<code>s1</code>
和 <code>s2</code> 共享
<code>data</code>），析构时会重复释放内存，引发崩溃。</li>
<li><strong>改进</strong>：需要实现拷贝构造函数和拷贝赋值运算符（遵循“规则五”）。</li>
</ul>
<p><strong>改进后的代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString &amp;other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;析构: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString s2 = <span class="built_in">move</span>(s1); <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）<code>noexcept</code> 的重要性</strong></p>
<ul>
<li>移动构造函数标记为
<code>noexcept</code>，告诉编译器它不会抛出异常。</li>
<li>标准库（如 <code>std::vector</code>）在移动元素时会优先选择
<code>noexcept</code> 的移动构造函数，否则可能退回到拷贝。</li>
</ul>
<hr />
<ol start="5" type="1">
<li><strong>移动语义的核心思想</strong></li>
</ol>
<ul>
<li><strong>移动语义</strong>：将资源从一个对象“转移”到另一个对象，而不是拷贝。</li>
<li><strong>适用场景</strong>：
<ul>
<li>临时对象（右值）即将销毁时。</li>
<li>需要高效转移资源（如动态内存、文件句柄）。</li>
</ul></li>
<li><strong>好处</strong>：
<ul>
<li>避免不必要的深拷贝，提高性能。</li>
<li>资源管理更安全（避免重复释放）。</li>
</ul></li>
</ul>
<hr />
<ol start="6" type="1">
<li><strong>总结</strong></li>
</ol>
<ul>
<li><strong>代码功能</strong>：
<ul>
<li><code>MyString</code> 是一个管理动态字符串的类。</li>
<li>移动构造函数通过右值引用（<code>&amp;&amp;</code>）实现资源转移，避免深拷贝。</li>
<li><code>std::move</code> 将 <code>s1</code>
转换为右值，触发移动构造。</li>
</ul></li>
<li><strong>输出解释</strong>：
<ul>
<li>构造 <code>s1</code>：分配内存，存储 “Hello”。</li>
<li>移动构造 <code>s2</code>：将 <code>s1</code> 的 <code>data</code>
转移给 <code>s2</code>，<code>s1</code> 的 <code>data</code> 置为
<code>nullptr</code>。</li>
<li>析构：<code>s2</code> 释放 “Hello”，<code>s1</code> 的
<code>data</code> 是 <code>nullptr</code>，不释放。</li>
</ul></li>
<li><strong>改进建议</strong>：
<ul>
<li>添加拷贝构造函数和拷贝赋值运算符，避免浅拷贝问题。</li>
<li>考虑使用 <code>std::string</code> 替代
<code>char*</code>，更安全且方便。</li>
</ul></li>
</ul>
<p>如果你还有不明白的地方（比如右值引用的细节或拷贝构造函数的实现），可以告诉我，我会进一步讲解！</p>
<hr />
<h4 id="引用与指针的对比">6. <strong>引用与指针的对比</strong></h4>
<table>
<thead>
<tr class="header">
<th><strong>特性</strong></th>
<th><strong>引用</strong></th>
<th><strong>指针</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>初始化</strong></td>
<td>必须初始化，不能改变指向</td>
<td>可以不初始化，可改变指向</td>
</tr>
<tr class="even">
<td><strong>内存</strong></td>
<td>不占用额外内存（只是别名）</td>
<td>占用内存（存储地址）</td>
</tr>
<tr class="odd">
<td><strong>语法</strong></td>
<td>直接使用（无需解引用）</td>
<td>需要 <code>*</code> 解引用</td>
</tr>
<tr class="even">
<td><strong>安全性</strong></td>
<td>更安全，不会指向无效内存</td>
<td>可能出现野指针、悬空指针</td>
</tr>
<tr class="odd">
<td><strong>用途</strong></td>
<td>函数参数、简化代码</td>
<td>动态内存、复杂数据结构</td>
</tr>
</tbody>
</table>
<p><strong>选择建议</strong>： -
优先使用引用，除非需要动态内存分配或改变指向（用指针）。 -
函数参数传递时，引用比指针更简洁且安全。</p>
<hr />
<h4 id="注意事项">7. <strong>注意事项</strong></h4>
<ul>
<li><strong>避免返回局部变量的引用</strong>：局部变量在函数返回后销毁，返回其引用会导致未定义行为。</li>
<li><strong>引用与指针混用</strong>：引用可以绑定到指针解引用后的值：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;x;</span><br><span class="line"><span class="type">int</span> &amp;ref = *ptr; <span class="comment">// ref 绑定到 ptr 指向的值</span></span><br><span class="line">ref = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl; <span class="comment">// 输出: 20</span></span><br></pre></td></tr></table></figure></li>
<li><strong>性能优化</strong>：对于大对象，使用引用传递（尤其是
<code>const</code> 引用）可以避免拷贝。</li>
</ul>
<hr />
<h4 id="总结-1">8. <strong>总结</strong></h4>
<ul>
<li><strong>引用基础</strong>：引用是变量的别名，操作引用等价于操作原始变量。</li>
<li><strong>用途</strong>：
<ul>
<li>函数参数传递：避免拷贝，提高效率。</li>
<li>函数返回值：允许直接修改。</li>
<li>简化代码：无需解引用。</li>
</ul></li>
<li><strong>常量引用</strong>：防止修改，绑定临时对象。</li>
<li><strong>右值引用</strong>：支持移动语义，优化性能。</li>
<li><strong>与指针对比</strong>：引用更安全、简洁，但灵活性不如指针。</li>
</ul>
<hr />
<h3
id="类与对象面向对象特性"><strong>类与对象（面向对象特性）</strong></h3>
<p>C++ 的面向对象特性是其区别于 C
的重要部分，支持封装、继承和多态。以下是对每个子特性的详细讲解。</p>
<h4 id="类定义class-和-struct"><strong>类定义（<code>class</code> 和
<code>struct</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：类是用户定义的类型，封装数据和行为；<code>class</code>
默认访问权限为 <code>private</code>，<code>struct</code> 默认为
<code>public</code>。</li>
<li><strong>使用场景</strong>：建模现实世界的实体，如人、车等。</li>
<li><strong>底层原理</strong>：类是编译器的蓝图，实例化后分配内存，成员按声明顺序排列。</li>
<li><strong>注意事项</strong>：注意内存对齐可能增加对象大小；<code>class</code>
和 <code>struct</code> 在语法上等价，仅默认访问权限不同。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  <span class="comment">// class 定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;  <span class="comment">// struct 定义</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;  <span class="comment">// 默认 public</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyClass x: &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    MyStruct s;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyStruct y: &quot;</span> &lt;&lt; s.y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="访问控制publicprivateprotected"><strong>访问控制（<code>public</code>、<code>private</code>、<code>protected</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：控制类成员的访问权限：
<ul>
<li><code>public</code>：任何地方可访问。</li>
<li><code>private</code>：仅类内部和友元可访问。</li>
<li><code>protected</code>：类内部和派生类可访问。</li>
</ul></li>
<li><strong>使用场景</strong>：封装数据，隐藏实现细节。</li>
<li><strong>底层原理</strong>：访问控制由编译器在编译时检查，不影响运行时。</li>
<li><strong>注意事项</strong>：合理设计访问权限以保护数据一致性。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// 私有</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;  <span class="comment">// 受保护</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> z = <span class="number">30</span>;  <span class="comment">// 公有</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; obj.x &lt;&lt; &quot;\n&quot;;  // 错误：私有</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; obj.y &lt;&lt; &quot;\n&quot;;  // 错误：受保护</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; obj.z &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 30</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; obj.<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="构造函数与析构函数"><strong>构造函数与析构函数</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><strong>构造函数</strong>：初始化对象，名称与类名相同，无返回值。构造顺序：基类
-&gt; 成员对象 -&gt; 派生类。</li>
<li><strong>析构函数</strong>：清理资源，名称为
<code>~类名</code>，自动调用。析构顺序：派生类 -&gt; 成员对象 -&gt;
基类（与构造相反）。</li>
<li>局部对象遵循“后构造先析构”，全局/静态对象和数组元素也有类似规律。虚析构函数确保多态场景下析构顺序正确。</li>
</ul></li>
<li><strong>使用场景</strong>：管理对象生命周期，如分配/释放动态内存。</li>
<li><strong>底层原理</strong>：构造函数在对象创建时由编译器调用，析构函数在对象销毁时调用（栈上自动，堆上需
<code>delete</code>）。</li>
<li><strong>注意事项</strong>：若未定义，编译器提供默认版本；动态内存需手动释放。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) &#123;  <span class="comment">// 构造函数</span></span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="built_in">int</span>(val);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;  <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 栈上对象，自动析构</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 输出 Constructor -&gt; Value -&gt; Destructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="拷贝构造函数"><strong>拷贝构造函数</strong></h4>
<ul>
<li><strong>功能</strong>：以现有对象初始化新对象，形式为
<code>Class(const Class&amp;)</code>。</li>
<li><strong>使用场景</strong>：对象复制，如函数参数传递。</li>
<li><strong>底层原理</strong>：默认执行浅拷贝，自定义可实现深拷贝。</li>
<li><strong>注意事项</strong>：若有动态资源，需深拷贝以避免双重释放。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">int</span>(val)) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="built_in">int</span>(*other.ptr);  <span class="comment">// 深拷贝</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    MyClass b = a;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10, 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="成员函数与数据成员"><strong>成员函数与数据成员</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><strong>数据成员</strong>：类中的变量，存储对象状态。</li>
<li><strong>成员函数</strong>：类中的函数，操作数据成员。</li>
</ul></li>
<li><strong>使用场景</strong>：实现类的行为和属性。</li>
<li><strong>底层原理</strong>：成员函数共享，所有对象调用同一代码；数据成员每个对象独立存储。</li>
<li><strong>注意事项</strong>：避免成员函数修改意外数据。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; x++; &#125;  <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial x: &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    obj.<span class="built_in">increment</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After increment: &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="静态成员static"><strong>静态成员（<code>static</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><strong>静态数据成员</strong>：类级别共享，所有对象共用。</li>
<li><strong>静态成员函数</strong>：无需对象即可调用，仅访问静态成员。</li>
</ul></li>
<li><strong>使用场景</strong>：计数对象数量、工具函数。</li>
<li><strong>底层原理</strong>：静态成员存储在全局数据区，生命周期与程序相同。</li>
<li><strong>注意事项</strong>：静态数据成员需在类外定义。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 静态数据成员</span></span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; count++; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;  <span class="comment">// 静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>;  <span class="comment">// 类外定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass a, b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object count: &quot;</span> &lt;&lt; MyClass::<span class="built_in">getCount</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="友元friend"><strong>友元（<code>friend</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：允许外部函数或类访问私有成员。</li>
<li><strong>使用场景</strong>：实现紧密相关的类或函数。</li>
<li><strong>底层原理</strong>：编译器放宽访问限制。</li>
<li><strong>注意事项</strong>：过度使用破坏封装。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">print</span><span class="params">(MyClass&amp; obj)</span></span>;  <span class="comment">// 友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; obj.x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="built_in">print</span>(obj);  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="继承单继承多继承"><strong>继承（单继承、多继承）</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><strong>单继承</strong>：一个基类派生一个子类。</li>
<li><strong>多继承</strong>：多个基类派生一个子类。</li>
</ul></li>
<li><strong>使用场景</strong>：代码复用、建模层次关系。</li>
<li><strong>底层原理</strong>：子类对象包含基类子对象，多继承可能导致内存布局复杂。</li>
<li><strong>注意事项</strong>：多继承可能引发菱形继承问题。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;  <span class="comment">// 单继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> z = <span class="number">30</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Multi</span> : <span class="keyword">public</span> Base, <span class="keyword">public</span> Base2 &#123;  <span class="comment">// 多继承</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; d.x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; d.y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10, 20</span></span><br><span class="line">    Multi m;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; m.x &lt;&lt; <span class="string">&quot;, z: &quot;</span> &lt;&lt; m.z &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10, 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多态性虚函数-virtual纯虚函数-0"><strong>多态性（虚函数
<code>virtual</code>，纯虚函数 <code>= 0</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><strong>虚函数</strong>：通过基类指针调用派生类实现。</li>
<li><strong>纯虚函数</strong>：定义抽象接口，派生类必须实现。</li>
</ul></li>
<li><strong>使用场景</strong>：运行时多态，如插件系统。</li>
<li><strong>底层原理</strong>：虚函数通过虚表（vtable）实现，每个类一个虚表指针。</li>
<li><strong>注意事项</strong>：虚函数有运行时开销；纯虚函数使类抽象。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>; &#125;  <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pure</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;  <span class="comment">// 虚析构函数，当基类指针指向派生类对象时，如果基类的析构函数不是虚函数，delete 操作只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类中分配的资源（如动态内存、文件句柄等）无法释放，造成内存泄漏或资源未清理。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pure</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Pure implemented\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">speak</span>();  <span class="comment">// Derived</span></span><br><span class="line">    ptr-&gt;<span class="built_in">pure</span>();   <span class="comment">// Pure implemented</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="抽象类与接口"><strong>抽象类与接口</strong></h4>
<ul>
<li><strong>功能</strong>：含纯虚函数的类为抽象类，不能实例化；全纯虚函数类可作为接口。</li>
<li><strong>使用场景</strong>：定义通用接口，如策略模式。</li>
<li><strong>底层原理</strong>：抽象类阻止实例化，强制子类实现。</li>
<li><strong>注意事项</strong>：析构函数应为虚函数。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">action</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Interface</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Impl</span> : <span class="keyword">public</span> Interface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Action\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Interface* ptr = <span class="keyword">new</span> <span class="built_in">Impl</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">action</span>();  <span class="comment">// Action</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="模板"><strong>模板</strong></h3>
<p>模板支持泛型编程，使代码类型无关。</p>
<h4 id="函数模板"><strong>函数模板</strong></h4>
<ul>
<li><strong>功能</strong>：定义泛型函数，适用于多种类型。</li>
<li><strong>使用场景</strong>：通用算法，如最大值计算。</li>
<li><strong>底层原理</strong>：编译器为每种类型生成具体函数。</li>
<li><strong>注意事项</strong>：类型需支持函数中使用的操作。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> my_utils &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max int: &quot;</span> &lt;&lt; my_utils::<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// 5，会和 std::max 冲突， &lt;algorithm&gt; 库下的，或者使用 ::max ,表示使用全局命名空间中的 max</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max double: &quot;</span> &lt;&lt; my_utils::<span class="built_in">max</span>(<span class="number">1.5</span>, <span class="number">2.5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="类模板"><strong>类模板</strong></h4>
<ul>
<li><strong>功能</strong>：定义泛型类，成员类型可变。</li>
<li><strong>使用场景</strong>：容器类，如向量、列表。</li>
<li><strong>底层原理</strong>：编译器为每种类型实例化类。</li>
<li><strong>注意事项</strong>：模板定义和实现通常放在头文件中。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(T v)</span> </span>&#123; value = v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box&lt;<span class="type">int</span>&gt; <span class="title">intBox</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int box: &quot;</span> &lt;&lt; intBox.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    <span class="function">Box&lt;<span class="type">double</span>&gt; <span class="title">doubleBox</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double box: &quot;</span> &lt;&lt; doubleBox.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3.14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="异常处理"><strong>异常处理</strong></h3>
<p>异常处理机制用于管理运行时错误。</p>
<h4
id="trycatchthrow"><strong><code>try</code>、<code>catch</code>、<code>throw</code></strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><code>throw</code>：抛出异常。</li>
<li><code>try</code>：包裹可能抛异常的代码。</li>
<li><code>catch</code>：捕获并处理异常。</li>
</ul></li>
<li><strong>使用场景</strong>：错误处理，如文件操作失败。</li>
<li><strong>底层原理</strong>：异常通过栈展开传递，调用析构函数。</li>
<li><strong>注意事项</strong>：未捕获的异常终止程序。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Negative value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// Negative value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="标准异常类如-stdexception"><strong>标准异常类（如
<code>std::exception</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：提供标准化的异常类型。</li>
<li><strong>使用场景</strong>：一致性错误处理。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of bounds&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Out of range: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="命名空间"><strong>命名空间</strong></h3>
<p>命名空间用于组织代码，避免命名冲突。</p>
<h4
id="定义namespace"><strong>定义（<code>namespace</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：将标识符分组，限定作用域。</li>
<li><strong>使用场景</strong>：库开发、避免全局污染。</li>
<li><strong>底层原理</strong>：编译器通过命名空间修饰符号名。</li>
<li><strong>注意事项</strong>：嵌套命名空间增加复杂度。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> MySpace &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">namespace</span> Inner &#123;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; MySpace::x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; MySpace::Inner::y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用using"><strong>使用（<code>using</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：引入命名空间或特定符号。</li>
<li><strong>注意事项</strong>：<code>using namespace</code>
可能导致冲突。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> MySpace &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> MySpace::x;  <span class="comment">// 引入 x</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    <span class="comment">// using namespace MySpace;  // 引入整个命名空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="动态内存管理"><strong>动态内存管理</strong></h3>
<p>C++ 支持手动管理堆内存。</p>
<h4 id="new-和-delete"><strong><code>new</code> 和
<code>delete</code></strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><code>new</code>：分配堆内存并构造对象。</li>
<li><code>delete</code>：析构对象并释放内存。</li>
</ul></li>
<li><strong>使用场景</strong>：动态对象生命周期管理。</li>
<li><strong>底层原理</strong>：调用内存分配器（如
<code>malloc</code>）和构造函数。</li>
<li><strong>注意事项</strong>：成对使用，避免内存泄漏。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* ptr = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; ptr-&gt;x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;  <span class="comment">// 释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数组new-和-delete"><strong>数组（<code>new[]</code> 和
<code>delete[]</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：分配和释放连续内存块。</li>
<li><strong>注意事项</strong>：<code>new[]</code> 需用
<code>delete[]</code> 释放。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 分配并初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] arr;  <span class="comment">// 释放数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="预处理器"><strong>预处理器</strong></h3>
<p>预处理器在编译前处理代码。</p>
<h4
id="宏定义define"><strong>宏定义（<code>#define</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：定义常量或简单函数。</li>
<li><strong>使用场景</strong>：常量、调试开关。</li>
<li><strong>底层原理</strong>：文本替换，无类型检查。</li>
<li><strong>注意事项</strong>：避免复杂宏，易出错。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))  <span class="comment">// 注意括号</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PI: &quot;</span> &lt;&lt; PI &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3.14</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square(5): &quot;</span> &lt;&lt; <span class="built_in">SQUARE</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="条件编译ifdefifndefendif"><strong>条件编译（<code>#ifdef</code>、<code>#ifndef</code>、<code>#endif</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：根据条件包含或排除代码。</li>
<li><strong>使用场景</strong>：跨平台代码、调试。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Debug mode\n&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Release mode\n&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> RELEASE</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not release\n&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="文件包含include"><strong>文件包含（<code>#include</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：引入头文件或源代码。</li>
<li><strong>注意事项</strong>：使用 <code>&lt;&gt;</code>
表示标准库，<code>""</code> 表示用户文件。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 标准库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span>  <span class="comment">// 用户头文件（假设存在）</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h2 id="现代-c-新特性c11-及之后"><strong>2. 现代 C++ 新特性（C++11
及之后）</strong></h2>
<h3 id="c11"><strong>C++11</strong></h3>
<h4 id="raii">RAII</h4>
<p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是
C++
编程中的一种核心设计理念，用于管理资源的分配和释放。它通过将资源的生命周期绑定到对象的生命周期，利用
C++
的自动对象管理机制（主要是栈对象的构造和析构），确保资源在使用完毕后被正确释放，避免资源泄漏。以下是对
RAII 的详细讲解，包括其原理、实现方式、优点和典型应用。</p>
<hr />
<h5 id="什么是-raii">什么是 RAII？</h5>
<p>RAII 的核心思想是：</p>
<ul>
<li><strong>资源获取</strong>（如内存、文件句柄、锁、网络连接等）在对象构造时完成。</li>
<li><strong>资源释放</strong>在对象析构时自动完成。</li>
<li>利用 C++
的<strong>栈对象生命周期</strong>（当对象离开作用域时，析构函数自动调用），RAII
确保资源在不再需要时被正确清理，即使发生异常也能保证释放。</li>
</ul>
<p>RAII 是 C++ 异常安全性和资源管理的基础，广泛用于标准库和现代 C++
编程。</p>
<hr />
<h5 id="raii-的工作原理">RAII 的工作原理</h5>
<ol type="1">
<li><strong>资源与对象绑定</strong>：
<ul>
<li>在对象的构造函数中获取资源（例如分配内存、打开文件、加锁）。</li>
<li>资源的释放逻辑放在析构函数中。</li>
</ul></li>
<li><strong>自动管理</strong>：
<ul>
<li>C++
保证当对象离开作用域（无论是正常退出还是抛出异常），其析构函数都会被调用。</li>
<li>因此，资源的释放是自动的，无需程序员手动干预。</li>
</ul></li>
<li><strong>异常安全</strong>：
<ul>
<li>即使代码抛出异常，栈上的对象仍会按逆序析构（栈解退，stack
unwinding），确保资源不泄漏。</li>
</ul></li>
</ol>
<hr />
<h5 id="raii-的代码示例">RAII 的代码示例</h5>
<p>以下是一个简单的 RAII 示例，用于管理动态分配的内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data; <span class="comment">// 动态分配的资源</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 构造函数中获取资源</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource acquired: &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 析构函数中释放资源</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource released&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource r; <span class="comment">// 栈上对象，自动管理</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using resource: &quot;</span> &lt;&lt; r.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 即使这里抛出异常，r 的析构函数也会被调用</span></span><br><span class="line">&#125; <span class="comment">// r 离开作用域，自动调用析构函数释放资源</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">useResource</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired: 42</span><br><span class="line">Using resource: 42</span><br><span class="line">Resource released</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中：</p>
<ul>
<li><code>Resource</code>
对象的构造函数分配内存（<code>new int</code>）。</li>
<li>析构函数释放内存（<code>delete data</code>）。</li>
<li><code>r</code>
是栈对象，离开作用域时自动调用析构函数，确保内存不泄漏。</li>
</ul>
<hr />
<h5 id="raii-的典型应用">RAII 的典型应用</h5>
<p>RAII 在 C++ 中无处不在，以下是几个常见场景：</p>
<ol type="1">
<li><strong>动态内存管理</strong>：
<ul>
<li>标准库的智能指针（如 <code>std::unique_ptr</code> 和
<code>std::shared_ptr</code>）是 RAII 的经典实现。</li>
<li>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 使用 ptr</span></span><br><span class="line">&#125; <span class="comment">// ptr 离开作用域，内存自动释放</span></span><br></pre></td></tr></table></figure></li>
<li><code>unique_ptr</code> 在析构时自动调用
<code>delete</code>，无需手动释放。</li>
</ul></li>
<li><strong>文件管理</strong>：
<ul>
<li><code>std::fstream</code>（如
<code>std::ifstream</code>、<code>std::ofstream</code>）使用 RAII
管理文件句柄。</li>
<li>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    file &lt;&lt; <span class="string">&quot;Hello, RAII!&quot;</span>;</span><br><span class="line">&#125; <span class="comment">// file 离开作用域，自动关闭文件</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>互斥锁管理</strong>：
<ul>
<li><code>std::lock_guard</code> 和 <code>std::unique_lock</code> 使用
RAII 管理线程同步中的锁。</li>
<li>示例（结合你的线程代码）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// RAII 管理锁</span></span><br><span class="line">        ++counter;</span><br><span class="line">    &#125; <span class="comment">// lock 离开作用域，自动解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>lock_guard</code>
在构造时加锁，析构时解锁，保证即使抛出异常，锁也会释放。</li>
</ul></li>
<li><strong>其他资源</strong>：
<ul>
<li>网络连接（如 <code>std::socket</code> 的封装）。</li>
<li>数据库连接。</li>
<li>图形资源（如 OpenGL 上下文）。</li>
</ul></li>
</ol>
<hr />
<h5 id="raii-的优点">RAII 的优点</h5>
<ol type="1">
<li><strong>自动资源管理</strong>：
<ul>
<li>资源释放由析构函数自动完成，避免手动调用
<code>delete</code>、<code>close</code> 等。</li>
</ul></li>
<li><strong>异常安全</strong>：
<ul>
<li>即使抛出异常，栈解退机制确保析构函数被调用，防止资源泄漏。</li>
</ul></li>
<li><strong>代码简洁</strong>：
<ul>
<li>减少手动管理资源的代码，降低出错概率。</li>
</ul></li>
<li><strong>确定性释放</strong>：
<ul>
<li>资源在对象离开作用域时立即释放，行为可预测。</li>
</ul></li>
</ol>
<hr />
<h5 id="raii-的注意事项">RAII 的注意事项</h5>
<ol type="1">
<li><strong>避免手动管理</strong>：
<ul>
<li>不要在 RAII 对象之外手动释放资源（如
<code>delete ptr.get()</code>），否则可能导致未定义行为。</li>
</ul></li>
<li><strong>析构函数不抛异常</strong>：
<ul>
<li>RAII 依赖析构函数的调用，析构函数应保证不抛出异常（通常标记为
<code>noexcept</code>）。</li>
<li>如果析构函数抛出异常，可能导致程序终止（<code>std::terminate</code>）。</li>
</ul></li>
<li><strong>拷贝和移动</strong>：
<ul>
<li>RAII 对象管理独占资源时（如
<code>std::unique_ptr</code>），通常禁用拷贝，允许移动。</li>
<li>如果需要共享资源（如
<code>std::shared_ptr</code>），需明确定义拷贝语义。</li>
</ul></li>
<li><strong>性能开销</strong>：
<ul>
<li>RAII
对象的构造和析构可能引入少量开销，但通常被其安全性和简洁性抵消。</li>
</ul></li>
</ol>
<hr />
<h5 id="raii-与你的线程代码">RAII 与你的线程代码</h5>
<p>在你的原始代码中： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>std::thread</code> 本身不是严格的 RAII
对象，因为它不会自动调用 <code>join</code> 或 <code>detach</code>。如果
<code>t1</code> 未被 <code>join</code> 或 <code>detach</code>
就离开作用域，程序会调用 <code>std::terminate</code>。</li>
<li>改进方式：使用 RAII 封装
<code>std::thread</code>，确保线程总是被正确管理： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadRAII</span> &#123;</span><br><span class="line">    std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadRAII</span><span class="params">(std::thread&amp;&amp; thread)</span> : t(std::move(thread)) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">ThreadRAII</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) t.<span class="built_in">join</span>(); <span class="comment">// 自动 join</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ThreadRAII</span>(<span class="type">const</span>.ConcurrentThreadRAII&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝</span></span><br><span class="line">    ThreadRAII&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadRAII&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ThreadRAII <span class="title">t1</span><span class="params">(std::thread(increment))</span></span>;</span><br><span class="line">    <span class="function">ThreadRAII <span class="title">t2</span><span class="params">(std::thread(increment))</span></span>;</span><br><span class="line">    <span class="comment">// 离开作用域时，t1 和 t2 自动 join</span></span><br><span class="line">    std::cout &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ThreadRAII</code> 确保线程在析构时被 <code>join</code>，符合
RAII 原则。</li>
</ul></li>
</ul>
<p>此外，修复数据竞争时使用的 <code>std::lock_guard</code> 是 RAII
的典型应用，确保锁的自动释放。</p>
<hr />
<h5 id="总结-2">总结</h5>
<ul>
<li><strong>RAII</strong> 是 C++ 的核心
idiom，通过将资源管理绑定到对象的构造和析构，实现自动、异常安全的资源管理。</li>
<li>它广泛应用于内存（智能指针）、文件、锁等场景，简化代码并提高可靠性。</li>
<li>关键点：资源在构造函数中获取，析构函数中释放；利用栈解退保证释放。</li>
<li>在你的线程代码中，RAII 可用于管理锁（如
<code>std::lock_guard</code>）或封装线程（如
<code>ThreadRAII</code>），解决数据竞争和线程管理问题。</li>
<li>RAII 是现代 C++（如 C++11
及以后）的基石，体现了“用对象管理资源”的哲学。</li>
</ul>
<p>如果需要更深入的讲解或特定示例，请告诉我！</p>
<h4 id="自动类型推导"><strong>自动类型推导</strong></h4>
<ul>
<li><strong><code>auto</code></strong>
<ul>
<li><strong>功能</strong>：让编译器根据初始化表达式推导变量类型。</li>
<li><strong>使用场景</strong>：简化复杂类型声明，如迭代器。</li>
<li><strong>底层原理</strong>：编译时类型推导，不影响运行时。</li>
<li><strong>注意事项</strong>：需初始化；不改变类型安全。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = <span class="number">10</span>;  <span class="comment">// int</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="number">3.14</span>;  <span class="comment">// double</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ni: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, d: &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>decltype</code></strong>
<ul>
<li><strong>功能</strong>：提取表达式的类型，用于声明变量。</li>
<li><strong>使用场景</strong>：模板编程、类型推导。</li>
<li><strong>底层原理</strong>：编译时分析表达式类型。</li>
<li><strong>注意事项</strong>：可与 <code>auto</code> 结合使用。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(x) y = <span class="number">20</span>;  <span class="comment">// y 是 int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">decltype</span>(x + <span class="number">3.14</span>) z = <span class="number">5.5</span>;  <span class="comment">// z 是 double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 5.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="范围-for-循环"><strong>范围 for 循环</strong></h4>
<ul>
<li><strong>功能</strong>：基于范围的循环，简化容器遍历。</li>
<li><strong>使用场景</strong>：数组、STL 容器遍历。</li>
<li><strong>底层原理</strong>：编译器将其转换为迭代器循环。</li>
<li><strong>注意事项</strong>：容器需支持 <code>begin()</code> 和
<code>end()</code>。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) &#123;  <span class="comment">// 按值</span></span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; x : v) &#123;  <span class="comment">// 按引用修改</span></span><br><span class="line">        x *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 2 4 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="nullptr"><strong>nullptr</strong></h4>
<ul>
<li><strong>功能</strong>：替代 <code>NULL</code>，明确表示空指针。</li>
<li><strong>使用场景</strong>：初始化指针、检查有效性。</li>
<li><strong>底层原理</strong>：<code>nullptr</code> 是
<code>nullptr_t</code> 类型，避免整数转换问题。</li>
<li><strong>注意事项</strong>：比
<code>NULL</code>（0）更类型安全。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;int\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>*)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;pointer\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pointer is null\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// func(NULL);  // 歧义，可能调用 int</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>);  <span class="comment">// 明确调用 pointer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="智能指针"><strong>智能指针</strong></h4>
<ul>
<li><strong><code>std::unique_ptr</code></strong>
<ul>
<li><strong>功能</strong>：独占所有权的智能指针，自动释放内存。</li>
<li><strong>使用场景</strong>：管理单一所有权的动态资源。</li>
<li><strong>底层原理</strong>：RAII 封装，析构时调用
<code>delete</code>。</li>
<li><strong>注意事项</strong>：不可复制，只能移动。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *uptr &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; uptr2 = uptr;  // 错误：不可复制</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uptr2 = std::<span class="built_in">move</span>(uptr);  <span class="comment">// 移动</span></span><br><span class="line">    <span class="keyword">if</span> (!uptr) std::cout &lt;&lt; <span class="string">&quot;uptr is null\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;uptr2: &quot;</span> &lt;&lt; *uptr2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>std::shared_ptr</code></strong>
<ul>
<li><strong>功能</strong>：共享所有权的智能指针，引用计数管理。</li>
<li><strong>使用场景</strong>：多个对象共享资源。</li>
<li><strong>底层原理</strong>：引用计数为 0 时释放内存。</li>
<li><strong>注意事项</strong>：避免循环引用。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sptr1: &quot;</span> &lt;&lt; *sptr1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sptr2 = sptr1;  <span class="comment">// 共享</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;sptr2: &quot;</span> &lt;&lt; *sptr2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Use count: &quot;</span> &lt;&lt; sptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After scope, sptr1: &quot;</span> &lt;&lt; *sptr1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 引用计数为 0，释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>std::weak_ptr</code></strong>
<ul>
<li><strong>功能</strong>：弱引用指针，解决 <code>shared_ptr</code>
循环引用。</li>
<li><strong>使用场景</strong>：配合 <code>shared_ptr</code>
管理复杂关系。</li>
<li><strong>底层原理</strong>：不增加引用计数，需通过
<code>lock()</code> 获取 <code>shared_ptr</code>。</li>
<li><strong>注意事项</strong>：需检查有效性。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">// struct 在 C++ 中可以像 class 一样使用，包含成员变量、构造函数、析构函数等，struct 默认 public，class 默认 private</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; prev;  <span class="comment">// 避免循环引用</span></span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    n1-&gt;next = n2;</span><br><span class="line">    n2-&gt;prev = n1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 正常销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="移动语义"><strong>移动语义</strong></h4>
<ul>
<li><strong>右值引用（<code>T&amp;&amp;</code>）</strong>
<ul>
<li><strong>功能</strong>：绑定到右值（如临时对象），支持移动语义。</li>
<li><strong>使用场景</strong>：优化资源转移，避免拷贝。</li>
<li><strong>底层原理</strong>：右值引用延长临时对象生命周期。</li>
<li><strong>注意事项</strong>：区分左值和右值。</li>
</ul></li>
<li><strong>移动构造函数和 <code>std::move</code></strong>
<ul>
<li><strong>功能</strong>：转移资源所有权，减少深拷贝。</li>
<li><strong>底层原理</strong>：将资源指针转移，原对象置为可销毁状态。</li>
<li><strong>注意事项</strong>：移动后原对象状态需定义。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val = <span class="number">0</span>) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(val)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;  <span class="comment">// 移动构造函数</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data ? *data : <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    MyClass b = std::<span class="built_in">move</span>(a);  <span class="comment">// 移动</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 0, 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="完美转发"><strong>完美转发</strong></h4>
<ul>
<li><strong>功能</strong>：通过 <code>std::forward</code>
和右值引用，保持参数的值类别（左值或右值）。</li>
<li><strong>使用场景</strong>：模板函数转发参数。</li>
<li><strong>底层原理</strong>：利用引用折叠规则（<code>T&amp;&amp;</code>
可绑定左值或右值）。</li>
<li><strong>注意事项</strong>：需与模板配合。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Lvalue: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Rvalue: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    forward(x);     <span class="comment">// Lvalue: 10</span></span><br><span class="line">    forward(<span class="number">20</span>);    <span class="comment">// Rvalue: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="lambda-表达式"><strong>Lambda 表达式</strong></h4>
<p>C++ 的 Lambda
表达式是一种便捷的方式，用于在代码中定义匿名函数对象。它在 C++11
中引入，广泛用于简化回调、函数式编程以及需要临时函数的场景。</p>
<ul>
<li><p><strong>功能</strong>：定义匿名函数，支持捕获外部变量。</p></li>
<li><p><strong>使用场景</strong>：回调、局部逻辑。</p></li>
<li><p><strong>底层原理</strong>：编译器生成闭包类。</p></li>
<li><p><strong>注意事项</strong>：捕获方式影响变量生命周期。</p></li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [x]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;  <span class="comment">// 按值捕获</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;By value: &quot;</span> &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">auto</span> refFunc = [&amp;x]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;  <span class="comment">// 按引用捕获</span></span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;By reference: &quot;</span> &lt;&lt; <span class="built_in">refFunc</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h5 id="lambda-表达式的基本语法"><strong>1. Lambda
表达式的基本语法</strong></h5>
<p>Lambda 表达式的完整语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt; return_type &#123; body &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>[capture]</code>（捕获列表）</strong>：指定外部变量如何被
Lambda 表达式捕获（按值或按引用）。</li>
<li><strong><code>(parameters)</code>（参数列表）</strong>：类似普通函数的参数，定义
Lambda 接受的输入。</li>
<li><strong><code>mutable</code></strong>（可选）：允许在按值捕获时修改捕获的变量（默认按值捕获是只读的）。</li>
<li><strong><code>-&gt; return_type</code>（返回类型，可选）</strong>：显式指定返回类型，通常由编译器推导。</li>
<li><strong><code>{ body }</code>（函数体）</strong>：Lambda
的实现逻辑。</li>
</ul>
<hr />
<h5 id="捕获列表详解"><strong>2. 捕获列表详解</strong></h5>
<p>捕获列表决定了 Lambda
如何访问外部作用域的变量。捕获方式有以下几种：</p>
<h6 id="按值捕获-x"><strong>(1) 按值捕获 <code>[x]</code></strong></h6>
<ul>
<li>外部变量被复制到 Lambda 内部，Lambda 持有该变量的副本。</li>
<li>默认情况下，按值捕获的变量是只读的，不能修改。</li>
<li>如果需要修改副本，可以使用 <code>mutable</code>
关键字，但不会影响外部变量。</li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [x]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;  <span class="comment">// x 是副本</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出 20</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 依然输出 20，因为 func 内部的 x 是副本</span></span><br></pre></td></tr></table></figure></p>
<h6 id="按引用捕获-x"><strong>(2) 按引用捕获
<code>[&amp;x]</code></strong></h6>
<ul>
<li>Lambda 直接引用外部变量，修改 Lambda 内部的变量会影响外部变量。</li>
<li>如果外部变量被销毁（例如离开作用域），Lambda
引用它会导致未定义行为（悬垂引用）。</li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> refFunc = [&amp;x]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;  <span class="comment">// x 是引用</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">refFunc</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出 40，因为 refFunc 引用了修改后的 x</span></span><br></pre></td></tr></table></figure></p>
<h6 id="全局捕获"><strong>(3) 全局捕获</strong></h6>
<ul>
<li><code>[=]</code>：按值捕获所有外部变量的副本。</li>
<li><code>[&amp;]</code>：按引用捕获所有外部变量。</li>
<li>混合捕获：可以组合，例如 <code>[=, &amp;x]</code>
表示默认按值捕获，但 <code>x</code> 按引用捕获。</li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> mixed = [=, &amp;x]() &#123; <span class="keyword">return</span> x + y; &#125;;  <span class="comment">// y 按值，x 按引用</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">mixed</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出 25（x=20, y=5 的副本）</span></span><br></pre></td></tr></table></figure></p>
<h6 id="捕获-this"><strong>(4) 捕获 <code>this</code></strong></h6>
<ul>
<li>在类成员函数中，<code>[this]</code>
捕获当前对象的指针，<code>[*this]</code>（C++17
起）捕获当前对象的副本。</li>
<li>按引用捕获 <code>[&amp;]</code> 隐式包含 <code>this</code>。</li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> lambda = [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">lambda</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>(5) 空捕获 <code>[]</code></strong></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> callback = [](<span class="type">int</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Callback: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>Lambda 表达式的捕获列表是
[]，表示<strong>空捕获</strong>，即<strong>不捕获任何外部变量</strong>，既不是按值捕获也不是按引用捕获。</p>
<p>空捕获列表 ([])：[] 表示 Lambda
表达式不从外部作用域捕获任何变量。</p>
<p>无外部变量引用：Lambda 的函数体 { std::cout &lt;&lt; “Callback:”
&lt;&lt; x &lt;&lt; “”; } 只使用了参数 x（通过函数调用传入）和全局对象
std::cout。std::cout 是全局的，不需要捕获，而 x 是 Lambda
的参数，不是外部作用域的变量。</p>
<p>捕获（按值 [=] 或按引用 [&amp;]）只有在 Lambda
访问外部作用域的变量时才起作用。例如，如果 Lambda 使用了外部的 int
y，才会涉及捕获方式。</p>
<hr />
<h5 id="lambda-的工作原理"><strong>3. Lambda 的工作原理</strong></h5>
<p>Lambda
表达式实际上是编译器生成的匿名类的实例（称为闭包对象）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [x]() &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>编译器会生成类似以下的类： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">// 捕获的变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Lambda</span>(<span class="type">int</span> x_) : <span class="built_in">x</span>(x_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125; <span class="comment">// 重载函数调用操作符，operator() 是重载的函数调用操作符，() 表示这个操作符不接受参数（空参数列表），int 是返回值类型，表示调用这个操作符会返回一个整数，const 表示这个成员函数不会修改对象的状态（x 不会被改变）。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>调用 <code>func()</code> 实际上是调用这个类的
<code>operator()</code>。这解释了 Lambda 为什么可以像函数一样使用。</p>
<hr />
<h5 id="lambda-的常见用途"><strong>4. Lambda 的常见用途</strong></h5>
<ol type="1">
<li><p><strong>标准库算法</strong>：与 <code>&lt;algorithm&gt;</code>
配合，例如 <code>std::sort</code>、<code>std::for_each</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>异步编程</strong>：与 <code>std::async</code>
或线程配合。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = []() &#123; std::cout &lt;&lt; <span class="string">&quot;Running task\n&quot;</span>; &#125;;</span><br><span class="line">std::<span class="built_in">async</span>(std::launch::async, task);</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>回调函数</strong>：传递给需要回调的函数。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> callback = [](<span class="type">int</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Callback: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;;<span class="comment">// </span></span><br><span class="line"><span class="built_in">someFunction</span>(callback);</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>立即执行</strong>（IIFE，Immediately Invoked Function
Expression）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = []() &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;();  <span class="comment">// 立即调用，result = 42</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<hr />
<h5 id="注意事项-1"><strong>5. 注意事项</strong></h5>
<ol type="1">
<li><p><strong>生命周期问题</strong>：</p>
<ul>
<li>按引用捕获时，确保捕获的变量在 Lambda 使用时仍然有效。</li>
<li>示例（错误用法）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> [&amp;x]() &#123; <span class="keyword">return</span> x; &#125;;  <span class="comment">// 悬垂引用，x 在函数返回后销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>性能开销</strong>：</p>
<ul>
<li>按值捕获会复制变量，可能会增加内存开销。</li>
<li>对于大对象，考虑按引用捕获或使用 <code>std::move</code>（C++11
起支持移动捕获，C++14 增强）。</li>
</ul></li>
<li><p><strong>C++14/17 增强</strong>：</p>
<ul>
<li><p><strong>C++14</strong>：支持泛型 Lambda（<code>auto</code>
参数）和初始化捕获。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [y = <span class="number">10</span>](<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> x + y; &#125;;  <span class="comment">// 初始化捕获</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>C++17</strong>：支持 <code>[*this]</code>
捕获对象副本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 [*this] 捕获对象副本</span></span><br><span class="line">        <span class="keyword">auto</span> lambda = [*<span class="keyword">this</span>]() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Lambda: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="comment">// 修改 x 不影响原始对象</span></span><br><span class="line">            x = <span class="number">20</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Lambda modified: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 Lambda</span></span><br><span class="line">        <span class="built_in">lambda</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始对象的 x 未改变</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Original: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟异步回调</span></span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">createAsyncCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回 Lambda，捕获 [*this]</span></span><br><span class="line">        <span class="keyword">return</span> [*<span class="keyword">this</span>]() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Async callback: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试 [*this] 捕获</span></span><br><span class="line">    Example obj;</span><br><span class="line">    obj.<span class="built_in">createLambda</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试异步场景</span></span><br><span class="line">    <span class="keyword">auto</span> callback = obj.<span class="built_in">createAsyncCallback</span>();</span><br><span class="line">    <span class="comment">// obj 销毁后，callback 仍然有效，因为它持有 obj 的副本</span></span><br><span class="line">    <span class="built_in">callback</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>C++20</strong>：支持无状态 Lambda 的默认构造和赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个无状态 Lambda，lambda 不捕获任何变量（[]），因此是无状态的，行为完全由函数体 &#123; return 42; &#125; 定义。</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = []() &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造无状态 Lambda（C++20），decltype(lambda) defaultLambda; 创建一个默认构造的闭包对象，行为与 lambda 相同。</span></span><br><span class="line">    <span class="keyword">decltype</span>(lambda) defaultLambda; <span class="comment">// 默认构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default constructed Lambda: &quot;</span> &lt;&lt; <span class="built_in">defaultLambda</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值（C++20），assignedLambda = lambda; 将 lambda 的行为复制到 assignedLambda，这是 C++20 新增的功能。</span></span><br><span class="line">    <span class="keyword">decltype</span>(lambda) assignedLambda;</span><br><span class="line">    assignedLambda = lambda; <span class="comment">// 赋值操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Assigned Lambda: &quot;</span> &lt;&lt; <span class="built_in">assignedLambda</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储在容器中，std::vector 和 std::optional 可以存储无状态 Lambda，因为它们支持默认构造和赋值。</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="title">decltype</span><span class="params">(lambda)</span>&gt; <span class="title">lambdaVector</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 默认构造 3 个 Lambda</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; l : lambdaVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Vector Lambda: &quot;</span> &lt;&lt; <span class="built_in">l</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::optional</span></span><br><span class="line">    std::optional&lt;<span class="keyword">decltype</span>(lambda)&gt; optionalLambda;</span><br><span class="line">    optionalLambda = lambda; <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">if</span> (optionalLambda) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Optional Lambda: &quot;</span> &lt;&lt; optionalLambda.<span class="built_in">value</span>()() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Lambda 捕获变量（有状态
Lambda），则无法使用默认构造或赋值，因为它们的行为依赖捕获的变量。</p>
<figure class="highlight cpp"><figcaption><span>compiling</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> statefulLambda = [x]() &#123; <span class="keyword">return</span> x; &#125;;</span><br><span class="line"><span class="keyword">decltype</span>(statefulLambda) defaultLambda; <span class="comment">// 错误：无默认构造函数</span></span><br><span class="line">statefulLambda = statefulLambda; <span class="comment">// 错误：无赋值操作符</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>mutable 关键字</strong>：</p>
<ul>
<li>按值捕获默认只读，使用 <code>mutable</code> 允许修改副本。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [x]() <span class="keyword">mutable</span> &#123; x += <span class="number">1</span>; <span class="keyword">return</span> x; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出 11</span></span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;       <span class="comment">// 输出 10，外部 x 不变</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h4 id="模板改进"><strong>模板改进</strong></h4>
<ul>
<li><strong>可变参数模板</strong>
<ul>
<li><strong>功能</strong>：支持不定数量的模板参数。</li>
<li><strong>使用场景</strong>：通用函数，如打印。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args);  <span class="comment">// C++17 折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="string">&quot; &quot;</span>, <span class="number">2.5</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;hello&quot;</span>);  <span class="comment">// 1 2.5 hello</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>模板别名</strong>
<ul>
<li><strong>功能</strong>：使用 <code>using</code>
定义模板类型别名。</li>
<li><strong>使用场景</strong>：简化复杂类型。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T&gt;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="初始化改进"><strong>初始化改进</strong></h4>
<ul>
<li><strong>统一初始化</strong>
<ul>
<li><strong>功能</strong>：使用 <code>{}</code> 初始化所有类型。</li>
<li><strong>使用场景</strong>：一致性初始化。</li>
<li><strong>注意事项</strong>：窄化转换（如 double 到 int）被禁止。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">double</span> d&#123;<span class="number">3.14</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, d: &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// int y&#123;3.14&#125;;  // 错误：窄化转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>初始化列表</strong>
<ul>
<li><strong>功能</strong>：用 <code>{}</code> 初始化容器或对象。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="并发支持"><strong>并发支持</strong></h4>
<p>C++ 的并发控制是现代 C++（特别是 C++11
及之后）的一个重要特性，旨在支持多线程编程并确保线程安全。并发控制涉及管理多个线程对共享资源的访问，避免数据竞争（data
race）、死锁（deadlock）等问题，同时最大化性能。</p>
<hr />
<h5 id="并发控制的核心概念"><strong>1. 并发控制的核心概念</strong></h5>
<h6 id="线程threads"><strong>(1) 线程（Threads）</strong></h6>
<ul>
<li>C++11 引入了 <code>&lt;thread&gt;</code>
头文件，支持原生线程管理。</li>
<li>线程表示并行执行的独立控制流，多个线程可能同时访问共享资源。</li>
<li>问题：未经同步的共享资源访问可能导致数据竞争。</li>
</ul>
<h6 id="数据竞争data-race"><strong>(2) 数据竞争（Data
Race）</strong></h6>
<ul>
<li>当多个线程同时访问共享资源（例如变量），且至少一个线程是写操作时，可能导致未定义行为。</li>
<li>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">        ++counter; <span class="comment">// counter 可能不是 2000，因为 ++counter 不是原子操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>; </span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>std::thread</code>
构造函数接受一个可调用对象（如函数、函数指针、lambda
表达式等）以及可选的参数。语法：<code>std::thread variable_name(callable, args...)</code>。在
<code>thread t1(increment);</code> 中，<code>increment</code>
是一个无参函数，因此没有额外参数。</p>
<p>构造 <code>t1</code> 时，<code>std::thread</code>
会分配一个新的线程（由操作系统管理），并在该线程中调用
<code>increment()</code>。新线程立即开始运行，除非系统资源受限。</p>
<p><code>t1</code>
的生命周期从构造开始，直到线程执行完成或程序结束。如果 <code>t1</code>
未被 <code>join</code> 或 <code>detach</code>，程序在 <code>t1</code>
析构时（例如离开作用域）会调用
<code>std::terminate</code>，导致程序崩溃。<code>t1.join()</code>
确保主线程等待 <code>t1</code> 完成，避免此问题。</p>
<p>写 <code>thread t1(increment);</code> 而不是
<code>thread t1(increment());</code>
是因为后者可能被解析为函数声明（称为“最令人头痛的解析”，most vexing
parse）。<code>thread t1(increment);</code>
明确表示创建一个线程对象，调用 <code>increment</code> 函数。</p>
<p><code>increment</code> 可以是任何可调用对象，例如：</p>
<ul>
<li><p>函数指针：<code>void (*func)() = increment; thread t1(func);</code></p></li>
<li><p>Lambda
表达式：<code>thread t1([](){ /* 代码 */ });</code></p></li>
<li><p>函数对象（functor）：<code>thread t1(MyFunctor());</code></p></li>
<li><p>如果 <code>increment</code> 需要参数，需在构造时提供：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(increment, <span class="number">42</span>)</span></span>; <span class="comment">// 传递参数 42</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>如果 <code>increment</code>
抛出异常，线程会终止，异常不会传播到主线程。需在 <code>increment</code>
内部捕获异常，或使用其他机制（如 <code>std::future</code>）处理。</p>
<p><code>counter</code> 是全局变量，被 <code>t1</code> 和
<code>t2</code> 共享。<code>++counter</code>
不是原子操作，即可能被其他线程中断，它实际上涉及三个步骤：</p>
<ol type="1">
<li>读取 <code>counter</code> 的当前值。</li>
<li>将值加 1。</li>
<li>将新值写回 <code>counter</code>。</li>
</ol>
<p>要确保 <code>counter</code> 总是
2000，需要消除数据竞争。常见方法：</p>
<ol type="1">
<li><p><strong>使用互斥锁（Mutex）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        ++counter;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mutex</code> 确保每次只有 一个线程能访问
<code>counter</code>，避免竞争。</li>
<li>缺点：频繁加锁解锁可能降低性能。</li>
</ul></li>
<li><p><strong>使用原子操作</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::atomic&lt;int&gt;</code> 提供原子操作，保证
<code>++counter</code> 不被中断。</li>
<li>更高效，适合简单计数器场景。</li>
</ul></li>
<li><p><strong>减少锁的粒度</strong>：</p>
<ul>
<li>将整个循环放在锁内（而不是每次迭代都加锁）可以减少加锁开销：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h6 id="同步原语synchronization-primitives"><strong>(3)
同步原语（Synchronization Primitives）</strong></h6>
<p>C++ 提供了多种工具来控制并发：</p>
<ul>
<li><strong>互斥锁（Mutex）</strong>：防止多个线程同时访问共享资源。</li>
<li><strong>条件变量（Condition
Variable）</strong>：协调线程间的等待和通知。</li>
<li><strong>原子操作（Atomic
Operations）</strong>：无锁的线程安全操作。</li>
<li><strong>未来（Future）和承诺（Promise）</strong>：异步任务的结果传递。</li>
<li><strong>线程局部存储（Thread-Local
Storage）</strong>：每个线程独立的数据。</li>
</ul>
<hr />
<h5 id="c-并发控制的主要工具"><strong>2. C++
并发控制的主要工具</strong></h5>
<h6 id="互斥锁mutex"><strong>(1)
互斥锁（<code>&lt;mutex&gt;</code>）</strong></h6>
<p>互斥锁用于保护共享资源，确保一次只有一个线程访问临界区。</p>
<ul>
<li><p><strong>常用类型</strong>：</p>
<ul>
<li><code>std::mutex</code>：基本互斥锁。</li>
<li><code>std::recursive_mutex</code>：允许同一线程多次锁定。</li>
<li><code>std::timed_mutex</code>：支持超时。</li>
<li><code>std::shared_mutex</code>（C++17）：支持读写锁（多个读线程或单个写线程）。</li>
</ul></li>
<li><p><strong>锁管理工具</strong>：</p>
<ul>
<li><code>std::lock_guard</code>：RAII 风格的锁，自动解锁。</li>
<li><code>std::unique_lock</code>：更灵活的锁，支持延迟锁定或转移。</li>
<li><code>std::scoped_lock</code>（C++17）：简化多锁管理，避免死锁。</li>
</ul></li>
<li><p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动锁定和解锁</span></span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter: &quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 2000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>注意</strong>：</p>
<ul>
<li>避免死锁：使用 <code>std::scoped_lock</code> 或按固定顺序加锁。</li>
<li>最小化锁的范围以提高性能。</li>
</ul></li>
</ul>
<h6 id="条件变量condition_variable"><strong>(2)
条件变量（<code>&lt;condition_variable&gt;</code>）</strong></h6>
<p>条件变量用于线程间的同步，允许一个线程等待特定条件，另一个线程通知条件满足。</p>
<ul>
<li><p><strong>常用类型</strong>：</p>
<ul>
<li><code>std::condition_variable</code>：与 <code>std::mutex</code>
配合使用。</li>
<li><code>std::condition_variable_any</code>：支持任意锁类型。</li>
</ul></li>
<li><p><strong>示例</strong>（生产者-消费者模型）：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !q.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 等待队列非空</span></span><br><span class="line">        <span class="type">int</span> value = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>注意</strong>：</p>
<ul>
<li>使用 <code>std::unique_lock</code> 与条件变量配合。</li>
<li>避免虚假唤醒（spurious wakeup），使用条件检查（如
<code>[] { return !q.empty(); }</code>）。</li>
</ul></li>
</ul>
<h6 id="原子操作atomic"><strong>(3)
原子操作（<code>&lt;atomic&gt;</code>）</strong></h6>
<p>原子操作提供无锁的线程安全操作，适合简单数据类型（如计数器）。</p>
<ul>
<li><p><strong>常用类型</strong>：</p>
<ul>
<li><code>std::atomic&lt;T&gt;</code>：支持整数、指针等类型的原子操作。</li>
<li><code>std::atomic_flag</code>：最简单的原子标志。</li>
</ul></li>
<li><p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// 原子递增</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter: &quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 2000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>内存序（Memory Order）</strong>：</p>
<ul>
<li><code>std::memory_order_relaxed</code>：最低性能约束。</li>
<li><code>std::memory_order_seq_cst</code>：默认，强一致性。</li>
<li>选择合适的内存序以平衡性能和正确性。</li>
</ul></li>
</ul>
<h6 id="未来和承诺future"><strong>(4)
未来和承诺（<code>&lt;future&gt;</code>）</strong></h6>
<p><code>std::future</code> 和 <code>std::promise</code>
用于异步任务的结果传递。</p>
<ul>
<li><p><strong>组件</strong>：</p>
<ul>
<li><code>std::promise</code>：设置任务结果。</li>
<li><code>std::future</code>：获取任务结果。</li>
<li><code>std::async</code>：异步执行函数。</li>
</ul></li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">42</span>); <span class="comment">// Set result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(prom))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// Prints 42</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, compute, <span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>：</p>
<ul>
<li><code>std::async</code> 的启动策略（<code>std::launch::async</code>
或 <code>std::launch::deferred</code>）影响执行时机。</li>
<li><code>std::future::get()</code> 阻塞直到结果可用。</li>
</ul></li>
</ul>
<h6 id="线程局部存储thread"><strong>(5)
线程局部存储（<code>&lt;thread&gt;</code>）</strong></h6>
<p><code>thread_local</code>
变量为每个线程提供独立副本，避免共享资源竞争。</p>
<ul>
<li><p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> tls_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++tls_counter;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; tls_counter &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>输出</strong>（可能）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread 1234: 1</span><br><span class="line">Thread 5678: 1</span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h5 id="c17-和-c20-的并发改进"><strong>3. C++17 和 C++20
的并发改进</strong></h5>
<h6 id="c17"><strong>C++17</strong></h6>
<ul>
<li><strong>并行算法</strong>（<code>&lt;algorithm&gt;</code>）：
<ul>
<li>支持并行执行标准算法，例如 <code>std::sort</code>：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execution&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(std::execution::par, vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li>
<li>执行策略：<code>std::execution::seq</code>（顺序）、<code>par</code>（并行）、<code>par_unseq</code>（并行无序）。</li>
</ul></li>
<li><strong>共享锁</strong>（<code>std::shared_mutex</code>）：
<ul>
<li>支持读写锁，允许多个读线程同时访问： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::shared_mutex smtx;</span><br><span class="line"><span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(smtx)</span></span>; <span class="comment">// 读锁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Read: &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(smtx)</span></span>; <span class="comment">// 写锁</span></span><br><span class="line">    ++data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h6 id="c20"><strong>C++20</strong></h6>
<ul>
<li><strong>信号量（<code>&lt;semaphore&gt;</code>）</strong>：
<ul>
<li>提供轻量级同步，例如 <code>std::counting_semaphore</code>：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;1&gt; <span class="title">sem</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem.<span class="built_in">acquire</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task running\n&quot;</span>;</span><br><span class="line">    sem.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>屏障（<code>&lt;barrier&gt;</code>）</strong>：
<ul>
<li>协调多个线程到达同步点： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;barrier&gt;</span></span></span><br><span class="line"><span class="function">std::barrier <span class="title">barrier</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; phase 1\n&quot;</span>;</span><br><span class="line">    barrier.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; phase 2\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>锁存器（<code>&lt;latch&gt;</code>）</strong>：
<ul>
<li>单次同步，线程等待计数归零： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="function">std::latch <span class="title">latch</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; done\n&quot;</span>;</span><br><span class="line">    latch.<span class="built_in">count_down</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>协作中断（<code>&lt;jthread&gt;</code>）</strong>：
<ul>
<li><code>std::jthread</code> 自动加入线程，支持中断：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jthread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(std::stop_token token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!token.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Running...\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t</span><span class="params">(task)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    t.<span class="built_in">request_stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h5 id="注意事项-2"><strong>4. 注意事项</strong></h5>
<ol type="1">
<li><strong>死锁</strong>：多锁时使用 <code>std::scoped_lock</code>
或固定加锁顺序。</li>
<li><strong>性能</strong>：优先考虑原子操作或无锁结构，减少锁争用。</li>
<li><strong>异常安全</strong>：使用 RAII（如
<code>std::lock_guard</code>）确保锁在异常时释放。</li>
<li><strong>调试</strong>：使用工具（如
ThreadSanitizer）检测数据竞争。</li>
<li><strong>C++ 版本</strong>：确保编译器支持目标特性（例如
<code>-std=c++20</code>）。</li>
</ol>
<hr />
<h5 id="总结-3"><strong>5. 总结</strong></h5>
<ul>
<li><strong>核心工具</strong>：互斥锁、条件变量、原子操作、未来/承诺、线程局部存储。</li>
<li><strong>C++17
改进</strong>：并行算法、<code>std::shared_mutex</code>。</li>
<li><strong>C++20
增强</strong>：信号量、屏障、锁存器、<code>std::jthread</code>。</li>
</ul>
<h4 id="constexpr"><strong>constexpr</strong></h4>
<ul>
<li><strong>功能</strong>：定义编译时常量或函数。</li>
<li><strong>使用场景</strong>：优化性能、静态断言。</li>
<li><strong>示例代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="built_in">square</span>(<span class="number">3</span>)];  <span class="comment">// 编译时计算 9</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="c14"><strong>C++14</strong></h3>
<p>C++14 是 C++11 的增量更新，增强了语言的易用性和表达能力。</p>
<h4 id="泛型-lambda"><strong>泛型 Lambda</strong></h4>
<ul>
<li><strong>功能</strong>：允许 Lambda 表达式的参数使用
<code>auto</code>，使其支持泛型。</li>
<li><strong>使用场景</strong>：需要处理多种类型的匿名函数，如通用回调。</li>
<li><strong>底层原理</strong>：编译器为 Lambda
生成一个模板化的闭包类，每个类型实例化一个具体函数。</li>
<li><strong>注意事项</strong>：提高了代码灵活性，但可能增加编译时间；需确保参数类型支持
Lambda 体内的操作。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> genericLambda = [](<span class="keyword">auto</span> x) &#123;  <span class="comment">// 参数 x 是泛型的</span></span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; <span class="built_in">genericLambda</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// 6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; <span class="built_in">genericLambda</span>(<span class="number">3.14</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 4.14</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Char: &quot;</span> &lt;&lt; <span class="built_in">genericLambda</span>(<span class="string">&#x27;A&#x27;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;    <span class="comment">// &#x27;B&#x27; (ASCII 66)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="返回类型推导"><strong>返回类型推导</strong></h4>
<ul>
<li><strong>功能</strong>：允许函数使用 <code>auto</code>
作为返回类型，由函数体推导。</li>
<li><strong>使用场景</strong>：简化函数声明，尤其在返回值类型复杂时。</li>
<li><strong>底层原理</strong>：编译器根据 <code>return</code>
语句推导类型，所有返回路径必须一致。</li>
<li><strong>注意事项</strong>：不能用于声明（需定义）；递归函数需显式返回类型。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;  <span class="comment">// 返回类型推导为 int</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;  <span class="comment">// 返回类型推导为 double</span></span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;          <span class="comment">// 5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply: &quot;</span> &lt;&lt; <span class="built_in">multiply</span>(<span class="number">2.5</span>, <span class="number">3.0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 7.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="constexpr-扩展"><strong>constexpr 扩展</strong></h4>
<ul>
<li><strong>功能</strong>：扩展 <code>constexpr</code>
函数，支持更复杂的编译时计算（如循环、条件语句）。</li>
<li><strong>使用场景</strong>：需要编译时计算复杂表达式，如数学函数。</li>
<li><strong>底层原理</strong>：编译器在编译时执行函数，确保结果为常量。</li>
<li><strong>注意事项</strong>：函数体内限制放宽，但仍需满足常量表达式要求（如无动态内存分配）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;  <span class="comment">// 编译时计算阶乘</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;  <span class="comment">// C++14 允许循环</span></span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="built_in">factorial</span>(<span class="number">4</span>)];  <span class="comment">// 编译时计算 24</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 24</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial(4): &quot;</span> &lt;&lt; <span class="built_in">factorial</span>(<span class="number">4</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="变量模板"><strong>变量模板</strong></h4>
<ul>
<li><strong>功能</strong>：允许定义模板化的变量，提供类型参数化的常量。</li>
<li><strong>使用场景</strong>：泛型常量，如类型相关的数学常数。</li>
<li><strong>底层原理</strong>：编译器为每种类型实例化变量。</li>
<li><strong>注意事项</strong>：需显式指定类型或推导。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535</span>);  <span class="comment">// 变量模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Float pi: &quot;</span> &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// 3.14159</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double pi: &quot;</span> &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 3.14159</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="c17-1"><strong>C++17</strong></h3>
<p>C++17 引入了更多实用特性，提升了语言的现代化程度。</p>
<h4 id="结构化绑定"><strong>结构化绑定</strong></h4>
<ul>
<li><strong>功能</strong>：解构赋值，将聚合类型（如
<code>pair</code>、<code>tuple</code>、结构体）的成员绑定到变量。</li>
<li><strong>使用场景</strong>：简化多返回值函数的使用。</li>
<li><strong>底层原理</strong>：编译器生成临时对象并解构，绑定到新变量。</li>
<li><strong>注意事项</strong>：需支持结构化绑定的类型（如
<code>std::pair</code> 或含 <code>std::tuple_size</code> 的类型）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = p;  <span class="comment">// 结构化绑定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1, 2.5</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> a; <span class="type">double</span> b; &#125;;</span><br><span class="line">    Point pt&#123;<span class="number">3</span>, <span class="number">4.5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [a, b] = pt;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3, 4.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="if-和-switch-初始化"><strong>if 和 switch 初始化</strong></h4>
<ul>
<li><strong>功能</strong>：允许在 <code>if</code> 和 <code>switch</code>
语句中初始化变量，限制作用域。</li>
<li><strong>使用场景</strong>：临时变量仅用于条件判断。</li>
<li><strong>底层原理</strong>：编译器将初始化和条件组合为单一语句。</li>
<li><strong>注意事项</strong>：变量作用域限于 <code>if</code> 或
<code>switch</code> 块。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span> x = <span class="number">10</span>; x &gt; <span class="number">0</span>) &#123;  <span class="comment">// 初始化并判断</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is positive: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; x &lt;&lt; &quot;\n&quot;;  // 错误：x 超出作用域</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="type">int</span> y = <span class="number">2</span>; y) &#123;  <span class="comment">// 初始化并切换</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: std::cout &lt;&lt; <span class="string">&quot;y is 2\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: std::cout &lt;&lt; <span class="string">&quot;Other\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="折叠表达式"><strong>折叠表达式</strong></h4>
<ul>
<li><strong>功能</strong>：简化可变参数模板的处理，允许对参数包进行一元或二元操作。</li>
<li><strong>使用场景</strong>：批量操作参数，如求和、打印。</li>
<li><strong>底层原理</strong>：编译器展开参数包并应用操作符。</li>
<li><strong>注意事项</strong>：支持常见运算符（如
<code>+</code>、<code>*</code>、<code>&amp;&amp;</code> 等）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);  <span class="comment">// 二元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args);  <span class="comment">// 打印所有参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="number">42</span>, <span class="string">&quot;\n&quot;</span>);  <span class="comment">// Hello 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="stdoptional"><strong>std::optional</strong></h4>
<ul>
<li><strong>功能</strong>：表示可能为空的值，提供类型安全的可选值。</li>
<li><strong>使用场景</strong>：函数可能无返回值，或值可选。</li>
<li><strong>底层原理</strong>：封装值和状态，析构时自动清理。</li>
<li><strong>注意事项</strong>：需检查是否有值（<code>has_value()</code>
或 <code>*</code>）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">maybeInt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;  <span class="comment">// 无值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> opt1 = <span class="built_in">maybeInt</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (opt1) std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *opt1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">auto</span> opt2 = <span class="built_in">maybeInt</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!opt2) std::cout &lt;&lt; <span class="string">&quot;No value\n&quot;</span>;  <span class="comment">// No value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="stdvariant"><strong>std::variant</strong></h4>
<ul>
<li><strong>功能</strong>：类型安全的联合类型，可存储多种类型之一。</li>
<li><strong>使用场景</strong>：替代 <code>union</code>，如状态机。</li>
<li><strong>底层原理</strong>：存储当前类型索引和值，析构时调用正确析构函数。</li>
<li><strong>注意事项</strong>：访问需使用 <code>std::get</code> 或
<code>std::visit</code>，错误访问抛异常。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; v = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(v) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    v = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(v) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3.14</span></span><br><span class="line">    v = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(v) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// Hello</span></span><br><span class="line">    <span class="comment">// std::get&lt;int&gt;(v);  // 抛出 std::bad_variant_access</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="stdany"><strong>std::any</strong></h4>
<ul>
<li><strong>功能</strong>：存储任意类型的值，提供类型擦除。</li>
<li><strong>使用场景</strong>：需要动态类型的场景，如脚本引擎。</li>
<li><strong>底层原理</strong>：使用类型擦除技术，存储值和类型信息。</li>
<li><strong>注意事项</strong>：访问需使用
<code>std::any_cast</code>，类型错误抛异常。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    a = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">double</span>&gt;(a) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 3.14</span></span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// Hello</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a);  <span class="comment">// 抛出 std::bad_any_cast</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bad cast: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="文件系统库stdfilesystem"><strong>文件系统库（<code>std::filesystem</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：提供文件和目录操作的标准化接口。</li>
<li><strong>使用场景</strong>：文件管理、路径处理。</li>
<li><strong>底层原理</strong>：封装操作系统文件 API。</li>
<li><strong>注意事项</strong>：需链接文件系统库（如
<code>-lstdc++fs</code> 在某些编译器）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fs::path p = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (fs::<span class="built_in">exists</span>(p)) &#123;</span><br><span class="line">        std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot; exists\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot; does not exist\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : fs::<span class="built_in">directory_iterator</span>(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; entry.<span class="built_in">path</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 列出当前目录</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="并行算法"><strong>并行算法</strong></h4>
<ul>
<li><strong>功能</strong>：STL 算法支持并行执行，优化多核性能。</li>
<li><strong>使用场景</strong>：大数据排序、变换。</li>
<li><strong>底层原理</strong>：依赖线程池或底层并发支持。</li>
<li><strong>注意事项</strong>：需编译器支持（如
<code>-ltbb</code>）。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(std::execution::par, v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());  <span class="comment">// 并行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 1 3 4 5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="inline-变量"><strong>inline 变量</strong></h4>
<ul>
<li><strong>功能</strong>：允许在头文件中定义 <code>inline</code>
静态变量，避免多重定义。</li>
<li><strong>使用场景</strong>：头文件中的全局常量。</li>
<li><strong>底层原理</strong>：编译器保证单一实例。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_H</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> globalVar = <span class="number">42</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="c20-1"><strong>C++20</strong></h3>
<p>C++20 是近年来最大的更新，引入了许多革新特性。</p>
<h4 id="概念concepts"><strong>概念（Concepts）</strong></h4>
<ul>
<li><strong>功能</strong>：约束模板参数，提供类型检查。</li>
<li><strong>使用场景</strong>：泛型编程中确保类型满足要求。</li>
<li><strong>底层原理</strong>：编译时验证类型特性。</li>
<li><strong>注意事项</strong>：需支持 C++20 的编译器。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> std::integral&lt;T&gt;  <span class="comment">// 约束 T 为整数类型</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// add(2.5, 3.5);  // 错误：double 不满足 integral</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ranges-库"><strong>Ranges 库</strong></h4>
<ul>
<li><strong>功能</strong>：提供范围操作，增强 STL 的功能性。</li>
<li><strong>使用场景</strong>：链式处理容器数据。</li>
<li><strong>底层原理</strong>：基于迭代器，新增视图概念。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> even = v | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    std::ranges::<span class="built_in">sort</span>(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 1 3 4 5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nEven: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : even) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="协程coroutines"><strong>协程（Coroutines）</strong></h4>
<ul>
<li><strong>功能</strong>：支持异步编程，允许函数暂停和恢复。</li>
<li><strong>使用场景</strong>：异步 I/O、生成器。</li>
<li><strong>底层原理</strong>：编译器生成状态机，依赖协程框架。</li>
<li><strong>注意事项</strong>：需库支持（如
<code>cppcoro</code>），示例简化。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="keyword">this</span>&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; value = v; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; coro;</span><br><span class="line">    <span class="built_in">Generator</span>(promise_type* p) : <span class="built_in">coro</span>(std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*p)) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Generator</span>() &#123; <span class="keyword">if</span> (coro) coro.<span class="built_in">destroy</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123; coro.<span class="built_in">resume</span>(); <span class="keyword">return</span> coro.<span class="built_in">promise</span>().value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Generator <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> i;  <span class="comment">// 暂停并返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> g = <span class="built_in">generate</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; g.<span class="built_in">next</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="模块modules"><strong>模块（Modules）</strong></h4>
<ul>
<li><strong>功能</strong>：替代头文件，提供模块化编程。</li>
<li><strong>使用场景</strong>：大型项目，减少编译依赖。</li>
<li><strong>底层原理</strong>：编译器生成模块单元，优化编译。</li>
<li><strong>注意事项</strong>：需 C++20
支持，主流编译器支持尚不完善。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from module\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();  <span class="comment">// Hello from module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="三路比较运算符"><strong>三路比较运算符（<code>&lt;=&gt;</code>）</strong></h4>
<ul>
<li><strong>功能</strong>：提供默认比较运算符，返回比较结果。</li>
<li><strong>使用场景</strong>：简化自定义类型的比较。</li>
<li><strong>底层原理</strong>：返回 <code>std::strong_ordering</code>
等类型。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Point&amp; other) <span class="type">const</span> = <span class="keyword">default</span>;  <span class="comment">// 默认比较</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1&#123;<span class="number">1</span>&#125;, p2&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1 &lt; p2: &quot;</span> &lt;&lt; (p1 &lt; p2) &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1 == p2: &quot;</span> &lt;&lt; (p1 == p2) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="consteval-和-constinit"><strong>consteval 和
constinit</strong></h4>
<ul>
<li><strong>功能</strong>：
<ul>
<li><code>consteval</code>：强制编译时计算。</li>
<li><code>constinit</code>：控制常量初始化。</li>
</ul></li>
<li><strong>使用场景</strong>：编译时优化、初始化控制。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;  <span class="comment">// 必须编译时计算</span></span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> global = <span class="built_in">square</span>(<span class="number">5</span>);  <span class="comment">// 确保编译时初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square(3): &quot;</span> &lt;&lt; <span class="built_in">square</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 9</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global: &quot;</span> &lt;&lt; global &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="新工具"><strong>新工具</strong></h4>
<ul>
<li><strong><code>std::span</code></strong>
<ul>
<li><strong>功能</strong>：提供连续内存的视图。</li>
<li><strong>使用场景</strong>：操作数组或容器片段。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::span&lt;<span class="type">int</span>&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(arr, <span class="number">3</span>)</span></span>;  <span class="comment">// 前 3 个元素</span></span><br><span class="line">    <span class="built_in">print</span>(s);  <span class="comment">// 1 2 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>std::bit_cast</code></strong>
<ul>
<li><strong>功能</strong>：类型安全的位转换。</li>
<li><strong>使用场景</strong>：低级数据处理。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bit&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">uint32_t</span> i = std::<span class="built_in">bit_cast</span>&lt;<span class="type">uint32_t</span>&gt;(f);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Float as uint32_t: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 1065353216</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4
id="日历和时区支持stdchrono-扩展"><strong>日历和时区支持（<code>std::chrono</code>
扩展）</strong></h4>
<ul>
<li><strong>功能</strong>：支持日期和时区操作。</li>
<li><strong>使用场景</strong>：时间相关应用。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">auto</span> now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Now: &quot;</span> &lt;&lt; now.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> today = <span class="built_in">floor</span>&lt;days&gt;(now);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Year: &quot;</span> &lt;&lt; year_month_day&#123;today&#125;.<span class="built_in">year</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h2 id="其他特性总结"><strong>3. 其他特性总结</strong></h2>
<h3 id="标准库扩展"><strong>标准库扩展</strong></h3>
<ul>
<li><strong>功能</strong>：STL 提供容器（如
<code>vector</code>）、算法、I/O 等。</li>
<li><strong>使用场景</strong>：日常编程。</li>
<li><strong>示例代码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nString: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="编译器特性"><strong>编译器特性</strong></h3>
<ul>
<li><strong>属性（<code>[[nodiscard]]</code> 等）</strong>
<ul>
<li><p><strong>功能</strong>：提供编译器提示。</p></li>
<li><p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// func();  // 警告：忽略返回值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<hr />
<h1 id="问题研究">问题研究</h1>
<h2 id="c-如何实现多态">C++ 如何实现多态</h2>
<p>在 C++
中，多态（Polymorphism）是面向对象编程的核心特性之一，它允许在运行时根据对象的实际类型执行不同的行为。C++
主要通过 <strong>虚函数（Virtual Functions）</strong> 和
<strong>继承（Inheritance）</strong> 实现多态，尤其是
<strong>运行时多态（Runtime
Polymorphism）</strong>，也称为动态多态。下面我将详细讲解 C++
如何实现多态及其底层原理，包括实现机制、使用场景、示例代码和注意事项。</p>
<hr />
<h3 id="c-多态的分类"><strong>1. C++ 多态的分类</strong></h3>
<p>C++ 中的多态分为两种：</p>
<ul>
<li><strong>编译时多态（Compile-time Polymorphism）</strong>：
<ul>
<li>通过 <strong>函数重载（Function Overloading）</strong> 和
<strong>运算符重载（Operator Overloading）</strong> 实现。</li>
<li>在编译时根据参数类型或数量确定调用哪个函数。</li>
<li><strong>原理</strong>：编译器通过名称修饰（Name
Mangling）生成唯一的函数签名。</li>
<li>示例（不展开，因为问题聚焦运行时多态）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>);     <span class="comment">// Int: 5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);  <span class="comment">// Double: 3.14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>运行时多态（Runtime Polymorphism）</strong>：
<ul>
<li>通过 <strong>虚函数</strong> 和 <strong>基类指针/引用</strong>
实现。</li>
<li>在运行时根据对象的实际类型决定调用哪个函数。</li>
<li>这是本文重点讲解的内容。</li>
</ul></li>
</ul>
<hr />
<h3 id="运行时多态的实现方式"><strong>2.
运行时多态的实现方式</strong></h3>
<p>C++ 通过以下机制实现运行时多态： -
<strong>继承</strong>：定义基类和派生类，形成层次结构。 -
<strong>虚函数</strong>：在基类中使用 <code>virtual</code>
关键字声明函数，派生类可以重写（Override）。 -
<strong>基类指针或引用</strong>：通过基类类型的指针或引用调用虚函数。</p>
<h4 id="关键字和语法"><strong>关键字和语法</strong></h4>
<ul>
<li><strong><code>virtual</code></strong>：标记函数为虚函数，启用动态分派。</li>
<li><strong><code>override</code></strong>（C++11）：显式声明派生类重写基类虚函数（可选，但推荐）。</li>
<li><strong><code>final</code></strong>（C++11）：禁止进一步重写虚函数或继承类（可选）。</li>
</ul>
<h4 id="基本示例-1"><strong>基本示例</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">// 虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base speaking\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;  <span class="comment">// 虚析构函数（重要）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived speaking\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    ptr-&gt;<span class="built_in">speak</span>();  <span class="comment">// 输出 &quot;Derived speaking&quot;</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;    <span class="comment">// 正确调用 Derived 的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived speaking</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，尽管 <code>ptr</code> 是 <code>Base*</code>
类型，但调用 <code>speak()</code> 时执行了 <code>Derived</code>
的版本，这就是运行时多态。</p>
<hr />
<h3 id="多态的底层原理虚函数表vtable"><strong>3.
多态的底层原理：虚函数表（vtable）</strong></h3>
<p>C++ 使用 <strong>虚函数表（Virtual Function Table，简称
vtable）</strong> 和 <strong>虚表指针（vptr）</strong>
来实现运行时多态。以下是详细原理：</p>
<h4 id="虚函数表的概念"><strong>3.1 虚函数表的概念</strong></h4>
<ul>
<li><strong>定义</strong>：每个包含虚函数的类在编译时会生成一个虚函数表（vtable），这是一个函数指针数组，存储该类所有虚函数的地址。</li>
<li><strong>内容</strong>：vtable
中按声明顺序存储虚函数的地址，派生类重写虚函数时会替换对应位置的地址。</li>
<li><strong>唯一性</strong>：每个类（而不是每个对象）拥有一个唯一的
vtable，共享给所有该类实例。</li>
</ul>
<h4 id="虚表指针vptr"><strong>3.2 虚表指针（vptr）</strong></h4>
<ul>
<li><strong>定义</strong>：每个包含虚函数的对象在内存中额外存储一个指向其类
vtable 的指针（vptr）。</li>
<li><strong>位置</strong>：vptr
通常存储在对象内存布局的开头（具体位置由编译器决定）。</li>
<li><strong>初始化</strong>：在对象构造时，构造函数会将 vptr
设置为指向该类的 vtable。</li>
</ul>
<h4 id="运行时分派的流程"><strong>3.3 运行时分派的流程</strong></h4>
<ol type="1">
<li><strong>对象创建</strong>：
<ul>
<li>创建 <code>Derived</code> 对象时，<code>Derived</code> 的构造函数将
vptr 设置为指向 <code>Derived</code> 的 vtable。</li>
<li><code>Derived</code> 的 vtable 中，<code>speak()</code> 的地址是
<code>Derived::speak</code> 的实现。</li>
</ul></li>
<li><strong>虚函数调用</strong>：
<ul>
<li>通过 <code>Base* ptr</code> 调用 <code>ptr-&gt;speak()</code>。</li>
<li>编译器生成代码，访问 <code>ptr</code> 指向对象的 vptr。</li>
<li>根据 vptr 找到 <code>Derived</code> 的 vtable。</li>
<li>从 vtable 中提取 <code>speak()</code>
的函数地址（偏移固定，由编译器确定）。</li>
<li>调用该地址对应的函数（即 <code>Derived::speak</code>）。</li>
</ul></li>
<li><strong>销毁对象</strong>：
<ul>
<li>删除对象时，虚析构函数确保按正确顺序调用析构函数（从派生类到基类）。</li>
</ul></li>
</ol>
<h4 id="内存布局示意图"><strong>内存布局示意图</strong></h4>
<p>假设 <code>Base</code> 和 <code>Derived</code> 的定义如上： -
<strong>Base 类 vtable</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0]: Base::speak</span><br><span class="line">[1]: Base::~Base</span><br></pre></td></tr></table></figure> - <strong>Derived 类
vtable</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0]: Derived::speak  // 重写</span><br><span class="line">[1]: Derived::~Derived</span><br></pre></td></tr></table></figure> - <strong>对象内存</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived 对象：</span><br><span class="line">| vptr (指向 Derived 的 vtable) |</span><br><span class="line">| 数据成员（若有）            |</span><br></pre></td></tr></table></figure></p>
<h4 id="编译器如何处理"><strong>3.4 编译器如何处理</strong></h4>
<ul>
<li><strong>静态代码</strong>：编译器为每个虚函数调用生成间接调用指令（如
<code>call [vptr + offset]</code>）。</li>
<li><strong>动态分派</strong>：运行时通过 vptr 和 vtable
确定实际函数地址。</li>
</ul>
<hr />
<h3 id="详细示例与验证"><strong>4. 详细示例与验证</strong></h3>
<p>以下代码展示多态的实现，并通过调试手段验证 vtable 的存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::func1\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::func2\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::func1\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::func2\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b1 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* b2 = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Calling through Base pointer:\n&quot;</span>;</span><br><span class="line">    b1-&gt;<span class="built_in">func1</span>();  <span class="comment">// Base::func1</span></span><br><span class="line">    b1-&gt;<span class="built_in">func2</span>();  <span class="comment">// Base::func2</span></span><br><span class="line">    b2-&gt;<span class="built_in">func1</span>();  <span class="comment">// Derived::func1</span></span><br><span class="line">    b2-&gt;<span class="built_in">func2</span>();  <span class="comment">// Derived::func2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> b1;  <span class="comment">// Base destroyed</span></span><br><span class="line">    <span class="keyword">delete</span> b2;  <span class="comment">// Derived destroyed -&gt; Base destroyed</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用引用</span></span><br><span class="line">    Derived d;</span><br><span class="line">    Base&amp; ref = d;</span><br><span class="line">    ref.<span class="built_in">func1</span>();  <span class="comment">// Derived::func1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Calling through Base pointer:</span><br><span class="line">Base::func1</span><br><span class="line">Base::func2</span><br><span class="line">Derived::func1</span><br><span class="line">Derived::func2</span><br><span class="line">Base destroyed</span><br><span class="line">Derived destroyed</span><br><span class="line">Base destroyed</span><br><span class="line">Derived::func1</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>验证 vtable</strong>：在调试器（如 GDB 或 Visual
Studio）中检查对象地址，会发现额外指针（vptr），其值指向 vtable。可以用
<code>sizeof</code> 检查对象大小： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of Base: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; <span class="string">&quot;\n&quot;</span>;    <span class="comment">// 通常 8（vptr）</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of Derived: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Derived) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 通常 8（共享 vptr）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="注意事项与限制"><strong>5. 注意事项与限制</strong></h3>
<ul>
<li><strong>虚函数的开销</strong>：
<ul>
<li><strong>空间开销</strong>：每个对象增加一个 vptr（通常 4 或 8
字节），每个类一个 vtable。</li>
<li><strong>时间开销</strong>：虚函数调用需要间接寻址，比直接调用慢。</li>
</ul></li>
<li><strong>虚析构函数</strong>：
<ul>
<li>如果基类析构函数不是虚函数，通过基类指针删除派生类对象只会调用基类析构函数，导致资源泄漏。</li>
<li>示例（错误情况）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">public</span>: ~<span class="built_in">Base</span>() &#123;&#125; &#125;;  <span class="comment">// 非虚析构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="keyword">public</span>: ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived\n&quot;</span>; &#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;  <span class="comment">// 只调用 Base::~Base，Derived::~Derived 被跳过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>纯虚函数（<code>= 0</code>）</strong>：
<ul>
<li>定义抽象类，强制派生类实现。</li>
<li>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Abstract</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mustImplement</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>非虚函数</strong>：通过基类指针调用时，始终执行基类版本，不实现多态。</li>
<li><strong>多重继承</strong>：
<ul>
<li>多继承下，每个基类的 vtable 独立，对象可能有多个 vptr。</li>
</ul></li>
</ul>
<hr />
<h3 id="多态的使用场景"><strong>6. 多态的使用场景</strong></h3>
<ul>
<li><strong>插件系统</strong>：基类定义接口，派生类实现具体功能。</li>
<li><strong>策略模式</strong>：运行时切换行为。</li>
<li><strong>框架设计</strong>：如 GUI 框架中，基类
<code>Widget</code>，派生类
<code>Button</code>、<code>TextBox</code>。</li>
</ul>
<hr />
<h3 id="总结-4"><strong>7. 总结</strong></h3>
<ul>
<li><strong>如何实现</strong>：C++
通过虚函数和基类指针/引用实现运行时多态。</li>
<li><strong>原理</strong>：依赖虚函数表（vtable）和虚表指针（vptr），编译器生成间接调用，运行时根据对象类型分派。</li>
<li><strong>关键点</strong>：需要 <code>virtual</code>
关键字、继承体系和动态绑定。</li>
<li><strong>优势</strong>：灵活性高，支持扩展。</li>
<li><strong>代价</strong>：增加内存和性能开销。</li>
</ul>
<p>如果需要更深入探讨（如 vtable
的内存布局、多继承下的实现，或性能分析），请告诉我，我可以进一步扩展！</p>
<h3 id="示意图">8. 示意图</h3>
<p>好的，我将使用 Mermaid 语法为你绘制 C++ 多态底层原理的图示，展示
<strong>虚函数表（vtable）</strong> 和 <strong>虚表指针（vptr）</strong>
的工作机制。由于 Mermaid
是一种基于文本的绘图工具，我会尽量清晰地表达多态的内存布局和调用流程。</p>
<p>以下是两种图： 1. <strong>类层次结构和 vtable
的关系图</strong>：展示基类和派生类的虚函数表。 2.
<strong>对象内存布局和调用流程图</strong>：展示对象中的 vptr 如何指向
vtable 并实现动态分派。</p>
<hr />
<h4 id="图-1类层次结构和虚函数表的关系"><strong>图
1：类层次结构和虚函数表的关系</strong></h4>
<p>这个图展示了 <code>Base</code> 和 <code>Derived</code>
类的继承关系，以及它们的 vtable 如何存储虚函数地址。</p>
<pre><code class="highlight mermaid">classDiagram
    class Base &#123;
        +speak()
        +~Base()
        -vptr
    &#125;
    class Derived &#123;
        +speak()
        +~Derived()
        -vptr
    &#125;
    Derived --|&gt; Base : 继承

    class Base_vtable &#123;
        +speak
        +~Base
    &#125;
    class Derived_vtable &#123;
        +speak
        +~Derived
    &#125;

    Base --&gt; Base_vtable
    Derived --&gt; Derived_vtable</code></pre>
<h5 id="解释"><strong>解释</strong></h5>
<ul>
<li><strong>Base 和 Derived 类</strong>：<code>Base</code>
是基类，<code>Derived</code> 是派生类，通过继承关系连接。</li>
<li><strong>虚函数表（vtable）</strong>：
<ul>
<li><code>Base_vtable</code>：存储 <code>Base::speak</code> 和
<code>Base::~Base</code> 的地址。</li>
<li><code>Derived_vtable</code>：存储 <code>Derived::speak</code> 和
<code>Derived::~Derived</code> 的地址，<code>speak</code> 被重写。</li>
</ul></li>
<li><strong>vptr</strong>：每个类实例包含一个虚表指针，指向其对应的
vtable。</li>
</ul>
<hr />
<h4 id="图-2对象内存布局和调用流程"><strong>图
2：对象内存布局和调用流程</strong></h4>
<p>这个图展示了 <code>Base* ptr = new Derived()</code>
的内存布局和运行时调用 <code>ptr-&gt;speak()</code> 的流程。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Main as main()
    participant Ptr as Base* ptr
    participant Obj as Derived 对象
    participant Vptr as vptr
    participant Vtable as Derived_vtable

    Main-&gt;&gt;Ptr: ptr = new Derived()
    Note right of Ptr: 分配 Derived 对象
    Ptr-&gt;&gt;Obj: 构造 Derived
    Obj-&gt;&gt;Vptr: 设置 vptr 指向 Derived_vtable
    Vptr-&gt;&gt;Vtable: 关联

    Main-&gt;&gt;Ptr: ptr-&gt;speak()
    Ptr-&gt;&gt;Obj: 访问对象
    Obj-&gt;&gt;Vptr: 获取 vptr
    Vptr-&gt;&gt;Vtable: 查找 vtable
    Vtable--&gt;&gt;Main: 调用 Derived::speak()

    Main-&gt;&gt;Ptr: delete ptr
    Ptr-&gt;&gt;Obj: 析构
    Obj-&gt;&gt;Vptr: 获取 vptr
    Vptr-&gt;&gt;Vtable: 调用 Derived::~Derived()
    Vtable--&gt;&gt;Obj: 完成析构</code></pre>
<h5 id="内存布局示意图-1"><strong>内存布局示意图</strong></h5>
<p>由于 Mermaid 不直接支持内存布局图，我用文本描述并结合上图解释：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Derived 对象内存布局：</span><br><span class="line">+-------------------+</span><br><span class="line">| vptr (指向 Derived_vtable) |  &lt;- 虚表指针</span><br><span class="line">+-------------------+</span><br><span class="line">| 数据成员（若有）   |</span><br><span class="line">+-------------------+</span><br><span class="line"></span><br><span class="line">Derived_vtable：</span><br><span class="line">+-------------------+</span><br><span class="line">| [0] Derived::speak |  &lt;- 虚函数地址</span><br><span class="line">| [1] Derived::~Derived |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure></p>
<h5 id="解释-1"><strong>解释</strong></h5>
<ul>
<li><strong>对象创建</strong>：
<ul>
<li><code>new Derived()</code> 创建对象，构造函数设置 <code>vptr</code>
指向 <code>Derived_vtable</code>。</li>
</ul></li>
<li><strong>虚函数调用</strong>：
<ul>
<li><code>ptr-&gt;speak()</code>：通过 <code>ptr</code> 访问对象，找到
<code>vptr</code>。</li>
<li><code>vptr</code> 指向 <code>Derived_vtable</code>，表中
<code>[0]</code> 是 <code>Derived::speak</code> 的地址。</li>
<li>调用该地址，执行 <code>Derived::speak</code>。</li>
</ul></li>
<li><strong>对象销毁</strong>：
<ul>
<li><code>delete ptr</code>：通过 <code>vptr</code> 找到
<code>Derived_vtable</code>，调用 <code>Derived::~Derived</code>。</li>
</ul></li>
</ul>
<hr />
<h4 id="代码验证"><strong>代码验证</strong></h4>
<p>以下代码与图对应，供参考： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base speaking\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived speaking\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">speak</span>();  <span class="comment">// 通过 vtable 调用 Derived::speak</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;    <span class="comment">// 通过 vtable 调用 Derived::~Derived</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived speaking</span><br><span class="line">Derived destroyed</span><br><span class="line">Base destroyed</span><br></pre></td></tr></table></figure></p>
<hr />
<h4 id="总结-5"><strong>总结</strong></h4>
<ul>
<li><strong>图 1</strong> 展示了类与 vtable
的静态关系，说明多态依赖继承和虚函数重写。</li>
<li><strong>图 2</strong> 展示了运行时动态分派的过程，强调 vptr 和
vtable 的作用。</li>
<li><strong>原理</strong>：C++
通过虚函数表和虚表指针实现运行时多态，确保基类指针能正确调用派生类的函数。</li>
</ul>
<p>如果需要调整图表内容、增加细节（如多继承的
vtable）或进一步解释，请告诉我！</p>
<h2 id="c-的模板和-java-的泛型比较">C++ 的模板和 Java 的泛型比较</h2>
<p>在编程语言中，C++ 的模板（Templates）和 Java
的泛型（Generics）都是为了实现代码的通用性和类型安全而设计的机制，但它们的实现方式、设计理念和使用场景有显著差异。以下从多个方面对它们进行比较，用中文详细讲解。</p>
<hr />
<h3 id="基本概念">1. <strong>基本概念</strong></h3>
<ul>
<li><p><strong>C++ 模板</strong>：</p>
<ul>
<li>C++
的模板是一种编译时（compile-time）的机制，允许开发者编写与类型无关的代码。</li>
<li>它是基于“代码生成”的思想：编译器在编译时根据模板参数生成具体的代码（称为“模板实例化”）。</li>
<li>模板可以用于类（类模板）、函数（函数模板）以及变量（C++14
引入变量模板）。</li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);      <span class="comment">// 实例化为 add&lt;int&gt;</span></span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">add</span>(<span class="number">1.5</span>, <span class="number">2.5</span>); <span class="comment">// 实例化为 add&lt;double&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Java 泛型</strong>：</p>
<ul>
<li>Java 的泛型是一种运行时（runtime）支持的机制，引入于 Java
5，主要用于提高类型安全性，避免运行时类型转换错误。</li>
<li>它是基于“类型擦除”（type
erasure）的实现：在编译时，泛型信息会被擦除，生成的字节码中只保留原始类型（raw
type），通过类型检查确保安全性。</li>
<li>泛型主要用于类、接口和方法。</li>
</ul>
<p>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Box&lt;Integer&gt; intBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">    intBox.set(<span class="number">10</span>);</span><br><span class="line">    System.out.println(intBox.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h3 id="实现机制">2. <strong>实现机制</strong></h3>
<ul>
<li><strong>C++ 模板</strong>：
<ul>
<li><strong>编译时实例化</strong>：每次使用不同的类型调用模板时，编译器会生成一份新的代码。例如，<code>add&lt;int&gt;</code>
和 <code>add&lt;double&gt;</code> 会生成两份独立的函数。</li>
<li><strong>无类型擦除</strong>：模板保留所有类型信息，编译器完全知道每个实例的具体类型。</li>
<li><strong>鸭子类型（Duck
Typing）</strong>：模板不要求类型实现特定接口，只要代码在语法上有效（比如支持
<code>+</code> 操作），编译就能通过。这也可能导致晦涩的错误信息。</li>
</ul></li>
<li><strong>Java 泛型</strong>：
<ul>
<li><strong>类型擦除</strong>：编译后，泛型类型信息被擦除，<code>Box&lt;Integer&gt;</code>
和 <code>Box&lt;String&gt;</code> 在字节码中都是
<code>Box</code>，只不过编译器插入了必要的类型转换（如
<code>(Integer)</code>）。</li>
<li><strong>运行时统一</strong>：由于擦除，运行时无法直接获取泛型参数的类型（需要通过反射绕过）。</li>
<li><strong>类型约束</strong>：泛型通常需要通过 <code>extends</code> 或
<code>super</code> 指定类型边界，要求类型实现特定接口或继承特定类。</li>
</ul></li>
</ul>
<hr />
<h3 id="灵活性与约束">3. <strong>灵活性与约束</strong></h3>
<ul>
<li><strong>C++ 模板</strong>：
<ul>
<li><strong>灵活性极高</strong>：可以用于任何类型，甚至包括基本类型（如
<code>int</code>、<code>double</code>），无需显式约束。</li>
<li><strong>支持非类型参数</strong>：模板不仅支持类型参数，还支持整数、指针等非类型参数。
示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[N];</span><br><span class="line">&#125;;</span><br><span class="line">Array&lt;<span class="number">5</span>&gt; arr; <span class="comment">// 固定大小数组</span></span><br></pre></td></tr></table></figure></li>
<li><strong>缺点</strong>：缺乏运行时类型检查，错误通常在编译时暴露，且错误信息可能复杂难懂。</li>
</ul></li>
<li><strong>Java 泛型</strong>：
<ul>
<li><strong>约束较多</strong>：不支持基本类型（如
<code>int</code>、<code>double</code>），必须使用包装类（如
<code>Integer</code>、<code>Double</code>），因为泛型基于对象。</li>
<li><strong>不支持非类型参数</strong>：只能使用类型参数，无法像 C++
那样用常量值作为模板参数。</li>
<li><strong>优点</strong>：通过类型擦除和编译时检查，保证了运行时的类型安全，且错误信息通常更直观。</li>
</ul></li>
</ul>
<hr />
<h3 id="性能">4. <strong>性能</strong></h3>
<ul>
<li><strong>C++ 模板</strong>：
<ul>
<li><strong>零运行时开销</strong>：由于模板在编译时生成具体代码，运行时没有额外的类型检查或转换开销，性能几乎等同于手写特定类型的代码。</li>
<li><strong>代码膨胀</strong>：每个类型实例化都会生成新代码，可能导致二进制文件变大。</li>
</ul></li>
<li><strong>Java 泛型</strong>：
<ul>
<li><strong>运行时开销</strong>：由于类型擦除和潜在的自动装箱/拆箱（如
<code>int</code> 到 <code>Integer</code>），可能引入性能损耗。</li>
<li><strong>代码复用</strong>：字节码中只有一个类定义，不会因为泛型参数不同而重复生成代码，二进制文件更小。</li>
</ul></li>
</ul>
<hr />
<h3 id="使用场景">5. <strong>使用场景</strong></h3>
<ul>
<li><strong>C++ 模板</strong>：
<ul>
<li><strong>高性能通用库</strong>：如
STL（标准模板库）中的容器（<code>vector</code>、<code>map</code>）和算法（<code>sort</code>），充分利用编译时优化。</li>
<li><strong>元编程</strong>：C++
模板支持模板元编程（TMP），可以实现复杂的编译时计算。 示例：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出 120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>Java 泛型</strong>：
<ul>
<li><strong>类型安全容器</strong>：如
<code>List&lt;T&gt;</code>、<code>Map&lt;K, V&gt;</code>，避免运行时类型转换错误。</li>
<li><strong>API 设计</strong>：泛型广泛用于框架和库（如 Java Collections
Framework），提高代码可读性和安全性。</li>
<li><strong>不支持元编程</strong>：由于类型擦除和运行时限制，泛型无法实现像
C++ 那样的编译时计算。</li>
</ul></li>
</ul>
<hr />
<h3 id="优缺点总结">6. <strong>优缺点总结</strong></h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 36%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>C++ 模板</th>
<th>Java 泛型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>实现时机</strong></td>
<td>编译时实例化</td>
<td>编译时检查，运行时擦除</td>
</tr>
<tr class="even">
<td><strong>类型支持</strong></td>
<td>支持基本类型和对象类型</td>
<td>仅支持对象类型（需包装类）</td>
</tr>
<tr class="odd">
<td><strong>灵活性</strong></td>
<td>高，支持非类型参数和元编程</td>
<td>较低，约束较多</td>
</tr>
<tr class="even">
<td><strong>性能</strong></td>
<td>无运行时开销，可能代码膨胀</td>
<td>有装箱/拆箱开销，代码复用好</td>
</tr>
<tr class="odd">
<td><strong>错误检测</strong></td>
<td>编译时，可能信息复杂</td>
<td>编译时，信息较清晰</td>
</tr>
<tr class="even">
<td><strong>运行时类型信息</strong></td>
<td>保留</td>
<td>擦除，需反射获取</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="实际例子对比">7. <strong>实际例子对比</strong></h3>
<ul>
<li><p><strong>C++ 模板</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line">    <span class="built_in">Container</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Container&lt;<span class="type">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">42</span>)</span></span>;      <span class="comment">// 实例化为 Container&lt;int&gt;</span></span><br><span class="line">    <span class="function">Container&lt;<span class="type">double</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">3.14</span>)</span></span>; <span class="comment">// 实例化为 Container&lt;double&gt;</span></span><br><span class="line">    c<span class="number">1.</span><span class="built_in">print</span>(); <span class="comment">// 输出 42</span></span><br><span class="line">    c<span class="number">2.</span><span class="built_in">print</span>(); <span class="comment">// 输出 3.14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Java 泛型</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Container</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Container</span><span class="params">(T v)</span> &#123; <span class="built_in">this</span>.value = v; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123; System.out.println(value); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Container&lt;Integer&gt; c1 = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;&gt;(<span class="number">42</span>);</span><br><span class="line">    Container&lt;Double&gt; c2 = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;&gt;(<span class="number">3.14</span>);</span><br><span class="line">    c1.print(); <span class="comment">// 输出 42</span></span><br><span class="line">    c2.print(); <span class="comment">// 输出 3.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>区别</strong>：C++
生成两个不同类（<code>Container&lt;int&gt;</code> 和
<code>Container&lt;double&gt;</code>），Java
生成单一字节码，运行时靠类型检查。</li>
</ul></li>
</ul>
<hr />
<h3 id="结论">8. <strong>结论</strong></h3>
<ul>
<li><strong>C++
模板</strong>更适合追求性能和灵活性的场景，尤其是嵌入式系统或高性能计算。它提供了强大的编译时能力，但需要开发者处理复杂的编译错误。</li>
<li><strong>Java
泛型</strong>更适合注重类型安全和代码简洁性的场景，适用于企业级应用和需要运行时一致性的环境，但牺牲了一些灵活性和性能。</li>
</ul>
<p>两者各有千秋，选择哪种取决于项目需求和语言生态。如果你有具体的应用场景想讨论，可以告诉我，我再深入分析！</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Bruce Yao
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://cmder.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++.html" title="C++">https://cmder.github.io/编程语言/C++/C++.html</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java.html" rel="prev" title="Java">
                  <i class="fa fa-angle-left"></i> Java
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" rel="next" title="设计模式">
                  设计模式 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2022 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bruce Yao</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/cmder" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: false,
  label: '🌓',
  autoMatchOsTheme: false
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
if (window.darkmode && !window.darkmode.isActivated()) {
  window.darkmode.toggle();
  var toggleButtons = document.getElementsByClassName("darkmode-toggle");
  if (toggleButtons && toggleButtons.length > 0) {
    for (i = 0; i < toggleButtons.length; i++) {
      toggleButtons[i].classList.add("darkmode-toggle--white");
    }
  }
}
</script>

</body>
</html>
