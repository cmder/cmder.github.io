<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cmder.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="知识结构">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 应用开发">
<meta property="og:url" content="https://cmder.github.io/Android/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.html">
<meta property="og:site_name" content="说码解字">
<meta property="og:description" content="知识结构">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-18T01:22:47.000Z">
<meta property="article:modified_time" content="2026-01-02T11:29:49.874Z">
<meta property="article:author" content="Bruce Yao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://cmder.github.io/Android/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.html">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://cmder.github.io/Android/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.html","path":"Android/应用开发/Android-应用开发.html","title":"Android 应用开发"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android 应用开发 | 说码解字</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"forest","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">说码解字</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">知识结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#android"><span class="nav-number">2.</span> <span class="nav-text">Android</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">View 事件分发流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. 事件分发的起点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%E5%92%8C%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. 关键方法和分发流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatchtoucheventmotionevent-event"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">2.1
dispatchTouchEvent(MotionEvent event)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onintercepttoucheventmotionevent-event%E4%BB%85-viewgroup-%E6%8B%A5%E6%9C%89"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">2.2
onInterceptTouchEvent(MotionEvent event)（仅
ViewGroup 拥有）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ontoucheventmotionevent-event"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">2.3
onTouchEvent(MotionEvent event)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.3.</span> <span class="nav-text">3. 事件分发的完整流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E-activity-%E5%BC%80%E5%A7%8B"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">3.1 从 Activity 开始</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5-viewgroup"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">3.2 进入 ViewGroup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5-view"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">3.3 进入 View</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%9B%9E%E4%BC%A0%E5%90%91%E4%B8%8A%E4%BC%A0%E6%92%AD"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">3.4 事件回传（向上传播）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.1.4.</span> <span class="nav-text">4. 关键注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="nav-number">2.1.5.</span> <span class="nav-text">5. 示例代码（伪代码）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.6.</span> <span class="nav-text">6. 总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">2.1.7.</span> <span class="nav-text">7. 流程图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#android-%E7%BB%98%E5%88%B6%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">Android 绘制渲染流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. 总体概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E4%B8%8A%E5%B1%82-view%E4%BB%8E-view-%E5%88%B0-viewrootimpl"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. 应用层（上层
View）：从 View 到 ViewRootImpl</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E8%A7%A6%E5%8F%91"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">2.1 绘制触发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#viewrootimpl-%E7%9A%84%E8%A7%92%E8%89%B2"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">2.2 ViewRootImpl 的角色</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#framework-%E5%B1%82%E4%BB%8E-viewrootimpl-%E5%88%B0-surfaceflinger"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. Framework
层：从 ViewRootImpl 到 SurfaceFlinger</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#choreographer-%E5%92%8C-vsync"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">3.1 Choreographer 和
VSYNC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#surface-%E5%92%8C-canvas"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">3.2 Surface 和
Canvas</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#surfaceflinger"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">3.3 SurfaceFlinger</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#native-%E5%B1%82jni-%E5%92%8C%E5%9B%BE%E5%BD%A2%E5%BA%93%E5%A6%82-skiaopenglvulkan"><span class="nav-number">2.2.4.</span> <span class="nav-text">4. Native 层：JNI
和图形库（如 Skia、OpenGL&#x2F;Vulkan）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jnijava-native-interface"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">4.1 JNI（Java Native Interface）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#skia-%E5%9B%BE%E5%BD%A2%E5%BA%93"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">4.2 Skia 图形库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#openglvulkan"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">4.3 OpenGL&#x2F;Vulkan</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hal-%E5%B1%82%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82"><span class="nav-number">2.2.5.</span> <span class="nav-text">5. HAL 层：硬件抽象层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hal-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">5.1 HAL 的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">5.2 硬件交互流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">2.2.6.</span> <span class="nav-text">6. 完整流程的总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%BA%BF"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">6.1 时间线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">6.2 关键路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vsync-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.2.6.3.</span> <span class="nav-text">6.3 VSYNC 的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.7.</span> <span class="nav-text">7. 性能优化与问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.2.8.</span> <span class="nav-text">8. 总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE-1"><span class="nav-number">2.2.9.</span> <span class="nav-text">9. 流程图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#view-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">View 绘制流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E7%9A%84%E6%80%BB%E4%BD%93%E6%A6%82%E8%BF%B0"><span class="nav-number">2.3.1.</span> <span class="nav-text">1. 绘制流程的总体概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E9%87%8F%E9%98%B6%E6%AE%B5measure"><span class="nav-number">2.3.2.</span> <span class="nav-text">2. 测量阶段（Measure）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">2.1 目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E5%8F%82%E6%95%B0"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">2.2 关键方法及其参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#view.measureint-widthmeasurespec-int-heightmeasurespec"><span class="nav-number">2.3.2.2.1.</span> <span class="nav-text">2.2.1
View.measure(int widthMeasureSpec, int heightMeasureSpec)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#view.onmeasureint-widthmeasurespec-int-heightmeasurespec"><span class="nav-number">2.3.2.2.2.</span> <span class="nav-text">2.2.2
View.onMeasure(int widthMeasureSpec, int heightMeasureSpec)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#viewgroup.measurechildrenint-widthmeasurespec-int-heightmeasurespec"><span class="nav-number">2.3.2.2.3.</span> <span class="nav-text">2.2.3
ViewGroup.measureChildren(int widthMeasureSpec, int heightMeasureSpec)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E9%87%8F%E9%98%B6%E6%AE%B5%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">2.3 测量阶段的注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E9%98%B6%E6%AE%B5layout"><span class="nav-number">2.3.3.</span> <span class="nav-text">3. 布局阶段（Layout）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-1"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">3.1 目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E5%8F%82%E6%95%B0-1"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">3.2 关键方法及其参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#view.layoutint-l-int-t-int-r-int-b"><span class="nav-number">2.3.3.2.1.</span> <span class="nav-text">3.2.1
View.layout(int l, int t, int r, int b)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#view.onlayoutboolean-changed-int-l-int-t-int-r-int-b"><span class="nav-number">2.3.3.2.2.</span> <span class="nav-text">3.2.2
View.onLayout(boolean changed, int l, int t, int r, int b)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E9%98%B6%E6%AE%B5%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">3.3 布局阶段的注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E9%98%B6%E6%AE%B5draw"><span class="nav-number">2.3.4.</span> <span class="nav-text">4. 绘制阶段（Draw）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-2"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">4.1 目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E5%8F%82%E6%95%B0-2"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">4.2 关键方法及其参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#view.drawcanvas-canvas"><span class="nav-number">2.3.4.2.1.</span> <span class="nav-text">4.2.1
View.draw(Canvas canvas)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#view.ondrawcanvas-canvas"><span class="nav-number">2.3.4.2.2.</span> <span class="nav-text">4.2.2
View.onDraw(Canvas canvas)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#viewgroup.dispatchdrawcanvas-canvas"><span class="nav-number">2.3.4.2.3.</span> <span class="nav-text">4.2.3
ViewGroup.dispatchDraw(Canvas canvas)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E9%98%B6%E6%AE%B5%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">4.3 绘制阶段的注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%BA%94%E7%94%A8%E5%B1%82%E5%88%B0-hal-%E5%B1%82%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B8%B2%E6%9F%93%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.5.</span> <span class="nav-text">5. 从应用层到 HAL
层的完整渲染绘制流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">5.1 应用层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#framework-%E5%B1%82"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">5.2 Framework 层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#native-%E5%B1%82"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">5.3 Native 层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hal-%E5%B1%82"><span class="nav-number">2.3.5.4.</span> <span class="nav-text">5.4 HAL 层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#invalidate-%E5%92%8C-requestlayout-%E7%9A%84%E8%AF%A6%E7%BB%86%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.6.</span> <span class="nav-text">6.
invalidate() 和 requestLayout()
的详细区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#invalidate"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">6.1 invalidate()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#requestlayout"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">6.2 requestLayout()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="nav-number">2.3.6.3.</span> <span class="nav-text">6.3 对比总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.3.7.</span> <span class="nav-text">7. 性能优化与注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">2.3.8.</span> <span class="nav-text">8. 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#android%E4%B8%ADipc%E6%96%B9%E5%BC%8F%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.4.</span> <span class="nav-text">Android中IPC方式、各种方式优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bundle"><span class="nav-number">2.4.1.</span> <span class="nav-text">1. Bundle</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">适用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#messenger"><span class="nav-number">2.4.2.</span> <span class="nav-text">2. Messenger</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">适用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aidlandroid-interface-definition-language"><span class="nav-number">2.4.3.</span> <span class="nav-text">3.
AIDL（Android Interface Definition Language）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-2"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">适用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#contentprovider"><span class="nav-number">2.4.4.</span> <span class="nav-text">4. ContentProvider</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-3"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">2.4.4.4.</span> <span class="nav-text">适用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#broadcastreceiver"><span class="nav-number">2.4.5.</span> <span class="nav-text">5. BroadcastReceiver</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-4"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="nav-number">2.4.5.3.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="nav-number">2.4.5.4.</span> <span class="nav-text">适用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket"><span class="nav-number">2.4.6.</span> <span class="nav-text">6. Socket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="nav-number">2.4.6.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-5"><span class="nav-number">2.4.6.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="nav-number">2.4.6.3.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="nav-number">2.4.6.4.</span> <span class="nav-text">适用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.7.</span> <span class="nav-text">各种方式的对比总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binder%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">Binder机制的作用和原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.5.1.</span> <span class="nav-text">Binder 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.5.2.</span> <span class="nav-text">Binder 的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">具体的通信流程：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="nav-number">2.5.3.</span> <span class="nav-text">Binder 通信的几个关键概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B"><span class="nav-number">2.5.4.</span> <span class="nav-text">Binder 的数据传输过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.5.5.</span> <span class="nav-text">Binder 的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-6"><span class="nav-number">2.5.5.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-6"><span class="nav-number">2.5.5.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-%E4%B8%8E%E4%BC%A0%E7%BB%9F-linux-ipc-%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.5.6.</span> <span class="nav-text">Binder 与传统 Linux IPC
机制的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">2.5.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ams%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86activity%E7%9A%84"><span class="nav-number">2.6.</span> <span class="nav-text">AMS是如何管理Activity的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ams-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="nav-number">2.6.1.</span> <span class="nav-text">1. AMS 的基本概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ams-%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2"><span class="nav-number">2.6.2.</span> <span class="nav-text">2. AMS 的核心角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ams-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86-activity"><span class="nav-number">2.6.3.</span> <span class="nav-text">3. AMS 如何管理
Activity</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-activity"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">1. 启动 Activity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#activity-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">2. Activity
的生命周期管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%A0%88%E7%AE%A1%E7%90%86"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">3. 任务栈管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">2.6.3.4.</span> <span class="nav-text">4. 进程管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86-activity-%E5%BC%82%E5%B8%B8"><span class="nav-number">2.6.3.5.</span> <span class="nav-text">5. 处理 Activity 异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ams-%E4%B8%8E-wms-%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C"><span class="nav-number">2.6.4.</span> <span class="nav-text">4. AMS 与 WMS
协同工作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA"><span class="nav-number">2.6.4.1.</span> <span class="nav-text">1. 窗口创建：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA"><span class="nav-number">2.6.4.2.</span> <span class="nav-text">2. 窗口显示：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%88%87%E6%8D%A2"><span class="nav-number">2.6.4.3.</span> <span class="nav-text">3. 窗口切换：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ams-%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A0%88%E7%AE%A1%E7%90%86"><span class="nav-number">2.6.5.</span> <span class="nav-text">5. AMS
的任务栈和任务栈管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">2.6.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#activitythread%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.7.</span> <span class="nav-text">ActivityThread工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#activitythread-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="nav-number">2.7.1.</span> <span class="nav-text">1. ActivityThread
的基本概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#activitythread-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">2.7.2.</span> <span class="nav-text">2. ActivityThread
的核心组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#activitythread-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.7.3.</span> <span class="nav-text">3. ActivityThread
的工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">1. 启动流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">2. 消息处理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#activity-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">2.7.3.3.</span> <span class="nav-text">3. Activity 启动过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#activity-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="nav-number">2.7.3.4.</span> <span class="nav-text">4. Activity
生命周期管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="nav-number">2.7.4.</span> <span class="nav-text">4.
与其他系统服务的协作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#activitythread-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">2.7.5.</span> <span class="nav-text">5. ActivityThread
的主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-number">2.7.6.</span> <span class="nav-text">6. 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.8.</span> <span class="nav-text">内存抖动是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E7%9A%84%E8%A1%A8%E7%8E%B0"><span class="nav-number">2.8.1.</span> <span class="nav-text">内存抖动的表现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.8.2.</span> <span class="nav-text">内存抖动的常见原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8"><span class="nav-number">2.8.3.</span> <span class="nav-text">如何避免内存抖动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">2.8.4.</span> <span class="nav-text">内存抖动对性能的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="nav-number">2.8.5.</span> <span class="nav-text">内存抖动的检测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.9.</span> <span class="nav-text">Android系统启动流程是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bootloader%E9%98%B6%E6%AE%B5"><span class="nav-number">2.9.1.</span> <span class="nav-text">1. Bootloader阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5"><span class="nav-number">2.9.2.</span> <span class="nav-text">2. Linux内核启动阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#init%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5"><span class="nav-number">2.9.3.</span> <span class="nav-text">3. Init进程启动阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zygote%E5%92%8Csystem-server%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5"><span class="nav-number">2.9.4.</span> <span class="nav-text">4. Zygote和System
Server启动阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8android-runtime-art"><span class="nav-number">2.9.5.</span> <span class="nav-text">5. 启动Android Runtime
(ART)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8launcher%E5%92%8C%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.9.6.</span> <span class="nav-text">6.
启动Launcher和应用进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-6"><span class="nav-number">2.9.7.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#app%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">2.10.</span> <span class="nav-text">App启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87"><span class="nav-number">2.10.1.</span> <span class="nav-text">1. 用户点击应用图标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#launcher%E8%AF%B7%E6%B1%82%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8"><span class="nav-number">2.10.2.</span> <span class="nav-text">2.
Launcher请求启动应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zygote%E8%BF%9B%E7%A8%8B%E6%B4%BE%E7%94%9F%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.10.3.</span> <span class="nav-text">3.
Zygote进程派生应用进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#activitythread%E5%90%AF%E5%8A%A8"><span class="nav-number">2.10.4.</span> <span class="nav-text">4. ActivityThread启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#activity%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">2.10.5.</span> <span class="nav-text">5. Activity的启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-number">2.10.6.</span> <span class="nav-text">6.
Activity生命周期方法调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#view%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="nav-number">2.10.7.</span> <span class="nav-text">7. View的渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA"><span class="nav-number">2.10.8.</span> <span class="nav-text">8. 用户界面显示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-7"><span class="nav-number">2.10.9.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wms%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86window%E7%9A%84"><span class="nav-number">2.11.</span> <span class="nav-text">WMS是如何管理Window的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.11.1.</span> <span class="nav-text">1. 窗口的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">2.11.2.</span> <span class="nav-text">2. 窗口的创建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E5%B8%83%E5%B1%80"><span class="nav-number">2.11.3.</span> <span class="nav-text">3. 窗口的管理和布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E7%BB%98%E5%88%B6%E5%92%8C%E6%98%BE%E7%A4%BA"><span class="nav-number">2.11.4.</span> <span class="nav-text">4. 窗口的绘制和显示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E7%84%A6%E7%82%B9%E7%AE%A1%E7%90%86"><span class="nav-number">2.11.5.</span> <span class="nav-text">5. 窗口的焦点管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E7%A7%BB%E9%99%A4"><span class="nav-number">2.11.6.</span> <span class="nav-text">6. 窗口的移除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%8A%A8%E7%94%BB"><span class="nav-number">2.11.7.</span> <span class="nav-text">7. 窗口动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91"><span class="nav-number">2.11.8.</span> <span class="nav-text">8. 输入事件的分发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-8"><span class="nav-number">2.11.9.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rxjava%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.12.</span> <span class="nav-text">RxJava的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rxjava%E6%A6%82%E8%BF%B0"><span class="nav-number">2.12.1.</span> <span class="nav-text">RxJava概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rxjava%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">2.12.2.</span> <span class="nav-text">RxJava的核心组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rxjava-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E4%BB%A5%E4%B8%8B%E5%85%B3%E9%94%AE%E6%80%9D%E6%83%B3"><span class="nav-number">2.12.3.</span> <span class="nav-text">RxJava
的实现基于以下关键思想：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#observable%E5%92%8Cobserver%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.12.3.1.</span> <span class="nav-text">1.
Observable和Observer模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.12.3.2.</span> <span class="nav-text">2.
链式操作符和装饰者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#schedulers%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">2.12.3.3.</span> <span class="nav-text">3.
Schedulers和线程控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8E%8B%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.13.</span> <span class="nav-text">背压问题及其解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%83%8C%E5%8E%8Bbackpressure"><span class="nav-number">2.13.1.</span> <span class="nav-text">1.
什么是背压（Backpressure）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8E%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88"><span class="nav-number">2.13.2.</span> <span class="nav-text">2. 背压的应对方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flowable-%E8%83%8C%E5%8E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.13.3.</span> <span class="nav-text">3. Flowable 背压模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flowable%E8%AF%B7%E6%B1%82%E6%95%B0%E9%87%8F%E7%AE%A1%E7%90%86"><span class="nav-number">2.13.4.</span> <span class="nav-text">4.
Flowable请求数量管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-9"><span class="nav-number">2.13.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-%E5%92%8C-flatmap"><span class="nav-number">2.14.</span> <span class="nav-text">map 和 flatMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.14.1.</span> <span class="nav-text">1. map 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.14.1.1.</span> <span class="nav-text">工作原理：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.14.1.2.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatmap-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.14.2.</span> <span class="nav-text">2. flatMap 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="nav-number">2.14.2.1.</span> <span class="nav-text">工作原理：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">2.14.2.2.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="nav-number">2.14.3.</span> <span class="nav-text">3. 区别总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatmap-%E5%92%8C-concatmap-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.14.4.</span> <span class="nav-text">4. flatMap 和
concatMap 的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#concatmap-%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.14.4.1.</span> <span class="nav-text">concatMap 示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-10"><span class="nav-number">2.14.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zip-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.15.</span> <span class="nav-text">zip 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="nav-number">2.15.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">2.15.2.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">2.15.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.15.4.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.15.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#aspectj-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.16.</span> <span class="nav-text">AspectJ 的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E7%BB%87%E5%85%A5compile-time-weaving"><span class="nav-number">2.16.1.</span> <span class="nav-text">1. 编译时织入（Compile-Time
Weaving）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%BB%87%E5%85%A5load-time-weavingltw"><span class="nav-number">2.16.2.</span> <span class="nav-text">2. 类加载时织入（Load-Time
Weaving，LTW）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BB%A3%E7%90%86"><span class="nav-number">2.16.3.</span> <span class="nav-text">3. 运行时代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%82%B9%E5%88%87%E5%85%A5%E7%82%B9%E5%92%8C%E9%80%9A%E7%9F%A5%E7%9A%84%E5%8C%B9%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">2.16.4.</span> <span class="nav-text">4.
连接点、切入点和通知的匹配机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81%E5%B9%B6%E7%BB%B4%E6%8A%A4-aspectj-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.16.5.</span> <span class="nav-text">5. 生成字节码并维护 AspectJ
的执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-11"><span class="nav-number">2.16.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#okhttp%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.17.</span> <span class="nav-text">OKHttp的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#okhttp-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.17.1.</span> <span class="nav-text">OKHttp 核心组件和工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#okhttp-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.17.2.</span> <span class="nav-text">OKHttp 的工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#okhttp%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">2.17.3.</span> <span class="nav-text">OKHttp的实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8interceptor%E6%9C%BA%E5%88%B6"><span class="nav-number">2.17.3.1.</span> <span class="nav-text">1.
拦截器（Interceptor）机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0connection-pool"><span class="nav-number">2.17.3.2.</span> <span class="nav-text">2. 连接池（Connection
Pool）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">2.17.3.3.</span> <span class="nav-text">3. 缓存机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.17.3.4.</span> <span class="nav-text">4. 异步处理和线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http2-%E5%92%8C-websocket-%E6%94%AF%E6%8C%81"><span class="nav-number">2.17.3.5.</span> <span class="nav-text">5. HTTP&#x2F;2 和 WebSocket
支持</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#okhttp%E7%9A%84%E6%95%B4%E4%BD%93%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="nav-number">2.17.4.</span> <span class="nav-text">OKHttp的整体工作原理图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-12"><span class="nav-number">2.17.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#glide-%E8%AF%B7%E6%B1%82%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.18.</span> <span class="nav-text">Glide 请求的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handler-%E5%8E%9F%E7%90%86"><span class="nav-number">2.19.</span> <span class="nav-text">Handler 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#handler-%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-number">2.19.1.</span> <span class="nav-text">Handler 原理概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-3"><span class="nav-number">2.19.2.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#handler-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">2.19.3.</span> <span class="nav-text">Handler 工作流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-number">2.19.4.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-number">2.19.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#idlehandler"><span class="nav-number">2.20.</span> <span class="nav-text">IdleHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-4"><span class="nav-number">2.20.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.20.2.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">2.20.3.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E8%80%83%E9%87%8F"><span class="nav-number">2.20.4.</span> <span class="nav-text">设计考量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="nav-number">2.20.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handler-%E6%B6%88%E6%81%AF%E5%B1%8F%E9%9A%9C"><span class="nav-number">2.21.</span> <span class="nav-text">Handler 消息屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#handler-%E5%92%8C-messagequeue"><span class="nav-number">2.21.1.</span> <span class="nav-text">Handler 和 MessageQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.21.2.</span> <span class="nav-text">消息屏障的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.21.3.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">2.21.4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-13"><span class="nav-number">2.21.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#android-%E5%9B%BE%E5%BD%A2%E6%A1%86%E6%9E%B6"><span class="nav-number">2.22.</span> <span class="nav-text">Android 图形框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82-hardware-abstraction-layer-hal"><span class="nav-number">2.22.1.</span> <span class="nav-text">1. 硬件抽象层
(Hardware Abstraction Layer, HAL)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.22.2.</span> <span class="nav-text">2. 图形驱动和接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#surface-%E5%92%8C-surfaceflinger"><span class="nav-number">2.22.3.</span> <span class="nav-text">3. Surface 和
SurfaceFlinger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E5%92%8C-vsync"><span class="nav-number">2.22.4.</span> <span class="nav-text">4. 硬件加速和 VSync</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#renderthread-%E5%92%8C-choreographer"><span class="nav-number">2.22.5.</span> <span class="nav-text">5. RenderThread 和
Choreographer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E7%9A%84-android-ui-%E7%BB%98%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.22.6.</span> <span class="nav-text">6. 顶层的 Android UI
绘制系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#view-%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">2.22.6.1.</span> <span class="nav-text">View 系统和绘制流程：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E5%92%8C-gpu-%E6%B8%B2%E6%9F%93"><span class="nav-number">2.22.6.2.</span> <span class="nav-text">硬件加速和 GPU 渲染：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.22.7.</span> <span class="nav-text">7. 动画系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%92%8C%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.22.8.</span> <span class="nav-text">8. 触摸事件和输入系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-14"><span class="nav-number">2.22.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#surfaceview-glsurfaceview-%E5%92%8C-texturesurfaceview"><span class="nav-number">2.23.</span> <span class="nav-text">SurfaceView,
GLSurfaceView 和 TextureSurfaceView</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#surfaceview"><span class="nav-number">2.23.1.</span> <span class="nav-text">1. SurfaceView</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">2.23.1.1.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">2.23.1.2.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">2.23.1.3.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#glsurfaceview"><span class="nav-number">2.23.2.</span> <span class="nav-text">2. GLSurfaceView</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-number">2.23.2.1.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">2.23.2.2.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="nav-number">2.23.2.3.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#textureview"><span class="nav-number">2.23.3.</span> <span class="nav-text">3. TextureView</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-2"><span class="nav-number">2.23.3.1.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="nav-number">2.23.3.2.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="nav-number">2.23.3.3.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.23.4.</span> <span class="nav-text">4. 区别总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.23.5.</span> <span class="nav-text">5. 选择建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mvc-mvp-%E5%92%8C-mvvm"><span class="nav-number">2.24.</span> <span class="nav-text">MVC, MVP 和 MVVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mvcmodel-view-controller%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.24.1.</span> <span class="nav-text">1.
MVC（Model-View-Controller）架构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="nav-number">2.24.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E8%A7%92%E8%89%B2"><span class="nav-number">2.24.1.2.</span> <span class="nav-text">组件角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E4%BA%A4%E4%BA%92"><span class="nav-number">2.24.1.3.</span> <span class="nav-text">数据流和交互</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-7"><span class="nav-number">2.24.1.4.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-7"><span class="nav-number">2.24.1.5.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%A4%BA"><span class="nav-number">2.24.1.6.</span> <span class="nav-text">图示：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mvpmodel-view-presenter%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.24.2.</span> <span class="nav-text">2.
MVP（Model-View-Presenter）架构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="nav-number">2.24.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E8%A7%92%E8%89%B2-1"><span class="nav-number">2.24.2.2.</span> <span class="nav-text">组件角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E4%BA%A4%E4%BA%92-1"><span class="nav-number">2.24.2.3.</span> <span class="nav-text">数据流和交互</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-8"><span class="nav-number">2.24.2.4.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-8"><span class="nav-number">2.24.2.5.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%A4%BA-1"><span class="nav-number">2.24.2.6.</span> <span class="nav-text">图示：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mvvmmodel-view-viewmodel%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.24.3.</span> <span class="nav-text">3.
MVVM（Model-View-ViewModel）架构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-8"><span class="nav-number">2.24.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E8%A7%92%E8%89%B2-2"><span class="nav-number">2.24.3.2.</span> <span class="nav-text">组件角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E4%BA%A4%E4%BA%92-2"><span class="nav-number">2.24.3.3.</span> <span class="nav-text">数据流和交互</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-9"><span class="nav-number">2.24.3.4.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-9"><span class="nav-number">2.24.3.5.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%A4%BA-2"><span class="nav-number">2.24.3.6.</span> <span class="nav-text">图示：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mvcmvp-%E5%92%8C-mvvm-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.24.3.7.</span> <span class="nav-text">MVC、MVP 和 MVVM
的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-15"><span class="nav-number">2.24.3.8.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">2.25.</span> <span class="nav-text">四大组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#activity%E6%B4%BB%E5%8A%A8"><span class="nav-number">2.25.1.</span> <span class="nav-text">1. Activity（活动）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-9"><span class="nav-number">2.25.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">2.25.1.2.</span> <span class="nav-text">主要特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="nav-number">2.25.1.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="nav-number">2.25.1.4.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#service%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.25.2.</span> <span class="nav-text">2. Service（服务）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-10"><span class="nav-number">2.25.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9-1"><span class="nav-number">2.25.2.2.</span> <span class="nav-text">主要特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="nav-number">2.25.2.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="nav-number">2.25.2.4.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#broadcastreceiver%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="nav-number">2.25.3.</span> <span class="nav-text">3.
BroadcastReceiver（广播接收器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-11"><span class="nav-number">2.25.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9-2"><span class="nav-number">2.25.3.2.</span> <span class="nav-text">主要特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-7"><span class="nav-number">2.25.3.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="nav-number">2.25.3.4.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#contentprovider%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85"><span class="nav-number">2.25.4.</span> <span class="nav-text">4.
ContentProvider（内容提供者）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-12"><span class="nav-number">2.25.4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9-3"><span class="nav-number">2.25.4.2.</span> <span class="nav-text">主要特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-8"><span class="nav-number">2.25.4.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-9"><span class="nav-number">2.25.4.4.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">2.25.5.</span> <span class="nav-text">四大组件的总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="nav-number">2.25.5.1.</span> <span class="nav-text">四大组件的协作：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#aidl"><span class="nav-number">2.26.</span> <span class="nav-text">AIDL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-aidl"><span class="nav-number">2.26.1.</span> <span class="nav-text">为什么需要 AIDL？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aidl-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.26.2.</span> <span class="nav-text">AIDL 的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aidl-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.26.3.</span> <span class="nav-text">AIDL 的使用步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-aidl-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.26.3.1.</span> <span class="nav-text">1. 定义 AIDL 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-aidl-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.26.3.2.</span> <span class="nav-text">2. 实现 AIDL 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%91%E5%AE%9A%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.26.3.3.</span> <span class="nav-text">3. 客户端绑定远程服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-androidmanifest.xml-%E4%B8%AD%E5%A3%B0%E6%98%8E%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.26.3.4.</span> <span class="nav-text">4. 在
AndroidManifest.xml 中声明服务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aidl-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81"><span class="nav-number">2.26.4.</span> <span class="nav-text">AIDL 的数据类型支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aidl-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.26.5.</span> <span class="nav-text">AIDL 的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-10"><span class="nav-number">2.26.5.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-10"><span class="nav-number">2.26.5.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aidl-%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.26.6.</span> <span class="nav-text">AIDL 的典型使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-16"><span class="nav-number">2.26.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">2.27.</span> <span class="nav-text">性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="nav-number">2.27.1.</span> <span class="nav-text">1. 内存优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">2.27.1.1.</span> <span class="nav-text">1.1 减少内存泄漏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.27.1.2.</span> <span class="nav-text">1.2 使用合适的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84-bitmap-%E9%85%8D%E7%BD%AE"><span class="nav-number">2.27.1.3.</span> <span class="nav-text">1.3 使用合适的 Bitmap 配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84-service"><span class="nav-number">2.27.1.4.</span> <span class="nav-text">1.4 避免使用过多的
Service</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ui-%E4%BC%98%E5%8C%96"><span class="nav-number">2.27.2.</span> <span class="nav-text">2. UI 优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D-ui-%E5%8D%A1%E9%A1%BFanr"><span class="nav-number">2.27.2.1.</span> <span class="nav-text">2.1 避免 UI 卡顿（ANR）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%B8%83%E5%B1%80"><span class="nav-number">2.27.2.2.</span> <span class="nav-text">2.2 优化布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81%E9%87%8D%E7%BB%98"><span class="nav-number">2.27.2.3.</span> <span class="nav-text">2.3 避免频繁重绘</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96"><span class="nav-number">2.27.3.</span> <span class="nav-text">3. 电量优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1"><span class="nav-number">2.27.3.1.</span> <span class="nav-text">3.1 减少不必要的后台任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E4%BC%A0%E6%84%9F%E5%99%A8%E5%92%8C-gps-%E4%BD%BF%E7%94%A8"><span class="nav-number">2.27.3.2.</span> <span class="nav-text">3.2 优化传感器和 GPS 使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96"><span class="nav-number">2.27.4.</span> <span class="nav-text">4. 网络优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="nav-number">2.27.4.1.</span> <span class="nav-text">4.1 减少不必要的网络请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE"><span class="nav-number">2.27.4.2.</span> <span class="nav-text">4.2 压缩数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="nav-number">2.27.4.3.</span> <span class="nav-text">4.3 批量处理网络请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%AB%98%E6%95%88%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%93"><span class="nav-number">2.27.4.4.</span> <span class="nav-text">4.4 使用高效的网络库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96"><span class="nav-number">2.27.5.</span> <span class="nav-text">5. 启动速度优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E5%90%AF%E5%8A%A8%E6%97%B6%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C"><span class="nav-number">2.27.5.1.</span> <span class="nav-text">5.1 减少启动时的初始化工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%86%B7%E5%90%AF%E5%8A%A8"><span class="nav-number">2.27.5.2.</span> <span class="nav-text">5.2 优化冷启动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96"><span class="nav-number">2.27.6.</span> <span class="nav-text">6. 多线程优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.27.6.1.</span> <span class="nav-text">6.1 合理使用线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89"><span class="nav-number">2.27.6.2.</span> <span class="nav-text">6.2 避免线程竞争</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><span class="nav-number">2.27.7.</span> <span class="nav-text">7. 数据库优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%AB%98%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="nav-number">2.27.7.1.</span> <span class="nav-text">7.1 使用高效的数据库操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.27.7.2.</span> <span class="nav-text">7.2 使用索引优化查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-number">2.27.8.</span> <span class="nav-text">8. 其他优化方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-proguard-%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-number">2.27.8.1.</span> <span class="nav-text">8.1 使用 ProGuard
进行代码混淆与优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96"><span class="nav-number">2.27.8.2.</span> <span class="nav-text">8.2 资源优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">2.27.9.</span> <span class="nav-text">结论：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mediacodec"><span class="nav-number">2.28.</span> <span class="nav-text">MediaCodec</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mediacodec-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.28.1.</span> <span class="nav-text">MediaCodec 的工作原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">2.28.2.</span> <span class="nav-text">基本工作流程图：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mediacodec-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.28.3.</span> <span class="nav-text">MediaCodec 的特点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">2.28.4.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#camera-%E5%92%8C-camera2-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.29.</span> <span class="nav-text">Camera 和 Camera2 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#api-%E7%9A%84%E6%8E%A8%E5%87%BA%E6%97%B6%E9%97%B4"><span class="nav-number">2.29.1.</span> <span class="nav-text">1. API 的推出时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#api-%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="nav-number">2.29.2.</span> <span class="nav-text">2. API 设计和复杂性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E8%83%BD%E5%8A%9B%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">2.29.3.</span> <span class="nav-text">3. 硬件能力的访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">2.29.4.</span> <span class="nav-text">4. 图像处理与数据流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E5%B8%A7%E7%8E%87%E6%8E%A7%E5%88%B6"><span class="nav-number">2.29.5.</span> <span class="nav-text">5. 性能与帧率控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-number">2.29.6.</span> <span class="nav-text">6. 开发者工具与兼容性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%92%8C%E8%BF%9B%E5%8C%96"><span class="nav-number">2.29.7.</span> <span class="nav-text">7. 扩展和进化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%B7%AE%E5%BC%82"><span class="nav-number">2.29.8.</span> <span class="nav-text">8. 示例代码差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-17"><span class="nav-number">2.29.9.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bufferqueue"><span class="nav-number">2.30.</span> <span class="nav-text">BufferQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bufferqueue-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">2.30.1.</span> <span class="nav-text">BufferQueue 的工作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="nav-number">2.30.1.1.</span> <span class="nav-text">主要组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">2.30.1.2.</span> <span class="nav-text">流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bufferqueue-%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-number">2.30.2.</span> <span class="nav-text">BufferQueue 的主要作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bufferqueue-%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.30.3.</span> <span class="nav-text">BufferQueue 的工作示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B"><span class="nav-number">2.30.3.1.</span> <span class="nav-text">示例流程：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bufferqueue-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.30.4.</span> <span class="nav-text">BufferQueue 的实际应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#camera-api"><span class="nav-number">2.30.4.1.</span> <span class="nav-text">1. Camera API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE"><span class="nav-number">2.30.4.2.</span> <span class="nav-text">2. 视频播放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#opengl-%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93"><span class="nav-number">2.30.4.3.</span> <span class="nav-text">3. OpenGL 纹理渲染</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bufferqueue-%E7%9A%84%E4%BC%98%E5%8C%96%E7%82%B9"><span class="nav-number">2.30.5.</span> <span class="nav-text">BufferQueue 的优化点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-18"><span class="nav-number">2.30.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="nav-number">2.31.</span> <span class="nav-text">组件化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="nav-number">2.31.1.</span> <span class="nav-text">为什么需要组件化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.31.2.</span> <span class="nav-text">组件化的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B1%82%E6%AC%A1"><span class="nav-number">2.31.3.</span> <span class="nav-text">组件化的架构层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.31.4.</span> <span class="nav-text">组件化的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gradle-%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%8C%96%E6%9E%84%E5%BB%BA"><span class="nav-number">2.31.4.1.</span> <span class="nav-text">1. Gradle
多模块化构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">2.31.4.2.</span> <span class="nav-text">2. 组件间通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%80%9A%E4%BF%A1interface-communication"><span class="nav-number">2.31.4.2.1.</span> <span class="nav-text">（1）接口通信（Interface
Communication）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E9%80%9A%E4%BF%A1router-communication"><span class="nav-number">2.31.4.2.2.</span> <span class="nav-text">（2）路由通信（Router
Communication）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BFevent-bus"><span class="nav-number">2.31.4.2.3.</span> <span class="nav-text">（3）事件总线（Event
Bus）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection"><span class="nav-number">2.31.4.2.4.</span> <span class="nav-text">（4）依赖注入（Dependency
Injection）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8C%96%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.31.4.3.</span> <span class="nav-text">3. 动态化加载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.31.5.</span> <span class="nav-text">组件化的开发模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.31.6.</span> <span class="nav-text">组件化的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-11"><span class="nav-number">2.31.6.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-11"><span class="nav-number">2.31.6.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-19"><span class="nav-number">2.31.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E5%8C%96"><span class="nav-number">2.32.</span> <span class="nav-text">插件化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8F%92%E4%BB%B6%E5%8C%96"><span class="nav-number">2.32.1.</span> <span class="nav-text">为什么需要插件化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#android-%E6%8F%92%E4%BB%B6%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.32.2.</span> <span class="nav-text">Android 插件化的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E5%8C%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.32.3.</span> <span class="nav-text">插件化的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6"><span class="nav-number">2.32.3.1.</span> <span class="nav-text">1. 动态加载插件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#classloader-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">2.32.3.2.</span> <span class="nav-text">2. ClassLoader
动态加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-number">2.32.3.3.</span> <span class="nav-text">3. 资源管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#activity-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86-1"><span class="nav-number">2.32.3.4.</span> <span class="nav-text">4. Activity
的生命周期管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.32.4.</span> <span class="nav-text">插件化框架的常见实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#replugin"><span class="nav-number">2.32.4.1.</span> <span class="nav-text">1. RePlugin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#small"><span class="nav-number">2.32.4.2.</span> <span class="nav-text">2. Small</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#droidplugin"><span class="nav-number">2.32.4.3.</span> <span class="nav-text">3. DroidPlugin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamicloadapk"><span class="nav-number">2.32.4.4.</span> <span class="nav-text">4. DynamicLoadApk</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.32.5.</span> <span class="nav-text">插件化的实现步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E5%8C%96%E7%9A%84%E6%8C%91%E6%88%98"><span class="nav-number">2.32.6.</span> <span class="nav-text">插件化的挑战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-20"><span class="nav-number">2.32.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="nav-number">2.33.</span> <span class="nav-text">热更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="nav-number">2.33.1.</span> <span class="nav-text">为什么需要热更新？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">2.33.2.</span> <span class="nav-text">热更新的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.33.3.</span> <span class="nav-text">热更新的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dex-%E6%96%87%E4%BB%B6%E6%9B%BF%E6%8D%A2"><span class="nav-number">2.33.3.1.</span> <span class="nav-text">1. Dex 文件替换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2hook-%E6%8A%80%E6%9C%AF"><span class="nav-number">2.33.3.2.</span> <span class="nav-text">2. 方法替换（Hook
技术）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%9B%BF%E6%8D%A2"><span class="nav-number">2.33.3.3.</span> <span class="nav-text">3. 资源替换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6"><span class="nav-number">2.33.4.</span> <span class="nav-text">热更新的常用框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tinker%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%BA%90"><span class="nav-number">2.33.4.1.</span> <span class="nav-text">1. Tinker（微信开源）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#andfix%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90"><span class="nav-number">2.33.4.2.</span> <span class="nav-text">2.
AndFix（阿里巴巴开源）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#robust%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E5%BC%80%E6%BA%90"><span class="nav-number">2.33.4.3.</span> <span class="nav-text">3.
Robust（美团点评开源）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nuwa"><span class="nav-number">2.33.4.4.</span> <span class="nav-text">4. Nuwa</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E6%8A%80%E6%9C%AF%E7%9A%84%E6%8C%91%E6%88%98"><span class="nav-number">2.33.5.</span> <span class="nav-text">热更新技术的挑战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-21"><span class="nav-number">2.33.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">2.34.</span> <span class="nav-text">线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#handler"><span class="nav-number">2.34.1.</span> <span class="nav-text">1. Handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asynctask%E5%B7%B2%E5%BA%9F%E5%BC%83%E4%BD%BF%E7%94%A8%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">2.34.2.</span> <span class="nav-text">2.
AsyncTask（已废弃，使用替代方案）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#executor-future-callable"><span class="nav-number">2.34.3.</span> <span class="nav-text">3. Executor + Future +
Callable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#handlerthread"><span class="nav-number">2.34.4.</span> <span class="nav-text">4. HandlerThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#broadcastreceiver-1"><span class="nav-number">2.34.5.</span> <span class="nav-text">5. BroadcastReceiver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eventbus"><span class="nav-number">2.34.6.</span> <span class="nav-text">6. EventBus</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#android-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E8%B7%B5%E5%9C%BA%E6%99%AF"><span class="nav-number">2.35.</span> <span class="nav-text">Android
的四种启动模式及实践场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#standard%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.35.1.</span> <span class="nav-text">1. standard（标准模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#singletop%E6%A0%88%E9%A1%B6%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.35.2.</span> <span class="nav-text">2.
singleTop（栈顶复用模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#singletask%E6%A0%88%E5%86%85%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.35.3.</span> <span class="nav-text">3.
singleTask（栈内复用模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#singleinstance%E5%8D%95%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.35.4.</span> <span class="nav-text">4.
singleInstance（单实例模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">2.35.5.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="nav-number">2.35.6.</span> <span class="nav-text">总结对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java"><span class="nav-number">3.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#hashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">HashMap的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.1.</span> <span class="nav-text">1. 基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83node"><span class="nav-number">3.1.2.</span> <span class="nav-text">2. 存储单元：Node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.3.</span> <span class="nav-text">3. 哈希函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-number">3.1.4.</span> <span class="nav-text">4. 处理哈希冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">1. 链地址法（链表）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A0%91%E5%8C%96"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">2. 红黑树（树化）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.5.</span> <span class="nav-text">5. 扩容机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.6.</span> <span class="nav-text">6. 查找过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.7.</span> <span class="nav-text">7. 删除操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashmap-%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">3.1.8.</span> <span class="nav-text">8. HashMap
的性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-22"><span class="nav-number">3.1.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jni%E4%B8%ADjava%E5%A6%82%E4%BD%95%E8%B0%83c"><span class="nav-number">3.2.</span> <span class="nav-text">JNI中Java如何调C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E-native-%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. 声明 Native 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90-cc-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. 生成 C&#x2F;C++ 头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-native-%E6%96%B9%E6%B3%95-cc-%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.3.</span> <span class="nav-text">3. 实现 Native 方法 (C&#x2F;C++
实现)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-cc-%E4%BB%A3%E7%A0%81%E5%B9%B6%E7%94%9F%E6%88%90%E5%BA%93"><span class="nav-number">3.2.4.</span> <span class="nav-text">4. 编译 C&#x2F;C++
代码并生成库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C-java-%E4%BB%A3%E7%A0%81"><span class="nav-number">3.2.5.</span> <span class="nav-text">5. 运行 Java 代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jni-%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="nav-number">3.2.6.</span> <span class="nav-text">6. JNI
调用机制的关键概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AD%97%E6%AE%B5"><span class="nav-number">3.2.7.</span> <span class="nav-text">7.
调用Java方法和访问字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-23"><span class="nav-number">3.2.8.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jni%E4%B8%ADc%E5%A6%82%E4%BD%95%E8%B0%83java"><span class="nav-number">3.3.</span> <span class="nav-text">JNI中C++如何调Java</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96jni%E7%8E%AF%E5%A2%83%E6%8C%87%E9%92%88-jnienv"><span class="nav-number">3.3.1.</span> <span class="nav-text">1. 获取JNI环境指针
(JNIEnv)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96java%E7%B1%BB"><span class="nav-number">3.3.2.</span> <span class="nav-text">2. 获取Java类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96java%E6%96%B9%E6%B3%95id"><span class="nav-number">3.3.3.</span> <span class="nav-text">3. 获取Java方法ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.4.</span> <span class="nav-text">4. 调用Java方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAjava%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.3.5.</span> <span class="nav-text">5. 创建Java对象实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AEjava%E5%AD%97%E6%AE%B5"><span class="nav-number">3.3.6.</span> <span class="nav-text">6. 访问Java字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8Bc-%E8%B0%83%E7%94%A8-java-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.7.</span> <span class="nav-text">7. 完整示例：C++ 调用 Java
方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">3.3.8.</span> <span class="nav-text">8. 异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-24"><span class="nav-number">3.3.9.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.4.</span> <span class="nav-text">内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86"><span class="nav-number">3.4.1.</span> <span class="nav-text">JVM
内存模型主要分为以下几个部分：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%9B%BE%E7%A4%BA"><span class="nav-number">3.4.2.</span> <span class="nav-text">JVM 内存模型的内存区域图示：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-garbage-collection"><span class="nav-number">3.4.3.</span> <span class="nav-text">垃圾回收 (Garbage Collection)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-25"><span class="nav-number">3.4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.5.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.1.</span> <span class="nav-text">垃圾回收的基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gc-roots-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%89"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">GC Roots 常见的有：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.2.</span> <span class="nav-text">垃圾回收的主要算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.5.3.</span> <span class="nav-text">Java 垃圾回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">3.5.4.</span> <span class="nav-text">垃圾回收的触发机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E8%B0%83%E4%BC%98"><span class="nav-number">3.5.5.</span> <span class="nav-text">垃圾回收的调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-26"><span class="nav-number">3.5.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.6.</span> <span class="nav-text">常用设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.6.1.</span> <span class="nav-text">1. 创建型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-singleton-pattern"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">1.1 单例模式 (Singleton
Pattern)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-factory-method-pattern"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">1.2 工厂方法模式
(Factory Method Pattern)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-abstract-factory-pattern"><span class="nav-number">3.6.1.3.</span> <span class="nav-text">1.3 抽象工厂模式
(Abstract Factory Pattern)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-builder-pattern"><span class="nav-number">3.6.1.4.</span> <span class="nav-text">1.4 建造者模式 (Builder
Pattern)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.6.2.</span> <span class="nav-text">2. 结构型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-adapter-pattern"><span class="nav-number">3.6.2.1.</span> <span class="nav-text">2.1 适配器模式 (Adapter
Pattern)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-decorator-pattern"><span class="nav-number">3.6.2.2.</span> <span class="nav-text">2.2 装饰器模式 (Decorator
Pattern)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-proxy-pattern"><span class="nav-number">3.6.2.3.</span> <span class="nav-text">2.3 代理模式 (Proxy
Pattern)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.6.3.</span> <span class="nav-text">3. 行为型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-observer-pattern"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">3.1 观察者模式 (Observer
Pattern)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-strategy-pattern"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">3.2 策略模式 (Strategy
Pattern)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-command-pattern"><span class="nav-number">3.6.3.3.</span> <span class="nav-text">3.3 命令模式 (Command
Pattern)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-27"><span class="nav-number">3.6.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">3.7.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">3.7.1.</span> <span class="nav-text">为什么需要并发编程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.7.2.</span> <span class="nav-text">Java 并发编程的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.7.2.1.</span> <span class="nav-text">1. 线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.7.2.2.</span> <span class="nav-text">2. 线程的生命周期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-number">3.7.3.</span> <span class="nav-text">线程同步与共享资源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.7.3.1.</span> <span class="nav-text">1. synchronized
关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.7.3.2.</span> <span class="nav-text">2. volatile 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lock-%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.7.3.3.</span> <span class="nav-text">3. Lock 接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-1"><span class="nav-number">3.7.4.</span> <span class="nav-text">线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-notify-notifyall"><span class="nav-number">3.7.4.1.</span> <span class="nav-text">1. wait() &#x2F; notify() &#x2F;
notifyAll()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#condition-%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.7.4.2.</span> <span class="nav-text">2. Condition 接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">3.7.5.</span> <span class="nav-text">Java 并发工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#executor-%E6%A1%86%E6%9E%B6"><span class="nav-number">3.7.5.1.</span> <span class="nav-text">1. Executor 框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#future-%E5%92%8C-callable"><span class="nav-number">3.7.5.2.</span> <span class="nav-text">2. Future 和 Callable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#countdownlatch"><span class="nav-number">3.7.5.3.</span> <span class="nav-text">3. CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cyclicbarrier"><span class="nav-number">3.7.5.4.</span> <span class="nav-text">4. CyclicBarrier</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reentrantlock"><span class="nav-number">3.7.6.</span> <span class="nav-text">2. ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-3"><span class="nav-number">3.7.6.1.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">3.7.6.2.</span> <span class="nav-text">用法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reentrantreadwritelock"><span class="nav-number">3.7.7.</span> <span class="nav-text">3.
ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-4"><span class="nav-number">3.7.7.1.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-1"><span class="nav-number">3.7.7.2.</span> <span class="nav-text">用法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stampedlock"><span class="nav-number">3.7.8.</span> <span class="nav-text">4. StampedLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-5"><span class="nav-number">3.7.8.1.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-2"><span class="nav-number">3.7.8.2.</span> <span class="nav-text">用法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#countdownlatch-1"><span class="nav-number">3.7.9.</span> <span class="nav-text">5. CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-6"><span class="nav-number">3.7.9.1.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-3"><span class="nav-number">3.7.9.2.</span> <span class="nav-text">用法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cyclicbarrier-1"><span class="nav-number">3.7.10.</span> <span class="nav-text">6. CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-7"><span class="nav-number">3.7.10.1.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-4"><span class="nav-number">3.7.10.2.</span> <span class="nav-text">用法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#semaphore"><span class="nav-number">3.7.11.</span> <span class="nav-text">7. Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-8"><span class="nav-number">3.7.11.1.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-5"><span class="nav-number">3.7.11.2.</span> <span class="nav-text">用法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readwritelock"><span class="nav-number">3.7.12.</span> <span class="nav-text">8. ReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-9"><span class="nav-number">3.7.12.1.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-6"><span class="nav-number">3.7.12.2.</span> <span class="nav-text">用法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-28"><span class="nav-number">3.7.13.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="nav-number">3.8.</span> <span class="nav-text">四种引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-waitnotify-%E5%92%8C-notifyall"><span class="nav-number">3.8.1.</span> <span class="nav-text">1. 使用
wait()、notify() 和
notifyAll()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.8.2.</span> <span class="nav-text">2. 使用
synchronized 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-lock-%E5%92%8C-condition%E4%BB%8E-java.util.concurrent-%E5%8C%85"><span class="nav-number">3.8.3.</span> <span class="nav-text">3.
使用 Lock 和 Condition（从
java.util.concurrent 包）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-blockingqueue"><span class="nav-number">3.8.4.</span> <span class="nav-text">4. 使用
BlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-semaphore"><span class="nav-number">3.8.5.</span> <span class="nav-text">5. 使用
Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-exchanger"><span class="nav-number">3.8.6.</span> <span class="nav-text">6. 使用
Exchanger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-29"><span class="nav-number">3.8.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm-%E4%B8%AD-java-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">3.9.</span> <span class="nav-text">JVM 中 Java 对象的创建过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="nav-number">3.9.1.</span> <span class="nav-text">1. 类加载检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">3.9.2.</span> <span class="nav-text">2. 内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA%E9%9B%B6%E5%80%BC"><span class="nav-number">3.9.3.</span> <span class="nav-text">3.
内存区域初始化为零值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">3.9.4.</span> <span class="nav-text">4. 设置对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E6%96%B9%E6%B3%95"><span class="nav-number">3.9.5.</span> <span class="nav-text">5. 执行构造方法（
方法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">3.9.6.</span> <span class="nav-text">6. 返回对象的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E9%94%81%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="nav-number">3.9.7.</span> <span class="nav-text">补充：锁与同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-30"><span class="nav-number">3.9.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">3.10.</span> <span class="nav-text">动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">3.10.1.</span> <span class="nav-text">1. JDK 动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.10.1.1.</span> <span class="nav-text">实现步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="nav-number">3.10.1.2.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-10"><span class="nav-number">3.10.1.3.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">3.10.2.</span> <span class="nav-text">2. CGLIB 动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">3.10.2.1.</span> <span class="nav-text">实现步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-3"><span class="nav-number">3.10.2.2.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-11"><span class="nav-number">3.10.2.3.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.10.3.</span> <span class="nav-text">3. 动态代理的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-cglib-%E4%BB%A3%E7%90%86%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">3.10.4.</span> <span class="nav-text">4. JDK 动态代理和 CGLIB
代理的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-31"><span class="nav-number">3.10.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c"><span class="nav-number">4.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">智能指针的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stdunique_ptr"><span class="nav-number">4.1.1.</span> <span class="nav-text">1.
std::unique_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-13"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9-4"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">主要特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-10"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">示例：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-9"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">使用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdshared_ptr"><span class="nav-number">4.1.2.</span> <span class="nav-text">2.
std::shared_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-14"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9-5"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">主要特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-11"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">示例：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-10"><span class="nav-number">4.1.2.4.</span> <span class="nav-text">使用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdweak_ptr"><span class="nav-number">4.1.3.</span> <span class="nav-text">3. std::weak_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-15"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9-6"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">主要特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-12"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">示例：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-11"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">使用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdauto_ptr%E5%B7%B2%E5%BA%9F%E5%BC%83"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.
std::auto_ptr（已废弃）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E7%B1%BB%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AF%B9%E6%AF%94"><span class="nav-number">4.1.5.</span> <span class="nav-text">各类智能指针对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-32"><span class="nav-number">4.1.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kotlin"><span class="nav-number">5.</span> <span class="nav-text">Kotlin</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8io%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%98%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.1.</span> <span class="nav-text">协程为什么在IO操作上优于线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">5.1.1.</span> <span class="nav-text">1. 调度算法的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">协程的调度机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">对比线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E9%A5%B1%E5%92%8C"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">为什么更饱和？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8"><span class="nav-number">5.1.2.</span> <span class="nav-text">2. 线程资源的充分利用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E9%AB%98%E6%95%88%E5%88%A9%E7%94%A8"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">协程的高效利用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#io-%E6%93%8D%E4%BD%9C%E4%B8%8B%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">I&#x2F;O 操作下的体现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%AF%B9%E6%AF%94"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">示例对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E6%88%90%E6%9C%AC%E6%9B%B4%E4%BD%8E"><span class="nav-number">5.1.3.</span> <span class="nav-text">3. 切换成本更低</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">协程的切换机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-number">5.1.3.2.</span> <span class="nav-text">对比线程切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#io-%E6%93%8D%E4%BD%9C%E4%B8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">5.1.3.3.</span> <span class="nav-text">I&#x2F;O 操作下的优势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8E-io-%E6%93%8D%E4%BD%9C%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">5.1.4.</span> <span class="nav-text">4. 关键在于 I&#x2F;O 操作的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#io-%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AD%89%E5%BE%85%E7%89%B9%E6%80%A7"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">I&#x2F;O 操作的等待特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E9%80%82%E9%85%8D%E6%80%A7"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">协程的适配性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E7%9A%84%E6%80%BB%E7%BB%93%E7%9A%84%E5%87%86%E7%A1%AE%E6%80%A7"><span class="nav-number">5.1.5.</span> <span class="nav-text">5. 你的总结的准确性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E7%BB%86%E8%8A%82"><span class="nav-number">5.1.5.1.</span> <span class="nav-text">补充细节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E8%A7%82%E7%A4%BA%E4%BE%8Bandroid-%E4%B8%AD%E7%9A%84-io"><span class="nav-number">5.1.6.</span> <span class="nav-text">6. 直观示例：Android 中的 I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="nav-number">5.1.7.</span> <span class="nav-text">7. 结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9F%B3%E8%A7%86%E9%A2%91"><span class="nav-number">6.</span> <span class="nav-text">音视频</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.</span> <span class="nav-text">视频播放器的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%E5%92%8C%E8%A7%A3%E5%B0%81%E8%A3%85"><span class="nav-number">6.1.1.</span> <span class="nav-text">1. 媒体文件的读取和解封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">容器格式和封装格式：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9A%84%E8%A7%A3%E7%A0%81"><span class="nav-number">6.1.2.</span> <span class="nav-text">2. 音视频的解码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">编码格式：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5"><span class="nav-number">6.1.3.</span> <span class="nav-text">3. 音视频同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3-ptsdts"><span class="nav-number">6.1.3.1.</span> <span class="nav-text">时间戳 (PTS&#x2F;DTS)：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E7%AE%97%E6%B3%95"><span class="nav-number">6.1.3.2.</span> <span class="nav-text">音视频同步算法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E5%92%8C%E6%92%AD%E6%94%BE"><span class="nav-number">6.1.4.</span> <span class="nav-text">4. 渲染和播放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93"><span class="nav-number">6.1.4.1.</span> <span class="nav-text">视频渲染：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE"><span class="nav-number">6.1.4.2.</span> <span class="nav-text">音频播放：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91%E5%92%8C%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92"><span class="nav-number">6.1.5.</span> <span class="nav-text">5. 控制逻辑和用户交互</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%92%8C%E7%BD%91%E7%BB%9C%E6%92%AD%E6%94%BE"><span class="nav-number">6.1.6.</span> <span class="nav-text">6. 缓冲和网络播放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F"><span class="nav-number">6.1.7.</span> <span class="nav-text">7. 硬件加速</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="nav-number">6.1.8.</span> <span class="nav-text">视频播放器实现流程总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-33"><span class="nav-number">6.1.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">6.2.</span> <span class="nav-text">视频直播的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">6.2.1.</span> <span class="nav-text">视频直播的基本流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%92%8C%E4%BC%98%E5%8C%96"><span class="nav-number">6.2.2.</span> <span class="nav-text">关键技术和优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">1. 编码优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">6.2.2.2.</span> <span class="nav-text">2. 传输协议的选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cdn-%E5%92%8C%E8%BE%B9%E7%BC%98%E8%8A%82%E7%82%B9%E4%BC%98%E5%8C%96"><span class="nav-number">6.2.2.3.</span> <span class="nav-text">3. CDN 和边缘节点优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E6%8E%A7%E5%88%B6"><span class="nav-number">6.2.2.4.</span> <span class="nav-text">4. 延迟控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%8A%96%E5%8A%A8%E4%B8%8E%E4%B8%A2%E5%8C%85%E5%A4%84%E7%90%86"><span class="nav-number">6.2.2.5.</span> <span class="nav-text">5. 网络抖动与丢包处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9A%84%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B"><span class="nav-number">6.2.3.</span> <span class="nav-text">实现原理的示例流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-34"><span class="nav-number">6.2.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E9%80%9F%E5%B7%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B5%81%E7%95%85"><span class="nav-number">6.3.</span> <span class="nav-text">网速差如何保证流畅</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E7%A0%81%E7%8E%87%E6%B5%81-adaptive-bitrate-streaming-abr"><span class="nav-number">6.3.1.</span> <span class="nav-text">1. 自适应码率流
(Adaptive Bitrate Streaming, ABR)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%8D%E4%BD%8E%E8%A7%86%E9%A2%91%E5%88%86%E8%BE%A8%E7%8E%87%E5%92%8C%E5%B8%A7%E7%8E%87"><span class="nav-number">6.3.2.</span> <span class="nav-text">2. 降低视频分辨率和帧率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%99%A8%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.3.</span> <span class="nav-text">3. 视频编码器优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E7%BC%93%E5%86%B2%E7%AD%96%E7%95%A5"><span class="nav-number">6.3.4.</span> <span class="nav-text">4. 提高缓冲策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%8E%E5%BB%B6%E8%BF%9F%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.3.5.</span> <span class="nav-text">5. 使用低延迟传输协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BF%AE%E6%AD%A3"><span class="nav-number">6.3.6.</span> <span class="nav-text">6. 网络丢包与错误修正</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%9B%B4%E6%92%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83"><span class="nav-number">6.3.7.</span> <span class="nav-text">7. 优化直播的网络环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%99%BA%E8%83%BD%E7%BC%93%E5%AD%98"><span class="nav-number">6.3.8.</span> <span class="nav-text">8. 使用预加载和智能缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%8D%E4%BD%8E%E9%9D%9E%E5%BF%85%E8%A6%81%E5%BC%80%E9%94%80"><span class="nav-number">6.3.9.</span> <span class="nav-text">9. 降低非必要开销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-35"><span class="nav-number">6.3.10.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.4.</span> <span class="nav-text">常用流媒体协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rtmpreal-time-messaging-protocol"><span class="nav-number">6.4.1.</span> <span class="nav-text">1. RTMP（Real-Time
Messaging Protocol）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-16"><span class="nav-number">6.4.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-12"><span class="nav-number">6.4.1.2.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-12"><span class="nav-number">6.4.1.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.4.1.4.</span> <span class="nav-text">架构示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hlshttp-live-streaming"><span class="nav-number">6.4.2.</span> <span class="nav-text">2. HLS（HTTP Live
Streaming）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-17"><span class="nav-number">6.4.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-13"><span class="nav-number">6.4.2.2.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-13"><span class="nav-number">6.4.2.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-5"><span class="nav-number">6.4.2.4.</span> <span class="nav-text">工作原理：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dashdynamic-adaptive-streaming-over-http"><span class="nav-number">6.4.3.</span> <span class="nav-text">3.
DASH（Dynamic Adaptive Streaming over HTTP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-18"><span class="nav-number">6.4.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-14"><span class="nav-number">6.4.3.2.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-14"><span class="nav-number">6.4.3.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-6"><span class="nav-number">6.4.3.4.</span> <span class="nav-text">工作原理：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rtspreal-time-streaming-protocol"><span class="nav-number">6.4.4.</span> <span class="nav-text">4. RTSP（Real-Time
Streaming Protocol）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-19"><span class="nav-number">6.4.4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-15"><span class="nav-number">6.4.4.2.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-15"><span class="nav-number">6.4.4.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-7"><span class="nav-number">6.4.4.4.</span> <span class="nav-text">工作原理：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webrtcweb-real-time-communication"><span class="nav-number">6.4.5.</span> <span class="nav-text">5. WebRTC（Web
Real-Time Communication）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-20"><span class="nav-number">6.4.5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-16"><span class="nav-number">6.4.5.2.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-16"><span class="nav-number">6.4.5.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-8"><span class="nav-number">6.4.5.4.</span> <span class="nav-text">工作原理：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#srtsecure-reliable-transport"><span class="nav-number">6.4.6.</span> <span class="nav-text">6. SRT（Secure Reliable
Transport）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-21"><span class="nav-number">6.4.6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-17"><span class="nav-number">6.4.6.2.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-17"><span class="nav-number">6.4.6.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-9"><span class="nav-number">6.4.6.4.</span> <span class="nav-text">工作原理：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-36"><span class="nav-number">6.4.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dts-%E5%92%8C-pts-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">6.5.</span> <span class="nav-text">DTS 和 PTS 有什么区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-37"><span class="nav-number">6.5.1.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">数据结构和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">7.1.</span> <span class="nav-text">1. 常用数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-array"><span class="nav-number">7.1.1.</span> <span class="nav-text">1.1 数组 (Array)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8Bjava"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">示例（Java）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8-linked-list"><span class="nav-number">7.1.2.</span> <span class="nav-text">1.2 链表 (Linked List)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8Bjava-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">7.1.2.1.</span> <span class="nav-text">示例（Java 单链表）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88-stack"><span class="nav-number">7.1.3.</span> <span class="nav-text">1.3 栈 (Stack)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8Bjava-%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="nav-number">7.1.3.1.</span> <span class="nav-text">示例（Java 使用栈）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97-queue"><span class="nav-number">7.1.4.</span> <span class="nav-text">1.4 队列 (Queue)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8Bjava-%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97"><span class="nav-number">7.1.4.1.</span> <span class="nav-text">示例（Java 使用队列）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-hash-table"><span class="nav-number">7.1.5.</span> <span class="nav-text">1.5 哈希表 (Hash Table)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8Bjava-%E4%BD%BF%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">7.1.5.1.</span> <span class="nav-text">示例（Java 使用哈希表）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91-tree"><span class="nav-number">7.1.6.</span> <span class="nav-text">1.6 树 (Tree)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">7.1.6.1.</span> <span class="nav-text">示例（二叉树的遍历）：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">2. 常用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.1.</span> <span class="nav-text">2.1 排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort"><span class="nav-number">7.2.1.1.</span> <span class="nav-text">2.1.1 快速排序 (Quick
Sort)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8Bjava-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">7.2.1.2.</span> <span class="nav-text">示例（Java 快速排序）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.2.</span> <span class="nav-text">2.2 查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-binary-search"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">2.2.1 二分查找 (Binary
Search)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8Bjava-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">示例（Java 二分查找）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-greedy-algorithm"><span class="nav-number">7.2.3.</span> <span class="nav-text">2.3 贪心算法 (Greedy
Algorithm)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8Bjava-%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98"><span class="nav-number">7.2.3.1.</span> <span class="nav-text">示例（Java 找零问题）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming"><span class="nav-number">7.2.4.</span> <span class="nav-text">2.4 动态规划 (Dynamic
Programming)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8Bjava-%E6%B1%82%E8%A7%A3%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">7.2.4.1.</span> <span class="nav-text">示例（Java 求解斐波那契数列）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-38"><span class="nav-number">7.2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">链表常用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="nav-number">7.3.1.</span> <span class="nav-text">1. 定义链表节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.3.2.</span> <span class="nav-text">2. 主要算法及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8"><span class="nav-number">7.3.2.1.</span> <span class="nav-text">2.1 遍历链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.2.1.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">7.3.2.1.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">7.3.2.1.3.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">7.3.2.2.</span> <span class="nav-text">2.2 反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">7.3.2.2.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">7.3.2.2.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="nav-number">7.3.2.2.3.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">7.3.2.3.</span> <span class="nav-text">2.3 合并两个有序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-number">7.3.2.3.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">7.3.2.3.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="nav-number">7.3.2.3.3.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%8E%AF"><span class="nav-number">7.3.2.4.</span> <span class="nav-text">2.4 检测链表中的环</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-3"><span class="nav-number">7.3.2.4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">7.3.2.4.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="nav-number">7.3.2.4.3.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">7.3.2.5.</span> <span class="nav-text">2.5 删除链表中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-4"><span class="nav-number">7.3.2.5.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="nav-number">7.3.2.5.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">7.3.2.5.2.1.</span> <span class="nav-text">删除指定值的节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%AA%E7%BB%99%E5%AE%9A%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4%E6%97%A0%E5%89%8D%E9%A9%B1"><span class="nav-number">7.3.2.5.2.2.</span> <span class="nav-text">只给定节点删除（无前驱）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="nav-number">7.3.2.5.3.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="nav-number">7.3.2.6.</span> <span class="nav-text">2.6 查找中间节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-5"><span class="nav-number">7.3.2.6.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="nav-number">7.3.2.6.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-5"><span class="nav-number">7.3.2.6.3.</span> <span class="nav-text">复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93"><span class="nav-number">7.3.3.</span> <span class="nav-text">3. 复杂度总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.3.4.</span> <span class="nav-text">4. 算法应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-39"><span class="nav-number">7.3.5.</span> <span class="nav-text">5. 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">8.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#https-%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">8.1.</span> <span class="nav-text">Https 进行连接的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">8.1.1.</span> <span class="nav-text">1. TCP 三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tls-%E6%8F%A1%E6%89%8B"><span class="nav-number">8.1.2.</span> <span class="nav-text">2. TLS 握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1"><span class="nav-number">8.1.3.</span> <span class="nav-text">3. 加密通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE-2"><span class="nav-number">8.1.4.</span> <span class="nav-text">流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="nav-number">8.1.5.</span> <span class="nav-text">完整流程总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.1.6.</span> <span class="nav-text">为什么这么设计？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#https-%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">8.2.</span> <span class="nav-text">Https
连接过程中使用对称和非对称加密的场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">8.2.1.</span> <span class="nav-text">对称加密和非对称加密的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#https-%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8A%A0%E5%AF%86%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.2.2.</span> <span class="nav-text">HTTPS 连接过程中加密的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-1"><span class="nav-number">8.2.2.1.</span> <span class="nav-text">1. TCP 三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tls-%E6%8F%A1%E6%89%8B-1"><span class="nav-number">8.2.2.2.</span> <span class="nav-text">2. TLS 握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1-1"><span class="nav-number">8.2.2.3.</span> <span class="nav-text">3. 加密通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%88%86%E5%B7%A5"><span class="nav-number">8.2.3.</span> <span class="nav-text">对称加密和非对称加密的分工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E5%88%86%E5%B7%A5"><span class="nav-number">8.2.4.</span> <span class="nav-text">为什么这样分工？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5-url-%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">8.3.</span> <span class="nav-text">浏览器输入 Url 后发生了什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#url-%E8%A7%A3%E6%9E%90"><span class="nav-number">8.3.1.</span> <span class="nav-text">1. URL 解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dns-%E8%A7%A3%E6%9E%90"><span class="nav-number">8.3.2.</span> <span class="nav-text">2. DNS 解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5"><span class="nav-number">8.3.3.</span> <span class="nav-text">3. 建立 TCP 连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tls-%E6%8F%A1%E6%89%8Bhttps-%E7%89%B9%E6%9C%89"><span class="nav-number">8.3.4.</span> <span class="nav-text">4. TLS 握手（HTTPS 特有）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81-http-%E8%AF%B7%E6%B1%82"><span class="nav-number">8.3.5.</span> <span class="nav-text">5. 发送 HTTP 请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="nav-number">8.3.6.</span> <span class="nav-text">6. 服务器处理请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E5%92%8C%E8%A7%A3%E6%9E%90-http-%E5%93%8D%E5%BA%94"><span class="nav-number">8.3.7.</span> <span class="nav-text">7. 接收和解析 HTTP 响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="nav-number">8.3.8.</span> <span class="nav-text">8. 资源加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="nav-number">8.3.9.</span> <span class="nav-text">9. 页面渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C-javascript"><span class="nav-number">8.3.10.</span> <span class="nav-text">10. 执行 JavaScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93-1"><span class="nav-number">8.3.11.</span> <span class="nav-text">完整流程总结</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Yao"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Yao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cmder" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cmder" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cmd100000@gmail.com" title="E-Mail → mailto:cmd100000@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cmder.github.io/Android/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Bruce Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="说码解字">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android 应用开发 | 说码解字">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android 应用开发
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-18 09:22:47" itemprop="dateCreated datePublished" datetime="2024-09-18T09:22:47+08:00">2024-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-02 19:29:49" itemprop="dateModified" datetime="2026-01-02T19:29:49+08:00">2026-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">应用开发</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="知识结构">知识结构</h1>
<pre><code class="highlight mermaid">graph LR
    A[Android 开发技术栈]
    
    A --&gt; B[基础组件]
    B --&gt; B1[Activity]
    B --&gt; B2[Service]
    B --&gt; B3[BroadcastReceiver]
    B --&gt; B4[ContentProvider]
    B --&gt; B5[Fragment]
    B --&gt; B6[Intent]
    B --&gt; B7[WebView]
    B --&gt; B8[WorkManager]
    B --&gt; B9[Android 启动模式]
    B --&gt; B10[Android 6.0 权限系统]

    A --&gt; C[架构与设计模式]
    C --&gt; C1[MVC]
    C --&gt; C2[MVP]
    C --&gt; C3[MVVM]
    C --&gt; C4[AOP]

    A --&gt; D[UI 与布局]
    D --&gt; D1[XML 布局]
    D --&gt; D2[ConstraintLayout]
    D --&gt; D3[RecyclerView]
    D --&gt; D4[屏幕适配]
    D --&gt; D5[自定义 View]
    D --&gt; D6[动画]

    A --&gt; E[运行时与系统]
    E --&gt; E1[ART vs Dalvik]
    E --&gt; E2[Android 系统架构]
    E --&gt; E3[进程与线程]
    E --&gt; E4[Handler 机制]

    A --&gt; F[性能优化]
    F --&gt; F1[代码混淆]
    F --&gt; F2[内存泄漏]
    F --&gt; F3[热修复]
    F --&gt; F4[启动优化]
    F --&gt; F5[网络优化]
    F --&gt; F6[电量优化]

    A --&gt; G[网络与数据]
    G --&gt; G1[HTTP/HTTPS]
    G --&gt; G2[JSON/XML 解析]
    G --&gt; G3[Room 数据库]
    G --&gt; G4[SharedPreferences]
    G --&gt; G5[文件存储]

    A --&gt; H[Jetpack]
    H --&gt; H1[Compose]
    H --&gt; H2[ViewModel]
    H --&gt; H3[LiveData]
    H --&gt; H4[Navigation]
    H --&gt; H5[Room]
    H --&gt; H6[WorkManager]

    A --&gt; I[第三方库]
    I --&gt; I1[Dagger2]
    I --&gt; I2[RxJava]
    I --&gt; I3[Retrofit]
    I --&gt; I4[OkHttp]
    I --&gt; I5[Glide/Picasso]
    I --&gt; I6[LeakCanary]
    I --&gt; I7[Butterknife]
    I --&gt; I8[ARouter]
    I --&gt; I9[EventBus]

    A --&gt; J[开发与发布]
    J --&gt; J1[Gradle 构建]
    J --&gt; J2[Google Play 发布流程]
    J --&gt; J3[持续集成]
    J --&gt; J4[版本控制 Git]

    A --&gt; K[调试与分析]
    K --&gt; K1[Logcat]
    K --&gt; K2[反编译]
    K --&gt; K3[Profilers]
    K --&gt; K4[ADB]</code></pre>
<h1 id="android">Android</h1>
<h2 id="view-事件分发流程">View 事件分发流程</h2>
<p>在 Android 中，View
的事件分发流程是处理用户触摸（Touch）事件的核心机制，主要涉及
<code>MotionEvent</code>
对象的传递和处理。事件分发决定了触摸事件（如点击、滑动等）如何从顶层的
<code>Activity</code> 传递到 <code>ViewGroup</code> 和最终的
<code>View</code>，以及在这些组件之间如何被拦截、消费或传递。以下是
Android 中 View 事件分发的详细流程和关键方法：</p>
<hr />
<h3 id="事件分发的起点">1. 事件分发的起点</h3>
<p>触摸事件通常以 <code>MotionEvent</code> 对象的形式从操作系统传递给
Android 应用程序。事件分发的起点一般是从 <code>Activity</code>
开始，具体流程如下：</p>
<ul>
<li><strong>事件来源</strong>：用户通过屏幕触摸生成
<code>MotionEvent</code>，操作系统将事件传递给当前活动（Activity）的窗口管理器（WindowManager）。</li>
<li><strong>进入 Activity</strong>：<code>Activity</code> 的
<code>dispatchTouchEvent(MotionEvent event)</code>
方法首先接收事件。</li>
</ul>
<hr />
<h3 id="关键方法和分发流程">2. 关键方法和分发流程</h3>
<p>事件分发涉及三个主要方法：<code>dispatchTouchEvent()</code>、<code>onInterceptTouchEvent()</code>（仅适用于
<code>ViewGroup</code>）和
<code>onTouchEvent()</code>。以下是它们的职责和在分发流程中的作用：</p>
<h4 id="dispatchtoucheventmotionevent-event">2.1
<code>dispatchTouchEvent(MotionEvent event)</code></h4>
<ul>
<li><strong>作用</strong>：分发触摸事件，决定事件是继续向下传递还是被当前组件消费。</li>
<li><strong>返回值</strong>：
<ul>
<li>返回
<code>true</code>：表示当前组件消费了事件，事件停止传播（不会继续传递给子视图或父视图）。</li>
<li>返回
<code>false</code>：表示当前组件不处理事件，事件继续传递（如果有父视图，则向上回传；如果没有父视图，则事件终止）。</li>
<li>调用
<code>super.dispatchTouchEvent(event)</code>：将事件交给默认逻辑处理，通常会继续向下传递（对于
<code>ViewGroup</code> 可能进入 <code>onInterceptTouchEvent</code>，对于
<code>View</code> 可能进入 <code>onTouchEvent</code>）。</li>
</ul></li>
<li><strong>流程</strong>：
<ul>
<li>在 <code>Activity</code> 中，<code>dispatchTouchEvent</code>
通常会将事件传递给其根视图（通常是 <code>DecorView</code> 或
<code>ContentView</code>）。</li>
<li>在 <code>ViewGroup</code> 中，<code>dispatchTouchEvent</code>
会先调用 <code>onInterceptTouchEvent</code>
判断是否拦截事件，如果不拦截，则继续传递给子视图。</li>
<li>在 <code>View</code> 中，<code>dispatchTouchEvent</code> 通常会调用
<code>onTouchEvent</code>。</li>
</ul></li>
</ul>
<h4 id="onintercepttoucheventmotionevent-event仅-viewgroup-拥有">2.2
<code>onInterceptTouchEvent(MotionEvent event)</code>（仅
<code>ViewGroup</code> 拥有）</h4>
<ul>
<li><strong>作用</strong>：<code>ViewGroup</code>
专有的方法，用于决定是否拦截触摸事件。</li>
<li><strong>返回值</strong>：
<ul>
<li>返回 <code>true</code>：表示 <code>ViewGroup</code>
拦截事件，事件不会传递给子视图，而是由当前 <code>ViewGroup</code> 的
<code>onTouchEvent</code> 处理。</li>
<li>返回 <code>false</code>：表示不拦截事件，事件继续向下传递给子视图的
<code>dispatchTouchEvent</code>。</li>
</ul></li>
<li><strong>注意</strong>：默认实现返回
<code>false</code>（不拦截），开发者可以重写此方法来自定义拦截逻辑。</li>
</ul>
<h4 id="ontoucheventmotionevent-event">2.3
<code>onTouchEvent(MotionEvent event)</code></h4>
<ul>
<li><strong>作用</strong>：处理触摸事件的具体逻辑，通常由
<code>View</code> 或 <code>ViewGroup</code>
实现，用于响应用户的触摸操作（如点击、滑动等）。</li>
<li><strong>返回值</strong>：
<ul>
<li>返回 <code>true</code>：表示消费了事件，事件停止传播。</li>
<li>返回 <code>false</code>：表示不消费事件，事件继续向上回传给父视图的
<code>dispatchTouchEvent</code>（如果有父视图）。</li>
</ul></li>
<li><strong>默认行为</strong>：
<ul>
<li>如果 <code>View</code> 可点击（<code>isClickable()</code> 返回
<code>true</code>），<code>onTouchEvent</code> 默认返回
<code>true</code>，表示消费事件。</li>
<li>如果 <code>View</code> 不可点击，默认返回
<code>false</code>，事件继续向上回传。</li>
</ul></li>
</ul>
<hr />
<h3 id="事件分发的完整流程">3. 事件分发的完整流程</h3>
<p>以下是触摸事件从 <code>Activity</code> 到 <code>View</code>
的典型分发流程（以 <code>ACTION_DOWN</code>
事件为例，<code>ACTION_MOVE</code> 和 <code>ACTION_UP</code>
事件遵循类似逻辑，但需要注意事件序列的连续性）：</p>
<h4 id="从-activity-开始">3.1 从 <code>Activity</code> 开始</h4>
<ol type="1">
<li>用户触摸屏幕，操作系统生成 <code>MotionEvent</code> 并传递给
<code>Activity</code> 的 <code>dispatchTouchEvent</code>。</li>
<li><code>Activity</code> 的 <code>dispatchTouchEvent</code> 通常调用
<code>super.dispatchTouchEvent</code>，将事件传递给其根视图（<code>DecorView</code>
或 <code>ContentView</code>）。
<ul>
<li>如果 <code>Activity</code> 的 <code>onTouchEvent</code> 返回
<code>true</code>，事件被消费，流程结束。</li>
<li>否则，事件继续向下传递。</li>
</ul></li>
</ol>
<h4 id="进入-viewgroup">3.2 进入 <code>ViewGroup</code></h4>
<ol start="3" type="1">
<li>事件到达 <code>ViewGroup</code> 的
<code>dispatchTouchEvent</code>。</li>
<li><code>ViewGroup</code> 先调用 <code>onInterceptTouchEvent</code>：
<ul>
<li>如果返回 <code>true</code>，事件被拦截，<code>ViewGroup</code> 的
<code>onTouchEvent</code> 处理事件。</li>
<li>如果返回 <code>false</code>，事件继续传递给子视图。</li>
</ul></li>
<li>如果有子视图，<code>ViewGroup</code>
会遍历子视图，找到被触摸的子视图（通常通过 <code>hitTestResult</code>
判断触摸点是否在子视图范围内），然后调用子视图的
<code>dispatchTouchEvent</code>。</li>
</ol>
<h4 id="进入-view">3.3 进入 <code>View</code></h4>
<ol start="6" type="1">
<li>事件到达具体的 <code>View</code>（非 <code>ViewGroup</code>）的
<code>dispatchTouchEvent</code>。</li>
<li><code>View</code> 的 <code>dispatchTouchEvent</code> 通常调用
<code>onTouchEvent</code>：
<ul>
<li>如果 <code>onTouchEvent</code> 返回
<code>true</code>，事件被消费，流程结束。</li>
<li>如果返回 <code>false</code>，事件向上回传给父视图的
<code>dispatchTouchEvent</code>。</li>
</ul></li>
</ol>
<h4 id="事件回传向上传播">3.4 事件回传（向上传播）</h4>
<ul>
<li>如果某个 <code>View</code> 或 <code>ViewGroup</code> 的
<code>onTouchEvent</code> 返回
<code>false</code>，事件会向上回传到其父视图的
<code>dispatchTouchEvent</code>，直到 <code>Activity</code>
或被某个组件消费。</li>
<li>如果整个链条没有组件消费事件，事件最终被丢弃。</li>
</ul>
<hr />
<h3 id="关键注意事项">4. 关键注意事项</h3>
<ul>
<li><strong>事件序列</strong>：触摸事件通常以
<code>ACTION_DOWN</code>（按下）、<code>ACTION_MOVE</code>（移动）、<code>ACTION_UP</code>（抬起）序列出现。如果
<code>ACTION_DOWN</code> 没有被消费，后续的 <code>ACTION_MOVE</code> 和
<code>ACTION_UP</code> 也不会传递。</li>
<li><strong>优先级</strong>：<code>onTouchListener</code>（如果设置）优先于
<code>onTouchEvent</code> 处理事件。如果 <code>onTouchListener</code>
返回 <code>true</code>，<code>onTouchEvent</code> 不会被调用。</li>
<li><strong>可点击性</strong>：<code>View</code> 的
<code>isClickable()</code>、<code>isLongClickable()</code> 等属性影响
<code>onTouchEvent</code> 的默认行为。</li>
<li><strong>自定义事件分发</strong>：开发者可以重写
<code>dispatchTouchEvent</code>、<code>onInterceptTouchEvent</code> 和
<code>onTouchEvent</code> 来实现自定义逻辑。</li>
</ul>
<hr />
<h3 id="示例代码伪代码">5. 示例代码（伪代码）</h3>
<p>以下是一个简单的示例，展示如何重写事件分发方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomViewGroup</span> <span class="keyword">extends</span> <span class="title class_">ViewGroup</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义分发逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* 特定条件 */</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 消费事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event); <span class="comment">// 继续分发</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 决定是否拦截事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 拦截事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不拦截</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理触摸事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// 处理按下事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 消费事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不消费，事件向上回传</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结">6. 总结</h3>
<p>Android 中 View 的事件分发流程是一个从上到下（<code>Activity</code> →
<code>ViewGroup</code> →
<code>View</code>）再从下到上（回传）的过程，主要依赖
<code>dispatchTouchEvent</code>、<code>onInterceptTouchEvent</code> 和
<code>onTouchEvent</code>
三种方法。理解这些方法的返回值（<code>true</code> 或
<code>false</code>）和调用顺序是掌握事件分发的关键。</p>
<h3 id="流程图">7. 流程图</h3>
<pre><code class="highlight mermaid">graph TD
    A[&quot;触摸事件 MotionEvent&quot;] --&gt; B[&quot;Activity.dispatchTouchEvent&quot;]
    B --&gt; C&#123;&quot;Activity.onTouchEvent 返回 true/false&quot;&#125;
    C -- true --&gt; D[&quot;事件消费，流程结束&quot;]
    C -- false --&gt; E[&quot;ViewGroup.dispatchTouchEvent&quot;]
    E --&gt; F&#123;&quot;onInterceptTouchEvent 返回 true/false&quot;&#125;
    F -- true --&gt; G[&quot;ViewGroup.onTouchEvent&quot;]
    G --&gt; H&#123;&quot;返回 true/false&quot;&#125;
    H -- true --&gt; D
    H -- false --&gt; I[&quot;事件回传至父视图&quot;]
    F -- false --&gt; J[&quot;View.dispatchTouchEvent&quot;]
    J --&gt; K[&quot;View.onTouchEvent&quot;]
    K --&gt; L&#123;&quot;返回 true/false&quot;&#125;
    L -- true --&gt; D
    L -- false --&gt; I
    A:::start
    B:::activity
    E:::viewgroup
    F:::viewgroup
    G:::viewgroup
    J:::view
    K:::view
    classDef start fill:#000000,color:#ffffff
    classDef activity fill:#0000FF,color:#ffffff
    classDef viewgroup fill:#FFA500,color:#000000
    classDef view fill:#FFFF00,color:#000000</code></pre>
<h2 id="android-绘制渲染流程">Android 绘制渲染流程</h2>
<p>在 Android 中，从上层的 <code>View</code>（应用层）到 Framework
层（系统框架层），再到底层的 HAL（Hardware Abstraction
Layer，硬件抽象层）的绘制渲染流程，涉及多个层次的协作，包括应用逻辑、Android
框架、JNI、本地库（如
Skia、OpenGL/Vulkan）和硬件驱动。这是一个从高层次用户界面绘制到低层次硬件渲染的完整链条。以下是详细讲解：</p>
<hr />
<h3 id="总体概述">1. 总体概述</h3>
<p>Android 的绘制渲染流程从应用层的 <code>View</code> 开始，经过
Framework 层的协调（如
<code>ViewRootImpl</code>、<code>SurfaceFlinger</code>），最终通过 HAL
层与硬件（GPU 和显示屏）交互。整个流程可以分为以下几个层次： -
<strong>应用层（上层 View）</strong>：<code>View</code> 和
<code>ViewGroup</code> 的绘制逻辑。 - <strong>Framework
层</strong>：系统框架（如
<code>ViewRootImpl</code>、<code>Choreographer</code>、<code>SurfaceFlinger</code>）管理和调度渲染。
- <strong>Native 层</strong>：JNI 和本地库（如 Skia
图形库、OpenGL/Vulkan）处理图形绘制。 - <strong>HAL
层</strong>：硬件抽象层，连接操作系统和硬件（如 GPU
驱动、显示驱动）。</p>
<p>流程通常由 VSYNC 信号驱动，确保与屏幕刷新同步（约 16ms 一次，60
FPS）。</p>
<hr />
<h3 id="应用层上层-view从-view-到-viewrootimpl">2. 应用层（上层
View）：从 <code>View</code> 到 <code>ViewRootImpl</code></h3>
<h4 id="绘制触发">2.1 绘制触发</h4>
<ul>
<li><strong>起点</strong>：应用层通过 <code>View</code> 和
<code>ViewGroup</code> 实现 UI 逻辑。当需要绘制或更新 UI 时（例如
<code>setContentView</code>、<code>invalidate()</code>、<code>requestLayout()</code>），触发绘制。</li>
<li><strong>关键组件</strong>：
<ul>
<li><strong>View</strong>：通过
<code>onMeasure</code>（测量）、<code>onLayout</code>（布局）、<code>onDraw</code>（绘制）完成尺寸计算、位置确定和内容渲染。</li>
<li><strong>ViewGroup</strong>：管理子视图的测量、布局和绘制（通过
<code>measureChildren</code>、<code>onLayout</code>、<code>dispatchDraw</code>）。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li>用户或代码调用 <code>invalidate()</code> 或
<code>requestLayout()</code>，标记 <code>View</code> 或
<code>ViewGroup</code> 需要重新绘制。</li>
<li><code>View</code> 通过 <code>draw(Canvas)</code>
绘制内容，<code>ViewGroup</code> 通过 <code>dispatchDraw</code>
递归绘制子视图。</li>
<li>这些操作最终由 <code>ViewRootImpl</code> 协调。</li>
</ol></li>
</ul>
<h4 id="viewrootimpl-的角色">2.2 <code>ViewRootImpl</code> 的角色</h4>
<ul>
<li><code>ViewRootImpl</code> 是应用层和 Framework 层的桥梁，负责：
<ul>
<li>发起测量、布局和绘制（<code>performTraversals</code>）。</li>
<li>与 <code>WindowManager</code> 交互，管理
<code>Surface</code>（用于渲染的缓冲区）。</li>
<li>监听 VSYNC 信号，通过 <code>Choreographer</code>
确保绘制与屏幕刷新同步。</li>
</ul></li>
<li><strong>方法</strong>：
<ul>
<li><code>performTraversals</code>：调用
<code>measure</code>、<code>layout</code>、<code>draw</code>，完成整个绘制流程。</li>
<li><code>draw</code>：将 <code>View</code> 层次结构渲染到
<code>Canvas</code>，并提交到 <code>Surface</code>。</li>
</ul></li>
</ul>
<hr />
<h3 id="framework-层从-viewrootimpl-到-surfaceflinger">3. Framework
层：从 <code>ViewRootImpl</code> 到 <code>SurfaceFlinger</code></h3>
<h4 id="choreographer-和-vsync">3.1 <code>Choreographer</code> 和
VSYNC</h4>
<ul>
<li><strong>VSYNC 信号</strong>：每隔约 16ms（60 FPS），系统发出 VSYNC
信号，通知 UI 线程开始绘制。</li>
<li><strong>Choreographer</strong>：
<ul>
<li>监听 VSYNC 信号，调用 <code>doFrame</code>，触发
<code>ViewRootImpl</code> 的 <code>performTraversals</code>。</li>
<li>确保绘制和渲染与屏幕刷新同步，避免丢帧（jank）。</li>
</ul></li>
</ul>
<h4 id="surface-和-canvas">3.2 <code>Surface</code> 和
<code>Canvas</code></h4>
<ul>
<li><strong>Surface</strong>：
<ul>
<li><code>Surface</code> 是 Framebuffer
的抽象，存储最终的像素数据。</li>
<li><code>ViewRootImpl</code> 创建 <code>Surface</code>
并将其绑定到窗口。</li>
</ul></li>
<li><strong>Canvas</strong>：
<ul>
<li><code>View</code> 的 <code>draw</code> 方法使用 <code>Canvas</code>
进行绘制，<code>Canvas</code> 操作 <code>Surface</code> 的缓冲区。</li>
<li>绘制内容通过 <code>Skia</code> 图形库（Native 层）转换为像素。</li>
</ul></li>
</ul>
<h4 id="surfaceflinger">3.3 <code>SurfaceFlinger</code></h4>
<ul>
<li><strong>作用</strong>：Framework 层的渲染服务，负责将多个
<code>Surface</code>（来自不同应用或窗口）合成并输出到屏幕。</li>
<li><strong>流程</strong>：
<ol type="1">
<li><code>ViewRootImpl</code> 将绘制结果提交到
<code>Surface</code>。</li>
<li><code>SurfaceFlinger</code> 接收所有 <code>Surface</code>，根据 Z
序（层级）进行合成。</li>
<li>使用硬件加速（OpenGL/Vulkan）将合成结果渲染到显示缓冲区（Framebuffer）。</li>
</ol></li>
<li><strong>硬件加速</strong>：默认启用硬件加速，<code>SurfaceFlinger</code>
通过 GPU 加速合成和渲染。</li>
</ul>
<hr />
<h3 id="native-层jni-和图形库如-skiaopenglvulkan">4. Native 层：JNI
和图形库（如 Skia、OpenGL/Vulkan）</h3>
<h4 id="jnijava-native-interface">4.1 JNI（Java Native Interface）</h4>
<ul>
<li><strong>作用</strong>：连接 Java（应用层和 Framework 层）与
C/C++（Native 层）。</li>
<li><strong>流程</strong>：
<ul>
<li><code>View</code> 和 <code>ViewRootImpl</code> 通过 JNI 调用 Native
层的函数。</li>
<li>例如，<code>Canvas</code> 的绘制操作最终调用 Skia 的 Native
函数。</li>
</ul></li>
</ul>
<h4 id="skia-图形库">4.2 Skia 图形库</h4>
<ul>
<li><strong>作用</strong>：Android 的 2D 图形库，用于处理
<code>Canvas</code> 的绘制操作。</li>
<li><strong>功能</strong>：
<ul>
<li>渲染文字、形状、位图等 2D 图形。</li>
<li>将 <code>Canvas</code> 的绘制指令转换为像素数据，存储到
<code>Surface</code>。</li>
</ul></li>
<li><strong>与硬件交互</strong>：Skia 可以直接与 GPU 交互（通过 OpenGL
或 Vulkan），加速渲染。</li>
</ul>
<h4 id="openglvulkan">4.3 OpenGL/Vulkan</h4>
<ul>
<li><strong>作用</strong>：3D 图形 API，用于硬件加速渲染。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>Skia 或 <code>SurfaceFlinger</code> 使用 OpenGL/Vulkan 将 2D/3D
图形渲染到 GPU 的缓冲区。</li>
<li>GPU 执行渲染指令，生成像素数据。</li>
<li>像素数据存储到 <code>Surface</code> 或 Framebuffer。</li>
</ol></li>
<li><strong>硬件加速</strong>：OpenGL/Vulkan 通过 GPU
优化复杂的绘制操作（如动画、复杂 UI）。</li>
</ul>
<hr />
<h3 id="hal-层硬件抽象层">5. HAL 层：硬件抽象层</h3>
<h4 id="hal-的作用">5.1 HAL 的作用</h4>
<ul>
<li>HAL 是操作系统和硬件之间的接口层，屏蔽硬件差异，确保 Android
框架可以与不同设备（CPU、GPU、显示屏）交互。</li>
<li>在绘制渲染中，HAL 主要涉及：
<ul>
<li><strong>GPU 驱动</strong>：处理 OpenGL/Vulkan
的渲染指令，执行图形计算。</li>
<li><strong>显示驱动</strong>：将 Framebuffer
的像素数据输出到物理屏幕。</li>
</ul></li>
</ul>
<h4 id="硬件交互流程">5.2 硬件交互流程</h4>
<ol type="1">
<li><strong>GPU 渲染</strong>：
<ul>
<li><code>SurfaceFlinger</code> 通过 HAL 调用 GPU 驱动，使用
OpenGL/Vulkan 渲染 <code>Surface</code> 数据。</li>
<li>GPU 在帧缓冲区（Framebuffer）中生成最终像素。</li>
</ul></li>
<li><strong>显示输出</strong>：
<ul>
<li>HAL 的显示驱动将 Framebuffer 内容传输到显示控制器（Display
Controller）。</li>
<li>显示控制器将像素数据刷新到物理屏幕，通常通过 LCD 或 OLED
面板显示。</li>
</ul></li>
<li><strong>VSYNC 同步</strong>：
<ul>
<li>HAL 层确保渲染和显示与显示设备的刷新率同步（通过 VSYNC 信号）。</li>
</ul></li>
</ol>
<hr />
<h3 id="完整流程的总结">6. 完整流程的总结</h3>
<h4 id="时间线">6.1 时间线</h4>
<ul>
<li><strong>应用层</strong>：<code>View</code> 调用
<code>invalidate()</code> 或 <code>requestLayout()</code>，触发
<code>ViewRootImpl</code> 的 <code>performTraversals</code>。</li>
<li><strong>Framework 层</strong>：<code>ViewRootImpl</code>
测量、布局、绘制内容到 <code>Surface</code>，<code>SurfaceFlinger</code>
合成多个 <code>Surface</code>。</li>
<li><strong>Native 层</strong>：Skia 处理 2D 绘制，OpenGL/Vulkan 加速 3D
渲染。</li>
<li><strong>HAL 层</strong>：GPU 驱动渲染像素，显示驱动输出到屏幕。</li>
</ul>
<h4 id="关键路径">6.2 关键路径</h4>
<ol type="1">
<li><strong>应用层</strong> → <strong>Framework 层</strong>：
<ul>
<li><code>View</code> → <code>ViewRootImpl</code> → <code>Surface</code>
→ <code>SurfaceFlinger</code>。</li>
</ul></li>
<li><strong>Framework 层</strong> → <strong>Native 层</strong>：
<ul>
<li><code>Canvas</code> → Skia → OpenGL/Vulkan。</li>
</ul></li>
<li><strong>Native 层</strong> → <strong>HAL 层</strong>：
<ul>
<li>GPU 驱动 → 显示驱动 → 物理屏幕。</li>
</ul></li>
</ol>
<h4 id="vsync-的作用">6.3 VSYNC 的作用</h4>
<ul>
<li>VSYNC
信号贯穿整个流程，确保绘制、渲染和显示同步，避免撕裂（tearing）或丢帧。</li>
</ul>
<hr />
<h3 id="性能优化与问题">7. 性能优化与问题</h3>
<ul>
<li><strong>应用层</strong>：优化 <code>onDraw</code> 和
<code>onMeasure</code>，减少不必要的重绘。</li>
<li><strong>Framework 层</strong>：使用硬件加速，优化
<code>SurfaceFlinger</code> 合成逻辑。</li>
<li><strong>Native 层</strong>：利用 Skia 和 OpenGL/Vulkan 的性能，减少
CPU 负载。</li>
<li><strong>HAL 层</strong>：确保 GPU
和显示驱动高效工作，匹配设备刷新率。</li>
</ul>
<p><strong>常见问题</strong>： -
<strong>掉帧（Jank）</strong>：主线程阻塞或渲染未同步 VSYNC。 -
<strong>过度绘制</strong>：<code>View</code>
绘制区域重叠，增加渲染负担。 - <strong>硬件兼容性</strong>：不同设备 GPU
或显示驱动可能导致性能差异。</p>
<hr />
<h3 id="总结-1">8. 总结</h3>
<p>从上层 <code>View</code> 到 Framework 层再到 HAL 层的 Android
绘制渲染流程，体现了多层次协作：应用层的 UI 逻辑通过 <code>View</code>
和 <code>ViewRootImpl</code> 触发，Framework 层通过
<code>SurfaceFlinger</code> 和 <code>Choreographer</code>
管理渲染，Native 层使用 Skia 和 OpenGL/Vulkan 加速图形处理，HAL
层最终将像素输出到硬件屏幕。这种分层设计确保了跨设备兼容性、性能优化和用户体验的平滑性。</p>
<h3 id="流程图-1">9. 流程图</h3>
<pre><code class="highlight mermaid">graph TD
    A[&quot;应用启动或 UI 更新 (invalidate/requestLayout)&quot;]:::start --&gt; B[&quot;View.invalidate() 或 requestLayout()&quot;]:::app
    B --&gt; C&#123;&quot;需要重新绘制？&quot;&#125;
    C -- 是 --&gt; D[&quot;ViewRootImpl.performTraversals()&quot;]:::framework
    C -- 否 --&gt; A
    D --&gt; E[&quot;View.measure()&quot;]:::app
    E --&gt; F&#123;&quot;是 ViewGroup？&quot;&#125;
    F -- 是 --&gt; G[&quot;ViewGroup.measureChildren()&quot;]:::app
    F -- 否 --&gt; H[&quot;View.onMeasure()&quot;]:::app
    G --&gt; H
    H --&gt; I[&quot;View.layout()&quot;]:::app
    I --&gt; J&#123;&quot;是 ViewGroup？&quot;&#125;
    J -- 是 --&gt; K[&quot;ViewGroup.onLayout()&quot;]:::app
    J -- 否 --&gt; L[&quot;View.setFrame()&quot;]:::app
    K --&gt; L
    L --&gt; M[&quot;View.draw()&quot;]:::app
    M --&gt; N&#123;&quot;是 ViewGroup？&quot;&#125;
    N -- 是 --&gt; O[&quot;ViewGroup.dispatchDraw()&quot;]:::app
    N -- 否 --&gt; P[&quot;View.onDraw()&quot;]:::app
    O --&gt; P
    P --&gt; Q[&quot;Canvas 提交至 Surface&quot;]:::framework
    Q --&gt; R[&quot;SurfaceFlinger 合成与渲染&quot;]:::framework
    R --&gt; S((&quot;VSYNC 信号同步？&quot;)):::sync
    S -- 是 --&gt; T[&quot;屏幕显示 (Framebuffer)&quot;]:::start
    S -- 否 --&gt; U[&quot;等待 VSYNC&quot;]:::framework
    U --&gt; S

    %% 定义颜色样式
    classDef start fill:#000000,color:#ffffff
    classDef app fill:#00FF00,color:#000000
    classDef framework fill:#0000FF,color:#ffffff
    classDef sync fill:#000000,color:#ffffff</code></pre>
<h2 id="view-绘制流程">View 绘制流程</h2>
<p>在 Android 中，<code>View</code>
的绘制流程是实现用户界面（UI）显示的核心机制，它由测量（Measure）、布局（Layout）和绘制（Draw）三个阶段组成。这些阶段通过
<code>View</code> 和 <code>ViewGroup</code> 的协作完成，最终由
<code>ViewRootImpl</code> 协调并渲染到屏幕上。以下是 Android
<code>View</code>
绘制流程的详细讲解，包括每个阶段的重要方法及其参数的解释，不提供流程图。</p>
<hr />
<h3 id="绘制流程的总体概述">1. 绘制流程的总体概述</h3>
<p><code>View</code> 的绘制流程通常由以下情况触发： - 应用启动时调用
<code>setContentView</code> 设置布局。 - 代码调用
<code>invalidate()</code> 或 <code>requestLayout()</code> 更新 UI。 -
用户交互（如触摸、滚动）或动画导致内容变化。 绘制流程与
VSYNC（垂直同步信号）同步，通过 <code>Choreographer</code>
确保与屏幕刷新（约 16ms，60 FPS）保持一致，避免掉帧（jank）。</p>
<p>整个流程分为三个主要阶段： 1. <strong>测量（Measure）</strong>：确定
<code>View</code> 的尺寸（宽度和高度）。 2.
<strong>布局（Layout）</strong>：确定 <code>View</code>
的位置（左、上、右、下坐标）。 3. <strong>绘制（Draw）</strong>：将
<code>View</code> 的内容渲染成像素并显示到屏幕上。</p>
<p>以下是每个阶段的详细说明，包括关键方法及其参数。</p>
<hr />
<h3 id="测量阶段measure">2. 测量阶段（Measure）</h3>
<h4 id="目的">2.1 目的</h4>
<p>测量阶段的目标是计算每个 <code>View</code>
的尺寸（<code>mMeasuredWidth</code> 和
<code>mMeasuredHeight</code>），确保符合父视图的布局约束。</p>
<h4 id="关键方法及其参数">2.2 关键方法及其参数</h4>
<h5 id="view.measureint-widthmeasurespec-int-heightmeasurespec">2.2.1
<code>View.measure(int widthMeasureSpec, int heightMeasureSpec)</code></h5>
<ul>
<li><strong>作用</strong>：根据父视图提供的 <code>MeasureSpec</code>
测量 <code>View</code> 的尺寸。</li>
<li><strong>参数</strong>：
<ul>
<li><code>widthMeasureSpec</code>：整数类型，表示宽度的测量规格，包含模式和大小。
<ul>
<li>模式（通过 <code>MeasureSpec.getMode()</code> 获取）：
<ul>
<li><code>MeasureSpec.UNSPECIFIED</code>：无限制，子视图可自由指定大小（很少见）。</li>
<li><code>MeasureSpec.EXACTLY</code>：精确模式，父视图指定固定大小（如
<code>match_parent</code> 或具体 dp 值）。</li>
<li><code>MeasureSpec.AT_MOST</code>：最大模式，子视图大小不超过父视图的可用空间（如
<code>wrap_content</code>）。</li>
</ul></li>
<li>大小（通过 <code>MeasureSpec.getSize()</code>
获取）：父视图允许的最大或固定尺寸（以像素为单位）。</li>
</ul></li>
<li><code>heightMeasureSpec</code>：类似
<code>widthMeasureSpec</code>，表示高度的测量规格。</li>
</ul></li>
<li><strong>返回值</strong>：无，直接调用 <code>onMeasure</code>
计算尺寸并设置 <code>mMeasuredWidth</code> 和
<code>mMeasuredHeight</code>。</li>
<li><strong>流程</strong>：
<ol type="1">
<li><code>ViewRootImpl</code> 或父 <code>ViewGroup</code>
调用此方法，传入 <code>MeasureSpec</code>。</li>
<li><code>View</code> 根据 <code>MeasureSpec</code>
和自身布局参数（<code>layoutParams</code>）计算尺寸。</li>
<li>调用 <code>onMeasure</code> 完成具体测量逻辑。</li>
</ol></li>
</ul>
<h5 id="view.onmeasureint-widthmeasurespec-int-heightmeasurespec">2.2.2
<code>View.onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code></h5>
<ul>
<li><strong>作用</strong>：<code>View</code> 或 <code>ViewGroup</code>
重写此方法自定义测量逻辑，计算并设置 <code>mMeasuredWidth</code> 和
<code>mMeasuredHeight</code>。</li>
<li><strong>参数</strong>：同 <code>measure</code>
方法，<code>widthMeasureSpec</code> 和 <code>heightMeasureSpec</code>
描述宽高约束。</li>
<li><strong>返回值</strong>：无，但必须调用
<code>setMeasuredDimension(width, height)</code> 设置最终尺寸。</li>
<li><strong>注意</strong>：
<ul>
<li><code>setMeasuredDimension(int measuredWidth, int measuredHeight)</code>：设置测量后的宽度和高度。</li>
<li>必须确保尺寸符合 <code>MeasureSpec</code>
的模式和大小限制，否则可能导致布局异常。</li>
</ul></li>
<li><strong>默认实现</strong>：
<ul>
<li>对于普通 <code>View</code>，根据 <code>MeasureSpec</code>
模式计算默认尺寸（例如 <code>EXACTLY</code>
直接使用指定大小，<code>AT_MOST</code> 使用 <code>padding</code>
和内容大小）。</li>
<li>对于 <code>ViewGroup</code>，调用 <code>measureChildren</code>
测量子视图，汇总子视图尺寸。</li>
</ul></li>
</ul>
<h5
id="viewgroup.measurechildrenint-widthmeasurespec-int-heightmeasurespec">2.2.3
<code>ViewGroup.measureChildren(int widthMeasureSpec, int heightMeasureSpec)</code></h5>
<ul>
<li><strong>作用</strong>：<code>ViewGroup</code>
用于测量所有子视图的尺寸。</li>
<li><strong>参数</strong>：同 <code>measure</code>，传递给子视图的
<code>MeasureSpec</code>。</li>
<li><strong>返回值</strong>：无，递归调用子视图的
<code>measure</code>。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>遍历子视图，调用每个子视图的 <code>measure</code>。</li>
<li>根据子视图的 <code>layoutParams</code> 和父视图的
<code>MeasureSpec</code> 调整子视图的测量规格。</li>
</ol></li>
</ul>
<h4 id="测量阶段的注意事项">2.3 测量阶段的注意事项</h4>
<ul>
<li>测量只关心尺寸，不涉及位置。</li>
<li>开发者可重写 <code>onMeasure</code> 自定义测量逻辑，但必须遵守
<code>MeasureSpec</code> 约束。</li>
<li>如果 <code>View</code> 尺寸发生变化，可能触发
<code>requestLayout()</code>，重新测量和布局。</li>
</ul>
<hr />
<h3 id="布局阶段layout">3. 布局阶段（Layout）</h3>
<h4 id="目的-1">3.1 目的</h4>
<p>布局阶段的目标是根据测量结果确定每个 <code>View</code>
的位置（<code>mLeft</code>、<code>mTop</code>、<code>mRight</code>、<code>mBottom</code>），确保
<code>View</code> 在屏幕上的正确摆放。</p>
<h4 id="关键方法及其参数-1">3.2 关键方法及其参数</h4>
<h5 id="view.layoutint-l-int-t-int-r-int-b">3.2.1
<code>View.layout(int l, int t, int r, int b)</code></h5>
<ul>
<li><strong>作用</strong>：设置 <code>View</code>
的边界，确定其在屏幕上的位置。</li>
<li><strong>参数</strong>：
<ul>
<li><code>l</code>：左边界（<code>mLeft</code>），相对于父视图的 x
坐标。</li>
<li><code>t</code>：上边界（<code>mTop</code>），相对于父视图的 y
坐标。</li>
<li><code>r</code>：右边界（<code>mRight</code>），<code>mLeft + mMeasuredWidth</code>。</li>
<li><code>b</code>：下边界（<code>mBottom</code>），<code>mTop + mMeasuredHeight</code>。</li>
</ul></li>
<li><strong>返回值</strong>：无，直接设置 <code>View</code>
的边界属性。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>父 <code>ViewGroup</code> 调用此方法，传入子视图的边界值。</li>
<li><code>View</code> 更新
<code>mLeft</code>、<code>mTop</code>、<code>mRight</code>、<code>mBottom</code>，确定位置。</li>
<li>如果 <code>View</code> 是 <code>ViewGroup</code>，递归调用子视图的
<code>layout</code>。</li>
</ol></li>
</ul>
<h5 id="view.onlayoutboolean-changed-int-l-int-t-int-r-int-b">3.2.2
<code>View.onLayout(boolean changed, int l, int t, int r, int b)</code></h5>
<ul>
<li><strong>作用</strong>：<code>ViewGroup</code>
重写此方法，定位其子视图。</li>
<li><strong>参数</strong>：
<ul>
<li><code>changed</code>：布尔值，指示布局是否发生变化（<code>true</code>
表示尺寸或位置有变化）。</li>
<li><code>l</code>、<code>t</code>、<code>r</code>、<code>b</code>：当前
<code>ViewGroup</code> 的边界，与 <code>layout</code> 的参数相同。</li>
</ul></li>
<li><strong>返回值</strong>：无，负责调用子视图的 <code>layout</code>
方法。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>根据子视图的 <code>mMeasuredWidth</code> 和
<code>mMeasuredHeight</code>，计算每个子视图的
<code>l</code>、<code>t</code>、<code>r</code>、<code>b</code>。</li>
<li>调用子视图的 <code>layout</code> 设置其位置。</li>
</ol></li>
<li><strong>默认实现</strong>：空实现，开发者需重写以自定义子视图布局。</li>
</ul>
<h4 id="布局阶段的注意事项">3.3 布局阶段的注意事项</h4>
<ul>
<li>布局依赖测量结果，必须在测量完成后执行。</li>
<li>位置可能受父视图的 <code>padding</code>、<code>margin</code>
和布局参数（如 <code>LinearLayout</code> 的权重）影响。</li>
<li>开发者可重写 <code>onLayout</code>
自定义子视图位置，但需确保不超出父视图范围。</li>
</ul>
<hr />
<h3 id="绘制阶段draw">4. 绘制阶段（Draw）</h3>
<h4 id="目的-2">4.1 目的</h4>
<p>绘制阶段的目标是将 <code>View</code> 的内容渲染成像素，并通过
<code>Canvas</code> 提交到 <code>Surface</code>，最终显示在屏幕上。</p>
<h4 id="关键方法及其参数-2">4.2 关键方法及其参数</h4>
<h5 id="view.drawcanvas-canvas">4.2.1
<code>View.draw(Canvas canvas)</code></h5>
<ul>
<li><strong>作用</strong>：绘制 <code>View</code>
的内容，包括背景、内容和子视图。</li>
<li><strong>参数</strong>：
<ul>
<li><code>canvas</code>：<code>Canvas</code>
对象，用于绘制图形，管理像素数据。</li>
</ul></li>
<li><strong>返回值</strong>：无，执行绘制逻辑并提交到
<code>Surface</code>。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>调用 <code>drawBackground</code> 绘制背景。</li>
<li>如果需要，调用 <code>saveLayer</code>
保存图层（用于透明度或复杂效果）。</li>
<li>调用 <code>onDraw</code> 绘制 <code>View</code> 内容。</li>
<li>如果是 <code>ViewGroup</code>，调用 <code>dispatchDraw</code>
绘制子视图。</li>
<li>绘制前景和装饰（如边框、滚动条）。</li>
<li>提交 <code>Canvas</code> 内容到 <code>Surface</code>。</li>
</ol></li>
</ul>
<h5 id="view.ondrawcanvas-canvas">4.2.2
<code>View.onDraw(Canvas canvas)</code></h5>
<ul>
<li><strong>作用</strong>：<code>View</code>
重写此方法自定义绘制逻辑。</li>
<li><strong>参数</strong>：
<ul>
<li><code>canvas</code>：<code>Canvas</code>
对象，用于绘制图形（例如文字、形状、图片）。</li>
</ul></li>
<li><strong>返回值</strong>：无，直接在 <code>Canvas</code>
上绘制内容。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>使用 <code>Canvas</code> 的方法（如
<code>drawText</code>、<code>drawRect</code>、<code>drawBitmap</code>）绘制内容。</li>
<li>确保绘制区域在 <code>View</code> 的边界内。</li>
</ol></li>
<li><strong>默认实现</strong>：空实现，开发者需重写以实现自定义绘制。</li>
</ul>
<h5 id="viewgroup.dispatchdrawcanvas-canvas">4.2.3
<code>ViewGroup.dispatchDraw(Canvas canvas)</code></h5>
<ul>
<li><strong>作用</strong>：<code>ViewGroup</code>
绘制其所有子视图。</li>
<li><strong>参数</strong>：
<ul>
<li><code>canvas</code>：<code>Canvas</code>
对象，传递给子视图进行绘制。</li>
</ul></li>
<li><strong>返回值</strong>：无，递归调用子视图的
<code>draw</code>。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>遍历子视图，调用每个子视图的 <code>draw</code>。</li>
<li>确保子视图按 Z 序（层级）绘制（通常从后向前）。</li>
</ol></li>
</ul>
<h4 id="绘制阶段的注意事项">4.3 绘制阶段的注意事项</h4>
<ul>
<li>绘制依赖测量和布局结果，确保内容按正确尺寸和位置渲染。</li>
<li>使用硬件加速（默认开启）通过 OpenGL/Vulkan 提升性能。</li>
<li>避免过度绘制（Overdraw），优化 <code>onDraw</code>
逻辑减少不必要的绘制。</li>
</ul>
<hr />
<h3 id="从应用层到-hal-层的完整渲染绘制流程">5. 从应用层到 HAL
层的完整渲染绘制流程</h3>
<h4 id="应用层">5.1 应用层</h4>
<ul>
<li><strong>触发</strong>：通过 <code>invalidate()</code> 或
<code>requestLayout()</code> 标记 UI 更新，调用 <code>View</code>
的绘制方法。</li>
<li><strong>流程</strong>：
<ol type="1">
<li>应用层 <code>View</code> 或 <code>ViewGroup</code> 调用
<code>invalidate()</code>（仅重绘）或
<code>requestLayout()</code>（重测、重排、重绘）。</li>
<li><code>ViewRootImpl</code> 接收到请求，调用
<code>performTraversals</code>，执行测量、布局、绘制。</li>
<li>测量阶段确定 <code>View</code>
尺寸，布局阶段确定位置，绘制阶段渲染内容到 <code>Canvas</code>。</li>
</ol></li>
</ul>
<h4 id="framework-层">5.2 Framework 层</h4>
<ul>
<li><strong>协调与渲染</strong>：
<ul>
<li><code>ViewRootImpl</code> 协调测量、布局、绘制，提交内容到
<code>Surface</code>。</li>
<li><code>SurfaceFlinger</code> 合成多个 <code>Surface</code>，通过
<code>Choreographer</code> 同步 VSYNC 信号。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li><code>Canvas</code> 内容提交到 <code>Surface</code>。</li>
<li><code>SurfaceFlinger</code> 合成 <code>Surface</code>，调用 Native
层渲染。</li>
<li>VSYNC 确保渲染与屏幕刷新同步。</li>
</ol></li>
</ul>
<h4 id="native-层">5.3 Native 层</h4>
<ul>
<li><strong>图形处理</strong>：
<ul>
<li>通过 JNI 调用 Skia（2D 图形库）和 OpenGL/Vulkan（3D
硬件加速）渲染。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li><code>Canvas</code> 绘制操作通过 JNI 传递到 Native 层。</li>
<li>Skia 处理 2D 绘制，OpenGL/Vulkan 加速 3D 渲染。</li>
<li>像素数据存储到 <code>Surface</code> 或 Framebuffer。</li>
</ol></li>
</ul>
<h4 id="hal-层">5.4 HAL 层</h4>
<ul>
<li><strong>硬件交互</strong>：
<ul>
<li>GPU 驱动处理渲染指令，显示驱动输出到屏幕。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li>GPU 驱动接收 OpenGL/Vulkan 指令，生成像素数据到 Framebuffer。</li>
<li>显示驱动将 Framebuffer 内容传输到显示控制器。</li>
<li>显示控制器刷新像素到物理屏幕（LCD 或 OLED）。</li>
</ol></li>
</ul>
<hr />
<h3 id="invalidate-和-requestlayout-的详细区别">6.
<code>invalidate()</code> 和 <code>requestLayout()</code>
的详细区别</h3>
<h4 id="invalidate">6.1 <code>invalidate()</code></h4>
<ul>
<li><strong>作用</strong>：标记 <code>View</code> 或
<code>ViewGroup</code> 的内容需要重新绘制，但不影响尺寸或位置。</li>
<li><strong>参数</strong>：无直接参数，调用
<code>view.invalidate()</code>。</li>
<li><strong>触发场景</strong>：
<ul>
<li>背景色、文字内容、绘制逻辑变化，但布局和尺寸不变。</li>
<li>例如：<code>setBackgroundColor()</code>、<code>setText()</code> 或
<code>onDraw()</code> 更新。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li>标记 <code>View</code> 的脏区域（dirty region）。</li>
<li><code>ViewRootImpl</code> 在下一个 VSYNC 信号触发
<code>draw()</code>，仅执行绘制阶段。</li>
<li>不触发测量或布局阶段。</li>
</ol></li>
<li><strong>性能影响</strong>：开销较小，仅重绘当前 <code>View</code>
和受影响区域。</li>
<li><strong>典型用例</strong>：动画、状态变化（如按钮颜色变化）。</li>
</ul>
<h4 id="requestlayout">6.2 <code>requestLayout()</code></h4>
<ul>
<li><strong>作用</strong>：标记 <code>View</code> 或
<code>ViewGroup</code> 的布局需要重新计算，可能影响尺寸和位置。</li>
<li><strong>参数</strong>：无直接参数，调用
<code>view.requestLayout()</code>。</li>
<li><strong>触发场景</strong>：
<ul>
<li>布局参数变化（如
<code>layout_width</code>、<code>layout_height</code>）。</li>
<li>子视图添加/移除或尺寸变化。</li>
<li>父视图或子视图的可见性、位置变化。</li>
</ul></li>
<li><strong>流程</strong>：
<ol type="1">
<li>标记 <code>View</code> 及其父视图需要重新布局。</li>
<li><code>ViewRootImpl</code> 在下一个 VSYNC 信号触发
<code>performTraversals</code>，执行测量、布局和绘制三个阶段。</li>
<li>可能导致整个视图树的重绘。</li>
</ol></li>
<li><strong>性能影响</strong>：开销较大，可能重测、重排、重绘整个视图树。</li>
<li><strong>典型用例</strong>：动态调整布局（如添加
<code>View</code>、<code>setVisibility()</code>）。</li>
</ul>
<h4 id="对比总结">6.3 对比总结</h4>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 35%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th><code>invalidate()</code></th>
<th><code>requestLayout()</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>作用</strong></td>
<td>标记需要重绘（只绘制阶段）</td>
<td>标记需要重新布局（测量、布局、绘制）</td>
</tr>
<tr class="even">
<td><strong>触发场景</strong></td>
<td>内容变化（如颜色、文字）</td>
<td>尺寸或位置变化（布局参数、子视图）</td>
</tr>
<tr class="odd">
<td><strong>影响范围</strong></td>
<td>只影响当前 <code>View</code> 的绘制</td>
<td>可能影响整个视图树</td>
</tr>
<tr class="even">
<td><strong>性能开销</strong></td>
<td>较小（只重绘）</td>
<td>较大（可能重测、重排、重绘）</td>
</tr>
<tr class="odd">
<td><strong>调用方法</strong></td>
<td><code>view.invalidate()</code></td>
<td><code>view.requestLayout()</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="性能优化与注意事项">7. 性能优化与注意事项</h3>
<ul>
<li><strong>测量阶段</strong>：确保 <code>onMeasure</code>
高效，避免复杂计算；遵守 <code>MeasureSpec</code> 约束。</li>
<li><strong>布局阶段</strong>：优化 <code>onLayout</code>
逻辑，减少递归调用；避免频繁触发 <code>requestLayout()</code>。</li>
<li><strong>绘制阶段</strong>：优化 <code>onDraw</code>
减少过度绘制，使用硬件加速提升性能；避免阻塞主线程。</li>
<li><strong>VSYNC 同步</strong>：确保绘制与 VSYNC 同步，避免丢帧。</li>
<li><strong>调试工具</strong>：使用 Android Studio 的 Layout Inspector
和 Profile GPU Rendering 分析性能瓶颈。</li>
</ul>
<hr />
<h3 id="总结-2">8. 总结</h3>
<p>Android <code>View</code>
的绘制流程由测量、布局和绘制三个阶段组成，涉及
<code>View</code>、<code>ViewGroup</code>、<code>ViewRootImpl</code>
和底层渲染管道（<code>SurfaceFlinger</code>、Skia、OpenGL/Vulkan、HAL）。每个阶段的关键方法（如
<code>measure</code>、<code>layout</code>、<code>draw</code>）及其参数（如
<code>MeasureSpec</code>、<code>Canvas</code>）确保 UI
的正确性和性能。<code>invalidate()</code> 和
<code>requestLayout()</code>
的区别在于触发范围和性能影响，前者仅重绘，后者可能重测、重排、重绘，开发者需根据场景选择合适的方法。</p>
<h2
id="android中ipc方式各种方式优缺点">Android中IPC方式、各种方式优缺点</h2>
<p>在 Android 中，IPC（Inter-Process
Communication，进程间通信）是指两个不同进程之间的通信机制。由于 Android
应用运行在各自独立的进程中，为了安全性和性能优化，进程间通信需要通过专门的机制来完成。Android
提供了多种 IPC 方式，每种方式各有优缺点，常见的 IPC 方式包括：</p>
<ol type="1">
<li><strong>Bundle</strong></li>
<li><strong>Messenger</strong></li>
<li><strong>AIDL（Android Interface Definition Language）</strong></li>
<li><strong>ContentProvider</strong></li>
<li><strong>BroadcastReceiver</strong></li>
<li><strong>Socket</strong></li>
</ol>
<p>下面详细介绍每种 IPC 方式及其优缺点。</p>
<h3 id="bundle">1. <strong>Bundle</strong></h3>
<h4 id="概述">概述：</h4>
<p><code>Bundle</code> 是 Android 内置的简单数据传递方式，通常用于在
<code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>
等组件之间传递数据。它主要用于在同一个应用的不同组件之间传递简单数据。</p>
<h4 id="优点">优点：</h4>
<ul>
<li>使用简单：不需要复杂的定义和管理，只需要打包和传递键值对。</li>
<li>速度快：适合在同一进程的组件之间传递少量数据。</li>
<li>Android 内置支持：大多数 Android 组件都原生支持
<code>Bundle</code>。</li>
</ul>
<h4 id="缺点">缺点：</h4>
<ul>
<li>仅支持基本类型数据：<code>Bundle</code> 只能存储基本类型（如
<code>int</code>、<code>boolean</code>）和少数系统类型（如
<code>Parcelable</code> 对象）。</li>
<li>进程间使用受限：用于进程间通信时，只能传递少量、简单的数据，不适合复杂的数据结构。</li>
</ul>
<h4 id="适用场景">适用场景：</h4>
<ul>
<li>同一应用内不同组件之间的简单数据传递。</li>
</ul>
<h3 id="messenger">2. <strong>Messenger</strong></h3>
<h4 id="概述-1">概述：</h4>
<p><code>Messenger</code> 是基于 <code>Handler</code> 的一种轻量级的 IPC
方式，适用于一对一的进程间通信。它通过 <code>Message</code>
传递数据，并支持在不同进程中通过 <code>Handler</code> 处理消息。</p>
<h4 id="优点-1">优点：</h4>
<ul>
<li>易于实现：通过消息的发送与接收机制，适合简单的 IPC。</li>
<li>基于 <code>Handler</code>，非常适合一对一的消息通信。</li>
<li>传输过程安全：所有消息都封装在 <code>Message</code> 对象中。</li>
</ul>
<h4 id="缺点-1">缺点：</h4>
<ul>
<li>不支持复杂的数据结构：与 <code>Bundle</code>
一样，只适用于简单的数据类型传输。</li>
<li>不适合多线程或高并发场景：<code>Messenger</code>
本质上是串行处理的，无法支持并发通信。</li>
<li>仅适用于一对一通信：不支持多个客户端同时与服务端通信。</li>
</ul>
<h4 id="适用场景-1">适用场景：</h4>
<ul>
<li>轻量级、一对一的进程间通信，适用于少量数据传输。</li>
</ul>
<h3 id="aidlandroid-interface-definition-language">3.
<strong>AIDL（Android Interface Definition Language）</strong></h3>
<h4 id="概述-2">概述：</h4>
<p>AIDL 是 Android
提供的支持进程间通信的工具，允许定义跨进程的接口。它适用于复杂的数据传递和多进程环境下的通信。AIDL
的原理是通过 Binder 机制实现客户端与服务端的通信。</p>
<h4 id="优点-2">优点：</h4>
<ul>
<li>强大的 IPC 支持：可以传递复杂的数据类型，如
<code>List</code>、<code>Map</code>，甚至自定义对象。</li>
<li>支持多进程：可以用于多客户端与同一服务端的并发通信。</li>
<li>自动生成代码：AIDL 会根据接口定义生成对应的代理类和服务端代码。</li>
</ul>
<h4 id="缺点-2">缺点：</h4>
<ul>
<li>实现复杂：需要编写 <code>.aidl</code>
文件，手动管理接口和服务端实现。</li>
<li>性能开销：由于数据序列化和反序列化的开销较大，AIDL 通信效率比
<code>Messenger</code> 稍低。</li>
<li>数据传递需要深度复制：对象必须实现 <code>Parcelable</code>
接口，数据在传递时被复制，无法共享对象的引用。</li>
</ul>
<h4 id="适用场景-2">适用场景：</h4>
<ul>
<li>复杂的进程间通信，特别是需要在不同进程之间传递复杂数据结构时。</li>
</ul>
<h3 id="contentprovider">4. <strong>ContentProvider</strong></h3>
<h4 id="概述-3">概述：</h4>
<p><code>ContentProvider</code> 是 Android
用于共享数据的机制，适用于应用间的数据共享。它允许应用通过 URI
来访问和操作其他应用的数据，支持增删改查等操作。典型的例子是 Android
系统的联系人、媒体文件等都是通过 <code>ContentProvider</code>
共享数据的。</p>
<h4 id="优点-3">优点：</h4>
<ul>
<li>数据共享机制：适用于不同应用间的数据共享。</li>
<li>支持 SQL 风格的数据操作：提供类似数据库的 <code>CRUD</code>
操作接口，方便对数据进行管理。</li>
<li>安全性：通过 URI 权限控制，可以限制其他应用访问
<code>ContentProvider</code> 中的数据。</li>
</ul>
<h4 id="缺点-3">缺点：</h4>
<ul>
<li>仅适用于数据共享：<code>ContentProvider</code>
适合管理和共享结构化数据，不适用于实时通信。</li>
<li>实现复杂：<code>ContentProvider</code>
的实现需要处理多种操作（如查询、插入、删除等），并且需要处理 URI
匹配和权限控制。</li>
</ul>
<h4 id="适用场景-3">适用场景：</h4>
<ul>
<li>不同应用间的数据共享，例如联系人、日历、媒体等数据。</li>
</ul>
<h3 id="broadcastreceiver">5. <strong>BroadcastReceiver</strong></h3>
<h4 id="概述-4">概述：</h4>
<p><code>BroadcastReceiver</code> 是 Android
的广播机制，允许应用在进程间或应用间发送广播消息，通知其他应用或组件执行相应操作。广播可以是系统广播，也可以是应用自定义广播。</p>
<h4 id="优点-4">优点：</h4>
<ul>
<li>广泛适用：适用于一对多的通信方式，可以通知多个接收方。</li>
<li>松耦合：发送者和接收者之间不需要直接联系，方便应用内不同模块之间的通信。</li>
<li>适合全局事件通知：系统事件（如电池状态变化、网络变化）通常通过广播通知。</li>
</ul>
<h4 id="缺点-4">缺点：</h4>
<ul>
<li>数据传输效率较低：广播消息一般用于传递简单数据，复杂数据传输效率较低。</li>
<li>不适合实时通信：广播的通信是异步的，无法保证消息的实时性。</li>
<li>安全问题：广播可能被其他应用截获，需小心数据安全。</li>
</ul>
<h4 id="适用场景-4">适用场景：</h4>
<ul>
<li>一对多的通信场景，适用于系统全局事件或应用内的全局消息通知。</li>
</ul>
<h3 id="socket">6. <strong>Socket</strong></h3>
<h4 id="概述-5">概述：</h4>
<p><code>Socket</code> 是一种网络通信方式，支持进程间通过网络协议（如
TCP、UDP）进行数据传输。Android 中也可以通过 <code>Socket</code>
在不同进程或不同设备间通信。</p>
<h4 id="优点-5">优点：</h4>
<ul>
<li>适合网络通信：<code>Socket</code>
可以在本地或远程进程间通信，甚至可以跨设备通信。</li>
<li>高度灵活：适用于需要自定义通信协议的场景。</li>
<li>支持大量数据传输：可以通过流的形式传输大量数据。</li>
</ul>
<h4 id="缺点-5">缺点：</h4>
<ul>
<li>实现复杂：需要手动处理网络连接、通信协议、数据包的解析与处理。</li>
<li>安全性问题：需要处理网络传输中的安全问题，如数据加密、身份认证等。</li>
</ul>
<h4 id="适用场景-5">适用场景：</h4>
<ul>
<li>适用于大数据传输或复杂网络通信场景，尤其是在进程间或设备间需要实时通信时。</li>
</ul>
<h3 id="各种方式的对比总结">各种方式的对比总结</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 34%" />
<col style="width: 30%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>IPC 方式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bundle</td>
<td>简单易用，适合传递基本数据类型</td>
<td>只能用于传递简单数据类型，跨进程使用受限</td>
<td>应用内组件之间的简单数据传递</td>
</tr>
<tr class="even">
<td>Messenger</td>
<td>轻量级，基于 <code>Handler</code> 的一对一通信，简单且易实现</td>
<td>不支持复杂数据结构，不适合多线程和并发场景</td>
<td>简单的一对一进程间通信</td>
</tr>
<tr class="odd">
<td>AIDL</td>
<td>支持复杂数据类型和并发通信，适合多进程场景</td>
<td>实现复杂，性能开销较大</td>
<td>复杂的进程间通信，需传递复杂数据时</td>
</tr>
<tr class="even">
<td>ContentProvider</td>
<td>适合应用间的数据共享，支持 SQL 风格的操作</td>
<td>实现复杂，仅适用于数据共享，无法用于实时通信</td>
<td>应用间的结构化数据共享</td>
</tr>
<tr class="odd">
<td>BroadcastReceiver</td>
<td>支持一对多通信，适合全局消息广播和系统事件通知</td>
<td>不适合实时通信，数据传输效率低</td>
<td>一对多的全局消息广播或系统事件通知</td>
</tr>
<tr class="even">
<td>Socket</td>
<td>灵活，支持大数据传输和跨设备通信</td>
<td>实现复杂，需要处理网络协议和安全问题</td>
<td>大量数据的实时传输或跨设备通信</td>
</tr>
</tbody>
</table>
<p>每种 IPC
方式适用于不同的场景，选择合适的方式可以提高开发效率和应用性能。</p>
<h2 id="binder机制的作用和原理">Binder机制的作用和原理</h2>
<p><strong>Binder</strong> 是 Android
中最重要的进程间通信（IPC）机制之一，Binder
的设计兼顾了高效性、安全性和灵活性，在 Android
系统中几乎所有的进程间通信都基于 Binder 机制，例如
<code>AIDL</code>、<code>Messenger</code>、<code>ContentProvider</code>
等都是通过 Binder 实现的。Binder 也是 Android 系统服务（如
<code>ActivityManagerService</code>、<code>WindowManagerService</code>
等）的通信基础。</p>
<h3 id="binder-的作用">Binder 的作用</h3>
<ol type="1">
<li><strong>进程间通信（IPC）</strong>：Binder 提供了一种高效的 IPC
机制，允许不同进程之间交换数据或请求服务。</li>
<li><strong>安全性</strong>：Binder 内核实现了身份验证机制，可以通过
UID（用户 ID） 验证通信双方的身份，保证进程间通信的安全性。</li>
<li><strong>高效性</strong>：Binder
使用内核缓冲区避免了数据的多次复制，减少了内存和 CPU 的消耗。</li>
<li><strong>轻量级</strong>：与传统的 Linux IPC
机制（如管道、消息队列、共享内存等）相比，Binder
更轻量级，性能更好，设计上更适合 Android 移动设备的资源受限环境。</li>
</ol>
<h3 id="binder-的原理">Binder 的原理</h3>
<p>Binder 是 Android 特有的 IPC 机制，底层由 Linux
内核驱动支持。它的工作原理包括以下几个关键组件：</p>
<ol type="1">
<li><p><strong>Binder 驱动</strong>：Binder 的核心是一个位于内核空间的
Binder
驱动程序（<code>/dev/binder</code>），负责管理和协调进程之间的数据传递、身份验证和资源管理。</p></li>
<li><p><strong>Binder 线程池</strong>：每个进程中负责处理 IPC
请求的服务端都会维护一个 Binder
线程池，这些线程负责处理来自客户端的请求。Binder
线程池的大小是动态调整的，当有新的请求时，线程池会处理该请求。</p></li>
<li><p><strong>Binder 引用（Binder Reference）</strong>：在 Binder
通信中，客户端和服务端通过 <code>Binder</code>
对象进行交互。客户端持有服务端的一个 <code>Binder</code>
引用，实际的通信是通过引用传递的。</p></li>
<li><p><strong>Binder 代理（Proxy）</strong>：在客户端进程中，Binder
通信通过代理对象（<code>Binder Proxy</code>）实现。代理对象封装了与服务端通信的细节，客户端通过代理对象调用服务端的方法，实际上是通过
<code>Binder</code> 驱动将请求传递给服务端。</p></li>
<li><p><strong>Binder 通信流程</strong>：Binder
使用请求-响应的方式实现通信。当客户端调用代理对象的某个方法时，该调用会封装为一个
<code>Transaction</code>，通过 <code>Binder</code>
驱动传递给服务端。服务端处理完请求后，将结果通过 <code>Binder</code>
驱动返回给客户端。</p></li>
</ol>
<h4 id="具体的通信流程">具体的通信流程：</h4>
<ol type="1">
<li><strong>客户端请求</strong>：
<ul>
<li>客户端进程通过调用 <code>Binder</code>
代理对象发起请求。代理对象将请求打包成 <code>Parcel</code>，并通过
Binder 驱动发送给服务端进程。</li>
</ul></li>
<li><strong>Binder 驱动处理</strong>：
<ul>
<li><code>Parcel</code>
包含请求的详细信息，包括调用的方法、参数等。Binder
驱动将这些信息传递给服务端的 Binder 线程池。</li>
</ul></li>
<li><strong>服务端处理</strong>：
<ul>
<li>服务端的某个线程从 Binder 线程池中取出请求并解包
<code>Parcel</code>，调用相应的业务逻辑进行处理，处理完后将结果打包成
<code>Parcel</code> 并通过 Binder 驱动返回给客户端。</li>
</ul></li>
<li><strong>客户端接收结果</strong>：
<ul>
<li>客户端进程的代理对象从 Binder
驱动接收到结果并解包，返回给应用程序。</li>
</ul></li>
</ol>
<h3 id="binder-通信的几个关键概念">Binder 通信的几个关键概念</h3>
<ol type="1">
<li><p><strong>Binder 驱动</strong>： Binder
的核心是一个内核态的驱动程序
<code>binder</code>，这个驱动程序负责管理客户端与服务端之间的通信。Binder
驱动程序主要负责以下几件事情：</p>
<ul>
<li>管理进程间的 <code>Binder</code> 句柄和引用。</li>
<li>负责将客户端请求发送给服务端，并返回结果给客户端。</li>
<li>提供跨进程的身份验证。</li>
</ul></li>
<li><p><strong>Parcel</strong>： <code>Parcel</code> 是 Android
中用于序列化和反序列化数据的容器。Binder 在传输数据时，必须将数据打包成
<code>Parcel</code> 对象。<code>Parcel</code> 支持基本数据类型（如
<code>int</code>、<code>String</code>），也支持复杂数据类型（如
<code>Parcelable</code> 对象）。</p></li>
<li><p><strong>Binder 线程池</strong>： 每个服务端进程会维护一个
<code>Binder</code> 线程池，负责处理来自客户端的 IPC
请求。每当客户端发起请求时，Binder
线程池中的某个线程会处理该请求。线程池的大小动态调整，能够提高服务端处理请求的效率。</p></li>
</ol>
<h3 id="binder-的数据传输过程">Binder 的数据传输过程</h3>
<ul>
<li><p><strong>数据的序列化和反序列化</strong>：Binder
通信中，所有数据通过 <code>Parcel</code>
序列化后进行传输。在客户端，方法调用时，参数会被写入
<code>Parcel</code>，传递给 Binder 驱动。在服务端，Binder 驱动将
<code>Parcel</code> 中的数据交给服务端的线程，线程读取
<code>Parcel</code> 并执行相应的操作。处理结果也会打包成
<code>Parcel</code> 返回给客户端。</p></li>
<li><p><strong>进程身份验证</strong>：Binder
内核驱动提供了进程的身份验证机制。每个通过 Binder
通信的进程都有一个唯一的标识符（UID），Binder
驱动会验证通信双方的身份，确保只有授权的进程才能通信。</p></li>
</ul>
<h3 id="binder-的优缺点">Binder 的优缺点</h3>
<h4 id="优点-6">优点：</h4>
<ol type="1">
<li><p><strong>高效性</strong>：Binder
的数据传输通过内核共享内存的方式实现，避免了传统 IPC
机制（如管道、Socket）中数据的多次拷贝，提高了通信效率。</p></li>
<li><p><strong>安全性</strong>：Binder
通过内核态的身份认证机制，确保通信的安全性。每次进程间通信时，Binder
驱动会验证通信双方的身份，防止未经授权的进程参与通信。</p></li>
<li><p><strong>支持一对多通信</strong>：Binder
允许多个客户端与一个服务端通信，并且多个进程可以同时访问同一个服务端。</p></li>
<li><p><strong>灵活性强</strong>：Binder
支持多种数据类型的传输，包括基本数据类型和自定义的
<code>Parcelable</code> 对象，适应性强。</p></li>
</ol>
<h4 id="缺点-6">缺点：</h4>
<ol type="1">
<li><p><strong>实现复杂</strong>：Binder
的底层实现非常复杂，涉及到内核态的驱动程序、进程间的通信协议和数据的序列化等。虽然
Android 提供了 <code>AIDL</code>、<code>Messenger</code>
等高级抽象来简化 Binder 的使用，但直接使用 Binder 的门槛较高。</p></li>
<li><p><strong>性能开销</strong>：尽管 Binder 比传统的 IPC
机制效率高，但序列化和反序列化数据依然会带来一定的性能开销。特别是在传输大量数据时，性能下降明显。</p></li>
</ol>
<h3 id="binder-与传统-linux-ipc-机制的对比">Binder 与传统 Linux IPC
机制的对比</h3>
<p>Binder 是 Android 特有的 IPC 机制，与传统的 Linux IPC
机制（如管道、消息队列、共享内存、Socket）相比，它有以下优点：</p>
<ul>
<li><strong>安全性更强</strong>：Binder
内置身份验证机制，确保通信的双方是可信任的进程。而传统的 Linux IPC
机制往往缺乏这种验证，容易受到攻击。</li>
<li><strong>数据传输更高效</strong>：Binder
使用共享内存减少了数据的拷贝次数，提升了传输效率。相比之下，传统 IPC
机制的数据传输通常需要多次拷贝。</li>
<li><strong>使用更简单</strong>：虽然 Binder 实现复杂，但 Android 提供了
<code>AIDL</code>、<code>Messenger</code> 等更高层次的
API，简化了开发者的使用体验。而传统 IPC
机制的使用往往需要编写大量的低层代码。</li>
</ul>
<h3 id="总结-3">总结</h3>
<p><strong>Binder</strong> 是 Android
系统中进程间通信的核心机制，提供了高效、安全、灵活的 IPC 能力。通过
Binder，Android
实现了系统服务和应用程序之间的通信，支持应用进程之间的高效数据交换。Binder
的主要优势在于它的高效性、安全性和易用性，尽管实现复杂，但 Android
提供了多种高层抽象（如 AIDL、Messenger 等）来简化开发者的使用。</p>
<h2 id="ams是如何管理activity的">AMS是如何管理Activity的</h2>
<p>在 Android 系统中，<code>AMS</code>（Activity Manager Service）
是负责管理应用进程、Activity、任务和应用生命周期的核心服务。<code>AMS</code>
在应用启动、Activity
切换、生命周期管理、任务栈管理等方面起着关键作用。它通过与
<code>Binder</code> 机制交互，协调应用进程和系统进程，管理 Activity
的创建、启动、切换、销毁等操作。</p>
<h3 id="ams-的基本概述">1. <strong>AMS 的基本概述</strong></h3>
<p><code>ActivityManagerService</code> 是 Android Framework
层的一个核心服务，用于管理应用的四大组件（Activity、Service、BroadcastReceiver、ContentProvider）。它位于
<code>system_server</code> 进程中，负责协调不同应用进程的行为。</p>
<ul>
<li><strong>启动 Activity</strong>：管理 Activity 的启动流程。</li>
<li><strong>管理 Activity 栈</strong>：负责维护和管理 Activity
的任务栈。</li>
<li><strong>控制 Activity 生命周期</strong>：管理每个 Activity
的生命周期状态（如启动、暂停、恢复、销毁）。</li>
<li><strong>管理进程和任务</strong>：通过管理任务栈（Task
Stack），调度不同的任务和进程。</li>
</ul>
<h3 id="ams-的核心角色">2. <strong>AMS 的核心角色</strong></h3>
<p><code>AMS</code> 通过与
<code>ActivityThread</code>、<code>WindowManagerService</code>、<code>PackageManagerService</code>
等系统服务协作，管理 Activity 的启动、生命周期及任务栈。它通过
<code>Binder</code> IPC 机制与应用进程通信。</p>
<ul>
<li><strong>ActivityThread</strong>：应用进程的主线程，负责执行应用中的
Activity 生命周期回调，处理 <code>AMS</code> 发来的消息。</li>
<li><strong>WindowManagerService
(WMS)</strong>：管理窗口的显示，<code>AMS</code> 与 <code>WMS</code>
协作来完成 Activity 的界面显示和切换。</li>
<li><strong>PackageManagerService
(PMS)</strong>：管理应用的安装、卸载和相关信息，<code>AMS</code>
通过它来检查应用的合法性。</li>
</ul>
<h3 id="ams-如何管理-activity">3. <strong>AMS 如何管理
Activity</strong></h3>
<p><code>AMS</code> 在管理 Activity 时，主要负责以下几个方面：</p>
<h4 id="启动-activity">1. <strong>启动 Activity</strong></h4>
<p>Activity 的启动是一个复杂的过程，<code>AMS</code>
是启动流程的核心。整个启动过程大致可以分为以下几步：</p>
<ol type="1">
<li><p><strong>应用请求启动 Activity</strong>： 应用通过
<code>startActivity()</code> 方法向 <code>ActivityManagerService</code>
请求启动一个 Activity，这个请求最终会通过 <code>Binder</code> 机制到达
<code>AMS</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用调用 startActivity()</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, TargetActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>AMS 接收启动请求</strong>： <code>AMS</code> 收到
<code>startActivity()</code>
请求后，会检查请求的合法性（例如是否具有相应的权限），然后通过
<code>startActivityAsUser()</code> 方法处理启动请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, </span></span><br><span class="line"><span class="params">    Intent intent, String resolvedType, ...)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivity(caller, intent, ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>创建或调度进程</strong>： 如果目标 <code>Activity</code>
所在的应用进程已经存在，<code>AMS</code>
会将启动请求发送给对应的进程；如果进程不存在，<code>AMS</code> 会通过
<code>Zygote</code> 启动一个新的进程。</p></li>
<li><p><strong>通过 Binder 通知 ActivityThread 启动 Activity</strong>：
<code>AMS</code> 通过 <code>ApplicationThreadProxy</code>（应用进程的
Binder 接口）向应用的 <code>ActivityThread</code> 发送启动 Activity
的请求。</p></li>
<li><p><strong>ActivityThread 创建 Activity 并启动</strong>： 应用进程的
<code>ActivityThread</code> 收到请求后，会调用
<code>Instrumentation</code> 创建目标 Activity，并执行 Activity
的生命周期方法（如
<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> &#123;</span><br><span class="line">    <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> performLaunchActivity(r, customIntent);</span><br><span class="line">    activity.performResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="activity-的生命周期管理">2. <strong>Activity
的生命周期管理</strong></h4>
<p><code>AMS</code> 负责管理每个 Activity 的生命周期状态。当应用的
Activity 切换、暂停或销毁时，<code>AMS</code>
会调度相应的生命周期方法。</p>
<ol type="1">
<li><p><strong>启动生命周期</strong>： 在 Activity
启动时，<code>AMS</code> 会调度应用进程的 <code>ActivityThread</code>
调用 Activity 的
<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>
方法。</p></li>
<li><p><strong>暂停和恢复生命周期</strong>： 当用户切换到另一个 Activity
时，<code>AMS</code> 会调用当前 Activity 的 <code>onPause()</code>
方法。随后，它会启动新的 Activity，并调用其 <code>onResume()</code>
方法。</p></li>
<li><p><strong>销毁生命周期</strong>： 当 <code>AMS</code> 检测到某个
Activity 不再需要时（如用户离开应用或内存不足时），它会调度
<code>ActivityThread</code> 调用 Activity 的 <code>onDestroy()</code>
方法，销毁该 Activity。</p></li>
</ol>
<h4 id="任务栈管理">3. <strong>任务栈管理</strong></h4>
<p><code>AMS</code> 使用 <strong>任务栈</strong>（Task Stack）来管理
Activity。每个任务栈代表一个任务，栈中的每个元素是一个
<code>Activity</code> 实例。任务栈以先进后出的方式管理 Activity。</p>
<ul>
<li><strong>前台任务栈</strong>：<code>AMS</code>
通过任务栈的堆栈结构管理用户当前正在使用的应用（即前台任务），栈顶的
Activity 是用户当前正在交互的 Activity。</li>
<li><strong>后台任务栈</strong>：不在前台显示的 Activity
会被放置到后台任务栈，<code>AMS</code> 可以通过回收内存来释放这些后台
Activity 的资源。</li>
</ul>
<p>每次 <code>AMS</code> 启动新的 Activity
时，都会将其压入栈中，当用户按下返回键时，会从任务栈中弹出顶层的
Activity 并销毁它。</p>
<h4 id="进程管理">4. <strong>进程管理</strong></h4>
<p><code>AMS</code> 还负责管理应用的进程，包括：</p>
<ul>
<li><strong>进程启动</strong>：当某个应用首次启动时，如果该应用的进程还未运行，<code>AMS</code>
会通过 <code>Zygote</code> 启动一个新的应用进程。</li>
<li><strong>进程优先级调整</strong>：根据进程中 Activity
的状态，<code>AMS</code>
会调整应用进程的优先级。例如，前台进程优先级高，而后台进程优先级低。</li>
<li><strong>内存回收</strong>：当系统内存不足时，<code>AMS</code>
会终止优先级较低的后台进程来回收内存。</li>
</ul>
<h4 id="处理-activity-异常">5. <strong>处理 Activity 异常</strong></h4>
<p>当某个 Activity 出现异常（如 ANR 或崩溃）时，<code>AMS</code>
负责检测并处理这些异常。</p>
<ul>
<li><strong>ANR（Application Not Responding）</strong>：当某个 Activity
在主线程中执行时间过长且未响应时，<code>AMS</code> 会触发 ANR
对话框，并允许用户选择强制关闭应用。</li>
<li><strong>崩溃处理</strong>：当应用进程崩溃时，<code>AMS</code>
会记录崩溃信息，并销毁相关的 Activity 或服务。</li>
</ul>
<h3 id="ams-与-wms-协同工作">4. <strong>AMS 与 WMS
协同工作</strong></h3>
<p><code>AMS</code> 与 <code>WindowManagerService</code>（WMS）协同管理
Activity 的界面显示和窗口管理。当一个 Activity
被启动时，<code>AMS</code> 会通知 <code>WMS</code>
创建一个窗口（<code>Window</code>），并将 Activity
的视图显示在该窗口中。</p>
<h4 id="窗口创建">1. <strong>窗口创建</strong>：</h4>
<p>当 <code>AMS</code> 启动一个 Activity 时，会通过 <code>Binder</code>
向 <code>WMS</code> 发送请求，要求它创建一个窗口用于显示该 Activity
的界面。</p>
<h4 id="窗口显示">2. <strong>窗口显示</strong>：</h4>
<p><code>WMS</code> 接收到 <code>AMS</code>
的请求后，会创建一个窗口，并将该窗口的句柄返回给 Activity。Activity 通过
<code>setContentView()</code>
设置自己的布局后，窗口就会被渲染在屏幕上。</p>
<h4 id="窗口切换">3. <strong>窗口切换</strong>：</h4>
<p>当用户在不同 Activity 之间切换时，<code>WMS</code>
会负责管理窗口的隐藏和显示。<code>AMS</code> 通知 <code>WMS</code> 当前
Activity 的显示或隐藏，<code>WMS</code> 相应地更新界面显示。</p>
<h3 id="ams-的任务栈和任务栈管理">5. <strong>AMS
的任务栈和任务栈管理</strong></h3>
<p><code>AMS</code> 中的任务栈（Task Stack）用来管理不同应用和 Activity
的执行顺序。任务栈是一个栈结构，栈顶的 Activity 是当前正在运行的
Activity。当用户启动新任务时，<code>AMS</code>
会创建一个新的任务栈或者向现有的任务栈中添加
Activity。任务栈的管理方式包括：</p>
<ul>
<li><strong>启动模式</strong>：Activity 的启动模式（如
<code>standard</code>、<code>singleTop</code>、<code>singleTask</code>、<code>singleInstance</code>）决定了
Activity 如何被添加到任务栈中。</li>
<li><strong>返回栈</strong>：当用户按下返回键时，当前任务栈中的 Activity
会被依次弹出，并销毁。</li>
</ul>
<h3 id="总结-4">总结</h3>
<p><code>ActivityManagerService</code> 是 Android 系统中负责管理
Activity、应用进程和任务栈的核心组件。它通过与
<code>ActivityThread</code>、<code>WindowManagerService</code>、<code>PackageManagerService</code>
等其他系统服务协作，管理 Activity
的启动、生命周期、任务栈以及异常处理。<code>AMS</code> 在整个 Android
系统架构中起着至关重要的作用，它确保了应用程序能够按照</p>
<p>正确的生命周期顺序进行操作，同时有效地管理系统资源和进程调度。</p>
<h2 id="activitythread工作原理">ActivityThread工作原理</h2>
<p><code>ActivityThread</code> 是 Android
中的一个关键类，它位于应用程序的主线程（UI
线程）中，负责管理应用的生命周期以及处理系统和应用之间的通信。<code>ActivityThread</code>
的主要职责是与
<code>AMS</code>（ActivityManagerService）进行交互，处理来自
<code>AMS</code> 的消息并调度 Activity、Service、BroadcastReceiver
等组件的生命周期方法。它可以被看作是应用程序主线程的控制中心。</p>
<h3 id="activitythread-的基本概述">1. <strong>ActivityThread
的基本概述</strong></h3>
<p><code>ActivityThread</code> 是 Android
应用进程中的核心类。它负责启动和管理应用程序的主线程，并调度执行
<code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>
等组件的生命周期回调。同时，它通过 <code>Handler</code>
机制与系统服务（如
<code>AMS</code>）进行通信，将来自系统的消息调度到应用层的相应组件。</p>
<p>在 Android 系统启动应用程序时，<code>ActivityThread</code>
类会启动主线程，创建主 <code>Looper</code> 和
<code>MessageQueue</code>，并通过消息驱动应用的各个组件执行。</p>
<h3 id="activitythread-的核心组件">2. <strong>ActivityThread
的核心组件</strong></h3>
<ul>
<li><strong><code>Looper</code> 和
<code>MessageQueue</code></strong>：<code>ActivityThread</code>
运行在应用程序的主线程中，主线程的执行是基于消息循环机制的。<code>ActivityThread</code>
会创建一个 <code>Looper</code> 和一个
<code>MessageQueue</code>，用于处理来自系统和应用内部的消息。</li>
<li><strong><code>Handler</code></strong>：<code>ActivityThread</code>
使用 <code>Handler</code> 来分发和处理消息。每当系统通过
<code>Binder</code> 向应用发送请求（如启动一个
<code>Activity</code>），这些请求都会被封装成消息，通过
<code>Handler</code> 分发到主线程处理。</li>
<li><strong><code>ApplicationThread</code></strong>：这是
<code>ActivityThread</code> 与 <code>AMS</code> 交互的 Binder
接口。<code>AMS</code> 通过 <code>ApplicationThread</code>
发送消息给应用进程，<code>ApplicationThread</code> 作为
<code>ActivityThread</code>
的内部类，充当应用程序和系统服务之间的桥梁。</li>
<li><strong><code>ActivityClientRecord</code></strong>：<code>ActivityThread</code>
中使用 <code>ActivityClientRecord</code> 来记录每个 Activity
的状态，包括它的生命周期状态、相关的
<code>Intent</code>、<code>Token</code> 等。</li>
</ul>
<h3 id="activitythread-的工作流程">3. <strong>ActivityThread
的工作流程</strong></h3>
<h4 id="启动流程">1. <strong>启动流程</strong></h4>
<p><code>ActivityThread</code> 是在应用启动时由 Zygote
进程创建的。当用户启动应用时，<code>Zygote</code> 进程 fork
出一个新的进程，并在新进程中启动 <code>ActivityThread</code>
的主线程。启动流程可以概括如下：</p>
<ol type="1">
<li><p><strong>Zygote 启动应用进程</strong>：
当应用被启动时，<code>ActivityManagerService</code> 通过
<code>Zygote</code> 创建一个新的应用进程。<code>Zygote</code> 负责 fork
出新的进程，并调用 <code>ActivityThread.main()</code>
方法来启动应用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>);  <span class="comment">// 与 AMS 绑定</span></span><br><span class="line">    Looper.loop();  <span class="comment">// 开启消息循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>创建 <code>ActivityThread</code> 实例</strong>：
<code>main()</code> 方法中会创建一个 <code>ActivityThread</code>
实例，并通过 <code>attach()</code> 方法与
<code>ActivityManagerService</code> 进行绑定，告知 <code>AMS</code>
该进程已经启动。</p></li>
<li><p><strong>绑定 <code>ApplicationThread</code></strong>：
<code>ActivityThread.attach()</code> 会通过
<code>ApplicationThread</code> 将该进程与 <code>AMS</code>
绑定，<code>AMS</code> 会通过 Binder
机制向该进程发送生命周期相关的消息。</p></li>
<li><p><strong>启动消息循环</strong>：
<code>ActivityThread.main()</code> 调用了
<code>Looper.loop()</code>，从此开始应用进程的消息循环。应用进程会不断从
<code>MessageQueue</code> 中读取消息，并通过 <code>Handler</code>
处理这些消息。</p></li>
</ol>
<h4 id="消息处理机制">2. <strong>消息处理机制</strong></h4>
<p><code>ActivityThread</code> 通过 <code>Handler</code> 来处理从
<code>AMS</code> 和其他系统服务发送来的消息，这些消息主要涉及
<code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>
的启动和生命周期管理。</p>
<ol type="1">
<li><p><strong>Handler 处理消息</strong>： <code>ActivityThread</code>
使用 <code>H</code> 类（继承自
<code>Handler</code>）处理不同类型的消息。每个消息会通过
<code>H.handleMessage()</code> 方法分发，<code>H</code>
类会根据消息类型调用对应的处理方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LAUNCH_ACTIVITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAUSE_ACTIVITY</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP_ACTIVITY</span> <span class="operator">=</span> <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> LAUNCH_ACTIVITY:</span><br><span class="line">                handleLaunchActivity((ActivityClientRecord) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PAUSE_ACTIVITY:</span><br><span class="line">                handlePauseActivity((IBinder) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOP_ACTIVITY:</span><br><span class="line">                handleStopActivity((IBinder) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 其他消息处理...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>生命周期消息处理</strong>： 当应用需要启动一个
<code>Activity</code> 时，<code>AMS</code> 会通过
<code>ApplicationThread</code>
将启动请求发送给应用进程。<code>ActivityThread</code>
收到消息后，会调用对应的生命周期方法（如
<code>handleLaunchActivity()</code>），执行 Activity
的创建、启动和显示。</p></li>
</ol>
<h4 id="activity-启动过程">3. <strong>Activity 启动过程</strong></h4>
<p>当应用需要启动一个新的 <code>Activity</code>
时，<code>ActivityThread</code> 负责执行该 <code>Activity</code>
的启动过程。具体步骤如下：</p>
<ol type="1">
<li><p><strong>收到启动 Activity 的消息</strong>：
<code>ActivityThread</code> 收到 <code>AMS</code> 通过
<code>ApplicationThread</code> 发来的 <code>LAUNCH_ACTIVITY</code>
消息。</p></li>
<li><p><strong>创建 Activity 实例</strong>：
<code>ActivityThread.handleLaunchActivity()</code> 方法首先会调用
<code>Instrumentation.newActivity()</code> 来创建 <code>Activity</code>
实例。<code>Instrumentation</code>
是一个用于监控应用组件生命周期的类，负责实际的 <code>Activity</code>
创建和生命周期管理。</p></li>
<li><p><strong>调用 Activity 生命周期</strong>： 在
<code>ActivityThread.performLaunchActivity()</code>
中，<code>Activity</code> 实例被创建后，<code>Activity</code> 的
<code>attach()</code>
方法会被调用，完成与窗口和上下文的绑定。接着，会调用
<code>Activity</code> 的 <code>onCreate()</code> 方法，开始执行 Activity
的初始化逻辑。</p></li>
<li><p><strong>显示 Activity</strong>： <code>Activity</code>
创建完成后，<code>ActivityThread</code> 会通过
<code>WindowManager</code> 将 <code>Activity</code>
的界面显示到屏幕上。</p></li>
</ol>
<h4 id="activity-生命周期管理">4. <strong>Activity
生命周期管理</strong></h4>
<p><code>ActivityThread</code> 负责管理 <code>Activity</code>
的生命周期，当应用的 <code>Activity</code>
状态发生变化时，<code>AMS</code> 会通过 <code>ApplicationThread</code>
将相应的生命周期事件通知
<code>ActivityThread</code>，例如暂停、停止、销毁等操作。</p>
<ol type="1">
<li><p><strong>暂停 Activity</strong>： 当用户切换到其他
<code>Activity</code> 或应用时，<code>AMS</code> 会通知
<code>ActivityThread</code> 调用 <code>Activity</code> 的
<code>onPause()</code> 方法来暂停当前 <code>Activity</code>。</p></li>
<li><p><strong>停止 Activity</strong>： 当 <code>AMS</code> 认为某个
<code>Activity</code> 不再需要显示时，会通知 <code>ActivityThread</code>
调用 <code>Activity</code> 的 <code>onStop()</code> 方法，停止该
<code>Activity</code>。</p></li>
<li><p><strong>销毁 Activity</strong>： 当某个 <code>Activity</code>
被销毁时，<code>AMS</code> 会发送销毁命令给
<code>ActivityThread</code>，<code>ActivityThread</code> 调用
<code>Activity</code> 的 <code>onDestroy()</code> 方法，销毁该
<code>Activity</code>，释放资源。</p></li>
</ol>
<h3 id="与其他系统服务的协作">4.
<strong>与其他系统服务的协作</strong></h3>
<p><code>ActivityThread</code> 通过 <code>ApplicationThread</code> 与
<code>ActivityManagerService</code>（AMS） 进行通信，协调管理
<code>Activity</code>、<code>Service</code> 和其他组件的生命周期。</p>
<ul>
<li><p><strong>与 <code>AMS</code> 的交互</strong>：
<code>ActivityThread</code> 通过 <code>ApplicationThread</code>
作为客户端接口与 <code>AMS</code> 进行交互。<code>AMS</code>
负责调度应用进程的生命周期事件，<code>ActivityThread</code>
接收到这些事件后，通知应用中的相应组件执行对应的生命周期方法。</p></li>
<li><p><strong>与 <code>WMS</code> 的交互</strong>：
<code>ActivityThread</code> 通过 <code>WindowManager</code> 与
<code>WindowManagerService</code> (WMS)
进行交互，管理应用界面的窗口显示和调整。每次启动新的
<code>Activity</code> 时，<code>ActivityThread</code> 都会请求
<code>WMS</code> 创建一个新的窗口来显示 <code>Activity</code>
的内容。</p></li>
</ul>
<h3 id="activitythread-的主要方法">5. <strong>ActivityThread
的主要方法</strong></h3>
<ul>
<li><strong><code>main()</code></strong>：应用进程的入口，负责启动
<code>ActivityThread</code>，并初始化 <code>Looper</code>
和消息队列。</li>
<li><strong><code>attach()</code></strong>：将应用进程与
<code>AMS</code> 进行绑定，建立进程间通信的通道。</li>
<li><strong><code>handleLaunchActivity()</code></strong>：处理
<code>Activity</code> 的启动流程，包括创建 <code>Activity</code>
实例、调用生命周期方法等。</li>
<li><strong><code>performLaunchActivity()</code></strong>：执行
<code>Activity</code> 的启动，包括调用
<code>onCreate()</code>、<code>onStart()</code> 等生命周期方法。</li>
<li><strong><code>handlePauseActivity()</code></strong>：处理
<code>Activity</code> 的暂停操作，调用 <code>onPause()</code>
方法。</li>
<li><strong><code>handleStopActivity()</code></strong>：处理
<code>Activity</code> 的停止操作，调用 <code>onStop()</code> 方法。</li>
<li><strong><code>handleDestroyActivity()</code></strong>：处理
<code>Activity</code> 的销毁操作，调用 <code>onDestroy()</code>
方法。</li>
</ul>
<h3 id="总结-5">6. <strong>总结</strong></h3>
<p><code>ActivityThread</code> 是 Android</p>
<p>应用进程中的核心类，负责管理
<code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>
的生命周期和 UI 线程的消息循环。通过与 <code>AMS</code>
的交互，它能够有效地调度应用的生命周期回调，并处理用户界面的显示和切换。<code>ActivityThread</code>
利用 <code>Handler</code>
机制，在主线程中调度和处理系统消息，保证了应用的正常运行。</p>
<h2 id="内存抖动是什么">内存抖动是什么</h2>
<p>内存抖动（Memory Churn 或 Memory
Thrashing）指的是程序在短时间内频繁地进行内存的分配和释放，导致大量的临时对象被频繁创建和销毁，进而导致垃圾回收器（GC）频繁运行，从而影响程序的性能。这种现象通常会导致应用程序出现性能下降、卡顿等问题。</p>
<h3 id="内存抖动的表现">内存抖动的表现</h3>
<ul>
<li><strong>频繁分配和释放内存</strong>：程序中有大量的临时对象被创建，但这些对象很快就不再被使用，导致它们很快被垃圾回收。</li>
<li><strong>垃圾回收频率增加</strong>：由于频繁创建和销毁对象，垃圾回收器需要频繁运行来回收不再使用的内存，GC
的频繁运行会导致程序暂停，从而影响性能。</li>
<li><strong>CPU 使用率增高</strong>：频繁的内存分配和回收会增加 CPU
的负担，导致 CPU 占用率增加。</li>
<li><strong>应用卡顿或掉帧</strong>：在 Android 或其他 UI
密集型应用中，内存抖动会导致 UI 卡顿或者掉帧，影响用户体验。</li>
</ul>
<h3 id="内存抖动的常见原因">内存抖动的常见原因</h3>
<ol type="1">
<li><strong>频繁创建短生命周期的对象</strong>：某些情况下，程序中会频繁创建一些生命周期很短的对象，比如循环中每次迭代都会创建新的对象，而这些对象会很快变为垃圾。</li>
<li><strong>集合类的使用不当</strong>：在集合类（如
<code>ArrayList</code>、<code>HashMap</code>
等）中频繁添加和删除元素，可能会导致大量对象的分配和释放，进而引发内存抖动。</li>
<li><strong>字符串拼接</strong>：频繁进行字符串拼接会创建大量的临时字符串对象，特别是在
Java 中，字符串是不可变的，拼接操作会不断创建新的对象。</li>
<li><strong>重复创建对象而不是重用</strong>：在某些场景下，程序会重复创建一些对象而不是复用它们，这会导致不必要的内存分配。</li>
</ol>
<h3 id="如何避免内存抖动">如何避免内存抖动</h3>
<ol type="1">
<li><p><strong>避免不必要的对象创建</strong>：尽量避免在短时间内频繁创建临时对象，可以考虑对象池技术来重用对象。</p></li>
<li><p><strong>使用更高效的集合类</strong>：根据需求选择合适的集合类，例如，在频繁访问或修改时，可以使用带有优化策略的集合类来减少内存开销。</p></li>
<li><p><strong>优化字符串操作</strong>：在频繁拼接字符串时，使用
<code>StringBuilder</code> 或 <code>StringBuffer</code>
来替代直接的字符串拼接操作，减少不必要的对象分配。</p></li>
<li><p><strong>避免过度依赖自动装箱/拆箱</strong>：自动装箱（auto-boxing）和拆箱（auto-unboxing）会创建额外的对象，特别是在频繁操作基本数据类型时，应该尽量使用基本数据类型而不是包装类。</p></li>
<li><p><strong>优化算法</strong>：检查程序中的算法是否有优化的空间，避免不必要的对象创建和销毁。</p></li>
</ol>
<h3 id="内存抖动对性能的影响">内存抖动对性能的影响</h3>
<p>内存抖动可能导致应用程序的响应速度变慢，尤其是对于实时性要求较高的应用，如游戏或多媒体应用。频繁的垃圾回收不仅会消耗系统资源，还会导致程序在
GC 过程中暂停，造成应用的卡顿现象。</p>
<h3 id="内存抖动的检测">内存抖动的检测</h3>
<p>在 Android 和 Java
应用中，开发者可以使用各种性能分析工具来检测内存抖动，例如：</p>
<ul>
<li><strong>Android Studio
Profiler</strong>：可以帮助开发者监控内存分配情况，查看对象的创建和销毁频率，找到潜在的内存抖动问题。</li>
<li><strong>MAT (Memory Analyzer Tool)</strong>：可以用于分析 Java
应用的堆内存，检查内存使用情况，找到潜在的内存抖动源。</li>
</ul>
<p>通过这些工具，开发者可以识别程序中频繁创建的对象，优化代码以减少内存抖动。</p>
<h2 id="android系统启动流程是什么">Android系统启动流程是什么</h2>
<p>Android系统的启动流程可以分为以下几个主要阶段，从设备加电到启动应用的过程如下：</p>
<h3 id="bootloader阶段">1. <strong>Bootloader阶段</strong></h3>
<ul>
<li><strong>加电</strong>：当设备加电时，系统从固件（Bootloader）开始启动。Bootloader负责初始化硬件和加载内核，它是系统启动的第一步。</li>
<li><strong>Bootloader初始化</strong>：Bootloader会进行一些硬件初始化工作，例如内存、处理器、时钟等硬件资源的配置。然后，它会查找操作系统内核并将其加载到内存中。</li>
<li><strong>启动内核</strong>：一旦内核被加载，Bootloader会将控制权交给内核，开始执行内核代码。</li>
</ul>
<h3 id="linux内核启动阶段">2. <strong>Linux内核启动阶段</strong></h3>
<ul>
<li><strong>内核初始化</strong>：Android系统基于Linux内核。内核启动时，会初始化系统的核心组件，包括内存管理、进程管理、文件系统、网络等。在这一步中，内核会设置设备树（Device
Tree）并识别设备的硬件信息。</li>
<li><strong>启动init进程</strong>：内核完成基本的初始化之后，会启动第一个用户空间进程
<code>init</code>。<code>init</code> 是 Android
系统的第一个用户态进程，进程号为 1。</li>
</ul>
<h3 id="init进程启动阶段">3. <strong>Init进程启动阶段</strong></h3>
<ul>
<li><strong>解析init.rc文件</strong>：<code>init</code> 进程会根据
<code>init.rc</code>
文件的配置启动系统的服务和进程。<code>init.rc</code>
文件定义了系统的服务、文件系统挂载、属性设置等重要配置。</li>
<li><strong>启动Zygote进程</strong>：<code>init</code> 进程会启动 Zygote
进程，Zygote 是 Android 系统中非常重要的一个进程，它负责初始化 Java
虚拟机（JVM）并加载核心的 Android 类库。几乎所有的应用进程都是由 Zygote
派生出来的。</li>
</ul>
<h3 id="zygote和system-server启动阶段">4. <strong>Zygote和System
Server启动阶段</strong></h3>
<ul>
<li><strong>启动Zygote</strong>：Zygote
进程启动后，它会预加载一些系统常用的类和资源，并开始监听特定的
socket，等待启动新的应用进程。</li>
<li><strong>启动System Server</strong>：Zygote
还会启动一个非常重要的进程——<code>System Server</code>，它负责启动并管理
Android 的系统服务。System Server 会启动一些关键的系统服务，如 Activity
Manager、Package Manager、Window Manager 等。</li>
</ul>
<h3 id="启动android-runtime-art">5. <strong>启动Android Runtime
(ART)</strong></h3>
<ul>
<li><strong>ART初始化</strong>：Zygote 启动后，Android
Runtime（ART）环境会被初始化。ART 是 Android
用来执行和管理应用的运行时环境，负责字节码的转换和执行。</li>
</ul>
<h3 id="启动launcher和应用进程">6.
<strong>启动Launcher和应用进程</strong></h3>
<ul>
<li><strong>启动Launcher</strong>：在系统服务启动完成后，<code>Activity Manager</code>
会启动 Launcher
应用，这是用户界面的主屏幕，也是用户启动其他应用的入口。</li>
<li><strong>启动应用进程</strong>：当用户点击应用时，Launcher 会向
Zygote 发起请求，Zygote 会 fork
一个新的进程，生成应用进程。在这个新的进程中，ART
会加载应用的类并执行。</li>
</ul>
<h3 id="总结-6">总结：</h3>
<ol type="1">
<li><strong>Bootloader</strong>：初始化硬件，加载内核。</li>
<li><strong>内核</strong>：初始化系统资源，启动 init 进程。</li>
<li><strong>Init进程</strong>：解析配置，启动 Zygote 和 System
Server。</li>
<li><strong>Zygote</strong>：启动 Android Runtime (ART) 和 System
Server。</li>
<li><strong>Launcher</strong>：系统界面显示，用户可以启动应用。</li>
</ol>
<p>每一步都承担着不同的角色，最终目的是让 Android
系统能够顺利地加载并运行用户的应用。</p>
<h2 id="app启动流程">App启动流程</h2>
<p>Android应用程序（App）的启动过程可以分为多个阶段，从用户点击应用图标到应用界面显示的过程涉及多个组件。以下是Android应用启动流程的详细说明：</p>
<h3 id="用户点击应用图标">1. <strong>用户点击应用图标</strong></h3>
<p>当用户点击应用图标时，Launcher（启动器）应用会发起启动应用的请求。这个请求会通过
<strong>Activity Manager</strong> 传递到系统层，进入应用启动流程。</p>
<h3 id="launcher请求启动应用">2.
<strong>Launcher请求启动应用</strong></h3>
<ul>
<li><strong>向Activity
Manager发送Intent</strong>：当用户点击应用图标后，Launcher 向
<code>ActivityManagerService</code> (AMS) 发送一个带有应用启动信息的
<code>Intent</code>。这个 <code>Intent</code>
通常包含应用包名以及要启动的 <code>Activity</code> 信息。</li>
<li><strong>Activity Manager 检查应用状态</strong>：AMS
检查该应用是否已经运行。如果应用已经在后台运行，则直接将应用切换到前台；如果应用还没有启动，AMS
将会启动一个新的应用进程。</li>
</ul>
<h3 id="zygote进程派生应用进程">3.
<strong>Zygote进程派生应用进程</strong></h3>
<ul>
<li><strong>启动新的应用进程</strong>：如果应用还没有进程在运行，AMS
会通过与 <code>Zygote</code> 进程通信，请求 Zygote
fork（派生）一个新的进程。这是因为 Android 的所有应用进程都是由 Zygote
fork 出来的，这样可以共享系统的类库和资源，减少启动时间和内存占用。</li>
<li><strong>创建新进程</strong>：Zygote fork
新进程后，新进程会通过反射机制，启动应用的入口类（通常是
<code>ActivityThread</code>）。</li>
</ul>
<h3 id="activitythread启动">4. <strong>ActivityThread启动</strong></h3>
<ul>
<li><strong>ActivityThread的启动</strong>：新应用进程启动后，Zygote fork
出来的新进程会调用 <code>ActivityThread</code> 类的 <code>main()</code>
方法，开始初始化应用的主线程。<code>ActivityThread</code>
是应用进程的主类，它负责管理应用的主线程、处理 UI 操作、管理 Activity
的生命周期等。</li>
<li><strong>建立主线程Looper</strong>：<code>ActivityThread</code>
初始化时，会创建一个 <code>Looper</code>，它是 Android
的消息循环机制，主线程中的所有消息都会在这个 Looper 中处理。</li>
</ul>
<h3 id="activity的启动">5. <strong>Activity的启动</strong></h3>
<ul>
<li><strong>AMS通知启动Activity</strong>：AMS 在新进程准备好后，会通过
<code>Binder</code> 通信机制通知应用进程，要求启动具体的
<code>Activity</code>。AMS 会调用 <code>ApplicationThread</code> 的
<code>scheduleLaunchActivity()</code> 方法来完成通知工作。</li>
<li><strong>创建Activity实例</strong>：<code>ActivityThread</code>
收到启动 <code>Activity</code> 的消息后，会调用
<code>performLaunchActivity()</code> 方法，创建目标
<code>Activity</code> 的实例，并调用它的 <code>onCreate()</code>
方法。</li>
</ul>
<h3 id="activity生命周期方法调用">6.
<strong>Activity生命周期方法调用</strong></h3>
<ul>
<li><strong>onCreate()</strong>：<code>Activity</code>
的实例创建后，系统会首先调用 <code>onCreate()</code> 方法。这个方法是
<code>Activity</code>
生命周期的第一步，通常在这里完成界面布局的初始化、数据的加载以及组件的绑定等工作。</li>
<li><strong>onStart()</strong> 和
<strong>onResume()</strong>：<code>onCreate()</code>
方法执行完毕后，<code>Activity</code> 的 <code>onStart()</code> 和
<code>onResume()</code> 方法也会被依次调用。在 <code>onResume()</code>
中，<code>Activity</code> 将进入前台，并与用户开始交互。</li>
</ul>
<h3 id="view的渲染">7. <strong>View的渲染</strong></h3>
<ul>
<li><strong>View的绘制</strong>：在 <code>onCreate()</code>
方法中，<code>Activity</code> 通常会调用 <code>setContentView()</code>
方法加载布局资源（XML文件），创建界面上的视图层次结构。这个过程通过
<code>LayoutInflater</code> 将 XML 布局文件解析为相应的视图对象。</li>
<li><strong>SurfaceFlinger</strong>：当 <code>Activity</code>
的视图层次结构完成后，系统会通过 <code>WindowManager</code>
将这些视图提交给底层的 <code>SurfaceFlinger</code>
进行显示。<code>SurfaceFlinger</code> 是 Android
的图形渲染引擎，它负责将所有应用窗口的图像合成并显示在屏幕上。</li>
</ul>
<h3 id="用户界面显示">8. <strong>用户界面显示</strong></h3>
<ul>
<li><strong>最终显示</strong>：经过前面一系列的初始化和渲染过程，<code>Activity</code>
的界面会最终呈现给用户，此时应用进入可交互状态，用户可以开始操作应用的界面。</li>
</ul>
<h3 id="总结-7">总结：</h3>
<ol type="1">
<li><strong>用户点击图标</strong>：Launcher 向 AMS 发送启动请求。</li>
<li><strong>AMS
检查应用状态</strong>：决定是切换到前台还是启动新的进程。</li>
<li><strong>Zygote fork 新进程</strong>：通过 Zygote fork
创建应用进程。</li>
<li><strong>ActivityThread
初始化</strong>：启动主线程，准备消息循环。</li>
<li><strong>创建Activity</strong>：AMS 通知应用启动
<code>Activity</code>，调用生命周期方法。</li>
<li><strong>界面渲染</strong>：加载布局，View
被绘制，最终显示到屏幕。</li>
</ol>
<p>这个流程确保了 Android
应用的快速启动，同时保证了内存和资源的有效利用。</p>
<h2 id="wms是如何管理window的">WMS是如何管理Window的</h2>
<p>在Android系统中，<strong>WindowManagerService (WMS)</strong>
是一个非常重要的系统服务，负责管理所有应用和系统窗口的显示。它控制着应用窗口的创建、布局、显示、和删除等操作。以下是WMS管理Window的主要过程和机制：</p>
<h3 id="窗口的分类">1. <strong>窗口的分类</strong></h3>
<p>在Android中，窗口主要有以下几种类型：</p>
<ul>
<li><strong>应用窗口</strong>（Application
Window）：由普通应用创建的窗口，通常是由<code>Activity</code>通过<code>setContentView()</code>加载布局来创建。</li>
<li><strong>子窗口</strong>（Sub-Window）：依附于主窗口的窗口，比如<code>Dialog</code>。</li>
<li><strong>系统窗口</strong>（System
Window）：系统级别的窗口，比如状态栏、导航栏、输入法窗口等。</li>
</ul>
<h3 id="窗口的创建过程">2. <strong>窗口的创建过程</strong></h3>
<ul>
<li><p><strong>应用向WMS请求创建窗口</strong>：当应用启动并创建<code>Activity</code>时，<code>Activity</code>通过<code>WindowManager</code>来向
<code>WindowManagerService</code> (WMS)
请求创建一个窗口。这个请求实际上是通过<code>WindowManagerGlobal</code>的<code>addView()</code>方法提交的。</p></li>
<li><p><strong>WMS
接收并处理请求</strong>：<code>WindowManagerGlobal</code>
会通过Binder机制与<code>WindowManagerService</code>通信。WMS接收到创建窗口的请求后，验证窗口类型、权限等信息，接着为窗口分配一个<code>WindowToken</code>，并把窗口信息加入到WMS的管理列表中。</p></li>
<li><p><strong>Surface的创建</strong>：<code>WMS</code>
在接受窗口请求后，会为窗口创建一个对应的<code>Surface</code>，这是实际用于绘制内容的地方。<code>Surface</code>
是通过<code>SurfaceFlinger</code>来管理的，它负责最终的窗口显示和图形合成。</p></li>
<li><p><strong>窗口的添加和排列</strong>：WMS会将新的窗口添加到系统中的窗口列表中，并根据窗口类型、层级和Z-order（Z轴的顺序）来确定窗口的显示顺序。例如，状态栏窗口永远在最顶层，应用窗口在状态栏下面。</p></li>
</ul>
<h3 id="窗口的管理和布局">3. <strong>窗口的管理和布局</strong></h3>
<ul>
<li><p><strong>布局计算</strong>：WMS负责计算每个窗口在屏幕上的位置和大小。当窗口被添加或窗口尺寸发生变化时，WMS会重新计算窗口的布局。布局计算包括窗口的坐标、大小、显示的层级等。</p></li>
<li><p><strong>使用<code>WindowState</code>记录窗口状态</strong>：每个窗口在WMS中都有一个对应的<code>WindowState</code>对象。这个对象存储了窗口的各种状态信息，比如位置、大小、是否可见、是否需要重新绘制等。WMS通过维护所有<code>WindowState</code>对象来管理系统中的所有窗口。</p></li>
<li><p><strong>窗口层级的管理</strong>：Android窗口的层级管理基于Z-order，即不同类型的窗口有不同的层级。比如应用窗口的层级一般比系统窗口低，而对话框、输入法窗口等可能会显示在应用窗口的上方。WMS会根据窗口的类型和需求来调整窗口的层级顺序。</p></li>
</ul>
<h3 id="窗口的绘制和显示">4. <strong>窗口的绘制和显示</strong></h3>
<ul>
<li><p><strong>SurfaceFlinger负责窗口合成</strong>：WMS只是负责窗口的管理和布局，但实际的窗口绘制和图像合成是由<code>SurfaceFlinger</code>完成的。WMS在窗口布局完成后，会将窗口对应的<code>Surface</code>交给<code>SurfaceFlinger</code>，由它负责将各个窗口的内容合成为一张最终的图像并显示到屏幕上。</p></li>
<li><p><strong>刷新和重绘</strong>：当窗口的内容发生变化（比如界面更新，用户操作等），WMS会通知相应的<code>WindowState</code>，要求它重新绘制。在绘制完成后，<code>SurfaceFlinger</code>会接收到新的窗口内容，并重新进行图像合成，最终更新到屏幕上。</p></li>
</ul>
<h3 id="窗口的焦点管理">5. <strong>窗口的焦点管理</strong></h3>
<ul>
<li><p><strong>焦点窗口</strong>：WMS负责管理系统中焦点窗口的分配。焦点窗口是指当前接收用户输入的窗口，通常是用户正在与之交互的应用窗口。WMS会根据窗口的优先级、可见性和类型等条件决定哪个窗口可以获得焦点。</p></li>
<li><p><strong>焦点切换</strong>：当用户切换应用、弹出对话框或者窗口发生变化时，WMS会处理焦点切换，确保新的焦点窗口能够正确接收到输入事件。</p></li>
</ul>
<h3 id="窗口的移除">6. <strong>窗口的移除</strong></h3>
<ul>
<li><p><strong>应用请求关闭窗口</strong>：当应用不再需要一个窗口时，通常会调用<code>WindowManager</code>的<code>removeView()</code>方法来移除窗口。这个请求会通过Binder传递给WMS。</p></li>
<li><p><strong>WMS移除窗口</strong>：WMS接收到移除窗口的请求后，会将窗口从内部的管理列表中移除，并释放对应的资源（比如<code>Surface</code>和<code>WindowToken</code>）。如果这个窗口是焦点窗口，WMS还会重新分配焦点给其他窗口。</p></li>
</ul>
<h3 id="窗口动画">7. <strong>窗口动画</strong></h3>
<ul>
<li><strong>窗口的动画处理</strong>：WMS还负责处理窗口的显示、隐藏、缩放等动画效果。当窗口被添加、移除或改变大小时，WMS会触发窗口动画，以提供更平滑的用户体验。这些动画通常通过<code>Surface</code>的变换来实现，最终由<code>SurfaceFlinger</code>合成到屏幕上。</li>
</ul>
<h3 id="输入事件的分发">8. <strong>输入事件的分发</strong></h3>
<ul>
<li><p><strong>事件分发的管理</strong>：WMS还负责管理输入事件的分发。系统中的输入事件（如触摸、按键）首先会传递给WMS，然后WMS会根据窗口的焦点状态和区域来决定将事件分发给哪个窗口的应用。</p></li>
<li><p><strong>确保正确的窗口接收输入</strong>：当用户点击屏幕时，WMS会根据点击位置查找对应的窗口，并将点击事件分发给该窗口。如果窗口不在焦点上或被覆盖，事件不会被传递给它。</p></li>
</ul>
<h3 id="总结-8">总结：</h3>
<p>WMS 作为 Android 系统中的核心服务，主要通过以下几方面管理窗口：</p>
<ol type="1">
<li><strong>窗口创建与销毁</strong>：通过接收应用或系统请求创建、添加或移除窗口。</li>
<li><strong>窗口布局和层级管理</strong>：计算窗口的位置、大小，并确定它的显示顺序。</li>
<li><strong>窗口显示和绘制</strong>：通过与<code>SurfaceFlinger</code>协作来完成窗口内容的渲染。</li>
<li><strong>焦点管理</strong>：决定哪个窗口可以接收用户输入，并处理焦点的切换。</li>
<li><strong>事件分发</strong>：管理输入事件的分发，确保用户操作能够正确传递到窗口。</li>
</ol>
<p>通过这些机制，WMS确保了Android系统中多窗口的正常运行、显示和交互。</p>
<h2 id="rxjava的实现原理">RxJava的实现原理</h2>
<h3 id="rxjava概述">RxJava概述</h3>
<p><strong>RxJava</strong> 是一个基于 <strong>ReactiveX</strong>
的响应式编程库，它将异步和事件驱动编程抽象为基于流的操作，使用
<strong>Observable</strong>、<strong>Observer</strong>、<strong>Scheduler</strong>
和其他核心组件来管理数据流和事件流。它能够让程序员以更简洁的方式处理异步操作，避免回调地狱，提升代码的可读性和维护性。</p>
<p>RxJava 的核心是
<code>Observable</code>，它发射一系列的数据，<code>Observer</code> 订阅
<code>Observable</code>，以响应 <code>Observable</code>
发射的每个数据项。通过运算符，开发者可以轻松地对数据流进行转换、过滤、合并等操作。</p>
<h3 id="rxjava的核心组件">RxJava的核心组件</h3>
<ul>
<li><strong>Observable</strong>：数据源，它发射一系列数据，<code>Observable</code>
可以是有限的或无限的。</li>
<li><strong>Observer</strong>：观察者，接收由 <code>Observable</code>
发射的每一个数据。</li>
<li><strong>Scheduler</strong>：调度器，用于指定在哪个线程中执行
<code>Observable</code> 和 <code>Observer</code> 的工作。</li>
</ul>
<h3 id="rxjava-的实现基于以下关键思想">RxJava
的实现基于以下关键思想：</h3>
<h4 id="observable和observer模式">1.
<strong>Observable和Observer模式</strong></h4>
<p>RxJava 的基本机制是
<strong>观察者模式</strong>，<code>Observable</code> 是可观察的对象，而
<code>Observer</code> 是观察者。当 <code>Observable</code>
发射数据时，它会通知所有订阅它的
<code>Observer</code>，<code>Observer</code>
会做出相应的反应。基本流程如下：</p>
<ul>
<li><code>Observable</code> 发射数据。</li>
<li><code>Observer</code> 订阅 <code>Observable</code>，并通过
<code>onNext()</code> 接收数据，<code>onError()</code>
处理错误，<code>onComplete()</code> 处理完成事件。</li>
</ul>
<h4 id="链式操作符和装饰者模式">2.
<strong>链式操作符和装饰者模式</strong></h4>
<p>RxJava 中的操作符（如
<code>map()</code>、<code>flatMap()</code>、<code>filter()</code>
等）通常用于转换或过滤数据流。这些操作符通过链式调用组合在一起，每个操作符会返回一个新的
<code>Observable</code>，但并不会立刻执行，直到有 <code>Observer</code>
订阅了链条上的 <code>Observable</code>。</p>
<p>内部实现使用了
<strong>装饰者模式</strong>。每个操作符实际上都是在现有的
<code>Observable</code> 上添加一层装饰，创建一个新的
<code>Observable</code>，通过这种方式逐步处理数据流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">          .map(i -&gt; i * <span class="number">2</span>)</span><br><span class="line">          .filter(i -&gt; i &gt; <span class="number">2</span>)</span><br><span class="line">          .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，每个操作符创建一个新的 <code>Observable</code>
实例，直到调用 <code>subscribe()</code>
时，才会执行整个链条，<code>Observable</code>
会发射转换后的数据给订阅者。</p>
<h4 id="schedulers和线程控制">3.
<strong>Schedulers和线程控制</strong></h4>
<p>RxJava 中引入了 <strong>Schedulers</strong>
来管理多线程操作，它提供了灵活的方式去控制代码的执行线程。RxJava
提供了几种常见的 <code>Scheduler</code>：</p>
<ul>
<li><strong>Schedulers.io()</strong>：用于I/O操作，如网络请求、文件操作等，背后是一个线程池。</li>
<li><strong>Schedulers.computation()</strong>：用于计算密集型工作，背后也是线程池。</li>
<li><strong>Schedulers.newThread()</strong>：每次都会创建一个新线程。</li>
<li><strong>AndroidSchedulers.mainThread()</strong>：在 Android
环境下，确保代码在主线程执行。</li>
</ul>
<p>例如，通过 <code>subscribeOn()</code> 和 <code>observeOn()</code>
操作符，可以指定 <code>Observable</code> 的数据发射线程和
<code>Observer</code> 的数据处理线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">          .subscribeOn(Schedulers.io())</span><br><span class="line">          .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">          .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>subscribeOn(Schedulers.io())</code>：指定
<code>Observable</code> 在 I/O 线程中运行。</li>
<li><code>observeOn(AndroidSchedulers.mainThread())</code>：指定
<code>Observer</code> 在 Android 主线程中运行，确保 UI
更新在主线程进行。</li>
</ul>
<h2 id="背压问题及其解决方案">背压问题及其解决方案</h2>
<h3 id="什么是背压backpressure">1.
<strong>什么是背压（Backpressure）？</strong></h3>
<p><strong>背压</strong>
问题是指在异步流处理中，数据生产者（<code>Observable</code>）的生产速度快于数据消费者（<code>Observer</code>）的消费速度，导致事件堆积，内存压力增大，甚至可能导致系统崩溃。</p>
<p>RxJava 中的 <code>Observable</code>
是无限制地发射数据的，特别是当使用 <code>Observable.interval()</code> 或
<code>Observable.fromIterable()</code> 时，可能会快速产生大量数据。如果
<code>Observer</code> 处理速度较慢，而 <code>Observable</code>
发射数据过快，系统的缓冲区可能会被填满，造成背压问题。</p>
<h3 id="背压的应对方案">2. <strong>背压的应对方案</strong></h3>
<p>为了解决背压问题，RxJava 提供了两种类型的 <code>Observable</code>
来处理背压：<code>Observable</code> 和 <code>Flowable</code>。</p>
<ul>
<li><strong>Observable</strong>：不支持背压处理，如果使用它而生产速度过快会导致数据丢失或缓冲区溢出。</li>
<li><strong>Flowable</strong>：支持背压处理，可以根据消费能力控制数据的发射速率。<code>Flowable</code>
是基于 <code>Reactive Streams</code>
规范实现的，允许消费者向生产者请求一定数量的数据，从而避免生产者发射过多数据。</li>
</ul>
<h3 id="flowable-背压模式">3. <strong>Flowable 背压模式</strong></h3>
<p><code>Flowable</code> 支持多种背压策略，以应对不同的背压场景：</p>
<ol type="1">
<li><p><strong>BUFFER</strong>：无限制缓冲所有未被处理的数据，直到内存耗尽。用于数据量较小时的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .onBackpressureBuffer()</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>DROP</strong>：当消费者来不及处理时，丢弃后续产生的数据，直到消费者可以处理为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .onBackpressureDrop()</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>LATEST</strong>：只保留最新的一条数据，当消费者准备好时，只接收最后发射的数据，其他数据会被丢弃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .onBackpressureLatest()</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>ERROR</strong>：当出现背压问题时抛出
<code>MissingBackpressureException</code>，这是最严格的模式，确保程序员能明确知道背压问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .onBackpressureError()</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="flowable请求数量管理">4.
<strong>Flowable请求数量管理</strong></h3>
<p><code>Flowable</code> 使用了一种 <strong>请求机制</strong>
来解决背压问题，消费者可以通过 <code>request()</code>
方法明确告诉生产者需要多少数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">                                      .onBackpressureDrop();</span><br><span class="line">flowable.subscribe(<span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line">        s.request(<span class="number">10</span>);  <span class="comment">// 请求 10 个数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received: &quot;</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Subscriber</code> 通过 <code>s.request(10)</code>
向 <code>Flowable</code> 请求10个数据，<code>Flowable</code>
会根据请求数量控制发射速率，从而避免背压问题。</p>
<h3 id="总结-9">总结</h3>
<ol type="1">
<li><p><strong>RxJava 实现原理</strong>：基于观察者模式，使用
<code>Observable</code> 发射数据，<code>Observer</code>
订阅并处理数据，操作符通过链式调用实现数据流的转换和处理。<code>Scheduler</code>
用于管理线程。</p></li>
<li><p><strong>背压问题</strong>：当数据生产者发射数据的速度快于消费者处理数据的速度时，会产生背压问题，可能导致内存溢出或数据丢失。</p></li>
<li><p><strong>背压解决方案</strong>：RxJava 提供了
<code>Flowable</code>
以及多种背压策略（BUFFER、DROP、LATEST、ERROR）来应对生产和消费速度不匹配的问题。</p></li>
</ol>
<h2 id="map-和-flatmap">map 和 flatMap</h2>
<p><code>RxJava</code>
是一种基于异步编程和事件驱动的响应式编程框架，广泛用于 Android 和 Java
开发中。在 <code>RxJava</code> 中，<code>map</code> 和
<code>flatMap</code>
是两个常见的操作符，用于对数据流进行转换，但它们的用途和功能略有不同。</p>
<h3 id="map-操作符">1. <code>map</code> 操作符</h3>
<p><strong><code>map</code></strong>
操作符用于将一个类型的流数据转换为另一种类型的流数据。它是一个一对一的转换操作符，即对于每个输入数据，<code>map</code>
生成一个对应的输出数据。</p>
<h4 id="工作原理">工作原理：</h4>
<ul>
<li><code>map</code> 操作符接收一个 <code>Function&lt;T, R&gt;</code>
函数，该函数接受一个类型 <code>T</code> 的输入，返回一个类型
<code>R</code> 的输出。</li>
<li>每当源 <code>Observable</code> 发出一个数据项时，<code>map</code>
就会应用这个函数，将数据项转换为新的数据类型，然后将转换后的数据项发射给下游。</li>
</ul>
<h4 id="示例">示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">observable.map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Number &quot;</span> + integer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number 1</span><br><span class="line">Number 2</span><br><span class="line">Number 3</span><br><span class="line">Number 4</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里，<code>map</code>
将整数转换为字符串，但依旧保持数据项的一对一对应关系。</li>
</ul>
<h3 id="flatmap-操作符">2. <code>flatMap</code> 操作符</h3>
<p><strong><code>flatMap</code></strong> 操作符与 <code>map</code>
类似，也用于将数据转换为另一种形式。但 <code>flatMap</code>
不再是一对一的转换，它可以将每个输入的元素转换为一个
<code>Observable</code>，并将所有这些 <code>Observable</code>
合并成一个单一的 <code>Observable</code> 流。</p>
<h4 id="工作原理-1">工作原理：</h4>
<ul>
<li><code>flatMap</code> 接收一个
<code>Function&lt;T, ObservableSource&lt;R&gt;&gt;</code>
函数，这个函数将输入的类型 <code>T</code> 转换为一个新的
<code>ObservableSource&lt;R&gt;</code>。</li>
<li><code>flatMap</code> 生成的多个 <code>Observable</code>
会被“扁平化”（flatten）成单一的流，所有这些 <code>Observable</code>
的数据会被合并并发射给下游。</li>
</ul>
<h4 id="示例-1">示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">observable.flatMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;String&gt; <span class="title function_">apply</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(<span class="string">&quot;Number &quot;</span> + integer, <span class="string">&quot;Square &quot;</span> + (integer * integer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Number 1</span><br><span class="line">Square 1</span><br><span class="line">Number 2</span><br><span class="line">Square 4</span><br><span class="line">Number 3</span><br><span class="line">Square 9</span><br><span class="line">Number 4</span><br><span class="line">Square 16</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在这个例子中，<code>flatMap</code> 将每个整数转换为两个字符串的
<code>Observable</code>，并将它们扁平化合并为一个单一的流。</li>
</ul>
<h3 id="区别总结">3. 区别总结</h3>
<ul>
<li><strong>转换关系</strong>：
<ul>
<li><code>map</code>
是<strong>一对一</strong>的转换，每个源数据只生成一个输出数据。</li>
<li><code>flatMap</code>
是<strong>一对多</strong>或<strong>多对多</strong>的转换，每个源数据可以生成多个输出数据，并将这些数据合并成单一的流。</li>
</ul></li>
<li><strong>输出类型</strong>：
<ul>
<li><code>map</code> 将输入数据转换为单一的其他类型数据。</li>
<li><code>flatMap</code> 将输入数据转换为
<code>Observable</code>，然后合并多个 <code>Observable</code>
的输出。</li>
</ul></li>
<li><strong>合并方式</strong>：
<ul>
<li><code>map</code> 不会涉及合并，直接一对一地转换。</li>
<li><code>flatMap</code> 将多个 <code>Observable</code> 合并为一个
<code>Observable</code>，且通常是无序的。</li>
</ul></li>
<li><strong>使用场景</strong>：
<ul>
<li><code>map</code> 适用于简单的单一转换，比如数据格式的转换。</li>
<li><code>flatMap</code>
适用于嵌套的异步操作，比如当你需要根据一个结果发起一个新的异步请求，并将所有的请求结果合并。</li>
</ul></li>
</ul>
<h3 id="flatmap-和-concatmap-的对比">4. <code>flatMap</code> 和
<code>concatMap</code> 的对比</h3>
<ul>
<li><code>flatMap</code> 发出的 <code>Observable</code>
是<strong>无序</strong>的，数据项的顺序可能会打乱。</li>
<li>如果你需要保持发射顺序，可以使用
<code>concatMap</code>，它会按顺序将每个 <code>Observable</code>
合并。</li>
</ul>
<h4 id="concatmap-示例"><code>concatMap</code> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">observable.concatMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;String&gt; <span class="title function_">apply</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(<span class="string">&quot;Number &quot;</span> + integer, <span class="string">&quot;Square &quot;</span> + (integer * integer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Number 1</span><br><span class="line">Square 1</span><br><span class="line">Number 2</span><br><span class="line">Square 4</span><br><span class="line">Number 3</span><br><span class="line">Square 9</span><br><span class="line">Number 4</span><br><span class="line">Square 16</span><br></pre></td></tr></table></figure></p>
<p>在这里，<code>concatMap</code> 保持了发射的顺序，而
<code>flatMap</code> 则可能导致顺序不一致。</p>
<h3 id="总结-10">总结</h3>
<ul>
<li><strong><code>map</code></strong>
适用于一对一转换，将每个输入数据转换为一个输出数据。</li>
<li><strong><code>flatMap</code></strong>
适用于将输入数据转换为多个数据流，并将这些数据流合并成一个单一的数据流。</li>
<li><code>flatMap</code> 适合处理异步操作，比如网络请求的嵌套调用，而
<code>map</code> 则适合简单的类型转换。</li>
</ul>
<h2 id="zip-操作符">zip 操作符</h2>
<p><code>zip</code> 操作符是 RxJava
中一个非常有用的组合操作符，用于将多个 <code>Observable</code> 或
<code>Flowable</code> 发出的数据项进行组合。它按顺序将每个源
<code>Observable</code>
发出的项组合成一个新项，直到其中一个源发出完毕。</p>
<h3 id="工作原理-2">工作原理</h3>
<ul>
<li><strong>输入</strong>：可以接受多个 <code>Observable</code>。</li>
<li><strong>输出</strong>：每当所有源 <code>Observable</code>
发出一个新项时，<code>zip</code> 就会将这些项组合成一个新项。</li>
<li><strong>顺序</strong>：组合项的顺序与输入源的顺序相对应。</li>
<li><strong>完成条件</strong>：当任意一个源 <code>Observable</code>
完成时，<code>zip</code> 将停止发出项。</li>
</ul>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; source1 = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Observable&lt;String&gt; source2 = Observable.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">Observable.zip(source1, source2, (num, letter) -&gt; num + letter)</span><br><span class="line">        .subscribe(result -&gt; System.out.println(result));</span><br></pre></td></tr></table></figure>
<h3 id="输出">输出</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1A</span><br><span class="line">2B</span><br><span class="line">3C</span><br></pre></td></tr></table></figure>
<h3 id="使用场景">使用场景</h3>
<ul>
<li>当你需要从多个数据源组合数据时，<code>zip</code>
是一个理想的选择，例如请求多个 API，然后将结果组合在一起。</li>
<li>它确保每个组合项都来自各个源 <code>Observable</code>
的同一“轮次”。</li>
</ul>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>如果输入的 <code>Observable</code> 数量不一样，<code>zip</code>
会在发出最短序列后完成。</li>
<li>你可以使用 <code>zip</code>
的重载版本来指定不同的合并函数，处理不同类型的数据。</li>
</ul>
<h2 id="aspectj-的实现原理">AspectJ 的实现原理</h2>
<p>AspectJ 是 Java
语言的一个扩展，用于实现面向方面编程（AOP，Aspect-Oriented
Programming）。AspectJ 的实现主要通过“切面”（Aspect）、“连接点”（Join
Point）、“切入点”（Pointcut）和“通知”（Advice）来完成。这些概念使得
AspectJ
可以在不修改源代码的前提下，对已有的代码功能进行扩展或修改。以下是
AspectJ 的主要实现原理：</p>
<h3 id="编译时织入compile-time-weaving">1. 编译时织入（Compile-Time
Weaving）</h3>
<p>在 AspectJ
中，织入（Weaving）是指将切面代码插入到主程序代码中的过程。AspectJ
支持多种织入方式，其中最常见的是编译时织入。它的原理是：</p>
<ul>
<li>在编译过程中，AspectJ 编译器（如 <code>ajc</code>）会分析 Java
代码和 AspectJ
代码，并根据定义的切入点，将相应的切面逻辑插入到匹配的连接点上。</li>
<li>最终生成的字节码已经包含了织入的切面逻辑，所以在运行时不需要额外的处理。</li>
</ul>
<p>编译时织入的优势在于生成的字节码已经包含了切面的逻辑，对运行时性能几乎没有影响。这种方式适用于在开发阶段已经确定好切面代码的场景。</p>
<h3 id="类加载时织入load-time-weavingltw">2. 类加载时织入（Load-Time
Weaving，LTW）</h3>
<p>类加载时织入是在运行时将切面织入到 Java
类中的方法。这种方式在类被加载到 JVM
中时，通过自定义的类加载器（ClassLoader）完成织入。具体实现原理为：</p>
<ul>
<li>JVM 加载类时，AspectJ 的 LTW 代理类加载器会拦截类的加载过程。</li>
<li>在加载类的字节码时，代理类加载器会将切面代码根据切入点织入到指定位置，生成新的字节码，再交由
JVM 加载。</li>
</ul>
<p>LTW
的优势在于动态性，可以根据运行时配置来织入切面代码，适合在复杂的应用中使用，例如
Spring 中的 AOP 支持。</p>
<h3 id="运行时代理">3. 运行时代理</h3>
<p>AspectJ 在 Spring AOP 中常见的动态代理模式下也可以实现 AOP。Spring
AOP 是基于代理的（proxy-based），而 AspectJ
是基于字节码级别的修改。在一些特殊情况下，AspectJ
也可以通过代理模式来实现动态织入，但通常会依赖于 Spring
框架中的代理机制。</p>
<h3 id="连接点切入点和通知的匹配机制">4.
连接点、切入点和通知的匹配机制</h3>
<p>AspectJ
的核心原理之一是通过切入点表达式来匹配连接点。具体流程如下：</p>
<ul>
<li><strong>连接点（Join
Point）</strong>：程序执行过程中可能插入切面代码的位置，包括方法调用、对象初始化等。</li>
<li><strong>切入点（Pointcut）</strong>：用于定义哪些连接点需要应用通知逻辑。切入点可以使用表达式来匹配方法或类。</li>
<li><strong>通知（Advice）</strong>：具体要在连接点执行的操作代码。在程序运行时，如果某个连接点匹配了切入点的定义，就会触发通知逻辑。</li>
</ul>
<h3 id="生成字节码并维护-aspectj-的执行流程">5. 生成字节码并维护 AspectJ
的执行流程</h3>
<p>AspectJ
生成的字节码在类的字节码中引入了切面逻辑。通过这个方式，编译后的类字节码会包含
AspectJ
定义的所有切面，并且在运行时确保切面能够在指定的连接点处执行。这种字节码生成和插入逻辑的实现是
AspectJ 的核心部分。</p>
<h3 id="总结-11">总结</h3>
<p>AspectJ
的实现原理主要依靠字节码插桩技术，无论是编译时、类加载时还是运行时，都围绕织入机制展开。它通过定义切入点和通知，将切面逻辑以各种方式织入到目标代码中，增强了代码的模块化和可维护性。</p>
<h2 id="okhttp的实现原理">OKHttp的实现原理</h2>
<p><strong>OKHttp</strong> 是一个高效的、支持 HTTP/2
的网络请求库，它被广泛用于 Android 和 Java 应用中。OKHttp 通过简洁的
API、灵活的连接池管理、对 HTTP
协议的完整支持，提供了强大的网络请求功能。下面我们深入了解 OKHttp
的实现原理及其关键机制。</p>
<h3 id="okhttp-核心组件和工作流程">OKHttp 核心组件和工作流程</h3>
<p>OKHttp 的网络请求机制由以下几个核心组件组成：</p>
<ul>
<li><strong>OkHttpClient</strong>：负责配置和管理网络请求的客户端。</li>
<li><strong>Request</strong>：封装 HTTP 请求的所有信息。</li>
<li><strong>Response</strong>：封装 HTTP 响应的所有信息。</li>
<li><strong>Call</strong>：表示一个具体的 HTTP 请求，<code>Call</code>
可以被执行或取消。</li>
<li><strong>Interceptor</strong>：拦截器，负责在请求和响应之间做中间处理。</li>
<li><strong>Dispatcher</strong>：负责管理异步请求的调度和执行。</li>
</ul>
<p>OKHttp 的请求流程通常包括以下几个步骤：</p>
<ol type="1">
<li>构建 <code>OkHttpClient</code> 客户端。</li>
<li>构建 <code>Request</code> 对象，指定请求的
URL、请求头和请求参数等。</li>
<li>通过 <code>OkHttpClient</code> 的 <code>newCall()</code> 方法创建
<code>Call</code> 对象。</li>
<li>执行 <code>Call</code>，通过同步或异步方式获取响应
<code>Response</code>。</li>
</ol>
<h3 id="okhttp-的工作流程">OKHttp 的工作流程</h3>
<ol type="1">
<li><p><strong>创建 OkHttpClient</strong> <code>OkHttpClient</code> 是
OKHttp 请求的核心类，负责管理连接池、缓存、拦截器等配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">        .writeTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>connectTimeout</code>：设置连接超时时间。</li>
<li><code>readTimeout</code>：设置读取超时时间。</li>
<li><code>writeTimeout</code>：设置写入超时时间。</li>
</ul></li>
<li><p><strong>创建 Request</strong> <code>Request</code> 对象封装了
HTTP 请求的信息，比如 URL、HTTP 方法、请求头和请求体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(<span class="string">&quot;https://example.com/api&quot;</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>创建 Call</strong> <code>Call</code> 对象是一次 HTTP
请求的封装，负责执行网络请求并获取响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> client.newCall(request);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>执行 Call</strong> 执行请求有两种方式：</p>
<ul>
<li><strong>同步请求</strong>：<code>execute()</code>，调用此方法会阻塞当前线程，直到请求完成。</li>
<li><strong>异步请求</strong>：<code>enqueue()</code>，调用此方法后，OKHttp
会在内部线程池中执行请求，并通过回调函数处理响应。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步请求</span></span><br><span class="line"><span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> call.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步请求</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 请求失败处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 请求成功处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="okhttp的实现细节">OKHttp的实现细节</h3>
<h4 id="拦截器interceptor机制">1.
<strong>拦截器（Interceptor）机制</strong></h4>
<p>拦截器是 OKHttp
中非常重要的一个概念，它允许在请求和响应的不同阶段进行拦截和处理。OKHttp
内部使用了 <strong>责任链模式</strong>
来处理网络请求，拦截器就是该模式中的核心环节。</p>
<p>拦截器主要分为两类：</p>
<ul>
<li><strong>应用拦截器（Application
Interceptor）</strong>：用于处理应用层的逻辑，如添加统一的请求头、修改请求或响应等。</li>
<li><strong>网络拦截器（Network
Interceptor）</strong>：用于处理底层网络请求，例如修改网络层数据、重新发起请求等。</li>
</ul>
<p>OKHttp 中内置了多个拦截器，如：</p>
<ul>
<li><strong>重试拦截器（RetryAndFollowUpInterceptor）</strong>：用于处理失败重试、重定向等操作。</li>
<li><strong>桥接拦截器（BridgeInterceptor）</strong>：负责处理应用层与网络层的桥接，例如设置请求头、响应头、Cookie
等。</li>
<li><strong>缓存拦截器（CacheInterceptor）</strong>：负责缓存逻辑的处理，判断请求是否可以使用缓存。</li>
<li><strong>连接拦截器（ConnectInterceptor）</strong>：负责管理连接池，处理连接的创建与复用。</li>
<li><strong>网络拦截器（NetworkInterceptor）</strong>：用于处理实际的网络
I/O 操作。</li>
</ul>
<p>拦截器通过链式调用的方式逐层传递请求和响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">    <span class="comment">// 修改请求</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> chain.proceed(request);</span><br><span class="line">    <span class="comment">// 修改响应</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个拦截器可以在 <code>chain.proceed(request)</code>
之前或之后对请求和响应进行处理。</p>
<h4 id="连接池connection-pool">2. <strong>连接池（Connection
Pool）</strong></h4>
<p>OKHttp 通过<strong>连接池</strong>来管理 HTTP
连接的复用，这大大提升了网络请求的性能，减少了不必要的 TCP
连接创建。OKHttp
默认会保持一组连接，当请求完成后，连接不会立即关闭，而是保留在连接池中，供后续请求复用。</p>
<ul>
<li><strong>连接复用</strong>：如果多个请求目标相同的主机（域名和端口相同），OKHttp
会复用已有的 TCP 连接，避免每次请求都建立新的连接。</li>
<li><strong>HTTP/2 支持</strong>：OKHttp 支持 HTTP/2 协议，允许在一个
TCP 连接上并行处理多个请求，从而进一步提升网络性能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .connectionPool(<span class="keyword">new</span> <span class="title class_">ConnectionPool</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>连接池的两个关键参数：</p>
<ul>
<li><strong>最大连接数</strong>：允许复用的最大连接数。</li>
<li><strong>连接空闲时间</strong>：当连接超过空闲时间后将被关闭。</li>
</ul>
<h4 id="缓存机制">3. <strong>缓存机制</strong></h4>
<p>OKHttp 提供了完整的 HTTP 缓存机制，遵循 HTTP 的缓存规则（如
<code>Cache-Control</code>、<code>ETag</code> 等），并允许本地缓存 GET
请求的响应。缓存拦截器通过判断缓存的有效性来决定是使用缓存还是发起新的网络请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>(cacheDirectory, cacheSize);</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .cache(cache)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>缓存目录</strong>：指定缓存文件存储的位置。</li>
<li><strong>缓存大小</strong>：限制缓存的大小。</li>
</ul>
<p>OKHttp
的缓存拦截器会根据缓存策略决定是否从缓存中读取数据或更新缓存。</p>
<h4 id="异步处理和线程池">4. <strong>异步处理和线程池</strong></h4>
<p>OKHttp 通过内部的 <strong>Dispatcher</strong>
类管理异步请求的执行。<code>Dispatcher</code>
是一个任务调度器，它使用线程池来执行异步请求，默认最多并行执行 64
个请求，并且对同一主机的请求最多并发 5 个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .dispatcher(<span class="keyword">new</span> <span class="title class_">Dispatcher</span>(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;())</span><br><span class="line">        ))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Dispatcher</strong>：控制请求的调度，管理队列中正在运行的异步请求以及等待的请求。</li>
<li><strong>线程池</strong>：用于执行异步任务，保证高效处理多个网络请求。</li>
</ul>
<h4 id="http2-和-websocket-支持">5. <strong>HTTP/2 和 WebSocket
支持</strong></h4>
<p>OKHttp 对 HTTP/2 的支持是其性能优化的一大亮点。通过
HTTP/2，多个请求可以在一个 TCP
连接上复用，减少了建立多个连接的开销。此外，OKHttp 还支持 WebSocket
协议，用于实现长连接的实时通讯。</p>
<ul>
<li><strong>HTTP/2
的好处</strong>：通过共享连接来处理多个请求，减少网络延迟和资源消耗。</li>
<li><strong>WebSocket 支持</strong>：OKHttp 提供了简单的 WebSocket
API，允许客户端与服务器之间保持长连接，并通过 WebSocket 传递数据。</li>
</ul>
<h3 id="okhttp的整体工作原理图">OKHttp的整体工作原理图</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+         +---------------------+</span><br><span class="line">|   OkHttpClient       |         |   Dispatcher         |</span><br><span class="line">+---------------------+         +---------------------+</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">|     Call             | &lt;---------------+</span><br><span class="line">+---------------------+                  |</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">|    Interceptor Chain |                  |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">|    RealConnection    | &lt;---------------+</span><br><span class="line">+---------------------+                  |</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">|   Connection Pool    |                  |</span><br><span class="line">+---------------------+                  |</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">+---------------------+         +---------------------+</span><br><span class="line">|   Network I/O        |         |   Response Cache    |</span><br><span class="line">+---------------------+         +---------------------+</span><br></pre></td></tr></table></figure>
<h3 id="总结-12">总结</h3>
<p>OKHttp 是通过
<strong>拦截器</strong>、<strong>连接池</strong>、<strong>异步调度器</strong>
等核心组件来高效管理 HTTP 请求的。其设计灵活，性能优化非常出色，特别是对
HTTP/2 的支持、连接复用和缓存机制，使得它成为 Android 和 Java
开发中非常流行的网络库。</p>
<ul>
<li><strong>拦截器链</strong>：使得请求和响应可以灵活地被拦截和修改。</li>
<li><strong>连接池</strong>：通过连接复用提升了网络请求的性能。</li>
<li><strong>缓存机制</strong>：提供了高效的 HTTP
缓存支持，避免不必要的网络请求。</li>
<li><strong>异步处理</strong>：通过 <code>Dispatcher</code>
和线程池管理异步请求的并发和调度。</li>
</ul>
<h2 id="glide-请求的生命周期">Glide 请求的生命周期</h2>
<p>Glide
的请求生命周期涉及多个阶段，从请求的创建到资源的加载和回收。理解这一生命周期有助于优化资源管理和提高应用性能。下面是一个典型的
Glide 请求生命周期：</p>
<ol type="1">
<li><strong>请求开始（Initialization）</strong>：
<ul>
<li>使用 <code>Glide.with(context)</code> 来创建一个
<code>RequestManager</code> 对象。<code>RequestManager</code>
负责管理请求的生命周期，并与 Android 的生命周期事件同步。</li>
</ul></li>
<li><strong>构建请求（Building the Request）</strong>：
<ul>
<li>通过链式调用，使用 <code>load()</code>
方法指定图像的来源（URL、文件、资源 ID 等）。</li>
<li>使用 <code>apply()</code> 方法可以应用
<code>RequestOptions</code>，配置图像的加载方式，例如占位符、错误图像、缩放类型等。</li>
</ul></li>
<li><strong>启动请求（Request Execution）</strong>：
<ul>
<li>调用 <code>into(target)</code> 方法来启动图像的加载过程，其中
<code>target</code> 通常是一个 <code>ImageView</code>。</li>
<li>Glide 会根据指定的 <code>RequestOptions</code> 和
<code>DiskCacheStrategy</code> 决定从缓存或网络加载资源。</li>
</ul></li>
<li><strong>资源加载（Resource Loading）</strong>：
<ul>
<li><strong>缓存检查</strong>：首先检查内存和磁盘缓存是否包含目标图像。</li>
<li><strong>网络请求或解码</strong>：如果缓存未命中，Glide
会请求网络资源或解码本地文件。</li>
<li><strong>Bitmap
Pooling</strong>：使用位图池复用机制以减少内存分配。</li>
</ul></li>
<li><strong>图像显示（Display）</strong>：
<ul>
<li>一旦资源准备好，图像将被显示在目标 <code>ImageView</code>
中。此过程也包括任何指定的 <code>Transformation</code>。</li>
</ul></li>
<li><strong>清理（Cleanup）</strong>：
<ul>
<li>当 <code>Activity</code> 或 <code>Fragment</code>
的生命周期变化（如销毁）时，Glide
会自动取消未完成的请求，释放内存资源。</li>
<li>可以手动调用例如 <code>Glide.with(context).clear(target)</code>
来取消加载或移除图像。</li>
</ul></li>
<li><strong>自动恢复（Automatic Lifecycle Integration）</strong>：
<ul>
<li><code>RequestManager</code> 和 <code>RequestBuilder</code>
会自动响应 Android 生命周期事件（如
<code>onPause</code>、<code>onResume</code>），以便在 UI
不可见时暂停图像加载，并在恢复时继续。</li>
</ul></li>
</ol>
<p>这种生命周期管理机制确保了高效的资源使用，防止内存泄漏，同时又能方便地集成到
Android 的组件生命周期中。</p>
<h2 id="handler-原理">Handler 原理</h2>
<p>Android 的 <code>Handler</code> 是 Android
系统中处理线程之间通信的一种机制。它允许你在一个线程中向其他线程发送和处理消息，最常见的场景是更新
UI。因为 Android 规定只能在主线程（UI 线程）中更新
UI，<code>Handler</code> 就成为了从工作线程与 UI
线程交互的重要工具。</p>
<h3 id="handler-原理概述">Handler 原理概述</h3>
<p><code>Handler</code>
是基于消息队列（MessageQueue）和消息循环（Looper）实现的。核心组件包括
<code>Handler</code>、<code>Message</code>、<code>Looper</code> 和
<code>MessageQueue</code>。以下是每个组件的角色：</p>
<ul>
<li><strong>Handler</strong>:
用于发送消息和处理消息。它向消息队列中发送消息，并在收到消息时执行相应的操作。</li>
<li><strong>Message</strong>: <code>Message</code> 是
<code>Handler</code>
处理的消息对象，包含了消息的内容，比如数据、标识符、目标 Handler
等。</li>
<li><strong>Looper</strong>:
负责管理线程中的消息循环。每个线程都可以通过 <code>Looper</code>
来关联一个消息队列。主线程默认有一个
<code>Looper</code>，工作线程需要手动创建。</li>
<li><strong>MessageQueue</strong>:
是一个消息队列，负责存储线程中的所有消息。<code>Looper</code> 会从
<code>MessageQueue</code> 中取出消息，然后分发给相应的
<code>Handler</code>。</li>
</ul>
<h3 id="工作原理-3">工作原理</h3>
<ol type="1">
<li><p><strong>Looper 准备</strong>: 每个线程可以通过
<code>Looper.prepare()</code> 方法来初始化一个 <code>Looper</code>
实例，并将其与当前线程关联。主线程的 <code>Looper</code>
是系统自动创建的，但子线程需要手动创建。</p></li>
<li><p><strong>消息发送</strong>: <code>Handler</code> 可以使用
<code>sendMessage()</code> 或 <code>post()</code> 方法将
<code>Message</code> 或 <code>Runnable</code> 发送到消息队列。每个
<code>Handler</code> 都与某个 <code>Looper</code>
关联，它们可以发送消息到这个 <code>Looper</code> 的
<code>MessageQueue</code> 中。</p></li>
<li><p><strong>消息存储</strong>: 发送的消息被存储在
<code>MessageQueue</code>
中。这个队列按时间顺序排列消息，先发送的消息先处理。</p></li>
<li><p><strong>消息处理</strong>: <code>Looper</code> 会不断地从
<code>MessageQueue</code> 中取出消息，并分发给相应的
<code>Handler</code>。每个 <code>Handler</code> 都有一个
<code>handleMessage()</code>
方法，当消息到达时，会调用这个方法来处理消息。</p></li>
<li><p><strong>Looper 轮询</strong>: 一旦 <code>Looper.loop()</code>
被调用，线程进入消息循环，<code>Looper</code> 就会不断地从
<code>MessageQueue</code> 中取消息，并将它们分发给关联的
<code>Handler</code>。</p></li>
</ol>
<h3 id="handler-工作流程图">Handler 工作流程图</h3>
<ol type="1">
<li>工作线程向主线程的 <code>Handler</code> 发送
<code>Message</code>。</li>
<li><code>MessageQueue</code> 接收到消息并入队。</li>
<li><code>Looper</code> 不断从 <code>MessageQueue</code> 取出消息。</li>
<li>取出消息后，<code>Looper</code> 分发给目标
<code>Handler</code>，调用 <code>Handler</code> 的
<code>handleMessage()</code> 进行处理。</li>
<li><code>Handler</code> 处理完消息后，循环继续，直到消息队列为空。</li>
</ol>
<h3 id="示例代码-1">示例代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程中创建 Handler</span></span><br><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 在主线程处理消息</span></span><br><span class="line">        textView.setText(<span class="string">&quot;Message received: &quot;</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程中发送消息</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.what = <span class="number">1</span>;</span><br><span class="line">        handler.sendMessage(msg); <span class="comment">// 发送消息到主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="注意事项-1">注意事项</h3>
<ul>
<li><strong>线程间通信</strong>: <code>Handler</code>
主要用于线程间的通信，工作线程可以通过 <code>Handler</code> 将消息发送到
UI 线程更新界面。</li>
<li><strong>避免内存泄漏</strong>: 当使用 <code>Handler</code>
时，特别是在活动或其他组件销毁时，如果没有妥善管理，可能会导致内存泄漏。建议使用
<code>WeakReference</code> 或者在 <code>onDestroy</code>
中移除所有的消息。</li>
<li><strong>主线程和子线程</strong>: <code>Handler</code>
的典型用法是在子线程进行耗时操作，然后通过 <code>Handler</code>
将结果发送到主线程更新 UI。</li>
</ul>
<p>总结来说，<code>Handler</code> 结合 <code>Looper</code> 和
<code>MessageQueue</code> 实现了 Android
中线程间的通信，主要用于处理子线程与主线程的消息交互。</p>
<h2 id="idlehandler">IdleHandler</h2>
<p>在 Android 中，<code>IdleHandler</code> 是用于处理
<code>MessageQueue</code>
在空闲时的任务的机制。它允许开发者在事件队列没有更多待处理消息时执行一些后台任务。这是通过
<code>Looper</code> 和 <code>MessageQueue</code> 框架实现的。以下是有关
<code>IdleHandler</code> 的详细信息：</p>
<h3 id="工作原理-4">工作原理</h3>
<ol type="1">
<li><strong>MessageQueue 和 Looper</strong>:
<ul>
<li>Android 的 <code>MessageQueue</code> 用于处理消息和可运行对象，它由
<code>Looper</code> 管理。</li>
<li>当 <code>MessageQueue</code> 中没有更多的消息时，可以触发
<code>IdleHandler</code>。</li>
</ul></li>
<li><strong>IdleHandler 接口</strong>:
<ul>
<li><code>IdleHandler</code> 是一个接口，其中包含一个
<code>queueIdle</code> 方法。</li>
<li>当 <code>Looper</code> 观察到消息队列空闲时，会调用此
<code>queueIdle</code> 方法。</li>
</ul></li>
<li><strong>注册 IdleHandler</strong>:
<ul>
<li>可以通过 <code>MessageQueue</code> 的 <code>addIdleHandler</code>
方法注册一个 <code>IdleHandler</code>。</li>
<li>多个 <code>IdleHandler</code> 可以同时添加到一个
<code>MessageQueue</code> 中。</li>
</ul></li>
</ol>
<h3 id="代码示例">代码示例</h3>
<p>以下是如何使用 <code>IdleHandler</code> 的一个基本示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> <span class="title class_">MessageQueue</span>.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行后台任务</span></span><br><span class="line">        Log.d(<span class="string">&quot;IdleHandler&quot;</span>, <span class="string">&quot;Queue is idle!&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 false 以在执行一次后移除此 IdleHandler</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-1">使用场景</h3>
<ul>
<li><strong>后台任务</strong>:
在不影响应用主线程的情况下，执行一些低优先级的背景任务，如日志记录或状态更新。</li>
<li><strong>资源清理</strong>:
空闲时释放不必要占用的资源，比如清理缓存。</li>
<li><strong>性能优化</strong>:
延迟不重要的工作以优化应用的性能，使得界面更流畅。</li>
</ul>
<h3 id="设计考量">设计考量</h3>
<ul>
<li><strong>任务性质</strong>: 由于 <code>IdleHandler</code>
执行在主线程，应确保任务对用户界面的影响最小。</li>
<li><strong>执行频率</strong>: 长时间任务应避免使用
<code>IdleHandler</code>，因为这可能影响到其他更高优先级的操作。</li>
<li><strong>返回值</strong>: <code>queueIdle</code> 方法返回
<code>true</code> 保留 <code>IdleHandler</code>，返回 <code>false</code>
表示处理完后从队列中移除，以避免反复执行。</li>
</ul>
<h3 id="注意事项-2">注意事项</h3>
<ul>
<li><strong>不能保证执行</strong>: 如果应用的 <code>MessageQueue</code>
经常忙于处理消息，<code>IdleHandler</code> 可能很少或不会被调用。</li>
<li><strong>避免阻塞</strong>: 确保 <code>queueIdle</code>
中的代码不会阻塞主线程，以免影响应用的响应速度。</li>
</ul>
<p><code>IdleHandler</code> 是一个有效的工具，
用于在不影响应用主线操作的情况下进行后台管理和优化。适当使用可以提升
Android 应用的性能和用户体验。</p>
<h2 id="handler-消息屏障">Handler 消息屏障</h2>
<p>Handler消息屏障（Message
Barrier）是Android消息处理机制中的一个概念，用于控制消息队列的处理顺序。它主要用于解决异步消息处理过程中优先级的问题。在常见的使用场景中，消息屏障允许某些重要的同步消息可以优先于异步消息来执行，提高应用的响应效率。</p>
<h3 id="handler-和-messagequeue">Handler 和 MessageQueue</h3>
<p>在 Android 中，<code>Handler</code> 和 <code>MessageQueue</code>
配合使用来管理消息的发送和处理。消息队列是一个有序的数据结构，通常会根据消息的到达时间顺序来看待处理。</p>
<h3 id="消息屏障的工作原理">消息屏障的工作原理</h3>
<ol type="1">
<li><strong>消息类型</strong>：
<ul>
<li><strong>同步消息</strong>：需要按照正常顺序处理的消息。</li>
<li><strong>异步消息</strong>：相对较不重要，允许可以稍后再处理。</li>
</ul></li>
<li><strong>屏障机制</strong>：
<ul>
<li>消息屏障会被插入消息队列中，从它插入的位置开始，所有同步消息会被暂时停止处理，但异步消息可以继续被处理。</li>
<li>当消息屏障插入队列后，随后的同步消息将被延迟处理，直到消息屏障被移除。</li>
</ul></li>
<li><strong>用法场景</strong>：
<ul>
<li>消息屏障通常被系统内部使用，通过设置它，可以让像动画或布局测量这样的耗时处理异步消息先行执行，优化UI的流畅性。</li>
<li>不是所有用户应用开发中直接去使用消息屏障，但理解其机制在性能调优中非常有帮助。</li>
</ul></li>
</ol>
<h3 id="实现方式">实现方式</h3>
<p>在 Android 源码中，<code>MessageQueue</code> 提供了
<code>postSyncBarrier</code>
方法用于插入一个消息屏障，其内部会生成一个特殊的 token 来标识屏障。</p>
<h3 id="示例-2">示例</h3>
<p>假设我们希望将某些动画消息优先于普通消息执行，可以通过插入消息屏障后再插入动画消息，动画消息以异步方式（Android
4.4开始支持）发送，这些消息会立即执行，后面的同步消息则会在屏障被移除后处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> messageQueue.postSyncBarrier();</span><br><span class="line"><span class="comment">// 发送异步消息</span></span><br><span class="line">messageQueue.sendMessage(…); <span class="comment">// 异步message setAsynchronous(true)</span></span><br><span class="line"><span class="comment">// 移除屏障</span></span><br><span class="line">messageQueue.removeSyncBarrier(token);</span><br></pre></td></tr></table></figure>
<h3 id="总结-13">总结</h3>
<p>使用消息屏障是一种高级性能优化策略，主要是帮助系统内部对不同优先级的消息进行合理调度。开发者在理解这类机制知识的同时，可以更好地设计那些需要高效响应的应用模块。</p>
<h2 id="android-图形框架">Android 图形框架</h2>
<p>参考：https://mp.weixin.qq.com/s/I0Hy03SkyYvNr-1v2oCTbA</p>
<p>Android
的图形渲染框架从底层硬件到顶层应用程序，是一套复杂而高效的架构。它涉及硬件抽象层（HAL）、图形驱动、图形引擎以及高级应用层
API。为了理解 Android
的图形渲染流程，可以将其划分为几个重要的层次，从最底层的硬件到最高层的应用绘制。以下是
Android 从底层到顶层的图形渲染框架的详细解析：</p>
<h3 id="硬件抽象层-hardware-abstraction-layer-hal">1. <strong>硬件抽象层
(Hardware Abstraction Layer, HAL)</strong></h3>
<p>Android 的底层图形框架直接与硬件交互，依赖于硬件抽象层 (HAL)
来统一访问不同的硬件组件。这一层是 Android
系统中的基础层，屏蔽了不同硬件平台的差异，使上层框架可以通过统一的接口来操作底层硬件。</p>
<ul>
<li><p><strong>SurfaceFlinger</strong>：SurfaceFlinger 是 Android
系统的核心组件之一，它负责将多个应用程序窗口的渲染结果合成到屏幕上。它与硬件抽象层交互，控制帧缓冲区
(Framebuffer)，并管理图形缓冲区的交换和显示。</p></li>
<li><p><strong>Gralloc (Graphics Allocation)</strong>：Gralloc
是图形内存分配器，它为图形帧缓冲区分配内存，用于存储各个应用程序渲染的图像。不同硬件平台的实现可能不同，Gralloc
负责跨平台的内存管理。</p></li>
<li><p><strong>硬件加速 (GPU)</strong>：Android 使用
GPU（图形处理单元）来加速图形渲染。GPU 通过 OpenGL ES 或 Vulkan
接口进行硬件加速渲染，从而大幅提升图形处理的效率。</p></li>
</ul>
<h3 id="图形驱动和接口">2. <strong>图形驱动和接口</strong></h3>
<p>在 HAL 之上，Android 通过 OpenGL ES、Vulkan 和 Skia 等图形 API
与底层的 GPU 交互。这些 API 使得应用程序可以高效地进行 2D 和 3D
图形的渲染。</p>
<ul>
<li><p><strong>OpenGL ES</strong>：OpenGL ES 是 OpenGL
的嵌入式版本，用于移动设备和嵌入式系统。它是 Android 系统中使用最广泛的
3D 图形 API，支持高效的 2D 和 3D 图形绘制。</p></li>
<li><p><strong>Vulkan</strong>：Vulkan 是一种现代的低开销、高性能的图形
API，特别适合于需要大量并发处理的高性能图形应用。它比 OpenGL ES
提供了更精细的控制和更高的性能，但复杂度也更高。</p></li>
<li><p><strong>Skia</strong>：Skia 是 Android 的 2D
图形库，它用于渲染所有的 2D 图形，包括文本、形状、位图等。Android
中的所有 View 组件最终都是通过 Skia 渲染的。</p></li>
<li><p><strong>EGL (Embedded-System Graphics Library)</strong>：EGL
是一个连接 OpenGL ES 和图形底层（如
Framebuffer、窗口系统）的接口，负责上下文管理、表面创建以及图形的缓冲交换。通过
EGL，应用程序可以创建和管理 OpenGL ES
的渲染上下文，并交换渲染结果。</p></li>
</ul>
<h3 id="surface-和-surfaceflinger">3. <strong>Surface 和
SurfaceFlinger</strong></h3>
<ul>
<li><p><strong>Surface</strong>：每个 Android 应用程序的窗口都与一个
<code>Surface</code> 对象相关联，<code>Surface</code>
是用于与系统共享图形缓冲区的抽象，它代表了一个可以绘制的画布。应用程序通过绘制到
<code>Surface</code> 来渲染内容，最终这些内容会被发送到
<code>SurfaceFlinger</code> 进行合成。</p></li>
<li><p><strong>SurfaceFlinger</strong>：作为 Android
的窗口合成器，<code>SurfaceFlinger</code> 负责将多个应用程序窗口的
<code>Surface</code> 进行合成，并最终显示在屏幕上。它接收来自不同应用的
<code>Surface</code>，并通过与硬件抽象层（HAL）和 Gralloc
的交互，将这些内容组合成一帧最终的图像，展示在屏幕上。</p></li>
</ul>
<h3 id="硬件加速和-vsync">4. <strong>硬件加速和 VSync</strong></h3>
<ul>
<li><p><strong>硬件加速</strong>：Android 系统在图形绘制过程中广泛使用了
GPU 硬件加速。所有 <code>View</code>
组件默认开启硬件加速，特别是在绘制复杂图形或动画时，硬件加速能极大提升性能。硬件加速通过
OpenGL ES 或 Vulkan 将图形渲染工作交给 GPU 执行，从而释放 CPU
资源。</p></li>
<li><p><strong>VSync (Vertical Sync)</strong>：VSync
是图形系统中的垂直同步机制，它控制图形帧的刷新频率。VSync
信号会同步图形缓冲区的交换与屏幕刷新，防止帧撕裂等问题。在 VSync
的控制下，系统以每秒 60
帧（或设备支持的其他刷新率）进行屏幕更新。</p></li>
</ul>
<h3 id="renderthread-和-choreographer">5. <strong>RenderThread 和
Choreographer</strong></h3>
<ul>
<li><p><strong>RenderThread</strong>：Android 中的
<code>RenderThread</code>
是一个独立的线程，用于处理界面渲染的任务。它负责管理硬件加速的绘制操作，将渲染任务提交给
GPU 以确保 UI 更新的高效性和响应性。</p></li>
<li><p><strong>Choreographer</strong>：<code>Choreographer</code> 是
Android 用于同步图形帧的系统，它负责协调应用程序的绘制周期和 VSync
信号。<code>Choreographer</code> 确保绘制、布局和动画更新与 VSync
同步，从而避免视觉上的不一致性和卡顿现象。</p></li>
</ul>
<h3 id="顶层的-android-ui-绘制系统">6. <strong>顶层的 Android UI
绘制系统</strong></h3>
<p>Android 的顶层图形渲染框架直接面向应用开发者，提供了丰富的绘制 API
和布局系统。主要包括以下几个核心部分：</p>
<h4 id="view-系统和绘制流程">View 系统和绘制流程：</h4>
<ol type="1">
<li><strong>View 和 ViewGroup</strong>：
<ul>
<li><code>View</code> 是 Android 中的基本 UI
单元，负责处理用户输入和界面显示。<code>ViewGroup</code> 是
<code>View</code> 的容器类，用来组织和管理子视图。</li>
<li>每个 <code>View</code> 都有一个 <code>draw()</code>
方法，通过它来实现自定义绘制逻辑，最终通过底层的 Skia
库进行实际绘制。</li>
</ul></li>
<li><strong>绘制流程</strong>：
<ul>
<li>Android 中的 UI
绘制是一个复杂的流程，从布局的测量、位置计算到最终的绘制，都是通过遍历
<code>View</code> 树来完成的。</li>
<li><strong>measure()</strong>、<strong>layout()</strong> 和
<strong>draw()</strong>
是绘制流程的三大核心步骤，负责布局、定位和绘制视图。</li>
</ul></li>
<li><strong>Canvas</strong> 和 <strong>Paint</strong>：
<ul>
<li><code>Canvas</code> 是 Android 的 2D
绘图类，代表了一个可绘制的表面。开发者可以在 <code>Canvas</code>
上绘制图形、文本和位图。</li>
<li><code>Paint</code>
是用来定义绘制风格的类，指定了颜色、线条宽度、文本大小等属性。</li>
</ul></li>
</ol>
<h4 id="硬件加速和-gpu-渲染">硬件加速和 GPU 渲染：</h4>
<ul>
<li>在 <code>View</code> 系统中，当开启硬件加速时，所有绘制操作会通过
OpenGL 渲染，<code>RenderThread</code> 会将 UI 绘制任务交给 GPU
处理。</li>
<li><strong>DisplayList</strong>：为了提高性能，Android 会将
<code>View</code> 的绘制操作记录在一个 DisplayList
中，类似于一个绘图的指令集。当内容需要重绘时，Android
可以快速重放这些指令而不需要重新计算所有内容。</li>
</ul>
<h3 id="动画系统">7. <strong>动画系统</strong></h3>
<p>Android 的动画系统也是图形框架的重要组成部分，它提供了多种动画 API
用于实现复杂的 UI 交互效果。</p>
<ul>
<li><p><strong>Property Animations</strong>：<code>ObjectAnimator</code>
和 <code>ValueAnimator</code> 是 Android
的属性动画系统，允许开发者以流畅的方式改变 <code>View</code>
的属性（如位置、透明度、缩放等），实现复杂的动画效果。</p></li>
<li><p><strong>硬件加速的动画</strong>：通过硬件加速，动画的每一帧可以在
GPU 上进行渲染，极大提升了动画的流畅度和性能。</p></li>
</ul>
<h3 id="触摸事件和输入系统">8. <strong>触摸事件和输入系统</strong></h3>
<p>Android
的触摸事件系统也是图形框架的一部分，负责处理用户输入，并将这些输入反馈到视图。</p>
<ul>
<li><p><strong>触摸事件分发</strong>：当用户在屏幕上触摸时，系统会生成触摸事件，并通过
<code>View</code> 的 <code>onTouchEvent()</code>
方法传递到各个视图中。<code>ViewGroup</code>
负责将事件分发给其子视图，直到目标视图处理该事件。</p></li>
<li><p><strong>多点触控</strong>：Android
支持多点触控，系统会为每个触控点生成唯一的
ID，允许开发者处理复杂的多点交互场景。</p></li>
</ul>
<h3 id="总结-14">总结</h3>
<p>Android
的图形渲染框架从底层到顶层，是一个层次分明、结构复杂的体系。底层通过硬件抽象层
(HAL) 和 GPU 来高效管理图形资源和渲染操作，中间层提供了 OpenGL ES、V</p>
<p>ulkan、Skia 等 API 来进行图形渲染，顶层则通过 <code>View</code>
系统、动画、触摸事件等接口为应用开发者提供了高效的 UI
绘制和交互工具。整个体系通过 VSync
和硬件加速技术，保证了图形渲染的高效性和流畅性。</p>
<h2 id="surfaceview-glsurfaceview-和-texturesurfaceview">SurfaceView,
GLSurfaceView 和 TextureSurfaceView</h2>
<p>参考：https://mp.weixin.qq.com/s/tzIKbtxQoVuwP6RmLj06Aw</p>
<p>在 Android 中，<code>SurfaceView</code>、<code>GLSurfaceView</code>
和 <code>TextureView</code>
是用于显示图形内容的三种常用控件，它们在实现方式、使用场景和性能特点上有所不同。以下是对它们的详细区别和应用场景的解析：</p>
<h3 id="surfaceview">1. <strong>SurfaceView</strong></h3>
<p><code>SurfaceView</code> 是 Android
中用于在独立线程上绘制内容的控件，通常用于处理高效的图形更新，比如视频播放、游戏渲染等场景。</p>
<h4 id="特点">特点：</h4>
<ul>
<li><p><strong>独立的 Surface</strong>：<code>SurfaceView</code>
的绘制是在一个独立的 <code>Surface</code> 上进行的，该
<code>Surface</code> 与主 UI
线程分离，意味着它可以在单独的渲染线程中进行绘制操作，不会影响主线程的性能。这样可以减少绘制时的卡顿。</p></li>
<li><p><strong>异步绘制</strong>：<code>SurfaceView</code>
的内容可以通过后台线程进行异步绘制，适合需要频繁更新内容的场景，比如视频流或实时渲染。</p></li>
<li><p><strong>透明问题</strong>：<code>SurfaceView</code>
的底层绘制是通过独立的 <code>Surface</code> 实现的，所以它不支持 View
层的叠加或透明效果。<code>SurfaceView</code>
显示的内容始终是在窗口最前面的部分，因此它的 <code>View</code>
层次较难与其他 UI 元素进行叠加。</p></li>
</ul>
<h4 id="使用场景-2">使用场景：</h4>
<ul>
<li>视频播放：例如使用 <code>MediaPlayer</code> 或
<code>ExoPlayer</code> 渲染视频内容。</li>
<li>游戏开发：使用单独的线程处理复杂的实时图形渲染。</li>
</ul>
<h4 id="示例-3">示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SurfaceView</span> <span class="variable">surfaceView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SurfaceView</span>(context);</span><br><span class="line"><span class="type">SurfaceHolder</span> <span class="variable">holder</span> <span class="operator">=</span> surfaceView.getHolder();</span><br><span class="line">holder.addCallback(<span class="keyword">new</span> <span class="title class_">SurfaceHolder</span>.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">        <span class="comment">// 在此处启动后台线程进行绘制操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="type">int</span> format, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 Surface 大小发生变化时调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">        <span class="comment">// 停止后台线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="glsurfaceview">2. <strong>GLSurfaceView</strong></h3>
<p><code>GLSurfaceView</code> 是一个专门用于 OpenGL 渲染的
<code>SurfaceView</code>，封装了 OpenGL ES 的绘制流程，简化了开发者的
OpenGL 渲染工作。它专为 2D 和 3D
图形渲染设计，特别适用于游戏和需要高性能图形渲染的应用场景。</p>
<h4 id="特点-1">特点：</h4>
<ul>
<li><p><strong>OpenGL ES 渲染支持</strong>：<code>GLSurfaceView</code>
封装了 OpenGL 的初始化、上下文管理、绘制回调等细节。开发者只需实现
<code>GLSurfaceView.Renderer</code> 接口来定义 OpenGL
渲染逻辑，而不需要手动管理 OpenGL 上下文和线程。</p></li>
<li><p><strong>独立线程渲染</strong>：<code>GLSurfaceView</code>
也通过后台线程来进行 OpenGL 绘制，与主线程分离，避免 UI 卡顿。</p></li>
<li><p><strong>双缓冲机制</strong>：它默认支持双缓冲机制，可以避免图像撕裂问题，确保渲染帧的流畅显示。</p></li>
<li><p><strong>EGL 管理</strong>：<code>GLSurfaceView</code> 自动管理
OpenGL 的 EGL 环境，处理 OpenGL
上下文、配置选择和窗口关联等操作，简化了开发者的工作。</p></li>
</ul>
<h4 id="使用场景-3">使用场景：</h4>
<ul>
<li>3D 图形渲染：如使用 OpenGL ES 绘制的 3D 游戏或数据可视化应用。</li>
<li>高性能 2D 图形渲染：如复杂的 2D 动画或自定义图形渲染。</li>
</ul>
<h4 id="示例-4">示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GLSurfaceView</span> <span class="variable">glSurfaceView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GLSurfaceView</span>(context);</span><br><span class="line"><span class="comment">// 设置OpenGL ES 版本，通常为2或3</span></span><br><span class="line">glSurfaceView.setEGLContextClientVersion(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Renderer</span></span><br><span class="line">glSurfaceView.setRenderer(<span class="keyword">new</span> <span class="title class_">GLSurfaceView</span>.Renderer() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化OpenGL资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawFrame</span><span class="params">(GL10 gl)</span> &#123;</span><br><span class="line">        <span class="comment">// 绘制每一帧的内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// 当Surface大小发生变化时调整视口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启渲染模式，默认是RENDERMODE_CONTINUOUSLY (连续渲染)</span></span><br><span class="line">glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);</span><br></pre></td></tr></table></figure>
<h3 id="textureview">3. <strong>TextureView</strong></h3>
<p><code>TextureView</code>
是一种更灵活的控件，允许应用程序直接控制渲染内容，并且可以像普通的
<code>View</code> 一样与其他 <code>View</code>
进行组合和叠加。它支持硬件加速，并且能够在应用层轻松管理。</p>
<h4 id="特点-2">特点：</h4>
<ul>
<li><p><strong>可叠加</strong>：<code>TextureView</code>
最大的优势是可以作为普通的 <code>View</code>
在视图层次中使用，这意味着它可以与其他 <code>View</code>
进行叠加、透明处理等复杂布局操作，克服了 <code>SurfaceView</code>
不支持叠加的问题。</p></li>
<li><p><strong>硬件加速</strong>：<code>TextureView</code>
支持硬件加速渲染，能够高效地处理复杂的图形内容。同时，它也支持在主线程上渲染，不像
<code>SurfaceView</code> 那样强制需要后台线程。</p></li>
<li><p><strong>灵活性</strong>：<code>TextureView</code> 通过
<code>SurfaceTexture</code>
提供了灵活的绘制接口，允许开发者使用自定义的渲染逻辑，例如结合 OpenGL 或
<code>Canvas</code> 绘制。</p></li>
<li><p><strong>更高的开销</strong>：虽然 <code>TextureView</code>
提供了更高的灵活性，但由于它在 <code>View</code>
层级中与其他视图一起渲染，性能开销比 <code>SurfaceView</code>
稍高，特别是在大规模或高频率的图形更新时。</p></li>
</ul>
<h4 id="使用场景-4">使用场景：</h4>
<ul>
<li>视频播放：与 <code>SurfaceView</code> 类似的场景，但允许在 UI
层级中进行透明和叠加处理。</li>
<li>自定义视图：如自定义控件中需要灵活的图形渲染。</li>
<li>动画和视频效果：需要叠加效果的动画或视频处理。</li>
</ul>
<h4 id="示例-5">示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextureView</span> <span class="variable">textureView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextureView</span>(context);</span><br><span class="line">textureView.setSurfaceTextureListener(<span class="keyword">new</span> <span class="title class_">TextureView</span>.SurfaceTextureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceTextureAvailable</span><span class="params">(SurfaceTexture surface, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// SurfaceTexture 可用时进行初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// SurfaceTexture 尺寸变化时调整</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> &#123;</span><br><span class="line">        <span class="comment">// 当SurfaceTexture被销毁时进行清理操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceTextureUpdated</span><span class="params">(SurfaceTexture surface)</span> &#123;</span><br><span class="line">        <span class="comment">// SurfaceTexture 更新时调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="区别总结-1">4. <strong>区别总结</strong></h3>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 27%" />
<col style="width: 32%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>SurfaceView</th>
<th>GLSurfaceView</th>
<th>TextureView</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>绘制机制</strong></td>
<td>使用独立的 Surface，后台线程渲染</td>
<td>基于 OpenGL ES 渲染，后台线程渲染</td>
<td>在主线程或后台线程渲染</td>
</tr>
<tr class="even">
<td><strong>渲染场景</strong></td>
<td>常用于视频播放、2D 游戏等</td>
<td>用于 2D/3D 图形渲染，专为 OpenGL 设计</td>
<td>适用于需要叠加、透明效果的场景</td>
</tr>
<tr class="odd">
<td><strong>是否支持叠加</strong></td>
<td>不支持与其他 View 叠加</td>
<td>不支持与其他 View 叠加</td>
<td>支持与其他 View 叠加</td>
</tr>
<tr class="even">
<td><strong>OpenGL 支持</strong></td>
<td>需要手动集成 OpenGL 支持</td>
<td>内置 OpenGL 支持，自动管理 EGL 环境</td>
<td>可以手动集成 OpenGL</td>
</tr>
<tr class="odd">
<td><strong>使用场景</strong></td>
<td>视频播放、后台线程绘制</td>
<td>3D 游戏、复杂动画</td>
<td>视频播放、动画、需要叠加的场景</td>
</tr>
<tr class="even">
<td><strong>性能</strong></td>
<td>高效，适合频繁更新的图形</td>
<td>高效，专为 OpenGL 优化</td>
<td>性能较 <code>SurfaceView</code> 略低</td>
</tr>
</tbody>
</table>
<h3 id="选择建议">5. <strong>选择建议</strong></h3>
<ul>
<li>如果需要进行简单的视频播放或者通过后台线程渲染图像，<strong><code>SurfaceView</code></strong>
是一个不错的选择。</li>
<li>如果你的应用涉及到 2D 或 3D 的高性能图形渲染，且依赖于 OpenGL
ES，<strong><code>GLSurfaceView</code></strong> 是最佳选择，因为它简化了
OpenGL 的管理和使用。</li>
<li>如果你需要在 <code>View</code> 层级中进行复杂的 UI
叠加（如视频播放的同时显示 UI
元素）或处理透明视图，<strong><code>TextureView</code></strong>
提供了更灵活</li>
</ul>
<p>的选择，但需要注意它可能带来更多的性能开销。</p>
<p>总结来说，<code>SurfaceView</code>、<code>GLSurfaceView</code> 和
<code>TextureView</code>
各有其适用的场景和特点，选择合适的控件取决于你项目的需求、性能要求以及图形渲染的复杂程度。</p>
<h2 id="mvc-mvp-和-mvvm">MVC, MVP 和 MVVM</h2>
<p>在软件开发中，<strong>MVC</strong>（Model-View-Controller）、<strong>MVP</strong>（Model-View-Presenter）和
<strong>MVVM</strong>（Model-View-ViewModel）是三种常见的架构模式，它们用于分离代码中的业务逻辑、数据层和用户界面层。这些架构模式的核心目的是提高代码的可维护性、可测试性和扩展性。下面是对
MVC、MVP 和 MVVM 这三种架构模式的详细介绍及其区别。</p>
<hr />
<h3 id="mvcmodel-view-controller架构模式">1.
<strong>MVC（Model-View-Controller）架构模式</strong></h3>
<h4 id="概述-6">概述</h4>
<p>MVC 是最早被提出的架构模式之一，用于分离应用程序的逻辑和用户界面。MVC
的核心思想是将应用程序分成三层：<strong>Model</strong>、<strong>View</strong>
和
<strong>Controller</strong>。在这种架构模式中，每一层都有明确的职责。</p>
<h4 id="组件角色">组件角色</h4>
<ul>
<li><strong>Model（模型）</strong>：负责数据的获取和管理。它包括业务逻辑和数据操作，例如从数据库或网络获取数据，并处理这些数据。</li>
<li><strong>View（视图）</strong>：负责展示数据。<code>View</code>
直接与用户进行交互，显示 <code>Model</code>
中的数据，并接收用户的输入。</li>
<li><strong>Controller（控制器）</strong>：控制器是 <code>Model</code>
和 <code>View</code> 之间的桥梁。它负责处理用户的输入，并调用
<code>Model</code> 来获取或更新数据，然后将这些数据传递给
<code>View</code> 进行显示。</li>
</ul>
<h4 id="数据流和交互">数据流和交互</h4>
<ul>
<li>用户通过 <code>View</code> 与应用程序交互。</li>
<li>用户的输入被传递给 <code>Controller</code>，由
<code>Controller</code> 处理。</li>
<li><code>Controller</code> 与 <code>Model</code>
交互，获取或修改数据。</li>
<li><code>Model</code> 将处理后的数据返回给
<code>Controller</code>，然后 <code>Controller</code> 将数据传递给
<code>View</code> 来更新界面。</li>
</ul>
<h4 id="优点-7">优点</h4>
<ul>
<li>分离了数据层和表现层，降低了代码的耦合度。</li>
<li>适用于简单的应用场景，快速开发 UI 界面。</li>
</ul>
<h4 id="缺点-7">缺点</h4>
<ul>
<li><code>Controller</code>
在复杂应用中容易变得臃肿，因为它需要处理大量的逻辑。</li>
<li><code>View</code> 与 <code>Model</code>
的解耦较差，<code>View</code> 可能会直接依赖
<code>Model</code>，不利于单元测试。</li>
</ul>
<h4 id="图示">图示：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User &lt;--&gt; View &lt;--&gt; Controller &lt;--&gt; Model</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="mvpmodel-view-presenter架构模式">2.
<strong>MVP（Model-View-Presenter）架构模式</strong></h3>
<h4 id="概述-7">概述</h4>
<p>MVP 是对 MVC 的一种改进，主要解决了 MVC 中 <code>Controller</code>
容易臃肿的问题，并增强了 <code>View</code> 和 <code>Model</code>
的解耦。MVP 将控制逻辑移到 <strong>Presenter</strong> 中，使得
<code>View</code> 只负责渲染界面，而 <code>Presenter</code>
完全控制应用逻辑。</p>
<h4 id="组件角色-1">组件角色</h4>
<ul>
<li><strong>Model（模型）</strong>：与 MVC 中的 <code>Model</code>
类似，负责管理数据和业务逻辑。</li>
<li><strong>View（视图）</strong>：<code>View</code> 负责显示
<code>Presenter</code> 提供的数据，并将用户的输入传递给
<code>Presenter</code>。在 Android 中，<code>View</code> 通常是
Activity、Fragment 或 XML 布局。</li>
<li><strong>Presenter（展示者）</strong>：<code>Presenter</code> 是
<code>View</code> 和 <code>Model</code>
之间的桥梁。它接收用户输入，处理业务逻辑，调用 <code>Model</code>
获取数据，并将结果传递给 <code>View</code>
来更新界面。<code>Presenter</code> 不直接依赖 UI
框架，因此可以单独进行单元测试。</li>
</ul>
<h4 id="数据流和交互-1">数据流和交互</h4>
<ul>
<li>用户通过 <code>View</code> 与应用程序交互。</li>
<li><code>View</code> 将用户的输入传递给 <code>Presenter</code>，由
<code>Presenter</code> 处理业务逻辑。</li>
<li><code>Presenter</code> 通过 <code>Model</code> 获取或更新数据。</li>
<li><code>Presenter</code> 将处理后的数据返回给
<code>View</code>，<code>View</code> 根据数据更新界面。</li>
</ul>
<h4 id="优点-8">优点</h4>
<ul>
<li>更好的解耦：<code>View</code> 和 <code>Model</code>
之间完全解耦，<code>View</code> 只负责界面渲染，<code>Presenter</code>
负责业务逻辑。</li>
<li><code>Presenter</code> 不依赖具体的 UI
组件，可以单独测试业务逻辑。</li>
<li>更好的代码组织结构，适合中大型应用。</li>
</ul>
<h4 id="缺点-8">缺点</h4>
<ul>
<li>在复杂应用中，<code>Presenter</code>
也可能变得臃肿，特别是当它负责过多的界面逻辑时。</li>
<li>对于频繁交互的场景，<code>Presenter</code> 和 <code>View</code>
之间的通信可能会增多，导致代码较为繁琐。</li>
</ul>
<h4 id="图示-1">图示：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User &lt;--&gt; View &lt;--&gt; Presenter &lt;--&gt; Model</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="mvvmmodel-view-viewmodel架构模式">3.
<strong>MVVM（Model-View-ViewModel）架构模式</strong></h3>
<h4 id="概述-8">概述</h4>
<p>MVVM
是近年来流行的架构模式，特别是在数据绑定和响应式编程方面表现出色。MVVM
是对 MVP 的进一步演化，它引入了 <strong>ViewModel</strong> 来处理
<code>View</code> 的状态，并与 <code>View</code> 通过双向数据绑定（Data
Binding）进行交互，减少了手动更新 UI 的操作。</p>
<h4 id="组件角色-2">组件角色</h4>
<ul>
<li><strong>Model（模型）</strong>：与 MVC、MVP 中的 <code>Model</code>
一致，负责业务逻辑和数据处理。</li>
<li><strong>View（视图）</strong>：<code>View</code> 负责展示 UI，通常为
XML 布局文件或者 UI 组件。在 MVVM 中，<code>View</code> 通过数据绑定与
<code>ViewModel</code> 进行交互。</li>
<li><strong>ViewModel（视图模型）</strong>：<code>ViewModel</code> 是
<code>Model</code> 和 <code>View</code> 之间的桥梁，负责处理逻辑和维护
UI 状态。它不直接与 <code>View</code> 交互，而是通过
<code>Data Binding</code> 或者
<code>LiveData</code>、<code>Observable</code> 等方式向
<code>View</code> 提供数据。<code>ViewModel</code> 不依赖具体的
<code>View</code>，因此具有很好的可测试性。</li>
</ul>
<h4 id="数据流和交互-2">数据流和交互</h4>
<ul>
<li>用户与 <code>View</code> 交互，<code>View</code>
将用户的操作通过数据绑定机制传递给 <code>ViewModel</code>。</li>
<li><code>ViewModel</code> 处理业务逻辑，调用 <code>Model</code>
获取数据。</li>
<li><code>Model</code> 将数据返回给
<code>ViewModel</code>，<code>ViewModel</code> 通过数据绑定自动更新
<code>View</code>。</li>
</ul>
<h4 id="优点-9">优点</h4>
<ul>
<li><strong>双向数据绑定</strong>：<code>View</code> 和
<code>ViewModel</code> 通过数据绑定机制进行交互，减少了手动更新 UI
的代码量。UI 可以自动响应数据变化。</li>
<li><strong>更好的分离</strong>：<code>View</code> 和
<code>ViewModel</code> 之间完全解耦，<code>ViewModel</code> 不需要知道
<code>View</code> 的具体实现，使得 <code>ViewModel</code>
更容易测试。</li>
<li><strong>响应式编程</strong>：通过 <code>LiveData</code> 或
<code>Observable</code>，<code>View</code>
可以实时监听数据的变化，适合需要频繁更新 UI 的场景。</li>
</ul>
<h4 id="缺点-9">缺点</h4>
<ul>
<li>学习曲线较高，特别是在没有数据绑定框架的情况下，手动实现数据绑定较为复杂。</li>
<li>数据绑定可能导致调试和追踪问题，因为 UI
和逻辑的交互变得不那么直观。</li>
</ul>
<h4 id="图示-2">图示：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User &lt;--&gt; View &lt;--&gt; ViewModel &lt;--&gt; Model</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="mvcmvp-和-mvvm-的区别"><strong>MVC、MVP 和 MVVM
的区别</strong></h4>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 27%" />
<col style="width: 26%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>MVC</th>
<th>MVP</th>
<th>MVVM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>View 和 Model 的关系</strong></td>
<td>View 和 Model 之间可以直接交互</td>
<td>View 和 Model 之间完全解耦</td>
<td>View 和 Model 之间完全解耦</td>
</tr>
<tr class="even">
<td><strong>业务逻辑的放置位置</strong></td>
<td>Controller</td>
<td>Presenter</td>
<td>ViewModel</td>
</tr>
<tr class="odd">
<td><strong>数据绑定</strong></td>
<td>无</td>
<td>无</td>
<td>双向数据绑定（需要框架支持）</td>
</tr>
<tr class="even">
<td><strong>可测试性</strong></td>
<td>较差，Controller 中的逻辑难以测试</td>
<td>较好，Presenter 易于测试</td>
<td>最好，ViewModel 不依赖 UI，易测试</td>
</tr>
<tr class="odd">
<td><strong>代码复杂度</strong></td>
<td>适合简单应用，较低复杂度</td>
<td>中等，适合中型应用</td>
<td>较高，适合复杂应用</td>
</tr>
<tr class="even">
<td><strong>使用场景</strong></td>
<td>小型应用或快速开发</td>
<td>中型应用或需要业务逻辑分离的场景</td>
<td>大型应用或需要响应式界面的场景</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="总结-15">总结</h4>
<ul>
<li><strong>MVC</strong>：最基础的架构模式，适用于简单或较小的项目，但当项目变复杂时，<code>Controller</code>
会变得臃肿，难以维护。</li>
<li><strong>MVP</strong>：相比 MVC，MVP 的 <code>View</code> 和
<code>Model</code> 之间解耦更彻底，<code>Presenter</code>
负责所有的业务逻辑，适合中等复杂度的应用。<code>Presenter</code>
更容易测试和维护。</li>
<li><strong>MVVM</strong>：提供了更高级的双向数据绑定机制，使得
<code>View</code> 和 <code>ViewModel</code>
之间的交互更加自动化，特别适合需要频繁更新 UI
的复杂应用，但引入了更高的复杂性。</li>
</ul>
<h2 id="四大组件">四大组件</h2>
<p>Android 的四大组件（Four Major Components）是 Android
应用程序的基础构建模块，它们分别是
<strong>Activity</strong>、<strong>Service</strong>、<strong>BroadcastReceiver</strong>
和
<strong>ContentProvider</strong>。每一个组件都有其独特的功能和用途，用于构建功能丰富且高度交互的应用程序。下面是对这四个组件的详细介绍：</p>
<hr />
<h3 id="activity活动">1. <strong>Activity（活动）</strong></h3>
<h4 id="概述-9">概述</h4>
<p><strong>Activity</strong> 是 Android
应用程序的主要组件，用于展示用户界面并处理用户与应用程序的交互。每个
Activity
都代表应用的一个界面，是应用与用户之间交互的入口点。用户可以通过触摸屏幕、按键等操作与
Activity 进行交互，Activity 会响应这些操作并作出相应的反应。</p>
<h4 id="主要特点">主要特点：</h4>
<ul>
<li><strong>生命周期</strong>：<code>Activity</code> 的生命周期由
Android 系统管理。常见的生命周期方法包括
<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code>
和 <code>onDestroy()</code>。通过这些方法，开发者可以处理
<code>Activity</code> 的创建、显示、暂停、销毁等过程中的事件。</li>
<li><strong>UI 界面</strong>：每个 <code>Activity</code> 都包含一个 UI
界面，通常由 XML 布局文件描述，开发者可以在其中添加按钮、文本框、图像等
UI 元素。</li>
</ul>
<h4 id="使用场景-5">使用场景：</h4>
<ul>
<li>展示用户界面，如登录页面、主页、设置界面等。</li>
<li>处理用户交互，如点击按钮、输入数据等。</li>
</ul>
<h4 id="示例-6">示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="service服务">2. <strong>Service（服务）</strong></h3>
<h4 id="概述-10">概述</h4>
<p><strong>Service</strong> 是一个运行在后台的 Android
组件，用于执行长时间运行的操作，例如下载文件、播放音乐、处理网络请求等。与
<code>Activity</code> 不同，<code>Service</code>
没有用户界面。<code>Service</code>
可以在应用程序关闭后继续运行，并且它可以与其他组件（如
<code>Activity</code>）进行交互。</p>
<h4 id="主要特点-1">主要特点：</h4>
<ul>
<li><strong>后台运行</strong>：<code>Service</code>
可以在后台执行操作，而不会直接与用户交互。</li>
<li><strong>生命周期</strong>：<code>Service</code>
也有其自己的生命周期管理方法，包括
<code>onStartCommand()</code>、<code>onBind()</code>、<code>onCreate()</code>
和 <code>onDestroy()</code>。服务可以是<strong>启动服务</strong>（通过
<code>startService()</code> 启动）或<strong>绑定服务</strong>（通过
<code>bindService()</code> 启动）。</li>
<li><strong>前台服务</strong>：<code>Service</code>
可以作为<strong>前台服务</strong>运行，这意味着它会持续运行并在状态栏中显示通知，用户可以知道服务正在运行。典型的例子是音乐播放器或
GPS 导航服务。</li>
</ul>
<h4 id="使用场景-6">使用场景：</h4>
<ul>
<li>长时间的后台任务，如音乐播放、下载文件、数据同步等。</li>
<li>执行任务后不需要与用户直接交互的操作。</li>
</ul>
<h4 id="示例-7">示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行后台任务</span></span><br><span class="line">        <span class="keyword">return</span> START_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果不支持绑定，返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="broadcastreceiver广播接收器">3.
<strong>BroadcastReceiver（广播接收器）</strong></h3>
<h4 id="概述-11">概述</h4>
<p><strong>BroadcastReceiver</strong> 是一种 Android
组件，用于监听和接收广播消息。广播是一种应用程序间的消息传递机制，系统或应用程序可以发送广播，其他应用程序或组件可以通过
<code>BroadcastReceiver</code>
监听并响应这些广播。广播可以是系统广播（如网络连接状态变化、电量变化等）或自定义广播。</p>
<h4 id="主要特点-2">主要特点：</h4>
<ul>
<li><strong>广播消息</strong>：广播消息是一种全局通知，广播接收器可以监听这些通知并对其作出反应。系统广播如
“BOOT_COMPLETED” 或
“ACTION_BATTERY_LOW”，应用广播则是应用自定义的广播消息。</li>
<li><strong>无界面组件</strong>：<code>BroadcastReceiver</code>
没有用户界面，只是在接收到广播时执行相应的逻辑。</li>
<li><strong>动态和静态注册</strong>：广播接收器可以在
AndroidManifest.xml 中进行静态注册，或者在代码中动态注册（通常使用
<code>registerReceiver()</code> 和 <code>unregisterReceiver()</code>
方法）。</li>
</ul>
<h4 id="使用场景-7">使用场景：</h4>
<ul>
<li>监听系统广播（如网络状态变化、低电量通知等）。</li>
<li>在应用程序之间进行消息传递。</li>
<li>在特定事件发生时触发操作，如日历提醒、下载完成通知等。</li>
</ul>
<h4 id="示例-8">示例：</h4>
<p><strong>动态注册广播接收器：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理广播</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action.equals(Intent.ACTION_BATTERY_LOW)) &#123;</span><br><span class="line">            <span class="comment">// 电量低时的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Activity中注册接收器</span></span><br><span class="line"><span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(Intent.ACTION_BATTERY_LOW);</span><br><span class="line"><span class="type">MyReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyReceiver</span>();</span><br><span class="line">registerReceiver(receiver, filter);</span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="contentprovider内容提供者">4.
<strong>ContentProvider（内容提供者）</strong></h3>
<h4 id="概述-12">概述</h4>
<p><strong>ContentProvider</strong> 是 Android
中用于在应用程序之间共享数据的组件。<code>ContentProvider</code>
通过标准化的接口为应用程序提供数据访问，可以管理文件、数据库、网络数据等。通过
<code>ContentProvider</code>，应用程序可以共享它们的数据，其他应用程序通过
<code>ContentResolver</code> 接口与 <code>ContentProvider</code>
进行通信。</p>
<h4 id="主要特点-3">主要特点：</h4>
<ul>
<li><strong>数据共享</strong>：<code>ContentProvider</code>
提供了跨应用的数据共享功能。它可以对 SQLite
数据库、文件或网络资源的数据进行操作。</li>
<li><strong>URI 访问数据</strong>：数据通过
URI（统一资源标识符）进行访问，<code>ContentProvider</code> 通过提供
CRUD 操作（创建、读取、更新、删除）来管理数据。</li>
<li><strong>安全性</strong>：<code>ContentProvider</code>
允许对共享的数据进行权限控制，开发者可以设置权限来限制其他应用对数据的访问。</li>
</ul>
<h4 id="使用场景-8">使用场景：</h4>
<ul>
<li>应用之间的数据共享，例如联系人、媒体、文件等。</li>
<li>实现应用与外部存储或其他应用的数据交互。</li>
<li>提供标准化的数据访问接口，例如 Android
系统的联系人、短信、媒体等数据访问。</li>
</ul>
<h4 id="示例-9">示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyContentProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase database;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化数据库</span></span><br><span class="line">        <span class="type">MyDatabaseHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDatabaseHelper</span>(getContext());</span><br><span class="line">        database = helper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询数据</span></span><br><span class="line">        <span class="keyword">return</span> database.query(<span class="string">&quot;my_table&quot;</span>, projection, selection, selectionArgs, <span class="literal">null</span>, <span class="literal">null</span>, sortOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span> &#123;</span><br><span class="line">        <span class="comment">// 插入数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> database.insert(<span class="string">&quot;my_table&quot;</span>, <span class="literal">null</span>, values);</span><br><span class="line">        <span class="keyword">return</span> Uri.withAppendedPath(uri, String.valueOf(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新数据</span></span><br><span class="line">        <span class="keyword">return</span> database.update(<span class="string">&quot;my_table&quot;</span>, values, selection, selectionArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> &#123;</span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        <span class="keyword">return</span> database.delete(<span class="string">&quot;my_table&quot;</span>, selection, selectionArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">(Uri uri)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回MIME类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.dir/vnd.example.my_table&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="四大组件的总结">四大组件的总结</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 15%" />
<col style="width: 31%" />
<col style="width: 42%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="header">
<th>组件</th>
<th>作用</th>
<th>典型使用场景</th>
<th>是否有用户界面</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Activity</strong></td>
<td>展示用户界面，处理用户交互</td>
<td>显示应用程序的界面，如主页、设置页面</td>
<td>有</td>
</tr>
<tr class="even">
<td><strong>Service</strong></td>
<td>执行后台任务，长时间运行操作</td>
<td>播放音乐、后台下载文件、数据同步等</td>
<td>无</td>
</tr>
<tr class="odd">
<td><strong>BroadcastReceiver</strong></td>
<td>监听并响应广播消息，进行全局事件处理</td>
<td>监听系统事件如网络变化、电量低等，或处理应用内的广播消息</td>
<td>无</td>
</tr>
<tr class="even">
<td><strong>ContentProvider</strong></td>
<td>在应用间共享数据，通过标准接口提供数据访问</td>
<td>共享联系人、文件、数据库等，或提供应用间的数据访问</td>
<td>无</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="四大组件的协作">四大组件的协作：</h4>
<ul>
<li>这些组件经常一起使用来构建复杂的 Android 应用程序。例如，一个应用的
<code>Activity</code> 可以启动 <code>Service</code>
来在后台处理任务，而当任务完成时通过广播通知
<code>BroadcastReceiver</code>，同时 <code>ContentProvider</code>
可以用于提供持久化的数据访问。</li>
</ul>
<p>掌握 Android 的四大组件是开发 Android
应用的基础，理解它们的生命周期、作用和交互</p>
<p>方式，可以帮助开发者设计和实现功能丰富且高效的应用程序。</p>
<h2 id="aidl">AIDL</h2>
<p><strong>AIDL</strong>（<strong>Android Interface Definition
Language</strong>，Android 接口定义语言）是 Android 提供的一种用于实现
<strong>进程间通信</strong>（Inter-Process Communication，简称
IPC）的机制。通过
AIDL，应用程序可以与运行在不同进程中的服务或组件进行通信，允许跨进程访问对象并调用远程方法。AIDL
是 Android
中强大且灵活的进程间通信工具之一，尤其适合在多进程环境中使用。</p>
<h3 id="为什么需要-aidl">为什么需要 AIDL？</h3>
<p>在 Android 中，默认情况下应用程序中的所有组件（如
<code>Activity</code>、<code>Service</code>
等）都是运行在同一个进程中的，可以直接通过引用对象来共享数据。但是，当组件运行在不同的进程时，它们之间是不能直接共享数据的，因为每个进程都有自己独立的内存空间。这时候就需要
AIDL 来进行进程间的数据传递和方法调用。</p>
<p>AIDL
的目标是允许你定义一个接口，让其他应用程序或服务可以调用你进程中的方法，就像调用本地方法一样。</p>
<h3 id="aidl-的工作原理">AIDL 的工作原理</h3>
<p>AIDL 的本质是利用 <strong>Binder</strong>
机制来实现不同进程之间的通信。在 Android
中，每个进程都有自己的内存空间，不能直接访问其他进程的数据。Binder 是
Android 的一种高效的 IPC 机制，AIDL 基于 Binder
来实现接口方法的跨进程调用。</p>
<p>AIDL 的工作流程如下：</p>
<ol type="1">
<li><strong>定义 AIDL 接口</strong>：创建一个 <code>.aidl</code>
文件，定义接口中可以被远程调用的方法。</li>
<li><strong>自动生成代码</strong>：Android SDK 工具会根据
<code>.aidl</code> 文件生成 <code>Stub</code> 和 <code>Proxy</code>
代码，<code>Stub</code> 负责接收远程调用，<code>Proxy</code>
负责在客户端执行远程调用。</li>
<li><strong>服务端实现接口</strong>：服务端实现 <code>Stub</code>
类中的方法，这些方法会在远程调用时被触发。</li>
<li><strong>客户端绑定服务</strong>：客户端通过
<code>bindService()</code> 绑定到远程服务，获取 <code>Proxy</code>
对象，并通过这个对象调用远程服务的方法。</li>
</ol>
<h3 id="aidl-的使用步骤">AIDL 的使用步骤</h3>
<h4 id="定义-aidl-接口">1. <strong>定义 AIDL 接口</strong></h4>
<p>首先，你需要定义一个 <code>.aidl</code>
文件，描述客户端和服务端共享的接口。AIDL
支持的基本数据类型包括：<code>int</code>、<code>long</code>、<code>boolean</code>、<code>float</code>、<code>double</code>、<code>String</code>
等，也支持数组、<code>List</code>、<code>Map</code> 和自定义
<code>Parcelable</code> 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// IMyAidlInterface.aidl</span><br><span class="line">package com.example.aidl;</span><br><span class="line"></span><br><span class="line">// 定义一个简单的接口，支持跨进程调用</span><br><span class="line">interface IMyAidlInterface &#123;</span><br><span class="line">    int add(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现-aidl-接口">2. <strong>实现 AIDL 接口</strong></h4>
<p>服务端需要实现这个接口。Android 会自动为这个接口生成一个
<code>Stub</code> 类，服务端需要继承这个 <code>Stub</code>
类并实现接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 AIDL 中定义的接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMyAidlInterface.<span class="type">Stub</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IMyAidlInterface</span>.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回 AIDL 的 Binder 对象</span></span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端绑定远程服务">3. <strong>客户端绑定远程服务</strong></h4>
<p>客户端通过 <code>bindService()</code> 方法来绑定远程服务，并获取
<code>Proxy</code> 对象。通过这个 <code>Proxy</code>
对象，客户端可以像调用本地方法一样调用远程服务中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IMyAidlInterface myAidlInterface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 ServiceConnection，处理与服务的连接和断开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 AIDL 接口的代理对象</span></span><br><span class="line">            myAidlInterface = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">            myAidlInterface = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        <span class="comment">// 绑定远程服务</span></span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 AIDL 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAddition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (myAidlInterface != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> myAidlInterface.add(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Result: &quot;</span> + result);  <span class="comment">// 输出结果：15</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在-androidmanifest.xml-中声明服务">4. <strong>在
<code>AndroidManifest.xml</code> 中声明服务</strong></h4>
<p>服务端的服务组件需要在 <code>AndroidManifest.xml</code>
中声明，并指定
<code>android:exported="true"</code>，以允许外部进程访问它。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MyService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.aidl.IMyAidlInterface&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="aidl-的数据类型支持">AIDL 的数据类型支持</h3>
<p>AIDL 支持以下几种数据类型：</p>
<ol type="1">
<li><strong>基本数据类型</strong>：如
<code>int</code>、<code>long</code>、<code>boolean</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>String</code>
等。</li>
<li><strong>集合类型</strong>：如 <code>List</code> 和
<code>Map</code>（<code>List</code> 可以是泛型
<code>List&lt;T&gt;</code>，T 必须是 AIDL 支持的类型）。</li>
<li><strong>自定义 <code>Parcelable</code>
对象</strong>：如果需要传递复杂的对象，可以实现 <code>Parcelable</code>
接口，并在 AIDL 文件中使用该类型。<code>Parcelable</code> 是 Android
中用于序列化对象的机制，它比 Java 的 <code>Serializable</code>
更高效。</li>
</ol>
<h3 id="aidl-的优缺点">AIDL 的优缺点</h3>
<h4 id="优点-10">优点：</h4>
<ol type="1">
<li><strong>跨进程通信</strong>：AIDL 是 Android 官方提供的 IPC
机制，支持跨进程调用远程服务中的方法。</li>
<li><strong>灵活性</strong>：通过
AIDL，可以灵活定义接口、数据类型以及不同进程间的调用方式。</li>
<li><strong>高效</strong>：AIDL 基于 Binder 机制，而 Binder 是 Android
特有的、非常高效的进程间通信方式。</li>
</ol>
<h4 id="缺点-10">缺点：</h4>
<ol type="1">
<li><strong>复杂性</strong>：AIDL
增加了开发复杂度，尤其是涉及到传递复杂对象时，需要手动实现
<code>Parcelable</code>。</li>
<li><strong>性能开销</strong>：虽然 AIDL 基于 Binder
是高效的，但频繁的跨进程通信仍然会带来一定的性能开销。一般情况下，应尽量减少进程间通信的频率和数据量。</li>
<li><strong>并发问题</strong>：AIDL 服务是多线程的，因此在实现 AIDL
接口时，开发者需要注意线程安全问题。</li>
</ol>
<h3 id="aidl-的典型使用场景">AIDL 的典型使用场景</h3>
<ol type="1">
<li><strong>音乐播放器</strong>：当音乐播放器的 UI
组件和后台播放服务运行在不同的进程中时，可以使用 AIDL 来让 UI
控制后台服务，比如播放、暂停、跳转等操作。</li>
<li><strong>远程数据处理</strong>：有些应用会在后台服务中进行繁重的计算任务或网络操作，而主应用进程可以通过
AIDL 调用这些任务并获取结果。</li>
<li><strong>跨应用通信</strong>：AIDL
可以用于不同应用间的通信。例如，应用 A 提供了一些服务，应用 B 可以通过
AIDL 访问这些服务。</li>
</ol>
<h3 id="总结-16">总结</h3>
<p>AIDL 是 Android 中用于实现进程间通信的强大工具，它基于 Binder
机制，允许不同进程的组件通过接口进行方法调用和数据传递。AIDL
主要用于需要在不同进程间进行复杂数据交互的场景，如后台服务、跨应用通信等。</p>
<p>开发者在使用 AIDL
时，需要了解进程间通信的特性，并注意线程安全和性能开销问题。虽然 AIDL
提供了极大的灵活性，但应在有必要的场景下使用，避免不必要的复杂度。</p>
<h2 id="性能优化">性能优化</h2>
<p>在 Android
应用开发中，性能优化是确保应用流畅运行、节省资源并提升用户体验的关键环节。常见的
Android 性能优化方法可以分为多种类型，如内存优化、UI
优化、电量优化、网络优化等。以下是一些常用的 Android 性能优化方法：</p>
<h3 id="内存优化">1. <strong>内存优化</strong></h3>
<p>参考：https://mp.weixin.qq.com/s/vuVZWsn9iGXTxvHQPfmKHQ</p>
<h4 id="减少内存泄漏">1.1 减少内存泄漏</h4>
<ul>
<li><strong>内存泄漏</strong>会导致应用在长时间运行后变得缓慢，甚至崩溃。</li>
<li>使用工具：Android Studio 的 <strong>LeakCanary</strong> 或
<strong>Memory Profiler</strong> 来检测内存泄漏。</li>
<li>避免持有对 <code>Context</code> 的长时间引用，尤其是
<code>Activity</code> 或 <code>Fragment</code>，避免使用静态变量持有
<code>Context</code>。</li>
<li>对于生命周期长的对象，如单例、线程等，应确保它们不会持有对短生命周期对象的引用。</li>
</ul>
<h4 id="使用合适的数据结构">1.2 使用合适的数据结构</h4>
<ul>
<li>使用轻量级的数据结构，比如在小数据量情况下使用
<code>ArrayList</code> 而不是 <code>HashMap</code>。</li>
<li>对于大数据或频繁操作的数据集，使用更高效的容器，比如
<code>SparseArray</code> 替代 <code>HashMap</code> 来节省内存。</li>
</ul>
<h4 id="使用合适的-bitmap-配置">1.3 使用合适的 Bitmap 配置</h4>
<ul>
<li>加载图片时使用 <code>BitmapFactory.Options</code> 的
<code>inSampleSize</code> 来缩放图片，防止加载过大的图片导致
<code>OutOfMemoryError</code>。</li>
<li>使用 <strong>LruCache</strong> 对图片进行缓存，避免重复加载。</li>
<li>在不需要图片时，及时调用 <code>Bitmap.recycle()</code>
来释放内存。</li>
</ul>
<h4 id="避免使用过多的-service">1.4 避免使用过多的
<code>Service</code></h4>
<ul>
<li><code>Service</code> 会常驻内存，占用资源。尽量使用
<strong>JobScheduler</strong> 或 <strong>WorkManager</strong>
来替代传统的 <code>Service</code>，尤其是后台任务的调度。</li>
</ul>
<h3 id="ui-优化">2. <strong>UI 优化</strong></h3>
<h4 id="避免-ui-卡顿anr">2.1 避免 UI 卡顿（ANR）</h4>
<ul>
<li>使用主线程（UI线程）处理复杂的逻辑或长时间的任务会导致
<strong>ANR（Application Not Responding）</strong>。</li>
<li>将耗时的操作（如网络请求、数据库查询、文件读写等）放在子线程中，使用
<strong>Handler</strong> 或 <strong>AsyncTask</strong>
进行异步处理。</li>
<li>对于频繁更新 UI 的场景，使用 <strong>RecyclerView</strong> 替代
<code>ListView</code>，并对 View 进行缓存和复用，减少创建和销毁
<code>View</code> 的次数。</li>
</ul>
<h4 id="优化布局">2.2 优化布局</h4>
<ul>
<li>减少布局层级，避免深层嵌套。</li>
<li>使用 <strong>ConstraintLayout</strong>，替代复杂的
<code>RelativeLayout</code> 和 <code>LinearLayout</code> 嵌套。</li>
<li>使用 <strong>Layout Inspector</strong>
工具分析布局层级，优化过于复杂的布局结构。</li>
<li>对于动态界面，使用 <strong>ViewStub</strong> 和
<strong>include</strong> 标签来优化布局加载，减少不必要的视图渲染。</li>
</ul>
<h4 id="避免频繁重绘">2.3 避免频繁重绘</h4>
<ul>
<li>避免频繁调用 <code>invalidate()</code>，尽量减少对 View
的重复绘制。</li>
<li>对于动画等频繁更新 UI 的场景，使用 <code>View.invalidate()</code>
时，只更新变化的区域而非整个视图。</li>
</ul>
<h3 id="电量优化">3. <strong>电量优化</strong></h3>
<h4 id="减少不必要的后台任务">3.1 减少不必要的后台任务</h4>
<ul>
<li>使用 <strong>JobScheduler</strong> 或 <strong>WorkManager</strong>
来调度任务，而不是使用 <code>Service</code> 或 <code>AlarmManager</code>
来频繁唤醒设备。</li>
<li>合理使用 <strong>Doze 模式</strong> 和 <strong>App
Standby</strong>，在应用进入后台时，尽量停止不必要的后台任务。</li>
<li>控制应用的唤醒频率，尽量减少 <code>WakeLock</code>
的使用，避免长时间占用 CPU。</li>
</ul>
<h4 id="优化传感器和-gps-使用">3.2 优化传感器和 GPS 使用</h4>
<ul>
<li>尽量减少传感器（如加速度计、陀螺仪）和 GPS 的高频次使用。</li>
<li>使用更节能的定位方式，如 <strong>Fused Location Provider
API</strong>，并根据需求调整定位精度，避免频繁的高精度 GPS 调用。</li>
</ul>
<h3 id="网络优化">4. <strong>网络优化</strong></h3>
<h4 id="减少不必要的网络请求">4.1 减少不必要的网络请求</h4>
<ul>
<li>合理使用网络请求，减少频繁的请求。</li>
<li>在需要重复请求的场景下，使用 <strong>缓存机制</strong>，例如 OkHttp
的缓存控制功能，避免每次都从服务器获取相同的数据。</li>
</ul>
<h4 id="压缩数据">4.2 压缩数据</h4>
<ul>
<li>尽量压缩网络请求的数据，使用 JSON 格式替代 XML
格式，减少数据包大小。</li>
<li>对图片等静态资源进行压缩，使用合适的图片格式和尺寸，减少带宽消耗。</li>
</ul>
<h4 id="批量处理网络请求">4.3 批量处理网络请求</h4>
<ul>
<li>使用 <strong>批量请求</strong>，例如合并多个请求或使用多路复用（如
HTTP/2 支持的多路复用）来减少网络交互的次数和延迟。</li>
<li>合理设计 API 接口，减少请求次数和数据传输量。</li>
</ul>
<h4 id="使用高效的网络库">4.4 使用高效的网络库</h4>
<ul>
<li>使用高效的网络库如
<strong>Retrofit</strong>、<strong>OkHttp</strong>，并配置合理的连接超时、读取超时等参数。</li>
<li>对于大文件下载，使用断点续传等技术减少网络资源浪费。</li>
</ul>
<h3 id="启动速度优化">5. <strong>启动速度优化</strong></h3>
<h4 id="减少启动时的初始化工作">5.1 减少启动时的初始化工作</h4>
<ul>
<li>在应用启动时，避免进行过多的初始化操作。将非必要的初始化延迟到用户实际需要时再进行。</li>
<li>使用 <strong>Lazy Initialization</strong>
技术，按需加载资源和模块。</li>
<li>通过 <strong>Profile GPU Rendering</strong>
工具检查启动时的绘制性能。</li>
</ul>
<h4 id="优化冷启动">5.2 优化冷启动</h4>
<ul>
<li>使用 <code>SplashActivity</code> 或空白的 <code>Theme</code>
来显示一个过渡界面，确保应用的冷启动时间尽可能短。</li>
<li>减少或推迟启动时的耗时操作，如数据库查询、网络请求等。</li>
</ul>
<h3 id="多线程优化">6. <strong>多线程优化</strong></h3>
<h4 id="合理使用线程池">6.1 合理使用线程池</h4>
<ul>
<li>避免创建过多的线程，尽量使用 <strong>线程池</strong>
来管理并发任务。</li>
<li>使用 <strong>AsyncTask</strong> 或 <strong>Executors</strong>
来处理异步任务，减少线程的开销和资源消耗。</li>
</ul>
<h4 id="避免线程竞争">6.2 避免线程竞争</h4>
<ul>
<li>合理管理多线程操作，避免多线程竞争资源导致的性能问题，例如使用锁机制时要避免锁粒度过大，影响性能。</li>
</ul>
<h3 id="数据库优化">7. <strong>数据库优化</strong></h3>
<h4 id="使用高效的数据库操作">7.1 使用高效的数据库操作</h4>
<ul>
<li>数据库操作应尽量在子线程中进行，避免阻塞主线程。</li>
<li>使用 <strong>批量插入/更新</strong>，减少频繁的数据库写入操作。</li>
<li>在查询时，尽量避免使用
<code>SELECT *</code>，而是只查询需要的字段，减少数据读取量。</li>
</ul>
<h4 id="使用索引优化查询">7.2 使用索引优化查询</h4>
<ul>
<li>对常用的查询字段建立索引，提高查询效率，但要避免在不必要的字段上建立过多的索引。</li>
</ul>
<h3 id="其他优化方法">8. <strong>其他优化方法</strong></h3>
<h4 id="使用-proguard-进行代码混淆与优化">8.1 使用 ProGuard
进行代码混淆与优化</h4>
<ul>
<li>开启 <strong>ProGuard</strong> 或 <strong>R8</strong>
来混淆代码、移除未使用的代码和资源，减小 APK
大小，并提升应用的安全性。</li>
</ul>
<h4 id="资源优化">8.2 资源优化</h4>
<ul>
<li>减少 APK 包大小，压缩图片、音频资源，删除不必要的资源文件。</li>
<li>使用 <strong>Android App Bundle</strong>，让 Google Play
根据用户设备生成最适合的 APK，减小下载包大小。</li>
</ul>
<h3 id="结论">结论：</h3>
<p>通过合理运用上述的性能优化策略，开发者可以显著提升 Android
应用的运行效率，减少内存消耗，避免 UI
卡顿和崩溃，提高电池续航，优化网络请求。性能优化是一个持续关注和调优的过程，借助
Android Studio 的工具（如 Profiler、Lint
等），可以更容易发现和解决潜在的性能瓶颈。</p>
<h2 id="mediacodec">MediaCodec</h2>
<p><code>MediaCodec</code> 是 Android 平台上的一个多媒体编解码器
API，允许应用程序高效地编码和解码音视频数据。它的主要作用是提供一个硬件加速的接口来处理媒体数据，能够在支持的设备上显著提高媒体处理的效率和性能。<code>MediaCodec</code>
通常与 <code>MediaExtractor</code>、<code>MediaMuxer</code>
等组件结合使用，以实现媒体的读取、解码、处理和重编码。下面是
<code>MediaCodec</code> 的工作原理及其基本流程：</p>
<h3 id="mediacodec-的工作原理"><code>MediaCodec</code> 的工作原理：</h3>
<p><code>MediaCodec</code>
使用缓冲区队列模型，在内部通过输入和输出缓冲区与编码器或解码器硬件进行交互。它的基本工作流程可以分为以下几个步骤：</p>
<ol type="1">
<li><strong>创建编码器或解码器</strong>：
<ul>
<li>应用程序需要根据需要使用的编解码器（如 H.264、AAC 等）来初始化一个
<code>MediaCodec</code> 实例。</li>
<li>通过 <code>MediaCodec.createDecoderByType()</code> 或
<code>MediaCodec.createEncoderByType()</code>
指定编码或解码的媒体格式类型。</li>
</ul></li>
<li><strong>配置 <code>MediaCodec</code></strong>：
<ul>
<li>使用 <code>configure()</code>
方法来设置编解码器的格式参数（例如帧率、码率、分辨率、采样率等），并且可以指定输入输出的
<code>Surface</code>（如果是视频数据）。</li>
<li>可以配置解码器将视频输出到屏幕或者输出到内存中进一步处理。</li>
</ul></li>
<li><strong>输入缓冲区处理（解码/编码）</strong>：
<ul>
<li><strong>填充输入缓冲区</strong>：<code>MediaCodec</code>
会分配一组输入缓冲区（input
buffers），应用程序需要获取这些缓冲区，然后将需要解码或编码的数据填充到缓冲区中。
<ul>
<li>通过 <code>dequeueInputBuffer()</code>
方法获取空闲的输入缓冲区。</li>
<li>应用程序将音视频数据填充到缓冲区后，再通过
<code>queueInputBuffer()</code> 提交给 <code>MediaCodec</code>
进行处理。</li>
</ul></li>
<li>对于视频解码，通常与 <code>MediaExtractor</code>
一起使用，先从媒体文件中提取帧数据，然后将数据送入输入缓冲区。</li>
</ul></li>
<li><strong>解码或编码过程</strong>：
<ul>
<li><code>MediaCodec</code>
内部硬件或软件会对输入缓冲区中的数据进行处理，解码或编码为指定的格式。</li>
<li>在解码的场景中，<code>MediaCodec</code> 将压缩的数据（如
H.264）解码为原始帧数据。在编码的场景中，<code>MediaCodec</code>
将原始数据（如 YUV）编码为压缩格式。</li>
</ul></li>
<li><strong>输出缓冲区处理</strong>：
<ul>
<li><code>MediaCodec</code>
将解码或编码后的数据放入输出缓冲区，应用程序可以通过
<code>dequeueOutputBuffer()</code> 获取这些缓冲区。</li>
<li>获取输出缓冲区后，应用程序可以对解码后的原始帧进行显示、保存，或者对编码后的数据进行封装存储等操作。</li>
<li>对于视频解码，可以直接将数据呈现到 <code>Surface</code>
上，避免数据从 GPU 到 CPU 再到 GPU 的拷贝，提升效率。</li>
</ul></li>
<li><strong>释放和重置</strong>：
<ul>
<li>完成编解码操作后，应用程序可以调用 <code>release()</code> 方法释放
<code>MediaCodec</code> 实例。</li>
<li>也可以通过 <code>flush()</code> 方法重置
<code>MediaCodec</code>，在不改变配置的前提下，清空所有缓冲区，适用于流式媒体解码场景。</li>
</ul></li>
</ol>
<h3 id="基本工作流程图">基本工作流程图：</h3>
<ol type="1">
<li><p><strong>创建 <code>MediaCodec</code> 并配置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MediaCodec codec = MediaCodec.createDecoderByType(&quot;video/avc&quot;);</span><br><span class="line">codec.configure(format, surface, null, 0);</span><br><span class="line">codec.start();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>解码数据</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">while (decoding) &#123;</span><br><span class="line">    // 获取输入缓冲区并填充数据</span><br><span class="line">    int inputBufferIndex = codec.dequeueInputBuffer(TIMEOUT_US);</span><br><span class="line">    if (inputBufferIndex &gt;= 0) &#123;</span><br><span class="line">        ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferIndex);</span><br><span class="line">        inputBuffer.clear();</span><br><span class="line">        // 从数据源读取数据并填充到缓冲区中</span><br><span class="line">        int sampleSize = extractor.readSampleData(inputBuffer, 0);</span><br><span class="line">        if (sampleSize &lt; 0) &#123;</span><br><span class="line">            // No more data</span><br><span class="line">            codec.queueInputBuffer(inputBufferIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);</span><br><span class="line">            decoding = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long presentationTimeUs = extractor.getSampleTime();</span><br><span class="line">            codec.queueInputBuffer(inputBufferIndex, 0, sampleSize, presentationTimeUs, 0);</span><br><span class="line">            extractor.advance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取解码后的输出缓冲区</span><br><span class="line">    MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();</span><br><span class="line">    int outputBufferIndex = codec.dequeueOutputBuffer(bufferInfo, TIMEOUT_US);</span><br><span class="line">    if (outputBufferIndex &gt;= 0) &#123;</span><br><span class="line">        // 处理解码后的数据</span><br><span class="line">        codec.releaseOutputBuffer(outputBufferIndex, true);  // true 表示渲染到 Surface</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>释放 <code>MediaCodec</code></strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">codec.stop();</span><br><span class="line">codec.release();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="mediacodec-的特点"><code>MediaCodec</code> 的特点：</h3>
<ul>
<li><strong>硬件加速</strong>：<code>MediaCodec</code> 通过设备硬件（如
GPU、DSP
等）加速解码和编码操作，比纯软件编解码效率更高，特别适合高分辨率视频处理。</li>
<li><strong>低延迟</strong>：由于直接操作缓冲区队列并结合硬件加速，能够提供低延迟的编解码，适合实时媒体处理，如视频会议、直播。</li>
<li><strong>灵活性</strong>：支持视频和音频的多种格式（如
H.264、H.265、VP8、AAC、MP3 等），可适应多种应用场景。</li>
</ul>
<p>总结来说，<code>MediaCodec</code>
提供了一个高效、灵活的多媒体编解码接口，通过硬件加速的方式让应用程序能够处理复杂的音视频数据，同时降低了对系统资源的消耗。</p>
<h3 id="参考">参考</h3>
<p><a
target="_blank" rel="noopener" href="https://juejin.cn/post/6844903573306916878">安卓解码器MediaCodec解析</a></p>
<h2 id="camera-和-camera2-的区别">Camera 和 Camera2 的区别</h2>
<p><code>Android Camera</code> API 和 <code>Camera2</code> API 是
Android 平台上用于开发摄像头功能的两个主要 API。<code>Camera2</code> API
是为了替代早期的 <code>Camera</code> API
而推出的，提供了更强大的功能和更灵活的控制方式。以下是这两个 API
的主要区别：</p>
<h3 id="api-的推出时间">1. <strong>API 的推出时间</strong></h3>
<ul>
<li><strong>Camera API</strong>：这是 Android 1.0
版本引入的较早的摄像头接口，它在 Android
5.0（Lollipop）之后逐渐被弃用。</li>
<li><strong>Camera2 API</strong>：在 Android
5.0（Lollipop）中引入，用于提供更精细的摄像头控制和硬件功能支持。</li>
</ul>
<h3 id="api-设计和复杂性">2. <strong>API 设计和复杂性</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li><strong>简单易用</strong>：<code>Camera API</code>
比较简单易用，适合快速开发一些基本的摄像头功能。</li>
<li><strong>功能有限</strong>：它的设计目标是提供基本的拍照和录制视频功能，无法直接访问摄像头硬件的高级特性。</li>
<li><strong>同步模式</strong>：操作大多是同步的，容易出现卡顿或性能瓶颈的问题，尤其在高性能需求场景下。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li><strong>高度灵活且复杂</strong>：<code>Camera2</code>
采用了全新的设计模式，基于管道（pipeline）机制。开发者可以非常灵活地控制图像捕捉流程，包括对曝光、对焦、ISO
等参数进行精细的调整。</li>
<li><strong>异步模式</strong>：<code>Camera2</code>
使用异步的回调机制，通过 <code>Handler</code>
来处理图像数据流，支持多线程和更好的性能优化。</li>
<li><strong>更高的学习曲线</strong>：与 <code>Camera API</code>
相比，<code>Camera2</code>
的使用更为复杂，需要对相机特性有更深入的了解。</li>
</ul></li>
</ul>
<h3 id="硬件能力的访问">3. <strong>硬件能力的访问</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li>只能进行非常有限的设置，例如分辨率和缩放。无法很好地访问和利用摄像头的高级功能。</li>
<li>不支持手动控制 ISO、快门速度、白平衡、对焦等参数。</li>
<li>无法使用 RAW 格式拍摄，只能获取压缩格式（如 JPEG）的图片。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li>提供对摄像头硬件的细粒度控制，允许开发者通过
<code>CaptureRequest</code>
自定义曝光时间、ISO、对焦距离、快门速度等参数。</li>
<li>支持高级模式，比如全手动模式、自动对焦/自动曝光/自动白平衡锁定等。</li>
<li>支持拍摄 RAW 格式图像，便于开发者在后期处理时有更大的灵活度。</li>
<li>允许开发者访问双摄像头功能，以及处理高帧率视频和慢动作视频。</li>
</ul></li>
</ul>
<h3 id="图像处理与数据流">4. <strong>图像处理与数据流</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li>图像处理和捕捉流程是比较固定的，开发者难以自定义数据流。</li>
<li>通过预览界面获取图像数据，无法获得预览与拍摄的分离控制。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li><code>Camera2</code> 提供了一个基于 <strong>管道（Capture
Pipeline）</strong>
的图像捕捉流程，可以同时处理多个数据流，比如同时预览、拍照、录像等。</li>
<li>可以处理多个输出目标（如
<code>Surface</code>、<code>ImageReader</code>），支持多线程并发处理数据。</li>
<li>支持并行预览、拍照和录像，且能够更好地控制帧率和分辨率。</li>
</ul></li>
</ul>
<h3 id="性能与帧率控制">5. <strong>性能与帧率控制</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li>性能相对较低，主要适用于低帧率的预览和拍摄。</li>
<li>对高帧率视频录制和高性能图像处理支持有限。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li>提供更高效的图像处理流程，支持高帧率视频录制和慢动作视频。</li>
<li>可以通过手动调节帧率和分辨率来优化性能，适合高性能场景。</li>
</ul></li>
</ul>
<h3 id="开发者工具与兼容性">6. <strong>开发者工具与兼容性</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li>由于 Camera API 较为简单，适合快速开发入门级的摄像头应用。</li>
<li>但是它的功能有限，且在 Android 5.0 之后逐渐被 Camera2
取代，因此并不适合现代高需求的应用场景。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li>虽然复杂度较高，但适合开发需要高度自定义、专业级别的应用，如专业相机应用、AR/VR
应用等。</li>
<li>Camera2 API 兼容 Android 5.0
及更高版本的设备，某些设备可能没有完全支持 Camera2 API
的所有特性（如完全手动控制），这取决于设备硬件支持。</li>
</ul></li>
</ul>
<h3 id="扩展和进化">7. <strong>扩展和进化</strong></h3>
<ul>
<li><strong>Camera API</strong>：
<ul>
<li>基本没有进一步的发展，功能已经很有限，主要用于向后兼容性。</li>
</ul></li>
<li><strong>Camera2 API</strong>：
<ul>
<li>是 Android 未来摄像头开发的主流 API，不断得到改进和扩展。随着
Android
版本的升级，新特性不断加入（如多摄像头的同步控制、深度图等）。</li>
</ul></li>
</ul>
<h3 id="示例代码差异">8. <strong>示例代码差异</strong></h3>
<p><strong>Camera API 示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> Camera.open();</span><br><span class="line">Camera.<span class="type">Parameters</span> <span class="variable">params</span> <span class="operator">=</span> camera.getParameters();</span><br><span class="line">camera.setPreviewDisplay(surfaceHolder);</span><br><span class="line">camera.startPreview();</span><br></pre></td></tr></table></figure>
<p><strong>Camera2 API 示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CameraManager</span> <span class="variable">manager</span> <span class="operator">=</span> (CameraManager) getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">CameraDevice.<span class="type">StateCallback</span> <span class="variable">stateCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraDevice</span>.StateCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpened</span><span class="params">(CameraDevice cameraDevice)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动相机预览</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDisconnected</span><span class="params">(CameraDevice cameraDevice)</span> &#123; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(CameraDevice cameraDevice, <span class="type">int</span> error)</span> &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">manager.openCamera(cameraId, stateCallback, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="总结-17">总结：</h3>
<ul>
<li><strong>Camera API</strong>
更简单，适合基础的拍照和视频录制应用，但功能和性能有限，已逐步被淘汰。</li>
<li><strong>Camera2 API</strong>
提供了更强大、更灵活的摄像头控制，适合对性能和高级功能有较高要求的应用开发，但其复杂性较高，需要开发者更深入的掌握相关概念和技术。</li>
</ul>
<p>目前，开发复杂或高性能摄像头应用时，<code>Camera2 API</code>
是首选。</p>
<h2 id="bufferqueue">BufferQueue</h2>
<p><code>BufferQueue</code> 是 Android
图形子系统中一个非常核心的组件，它负责管理生产者和消费者之间的缓冲区交换，通常用于处理图像和视频流数据。<code>BufferQueue</code>
是构建图像渲染管道的基础部分，应用于窗口管理器（SurfaceFlinger）、相机、视频播放器等与图像显示相关的系统组件中。</p>
<h3 id="bufferqueue-的工作机制"><code>BufferQueue</code> 的工作机制</h3>
<p><code>BufferQueue</code>
是一个<strong>生产者/消费者模式</strong>的实现，包含两个主要部分： -
<strong>生产者（Producer）</strong>：向缓冲区队列提交图像数据。 -
<strong>消费者（Consumer）</strong>：从缓冲区队列读取并处理图像数据。</p>
<p>生产者和消费者可以在不同的线程或进程中运行，<code>BufferQueue</code>
负责在它们之间传递缓冲区。</p>
<h4 id="主要组件">主要组件</h4>
<ol type="1">
<li><p><strong><code>GraphicBuffer</code></strong>：<code>BufferQueue</code>
中传递的实际缓冲区，是承载图像数据的内存块。生产者将数据填充到
<code>GraphicBuffer</code>
中，消费者从中读取图像并进行处理或显示。</p></li>
<li><p><strong><code>BufferSlot</code></strong>：<code>BufferQueue</code>
中的每个缓冲区被称为一个 <code>BufferSlot</code>，通常
<code>BufferQueue</code> 维护一个固定数量的
<code>BufferSlot</code>。生产者和消费者通过 <code>BufferSlot</code>
来交换数据。</p></li>
<li><p><strong><code>Surface</code> 和
<code>SurfaceTexture</code></strong>：</p>
<ul>
<li><strong><code>Surface</code></strong>：生产者通过
<code>Surface</code> 向 <code>BufferQueue</code>
提交数据，常用于图像渲染。例如，当一个应用想要在屏幕上绘制图像时，它会通过
<code>Surface</code> 向 <code>BufferQueue</code> 发送图像。</li>
<li><strong><code>SurfaceTexture</code></strong>：消费者通过
<code>SurfaceTexture</code> 从 <code>BufferQueue</code>
获取数据，通常用于纹理渲染（如 OpenGL 中的渲染）。</li>
</ul></li>
</ol>
<h4 id="流程">流程</h4>
<ol type="1">
<li><strong>生产者提交数据</strong>：
<ul>
<li>生产者通过 <code>Surface</code> 或其他接口向
<code>BufferQueue</code> 提交新的 <code>GraphicBuffer</code>。</li>
<li>生产者调用 <code>dequeueBuffer()</code> 从 <code>BufferQueue</code>
请求一个空闲的缓冲区
<code>BufferSlot</code>，生产者可以向这个缓冲区中填充图像数据。</li>
<li>填充完数据后，生产者调用 <code>queueBuffer()</code>
将这个缓冲区返回给
<code>BufferQueue</code>，表示该缓冲区现在包含了新的一帧图像数据。</li>
</ul></li>
<li><strong>消费者读取数据</strong>：
<ul>
<li>消费者会调用 <code>acquireBuffer()</code> 来从
<code>BufferQueue</code> 中获取已填充的
<code>BufferSlot</code>，并从中读取图像数据。</li>
<li>一旦消费者完成了对图像的处理或显示，它会调用
<code>releaseBuffer()</code>，将缓冲区返回给
<code>BufferQueue</code>，以便生产者再次使用。</li>
</ul></li>
</ol>
<h3 id="bufferqueue-的主要作用"><code>BufferQueue</code> 的主要作用</h3>
<ol type="1">
<li><p><strong>异步图像处理</strong>： <code>BufferQueue</code>
实现了生产者和消费者的异步通信。生产者和消费者可以在不同的线程或进程中独立运行，<code>BufferQueue</code>
通过缓冲区管理确保数据交换的高效和流畅。生产者可以持续生成数据而不用等待消费者处理完成。</p></li>
<li><p><strong>双缓冲或多缓冲机制</strong>： <code>BufferQueue</code>
支持多缓冲机制（通常是双缓冲或三缓冲），确保在高帧率的图像处理过程中避免撕裂现象。生产者可以生成下一帧数据，而消费者正在处理或显示上一帧的数据。</p></li>
<li><p><strong>图形显示和纹理渲染的桥梁</strong>： 在 Android
中，应用通过 <code>Surface</code> 提交图像数据，这些数据被消费者（如
<code>SurfaceFlinger</code> 或 GPU）从 <code>BufferQueue</code>
中读取，用于最终的图形显示或作为 OpenGL 纹理使用。</p></li>
</ol>
<h3 id="bufferqueue-的工作示例"><code>BufferQueue</code> 的工作示例</h3>
<p><strong>图形渲染流程</strong>： 在一个典型的 Android
图形渲染场景中，应用程序通过 <code>SurfaceView</code>
绘制图像，背后实际涉及 <code>BufferQueue</code> 的运作： - 应用通过
<code>Surface</code> 提交绘制数据（例如，游戏中的帧）。 -
<code>BufferQueue</code> 在后台处理缓冲区队列。 -
<code>SurfaceFlinger</code> 作为消费者，从 <code>BufferQueue</code>
获取缓冲区并将其合成到最终的显示屏幕上。</p>
<h4 id="示例流程">示例流程：</h4>
<ol type="1">
<li>应用程序向 <code>Surface</code> 请求一个缓冲区。</li>
<li><code>BufferQueue</code>
分配一个空闲的缓冲区（<code>BufferSlot</code>）并返回给应用程序。</li>
<li>应用程序将图像数据写入缓冲区，并将其放回
<code>BufferQueue</code>。</li>
<li><code>SurfaceFlinger</code> 从 <code>BufferQueue</code>
获取这个缓冲区，并将其显示在屏幕上。</li>
<li>一旦显示完成，缓冲区会被标记为空闲状态，并且可供生产者再次使用。</li>
</ol>
<h3 id="bufferqueue-的实际应用场景">BufferQueue 的实际应用场景</h3>
<h4 id="camera-api">1. <strong>Camera API</strong></h4>
<p>在 Camera 应用程序中，<code>BufferQueue</code>
被用于管理相机的预览帧流。相机硬件作为生产者不断地将预览帧（图像数据）发送到
<code>BufferQueue</code> 中，而应用程序或 <code>SurfaceFlinger</code>
作为消费者，从 <code>BufferQueue</code> 中获取并处理或显示这些帧。</p>
<h4 id="视频播放">2. <strong>视频播放</strong></h4>
<p>在视频播放过程中，视频解码器解码后的图像帧通过
<code>BufferQueue</code>
发送给显示器。解码器是生产者，播放器是消费者。视频播放器通过
<code>SurfaceView</code> 或 <code>TextureView</code>
处理解码后的图像，并呈现在用户界面上。</p>
<h4 id="opengl-纹理渲染">3. <strong>OpenGL 纹理渲染</strong></h4>
<p><code>SurfaceTexture</code> 使用 <code>BufferQueue</code>
来管理将图像数据传递给 GPU 的过程。应用程序可以通过
<code>SurfaceTexture</code> 从摄像头或其他数据源获取图像，并将其作为
OpenGL 纹理进行渲染。</p>
<h3 id="bufferqueue-的优化点">BufferQueue 的优化点</h3>
<ul>
<li><p><strong>锁定与并发</strong>：<code>BufferQueue</code>
使用了同步机制来确保生产者和消费者的并发访问安全。在高性能场景下，对锁的优化非常关键。Android
内部对 <code>BufferQueue</code>
的锁机制进行了深度优化，避免了不必要的阻塞和性能开销。</p></li>
<li><p><strong>多缓冲区模式</strong>：通过支持双缓冲、三缓冲等机制，<code>BufferQueue</code>
能够有效减少生产者和消费者之间的等待时间，提高图像处理的流畅度。</p></li>
<li><p><strong>硬件加速</strong>：<code>BufferQueue</code>
直接与硬件加速进行协作，生产者和消费者可以使用
<code>GraphicBuffer</code> 来减少数据拷贝的开销，直接在 GPU
中操作，提高效率。</p></li>
</ul>
<h3 id="总结-18">总结</h3>
<p><code>BufferQueue</code> 是 Android
图形系统的核心机制，用于协调生产者（例如应用、相机、视频解码器等）和消费者（如
<code>SurfaceFlinger</code>、OpenGL
渲染器等）之间的缓冲区传递。它通过异步处理和多缓冲区机制，确保图像数据高效传输，并避免卡顿、撕裂等现象。在实际的
Android 开发中，理解 <code>BufferQueue</code>
的工作原理对于优化图像显示性能非常重要。</p>
<h2 id="组件化">组件化</h2>
<p>Android
组件化是一种将应用程序的不同功能模块分离成独立组件的开发架构模式。这些组件可以单独开发、测试、调试和维护，并且通过某种机制进行集成，最终构成一个完整的应用程序。组件化的目的是提升代码的可维护性、复用性和灵活性，尤其在大型团队开发中显得尤为重要。</p>
<h3 id="为什么需要组件化">为什么需要组件化？</h3>
<ol type="1">
<li><p><strong>降低复杂度</strong>：随着应用功能越来越复杂，代码变得难以维护和扩展。通过将不同功能划分成模块，可以降低整体代码的复杂性。</p></li>
<li><p><strong>并行开发</strong>：团队成员可以同时开发不同的模块，减少相互依赖，提高开发效率。</p></li>
<li><p><strong>复用性</strong>：组件可以在不同项目中复用，降低代码冗余，提升开发效率。</p></li>
<li><p><strong>独立性</strong>：组件可以独立开发、调试和测试，不依赖于整个应用程序的运行，减少开发调试的时间。</p></li>
<li><p><strong>降低耦合</strong>：通过组件化，模块间的依赖性降低，模块之间的通信可以通过接口或依赖注入实现，从而降低耦合度。</p></li>
</ol>
<h3 id="组件化的基本概念">组件化的基本概念</h3>
<ol type="1">
<li><strong>组件（Component）</strong>：
<ul>
<li>每个组件是一个相对独立的功能模块，比如登录模块、用户模块、支付模块等。</li>
<li>组件可以是可执行的 Android 模块（如
<code>Activity</code>、<code>Service</code>），也可以是非可执行的业务逻辑模块（如数据处理、工具库等）。</li>
</ul></li>
<li><strong>模块化（Modularization）</strong>：
<ul>
<li>组件化的实现通常是通过模块化来完成的，Android 中通过 Gradle
的多模块构建实现模块化开发。</li>
<li>每个模块可以有自己的独立的代码、资源和配置，模块之间可以通过接口进行交互。</li>
</ul></li>
<li><strong>公共库（Common Library）</strong>：
<ul>
<li>在组件化架构中，公共库是存放通用代码（如工具类、网络请求、日志处理等）的模块，其他业务模块可以依赖它。</li>
</ul></li>
<li><strong>主应用（App Shell）</strong>：
<ul>
<li>主应用是最终集成所有模块的入口。各个组件开发完成后，最终都会通过某种机制集成到主应用中，主应用通常只负责整体调度和框架集成，而不包含具体的业务逻辑。</li>
</ul></li>
<li><strong>组件通信（Component Communication）</strong>：
<ul>
<li>不同组件之间通常通过接口（Interface）、事件总线（Event
Bus）或依赖注入（Dependency Injection）等方式进行通信。</li>
</ul></li>
</ol>
<h3 id="组件化的架构层次">组件化的架构层次</h3>
<p>组件化架构一般分为几个层次，每个层次都有其独立的职责和功能：</p>
<ol type="1">
<li><strong>基础层（Base Layer）</strong>：
<ul>
<li>包含一些通用的基础库和工具库，提供网络请求、数据库操作、日志管理等功能。</li>
<li>例如 <code>common</code> 模块，通常包含 Android
应用开发过程中用到的工具类、常用函数和常量等。</li>
</ul></li>
<li><strong>业务层（Business Layer）</strong>：
<ul>
<li>包含具体的业务功能，每个功能模块封装在一个独立的组件中，比如登录模块、用户管理模块、支付模块等。</li>
<li>这些模块通常不直接相互依赖，而是通过公共接口来进行通信。</li>
</ul></li>
<li><strong>接口层（Interface Layer）</strong>：
<ul>
<li>定义模块之间的交互接口，确保模块之间解耦。通过接口和服务的方式，其他模块能够调用业务逻辑而无需知道其具体实现。</li>
<li>例如，使用 <code>Router</code> 作为组件之间导航的工具，或者通过
<code>EventBus</code> 发送事件来进行模块间通信。</li>
</ul></li>
<li><strong>主应用层（App Shell Layer）</strong>：
<ul>
<li>主应用层负责集成各个业务模块，将所有模块组合成一个完整的应用程序。</li>
<li>在开发阶段，主应用可以是一个轻量的壳应用，主要用于调度和启动业务模块。</li>
</ul></li>
</ol>
<h3 id="组件化的实现方式">组件化的实现方式</h3>
<p>Android 组件化有多种实现方式，常见的方式包括使用 <code>Gradle</code>
的多模块构建、使用路由（Router）进行模块间通信、通过服务接口定义模块交互、以及通过依赖注入框架实现模块的动态加载。</p>
<h4 id="gradle-多模块化构建">1. <strong>Gradle
多模块化构建</strong></h4>
<p>在 Android 中，使用 <code>Gradle</code>
可以轻松实现模块化构建。每个业务模块可以通过 <code>Gradle</code>
定义成一个独立的 Android Library 或 Android Module。通过配置
<code>settings.gradle</code> 和
<code>build.gradle</code>，可以将这些模块组合到主应用中。</p>
<ul>
<li><p><strong>模块划分</strong>：一个应用被拆分成多个 Gradle
模块，每个模块可以是 <code>Android Library</code> 或
<code>Java Library</code>，也可以是可执行的 Android 模块。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line">include <span class="string">&#x27;:app&#x27;</span></span><br><span class="line">include <span class="string">&#x27;:login&#x27;</span></span><br><span class="line">include <span class="string">&#x27;:user&#x27;</span></span><br><span class="line">include <span class="string">&#x27;:payment&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app/build.gradle</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(<span class="string">&#x27;:login&#x27;</span>)</span><br><span class="line">    implementation project(<span class="string">&#x27;:user&#x27;</span>)</span><br><span class="line">    implementation project(<span class="string">&#x27;:payment&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，模块之间的依赖是明确的，编译时 <code>Gradle</code>
能自动解析模块间的依赖关系。</p>
<h4 id="组件间通信方式">2. <strong>组件间通信方式</strong></h4>
<h5
id="接口通信interface-communication">（1）<strong>接口通信（Interface
Communication）</strong></h5>
<ul>
<li><p>模块之间通过接口（Interface）来实现通信和解耦。接口可以定义在公共模块中，各个业务模块通过实现这些接口来完成具体的业务逻辑。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公共模块中的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录模块实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 具体的登录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="路由通信router-communication">（2）<strong>路由通信（Router
Communication）</strong></h5>
<ul>
<li><p>路由器（Router）是一种常见的组件间通信方式，它允许模块通过
URI（统一资源标识符）进行导航或调用彼此的功能。常用的路由库如
<strong>ARouter</strong>。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在登录模块中定义路由路径</span></span><br><span class="line"><span class="meta">@Route(path = &quot;/login/main&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="comment">// 具体业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在用户模块中通过路由跳转到登录模块</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">&quot;/login/main&quot;</span>).navigation();</span><br></pre></td></tr></table></figure></p>
<h5 id="事件总线event-bus">（3）<strong>事件总线（Event
Bus）</strong></h5>
<ul>
<li><p>使用事件总线（如
<code>EventBus</code>、<code>RxBus</code>）在不同模块之间发送事件通知，实现模块之间的解耦和通信。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送事件</span></span><br><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> <span class="title class_">LoginEvent</span>(<span class="string">&quot;User logged in&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收事件</span></span><br><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoginEvent</span><span class="params">(LoginEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理登录事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="依赖注入dependency-injection">（4）<strong>依赖注入（Dependency
Injection）</strong></h5>
<ul>
<li>使用依赖注入框架（如 <strong>Dagger</strong> 或
<strong>Hilt</strong>）可以实现动态加载组件，进一步解耦模块之间的依赖。</li>
</ul>
<h4 id="动态化加载">3. <strong>动态化加载</strong></h4>
<p>在某些场景下，组件可能不需要随着应用一起打包，而是需要在运行时动态加载。例如在插件化框架（如
<strong>RePlugin</strong>、<strong>Small</strong>）中，组件可以作为插件单独打包和发布，主应用可以在运行时动态加载这些插件。</p>
<h3 id="组件化的开发模式">组件化的开发模式</h3>
<ol type="1">
<li><strong>单一组件模式（Single Component Mode）</strong>：
<ul>
<li>在组件开发的早期阶段，每个组件通常独立开发和测试。开发者可以通过单一组件的模式，将某个模块设置为一个独立的应用进行调试。</li>
</ul></li>
<li><strong>集成模式（Integration Mode）</strong>：
<ul>
<li>当所有组件开发完成后，它们会集成到主应用中，组成一个完整的应用程序。此时可以通过配置
<code>Gradle</code> 构建文件来控制每个模块的集成状态。</li>
</ul></li>
</ol>
<h3 id="组件化的优缺点">组件化的优缺点</h3>
<h4 id="优点-11">优点：</h4>
<ol type="1">
<li><strong>开发效率提升</strong>：模块化拆分后，不同功能模块可以并行开发、测试、调试，提高开发效率。</li>
<li><strong>代码可维护性提升</strong>：代码拆分成小的模块后，每个模块都更加独立，维护和扩展变得更加容易。</li>
<li><strong>模块复用</strong>：业务模块可以复用到其他项目中，减少重复开发的工作量。</li>
<li><strong>灵活的应用架构</strong>：可以通过增加或减少模块来灵活调整应用的功能，而无需对整个应用进行大的改动。</li>
</ol>
<h4 id="缺点-11">缺点：</h4>
<ol type="1">
<li><strong>初期成本较高</strong>：组件化架构的搭建和维护需要一定的技术门槛，初期设计和实施的成本较高。</li>
<li><strong>复杂的依赖管理</strong>：组件化会导致依赖管理变得复杂，特别是在有大量公共库和模块之间存在复杂依赖关系的情况下。</li>
<li></li>
</ol>
<p><strong>性能开销</strong>：如果模块之间的通信频繁，或者路由、依赖注入的使用不当，可能会带来一定的性能开销。</p>
<h3 id="总结-19">总结</h3>
<p>Android
组件化是一种非常有效的架构模式，尤其适用于大型项目或多人协作开发的项目。通过合理的模块划分、解耦的通信方式和灵活的依赖管理，组件化能够提升项目的可维护性和扩展性，同时也能提高开发效率。不过，组件化的实施需要根据项目规模、团队需求和性能考虑权衡进行。</p>
<h2 id="插件化">插件化</h2>
<p>Android
插件化是一种将应用程序的功能模块化，并且在运行时动态加载模块的方法。与组件化不同，插件化的目标是使应用程序的某些功能可以在应用发布后动态添加、更新或移除，而无需重新打包整个应用。通过插件化，开发者可以灵活地更新或扩展应用程序的功能，提升应用的可扩展性和灵活性。</p>
<h3 id="为什么需要插件化">为什么需要插件化？</h3>
<ol type="1">
<li><p><strong>动态扩展</strong>：应用程序的功能可以在运行时动态加载，无需重新打包发布整个应用。例如，可以在应用中实现动态更新某些模块（如业务功能、界面等）。</p></li>
<li><p><strong>减少 APK
大小</strong>：将一些次要或不常用的功能以插件的形式分离出去，用户可以在需要时才下载和加载这些功能，减少初始安装包的体积。</p></li>
<li><p><strong>灵活更新</strong>：通过插件化，可以局部更新应用中的某些功能模块，而无需发布完整的更新包，从而减少用户的更新成本和开发者的发布压力。</p></li>
<li><p><strong>多团队并行开发</strong>：不同功能模块可以作为插件独立开发和测试，团队之间的耦合降低，提升开发效率。</p></li>
<li><p><strong>实现业务隔离</strong>：通过插件化架构，不同业务模块可以相对独立地实现和部署，避免功能模块之间的代码耦合，提升代码的可维护性。</p></li>
</ol>
<h3 id="android-插件化的基本概念">Android 插件化的基本概念</h3>
<ol type="1">
<li><strong>宿主（Host App）</strong>：
<ul>
<li>宿主是插件化系统的核心部分，它负责加载和运行插件，同时管理插件与宿主的交互。</li>
<li>宿主提供了基本的应用框架和资源，插件运行时依赖于宿主提供的环境。</li>
</ul></li>
<li><strong>插件（Plugin）</strong>：
<ul>
<li>插件是一个独立的功能模块，可以被宿主动态加载和运行。插件通常包含自己的代码、资源和配置。</li>
<li>插件可以是一个完整的模块（如登录模块、支付模块），也可以是某个具体的功能（如一个新界面、一个新工具等）。</li>
</ul></li>
<li><strong>插件框架（Plugin Framework）</strong>：
<ul>
<li>插件框架是插件化的基础，它负责管理插件的加载、卸载、资源访问和类的调用等功能。</li>
<li>常见的插件框架有
<strong>RePlugin</strong>、<strong>Small</strong>、<strong>DynamicLoadApk</strong>、<strong>DroidPlugin</strong>
等。</li>
</ul></li>
<li><strong>资源管理（Resource Management）</strong>：
<ul>
<li>插件的资源（如图片、布局文件等）需要与宿主应用的资源隔离开来，插件框架负责解决插件和宿主之间的资源访问问题。</li>
</ul></li>
<li><strong>ClassLoader</strong>：
<ul>
<li>Android 插件化的一个关键技术点是
<strong>ClassLoader</strong>，它用于动态加载插件的类文件，使插件能够在宿主环境中执行。</li>
<li>插件框架通常会通过自定义的 <code>ClassLoader</code>
来实现插件的动态加载和隔离。</li>
</ul></li>
<li><strong>插件生命周期管理</strong>：
<ul>
<li>插件中的 <code>Activity</code>、<code>Service</code>
等组件的生命周期需要通过插件框架进行管理，插件框架会负责将插件中的组件映射到宿主的上下文环境中执行。</li>
</ul></li>
</ol>
<h3 id="插件化的工作原理">插件化的工作原理</h3>
<h4 id="动态加载插件">1. <strong>动态加载插件</strong></h4>
<p>Android 插件化的核心原理是
<strong>动态加载</strong>，即在应用运行时，通过某种机制将插件的代码和资源加载到宿主的内存中，并运行这些代码。其基本流程如下：</p>
<ol type="1">
<li><p><strong>插件打包</strong>：插件通常被打包成 APK
格式，但它不是一个独立运行的应用程序。插件的代码、资源和配置文件（如
<code>AndroidManifest.xml</code>）打包在一起。</p></li>
<li><p><strong>插件的加载</strong>：宿主应用通过插件框架使用
<code>DexClassLoader</code> 或 <code>PathClassLoader</code>
动态加载插件中的代码和资源。这个过程通常需要解决类的查找、资源加载和
<code>AndroidManifest.xml</code> 文件的解析等问题。</p></li>
<li><p><strong>插件组件的运行</strong>：插件的
<code>Activity</code>、<code>Service</code>
等组件不能直接注册到系统中，而是通过插件框架模拟这些组件的生命周期。宿主会将插件的组件映射到宿主环境中运行。</p></li>
</ol>
<h4 id="classloader-动态加载机制">2. <strong>ClassLoader
动态加载机制</strong></h4>
<p>Android 插件化的一个关键点是通过 <strong>ClassLoader</strong>
实现插件的动态加载。插件框架通常使用 <code>DexClassLoader</code>
或自定义 <code>ClassLoader</code> 来加载插件的 <code>.dex</code>
文件（即插件的字节码），从而使插件的代码在宿主中运行。</p>
<ul>
<li><p><strong><code>DexClassLoader</code></strong>：Android
提供的一个类加载器，用于加载外部存储或网络下载的 <code>.dex</code>
文件。插件框架会利用这个类加载器将插件的代码动态加载到内存中。</p></li>
<li><p><strong>类的加载顺序</strong>：插件加载时，ClassLoader
会首先从宿主的类路径中查找需要的类，如果没有找到，则会从插件的
<code>.dex</code>
文件中查找类。这样可以实现插件与宿主之间的类隔离。</p></li>
</ul>
<h4 id="资源管理">3. <strong>资源管理</strong></h4>
<p>插件化的一个重要挑战是 <strong>资源的管理</strong>，因为 Android
的资源（如图片、布局文件等）是通过 <code>R</code>
文件生成的静态引用，而插件的资源和宿主的资源需要分开管理，不能冲突。</p>
<ul>
<li>插件框架通常会通过 <code>AssetManager</code>
动态加载插件的资源包，并将插件的资源加入宿主的资源管理系统中。</li>
<li>宿主和插件的资源 ID 可能会发生冲突，插件框架需要通过
<code>Resources</code> 动态解析插件资源，避免 ID 冲突。</li>
</ul>
<h4 id="activity-的生命周期管理-1">4. <strong>Activity
的生命周期管理</strong></h4>
<p>插件化中，插件的 <code>Activity</code> 不能直接注册到系统的
<code>AndroidManifest.xml</code> 中，因此插件框架需要模拟
<code>Activity</code> 的生命周期，并将插件的 <code>Activity</code>
与宿主的 <code>Activity</code> 进行映射。</p>
<ul>
<li>插件框架会在宿主的 <code>AndroidManifest.xml</code> 中注册一个占位的
<code>Activity</code>（称为代理 <code>Activity</code>），当插件的
<code>Activity</code> 需要启动时，宿主会启动代理
<code>Activity</code>，然后通过反射将插件的 <code>Activity</code>
的生命周期方法映射到代理 <code>Activity</code> 上执行。</li>
</ul>
<h3 id="插件化框架的常见实现">插件化框架的常见实现</h3>
<h4 id="replugin">1. <strong>RePlugin</strong></h4>
<p><strong>RePlugin</strong> 是一个由 360 公司开发的开源 Android
插件化框架，目标是解决复杂的插件化场景，包括插件的动态加载、卸载、资源管理和生命周期管理。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li>支持插件的动态加载和卸载。</li>
<li>插件可以动态更新，且更新过程无需重启宿主应用。</li>
<li>插件和宿主的资源可以独立管理，避免冲突。</li>
<li>支持插件的独立调试，开发体验较好。</li>
</ul></li>
<li><strong>实现原理</strong>：
<ul>
<li>使用自定义的 <code>ClassLoader</code> 来实现插件的动态加载。</li>
<li>通过代理 <code>Activity</code> 来处理插件的组件生命周期问题。</li>
<li>使用 <code>Resources</code> 和 <code>AssetManager</code>
动态管理插件的资源。</li>
</ul></li>
</ul>
<h4 id="small">2. <strong>Small</strong></h4>
<p><strong>Small</strong>
是一个轻量级的插件化框架，适合那些只需要简单插件化场景的应用。它的设计目标是让开发者尽可能少地修改现有项目代码，同时实现应用的插件化。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li>插件轻量化，依赖少，集成简单。</li>
<li>支持资源管理、类加载、Activity 生命周期管理。</li>
<li>支持插件动态加载。</li>
</ul></li>
<li><strong>实现原理</strong>：
<ul>
<li>Small 使用 <code>PathClassLoader</code> 来加载插件的代码。</li>
<li>插件的资源通过 <code>AssetManager</code>
动态加入宿主的资源系统中，保证宿主和插件之间的资源隔离。</li>
</ul></li>
</ul>
<h4 id="droidplugin">3. <strong>DroidPlugin</strong></h4>
<p><strong>DroidPlugin</strong> 是 360
安全团队开发的另一个开源插件化框架，专注于通过插件化实现应用多进程、热更新和动态功能扩展。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li>支持插件的动态安装、卸载、升级。</li>
<li>支持插件的多进程运行。</li>
<li>插件可以访问宿主提供的服务，能够进行复杂的业务逻辑实现。</li>
</ul></li>
<li><strong>实现原理</strong>：
<ul>
<li>DroidPlugin 使用代理机制来启动和管理插件的
<code>Activity</code>、<code>Service</code> 和
<code>BroadcastReceiver</code>。</li>
<li>通过自定义的 <code>ClassLoader</code> 来动态加载插件的代码。</li>
</ul></li>
</ul>
<h4 id="dynamicloadapk">4. <strong>DynamicLoadApk</strong></h4>
<p><strong>DynamicLoadApk</strong> 是另一个简单的插件化框架，主要通过
<code>DexClassLoader</code> 动态加载插件的代码，并通过代理
<code>Activity</code> 来实现插件 <code>Activity</code>
的生命周期管理。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li>插件通过 APK 文件形式加载，插件的代码和宿主隔离。</li>
<li>支持插件 <code>Activity</code> 的生命周期管理。</li>
<li>框架简单易用，适合简单插件化场景。</li>
</ul></li>
</ul>
<h3 id="插件化的实现步骤">插件化的实现步骤</h3>
<ol type="1">
<li><strong>创建宿主应用</strong>：宿主应用是插件化系统的核心，负责加载和管理插件。首先，需要在宿主应用</li>
</ol>
<p>中配置插件框架，并为插件的加载提供接口。</p>
<ol start="2" type="1">
<li><p><strong>创建插件应用</strong>：插件是宿主应用的功能扩展，插件通常打包为
APK 格式，并通过插件框架加载到宿主中运行。</p></li>
<li><p><strong>使用插件框架</strong>：选择合适的插件框架（如
RePlugin、Small、DroidPlugin），并在宿主应用中集成框架代码，处理插件的加载、资源管理和生命周期管理。</p></li>
<li><p><strong>处理组件和资源</strong>：插件中的组件（如
Activity、Service）和资源（如图片、布局文件）需要通过插件框架进行加载和管理，确保插件和宿主的资源和组件能够正确工作。</p></li>
</ol>
<h3 id="插件化的挑战">插件化的挑战</h3>
<ol type="1">
<li><p><strong>性能问题</strong>：插件化框架在加载和卸载插件时，会涉及到大量的反射操作、资源加载等，可能会影响性能。特别是在低端设备上，插件的加载速度可能较慢。</p></li>
<li><p><strong>资源冲突</strong>：插件和宿主的资源可能会发生冲突，特别是资源
ID 重复的问题。插件框架需要解决资源的隔离和冲突问题。</p></li>
<li><p><strong>兼容性问题</strong>：不同的 Android
版本和设备在处理插件加载和资源管理时，可能会表现出不同的行为，这需要插件框架进行兼容性处理。</p></li>
<li><p><strong>调试难度</strong>：插件的动态加载和运行增加了调试的难度，开发者需要使用特定的工具和框架来调试插件中的问题。</p></li>
</ol>
<h3 id="总结-20">总结</h3>
<p>Android
插件化是一种强大的架构模式，它允许应用程序在运行时动态加载和卸载功能模块，提升应用的灵活性和扩展性。插件化的核心原理是通过
<code>ClassLoader</code>
动态加载插件的代码，并通过插件框架处理插件的资源和组件生命周期管理。常见的插件化框架如
RePlugin、Small、DroidPlugin
等，能够帮助开发者快速实现应用的插件化。</p>
<p>插件化的实施可以解决应用程序动态更新、功能扩展、模块化开发等问题，但同时也带来了性能、资源冲突和兼容性等挑战。开发者在使用插件化时需要根据具体需求权衡利弊，并选择合适的框架和实现方案。</p>
<h2 id="热更新">热更新</h2>
<p><strong>Android
热更新</strong>（Hotfix）是一种在应用程序无需重新安装或从应用商店下载新版本的情况下，动态修复代码或资源错误的技术。通过热更新技术，开发者可以在不经过
Google Play 等应用商店重新发布应用的情况下修复应用中的
Bug，甚至在某些情况下动态更新应用中的某些业务逻辑。</p>
<h3 id="为什么需要热更新">为什么需要热更新？</h3>
<ol type="1">
<li><p><strong>快速修复
Bug</strong>：应用发布后，可能会出现一些紧急问题或
Bug，传统的方式需要重新打包、发布、等待用户更新，这个过程可能会导致修复延迟，影响用户体验。热更新可以立即修复这些问题。</p></li>
<li><p><strong>减少发布成本</strong>：每次发布新版本的应用都需要经过打包、测试、上架等一系列复杂流程，热更新能够节省开发和发布的时间成本。</p></li>
<li><p><strong>增强灵活性</strong>：热更新可以动态修改应用中的某些逻辑或资源，提升应用的灵活性。</p></li>
<li><p><strong>减少应用重新发布的频率</strong>：通过热更新技术，可以减少应用频繁上架应用市场的次数，减少对用户造成的打扰。</p></li>
</ol>
<h3 id="热更新的基本原理">热更新的基本原理</h3>
<p>Android
热更新的基本原理是通过动态加载机制，替换应用程序中的部分代码或资源，使应用在运行时能够使用新的代码或资源，而无需重新安装或重启应用。其主要实现方式有以下几种：</p>
<ol type="1">
<li><p><strong>类替换（Class
Replacement）</strong>：在应用运行时，通过修改类加载器（<code>ClassLoader</code>）的加载逻辑，将有问题的类替换为修复后的类。</p></li>
<li><p><strong>方法替换（Method
Hooking）</strong>：通过字节码修改技术，将应用中的某些方法替换为新的方法，这样可以在不改变整个类的情况下修复部分方法。</p></li>
<li><p><strong>资源替换（Resource
Replacement）</strong>：通过动态加载外部资源包的方式，替换应用中的图片、布局、字符串等资源。</p></li>
</ol>
<h3 id="热更新的实现方式">热更新的实现方式</h3>
<p>目前，Android 热更新技术主要通过以下几种方式实现：</p>
<h4 id="dex-文件替换">1. <strong>Dex 文件替换</strong></h4>
<p>Dex 文件是 Android
中的可执行文件格式，它包含了应用程序的字节码。通过热更新技术，可以在应用运行时动态加载新的
Dex 文件，替换掉原来的有问题的类。</p>
<ul>
<li><strong>关键技术</strong>：
<ul>
<li>使用 <code>DexClassLoader</code> 或 <code>PathClassLoader</code>
动态加载新的 Dex 文件。</li>
<li>通过修改 <code>ClassLoader</code> 的父加载器，将新 Dex
中的类优先加载，覆盖掉原应用中的类。</li>
</ul></li>
<li><strong>示例流程</strong>：
<ol type="1">
<li>应用运行时，发现某个类存在问题。</li>
<li>从服务器下载修复后的 Dex 文件。</li>
<li>使用 <code>DexClassLoader</code> 动态加载这个 Dex
文件，并替换有问题的类。</li>
</ol></li>
<li><strong>优点</strong>：可以灵活地替换整个类，适用于修复逻辑错误。</li>
<li><strong>缺点</strong>：修改的是整个类，粒度相对较大，且存在兼容性问题。</li>
</ul>
<h4 id="方法替换hook-技术">2. <strong>方法替换（Hook
技术）</strong></h4>
<p>方法替换是一种更加精细的热更新技术。通过 Hook
技术，可以在不替换整个类的情况下，仅替换有问题的方法。这种方式使用了字节码操作技术，通过修改运行时方法的字节码来实现方法级别的替换。</p>
<ul>
<li><strong>关键技术</strong>：
<ul>
<li>使用字节码操作框架，如 <strong>ASM</strong> 或
<strong>JavaAssist</strong>，在运行时动态修改方法的字节码。</li>
<li>Hook Android 的类加载器，拦截方法的调用，并替换为修复后的逻辑。</li>
</ul></li>
<li><strong>示例流程</strong>：
<ol type="1">
<li>应用运行时发现某个方法存在 Bug。</li>
<li>从服务器下载包含新方法的字节码。</li>
<li>使用字节码修改工具，将旧方法替换为新方法。</li>
</ol></li>
<li><strong>优点</strong>：可以只替换有问题的方法，避免对整个类的替换，修复粒度更细。</li>
<li><strong>缺点</strong>：实现复杂，尤其是在不同版本的 Android
系统上存在兼容性问题。</li>
</ul>
<h4 id="资源替换">3. <strong>资源替换</strong></h4>
<p>热更新不仅限于代码的修复，某些情况下，应用中的资源文件（如图片、布局、字符串等）也可能需要动态更新。通过资源替换技术，可以在不重启应用的情况下，动态更新应用的资源。</p>
<ul>
<li><strong>关键技术</strong>：
<ul>
<li>动态加载资源包（APK、AAR 或其他格式）。</li>
<li>使用反射或 <code>AssetManager</code>
将外部资源与应用的资源系统整合。</li>
</ul></li>
<li><strong>示例流程</strong>：
<ol type="1">
<li>应用发现某个资源有问题。</li>
<li>从服务器下载新的资源文件（如 APK 包中的资源）。</li>
<li>使用 <code>AssetManager</code> 加载新资源，替换旧资源。</li>
</ol></li>
<li><strong>优点</strong>：可以动态更新应用的图片、布局等静态资源，不需要重新安装应用。</li>
<li><strong>缺点</strong>：资源的替换相对简单，但可能需要与代码的热更新结合使用。</li>
</ul>
<h3 id="热更新的常用框架">热更新的常用框架</h3>
<h4 id="tinker微信开源">1. <strong>Tinker（微信开源）</strong></h4>
<p><strong>Tinker</strong>
是腾讯微信团队开源的一个热修复框架，支持类、So
库、资源等多种类型的修复。Tinker 是目前最流行的 Android
热修复框架之一，广泛应用于大多数 Android 应用中。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>支持 Dex 修复：可以动态替换应用中的代码。</li>
<li>支持资源修复：可以动态加载新的图片、布局等资源。</li>
<li>支持 So 库修复：可以修复应用中的本地库文件。</li>
</ul></li>
<li><p><strong>原理</strong>： Tinker 通过生成一个 Patch
文件（补丁包），这个补丁包包含需要修复的 Dex 文件、资源或 So
文件。应用运行时加载这个补丁包，并通过反射和 <code>ClassLoader</code>
动态替换原有的代码和资源。</p></li>
<li><p><strong>Tinker 工作流程</strong>：</p>
<ol type="1">
<li>构建补丁包：开发者通过 Tinker
工具生成一个补丁包，包含需要修复的代码和资源。</li>
<li>应用加载补丁包：应用启动时，通过 Tinker 框架加载补丁包。</li>
<li>动态替换：Tinker 框架通过自定义的 <code>ClassLoader</code> 和
<code>AssetManager</code> 将补丁包中的内容替换到原有的应用中。</li>
</ol></li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>支持多种修复类型，功能强大。</li>
<li>已在多个大型应用中验证，稳定性好。</li>
</ul></li>
<li><p><strong>劣势</strong>：</p>
<ul>
<li>实现相对复杂，集成门槛较高。</li>
<li>对于大版本更新，热修复的效果有限。</li>
</ul></li>
</ul>
<h4 id="andfix阿里巴巴开源">2.
<strong>AndFix（阿里巴巴开源）</strong></h4>
<p><strong>AndFix</strong>
是阿里巴巴开源的一个轻量级的热修复框架，专注于方法级别的替换，适合快速修复线上
Bug。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>修复粒度小：AndFix
通过修改方法字节码实现热修复，不需要替换整个类。</li>
<li>使用方便：无需重新打包应用，可以通过补丁文件直接修复 Bug。</li>
</ul></li>
<li><p><strong>原理</strong>： AndFix 利用 <code>JNI</code>
技术修改方法的字节码，从而在运行时替换掉有问题的方法。修复的补丁是基于方法级别的字节码修改，而不是替换整个
Dex 文件。</p></li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>修复粒度小，效率高。</li>
<li>实现简单，开发者容易上手。</li>
</ul></li>
<li><p><strong>劣势</strong>：</p>
<ul>
<li>只支持方法级别的修复，适用场景有限。</li>
<li>由于底层依赖于 <code>JNI</code> 和
<code>ASM</code>，可能会存在一定的兼容性问题。</li>
</ul></li>
</ul>
<h4 id="robust美团点评开源">3.
<strong>Robust（美团点评开源）</strong></h4>
<p><strong>Robust</strong>
是美团点评开源的另一个热修复框架，专注于解决类、方法的修复问题。Robust
提供了不同的修复方案，适用于不同的业务场景。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>支持类和方法的替换，修复粒度灵活。</li>
<li>提供了不同的模式（如全量模式和增量模式）来满足不同的业务需求。</li>
</ul></li>
<li><p><strong>原理</strong>： 通过代理机制，Robust
在运行时创建一个类的代理对象，并将代理对象的方法指向修复后的方法实现。通过这种方式，Robust
可以在不修改原始类的情况下，修复其中的 Bug。</p></li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>提供多种修复模式，适用场景广泛。</li>
<li>不依赖 <code>JNI</code>，兼容性较好。</li>
</ul></li>
<li><p><strong>劣势</strong>：</p>
<ul>
<li>修复效率相对较低。</li>
<li>实现相对复杂。</li>
</ul></li>
</ul>
<h4 id="nuwa">4. <strong>Nuwa</strong></h4>
<p><strong>Nuwa</strong> 是另一个早期的 Android 热修复框架，Nuwa
采用了类似 Tinker 的实现方式，但更加轻</p>
<p>量，专注于 Dex 文件的修复。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li>支持 Dex 修复，重点是修复逻辑错误。</li>
<li>较为简单，适合快速集成和使用。</li>
</ul></li>
<li><strong>优势</strong>：
<ul>
<li>实现简单，轻量级。</li>
<li>不依赖过多的外部框架。</li>
</ul></li>
<li><strong>劣势</strong>：
<ul>
<li>不支持资源和 So 文件的修复。</li>
<li>功能相对较为单一。</li>
</ul></li>
</ul>
<h3 id="热更新技术的挑战">热更新技术的挑战</h3>
<p>尽管热更新可以极大地提高开发和发布效率，但实现热更新时仍然面临着一些技术挑战：</p>
<ol type="1">
<li><p><strong>兼容性问题</strong>：不同版本的 Android
系统中，<code>ClassLoader</code>
和资源管理机制有所不同，可能导致热更新在某些设备上不兼容或无法正常工作。尤其是在
Android 5.0 及以上，ART 虚拟机引入了新的机制，使得 Dex
文件的修改更加困难。</p></li>
<li><p><strong>安全性问题</strong>：热更新的补丁文件通常需要通过网络下载，这会带来一定的安全风险。如果补丁文件没有做好安全校验，可能被恶意攻击者利用，篡改补丁内容。热更新框架需要对补丁进行严格的签名和校验。</p></li>
<li><p><strong>性能问题</strong>：由于热更新涉及到类加载器的修改、字节码的替换等操作，可能会带来一定的性能开销。过多或频繁的热更新可能导致应用启动变慢或运行时的性能下降。</p></li>
<li><p><strong>系统限制</strong>：Google 从 Android 7.0 开始对动态加载的
APK 进行了限制，增加了对 <code>Dex</code>
文件的验证和优化，某些热更新框架在新的 Android 版本上可能失效。</p></li>
</ol>
<h3 id="总结-21">总结</h3>
<p>Android 热更新技术为开发者提供了一种在应用运行时动态修复 Bug
或更新代码的能力。通过 Dex
文件替换、方法级别修复、资源替换等方式，开发者可以在不重新打包应用的情况下快速修复问题或更新功能。</p>
<p>常见的热更新框架如
<strong>Tinker</strong>、<strong>AndFix</strong>、<strong>Robust</strong>
等，为开发者提供了不同的解决方案。每种框架都有其独特的实现方式和适用场景，开发者可以根据自己的需求选择合适的框架。</p>
<p>尽管热更新具有显著的优点，但在实际应用中也面临兼容性、安全性和性能方面的挑战。开发者在使用热更新技术时需要权衡利弊，确保应用的稳定性和用户体验。</p>
<h2 id="线程间通信">线程间通信</h2>
<p>在 Android
开发中，线程间通信是一项非常重要的任务，尤其是在处理多线程操作时，比如在后台线程中执行耗时任务，然后将结果返回到主线程更新
UI。由于 Android 的 UI
操作只能在主线程中执行，线程间的通信机制变得尤为关键。以下是几种常见的
Android 线程间通信方式：</p>
<h3 id="handler">1. <strong>Handler</strong></h3>
<p><code>Handler</code> 是 Android
中最常用的线程间通信工具。它主要用于将消息从后台线程传递到主线程，从而更新
UI。<code>Handler</code>
工作机制是将消息放入一个线程的消息队列中，Looper
再循环处理这些消息。</p>
<ul>
<li><strong>工作原理</strong>：
<ol type="1">
<li><code>Looper</code> 负责轮询消息队列。</li>
<li><code>Handler</code> 用于发送消息。</li>
<li><code>Message</code> 是传递的数据载体。</li>
</ol></li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在子线程中进行耗时操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> performTask();</span><br><span class="line">        <span class="comment">// 将结果传递给主线程</span></span><br><span class="line">        handler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 更新 UI</span></span><br><span class="line">                textView.setText(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="asynctask已废弃使用替代方案">2.
<strong>AsyncTask</strong>（已废弃，使用替代方案）</h3>
<p><code>AsyncTask</code>
过去用于在后台线程执行任务并在主线程中返回结果。由于存在内存泄漏风险和并发控制不佳的缺陷，从
Android API 30 开始已经被废弃。</p>
<p>建议使用 <code>ExecutorService</code> 和 <code>Handler</code>
组合来替代 <code>AsyncTask</code>。</p>
<h3 id="executor-future-callable">3. <strong>Executor + Future +
Callable</strong></h3>
<p><code>ExecutorService</code> 是一种管理线程池的方式，可以用来替代
<code>AsyncTask</code> 执行异步任务。通过 <code>Future</code>
可以获取任务的执行结果，使用 <code>Callable</code> 来返回结果。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 执行后台任务</span></span><br><span class="line">        <span class="keyword">return</span> performTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();  <span class="comment">// 获取任务结果</span></span><br><span class="line">            handler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 更新 UI</span></span><br><span class="line">                    textView.setText(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="handlerthread">4. <strong>HandlerThread</strong></h3>
<p><code>HandlerThread</code> 是一个带有 <code>Looper</code>
的线程。通过 <code>HandlerThread</code> 可以轻松地创建后台线程，并且利用
<code>Handler</code> 来处理它的消息队列。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HandlerThread</span> <span class="variable">handlerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;MyHandlerThread&quot;</span>);</span><br><span class="line">handlerThread.start();</span><br><span class="line"><span class="type">Handler</span> <span class="variable">backgroundHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(handlerThread.getLooper());</span><br><span class="line"></span><br><span class="line">backgroundHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行后台任务</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> performTask();</span><br><span class="line">        <span class="comment">// 使用主线程的 handler 更新 UI</span></span><br><span class="line">        handler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                textView.setText(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="broadcastreceiver-1">5. <strong>BroadcastReceiver</strong></h3>
<p><code>BroadcastReceiver</code> 主要用于不同组件（Activity、Service
等）之间的通信。它也可以用于线程间通信，尤其在多个线程之间需要广播事件时。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<ol type="1">
<li><p>发送广播： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.UPDATE_UI&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;Hello from background&quot;</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></p></li>
<li><p>接收广播： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BroadcastReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        textView.setText(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">registerReceiver(receiver, <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(<span class="string">&quot;com.example.UPDATE_UI&quot;</span>));</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="eventbus">6. <strong>EventBus</strong></h3>
<p><code>EventBus</code>
是一个第三方库，它简化了线程间的通信流程。通过发布-订阅模式，可以轻松地在后台线程发布事件，并在主线程订阅和处理这些事件。</p>
<ul>
<li><strong>基本步骤</strong>：
<ol type="1">
<li>在后台线程发布事件。</li>
<li>在主线程订阅该事件并处理。</li>
</ol></li>
</ul>
<p><strong>总结</strong>： Android
提供了多种线程间通信的机制。最常用的方案是基于 <code>Handler</code>
的方法，因为它与 Android
的消息队列机制紧密集成。对于一些复杂的场景，诸如
<code>ExecutorService</code> 和 <code>HandlerThread</code>
也能提供更灵活的多线程处理能力。</p>
<h2 id="android-的四种启动模式及实践场景">Android
的四种启动模式及实践场景</h2>
<p>在 Android 开发中，Activity 的四种启动模式（Launch Mode）是指在
AndroidManifest.xml 中通过 <code>android:launchMode</code>
属性或在代码中通过 Intent 的标志位来控制 Activity
的启动行为。这四种启动模式分别是
<code>standard</code>、<code>singleTop</code>、<code>singleTask</code>
和
<code>singleInstance</code>，每种模式适用于不同的实践场景。以下是对它们的详细说明及其应用场景：</p>
<h3 id="standard标准模式">1. <strong>standard（标准模式）</strong></h3>
<ul>
<li><strong>描述</strong>：这是默认的启动模式。每次启动一个
Activity，都会创建一个新的实例并将其压入任务栈中，无论该 Activity
是否已经存在。</li>
<li><strong>行为</strong>：每次调用
<code>startActivity()</code>，都会生成一个新的实例，即使栈中已经存在相同的
Activity。</li>
<li><strong>实践场景</strong>：
<ul>
<li>适用于大多数普通的页面跳转场景，例如从列表页进入详情页。</li>
<li>示例：一个新闻应用中，用户从新闻列表点击进入不同的新闻详情页面，每次点击都会创建一个新的详情页实例。</li>
</ul></li>
<li><strong>注意</strong>：如果不指定 <code>launchMode</code>，Activity
默认使用此模式。</li>
</ul>
<hr />
<h3 id="singletop栈顶复用模式">2.
<strong>singleTop（栈顶复用模式）</strong></h3>
<ul>
<li><strong>描述</strong>：如果目标 Activity
已经位于任务栈的栈顶，则不会创建新实例，而是复用栈顶的现有实例，并调用其
<code>onNewIntent()</code> 方法传递新的 Intent
数据；如果不在栈顶，则会创建新实例。</li>
<li><strong>行为</strong>：避免在栈顶重复创建相同的 Activity。</li>
<li><strong>实践场景</strong>：
<ul>
<li>适用于需要避免重复打开相同页面的场景，例如搜索页面。</li>
<li>示例：一个搜索应用中，用户在搜索结果页再次点击“搜索”按钮，不希望创建新的搜索结果页，而是更新当前页面的内容。</li>
</ul></li>
<li><strong>注意</strong>：如果栈顶不是目标 Activity，则行为与
<code>standard</code> 相同。</li>
</ul>
<hr />
<h3 id="singletask栈内复用模式">3.
<strong>singleTask（栈内复用模式）</strong></h3>
<ul>
<li><strong>描述</strong>：在任务栈中只允许存在一个该 Activity
的实例。如果栈中不存在该
Activity，则创建新实例并压入栈中；如果栈中已存在，则清除其上方的所有
Activity，并调用已有实例的 <code>onNewIntent()</code> 方法。</li>
<li><strong>行为</strong>：确保任务栈中只有一个实例，适合作为应用的“根”或“主”页面。</li>
<li><strong>实践场景</strong>：
<ul>
<li>适用于应用的首页或核心功能页面，避免重复创建。</li>
<li>示例：一个社交应用的主界面（如微信的聊天列表），无论从通知栏还是其他页面返回，都只复用现有的主界面实例，并清理其上方的栈。</li>
</ul></li>
<li><strong>注意</strong>：这种模式会影响任务栈的结构，需谨慎使用。</li>
</ul>
<hr />
<h3 id="singleinstance单实例模式">4.
<strong>singleInstance（单实例模式）</strong></h3>
<ul>
<li><strong>描述</strong>：该模式会为 Activity
创建一个独立的任务栈，且该栈中只允许存在这一个 Activity 实例。其他
Activity 无法进入该任务栈。</li>
<li><strong>行为</strong>：完全独立于其他任务栈，适合完全隔离的
Activity。</li>
<li><strong>实践场景</strong>：
<ul>
<li>适用于与主应用逻辑完全分离的功能，例如拨号界面或第三方授权登录页面。</li>
<li>示例：一个应用中调用系统拨号界面，拨号界面运行在独立的任务栈中，完成后返回原应用。</li>
</ul></li>
<li><strong>注意</strong>：这种模式会创建新的任务栈，通常用于跨应用的交互场景。</li>
</ul>
<hr />
<h3 id="代码示例-1"><strong>代码示例</strong></h3>
<p>在 AndroidManifest.xml 中配置启动模式： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>通过 Intent 动态设置启动模式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MainActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="总结对比"><strong>总结对比</strong></h3>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 16%" />
<col style="width: 36%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>启动模式</th>
<th>实例数量</th>
<th>任务栈行为</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>standard</td>
<td>多个实例</td>
<td>每次创建新实例压栈</td>
<td>普通页面跳转</td>
</tr>
<tr class="even">
<td>singleTop</td>
<td>栈顶复用</td>
<td>栈顶复用，其他情况新建</td>
<td>搜索结果页</td>
</tr>
<tr class="odd">
<td>singleTask</td>
<td>栈内单实例</td>
<td>栈内复用，清栈至该实例</td>
<td>应用主界面</td>
</tr>
<tr class="even">
<td>singleInstance</td>
<td>全局单实例</td>
<td>独立任务栈，仅一个实例</td>
<td>拨号或授权页面</td>
</tr>
</tbody>
</table>
<p>根据实际需求选择合适的启动模式，可以优化应用的导航体验和资源使用效率。</p>
<h1 id="java">Java</h1>
<h2 id="hashmap的实现原理">HashMap的实现原理</h2>
<p><code>HashMap</code> 是 Java
集合框架中的一个常用数据结构，基于哈希表（Hash
Table）实现，用于存储键值对（key-value）数据。<code>HashMap</code>
的核心思想是通过哈希函数快速定位键的位置，进而实现高效的查找、插入和删除操作。以下是
<code>HashMap</code> 的实现原理及其主要特性。</p>
<h3 id="基本结构">1. <strong>基本结构</strong></h3>
<p><code>HashMap</code>
主要基于<strong>数组</strong>和<strong>链表</strong>（JDK 1.8
之前）或<strong>红黑树</strong>（JDK 1.8
及之后）的数据结构来实现。它的核心结构如下：</p>
<ul>
<li><p><strong>数组（Node[] table）</strong>：哈希表的核心部分是一个
<code>Node</code> 数组，数组中的每个元素是一个链表的头节点（JDK 1.8
之前）或红黑树的根节点（JDK 1.8 之后）。</p></li>
<li><p><strong>链表或红黑树</strong>：当多个键的哈希值相同时，会发生哈希冲突。在
JDK 1.8 之前，冲突的键值对会以链表的形式存储在数组的同一个位置上；而在
JDK 1.8 之后，当冲突的链表长度超过一定阈值（默认是
8）时，链表会转化为红黑树以提高性能。</p></li>
</ul>
<h3 id="存储单元node">2. <strong>存储单元：Node</strong></h3>
<p>每个键值对都封装在一个 <code>Node</code> 对象中，<code>Node</code> 是
<code>HashMap</code> 中的内部类。<code>Node</code> 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;      <span class="comment">// 哈希值</span></span><br><span class="line">    <span class="keyword">final</span> K key;         <span class="comment">// 键</span></span><br><span class="line">    V value;             <span class="comment">// 值</span></span><br><span class="line">    Node&lt;K,V&gt; next;      <span class="comment">// 指向下一个节点的指针 (用于链表)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hash</code>：键的哈希值。</li>
<li><code>key</code>：存储的键。</li>
<li><code>value</code>：存储的值。</li>
<li><code>next</code>：用于指向下一个节点（当发生哈希冲突时，形成链表）。</li>
</ul>
<h3 id="哈希函数">3. <strong>哈希函数</strong></h3>
<p><code>HashMap</code>
通过哈希函数将键映射到数组的索引位置。哈希函数的目的是通过键计算出一个整数（即哈希值），然后通过取模运算将哈希值映射到数组中的一个具体位置。</p>
<ul>
<li><p><strong>哈希值的计算</strong>： <code>HashMap</code> 使用键的
<code>hashCode()</code>
方法来计算哈希值。为了减少哈希冲突并提高分布的均匀性，<code>HashMap</code>
会进一步处理 <code>hashCode()</code> 返回的哈希值。JDK 1.8
中的实现将高位的哈希值与低位异或（XOR）运算以减少冲突：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>数组索引计算</strong>： <code>HashMap</code> 使用
<code>哈希值 % 数组长度</code>
的方式将哈希值映射到数组的某个索引位置（实际上是通过
<code>hash &amp; (table.length - 1)</code>
位运算来计算索引，这比取模运算效率更高）。</p></li>
</ul>
<h3 id="处理哈希冲突">4. <strong>处理哈希冲突</strong></h3>
<p>哈希冲突发生在多个键具有相同的哈希值并映射到数组的同一位置时。<code>HashMap</code>
通过以下两种方式处理哈希冲突：</p>
<h4 id="链地址法链表">1. <strong>链地址法（链表）</strong>：</h4>
<p>在 JDK 1.8 之前，<code>HashMap</code>
处理冲突时使用的是链地址法。多个哈希值相同的元素会被存储在同一个数组位置（即
<code>Node</code>），形成一个链表。新的元素会插入到链表的末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入新节点</span></span><br><span class="line">Node&lt;K,V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 将新节点挂在原链表的末尾</span></span><br><span class="line">lastNode.next = newNode;</span><br></pre></td></tr></table></figure>
<h4 id="红黑树树化">2. <strong>红黑树（树化）</strong>：</h4>
<p>在 JDK 1.8 之后，当链表长度超过 8
时，链表会转化为红黑树。红黑树的查找、插入和删除的时间复杂度为 O(log
n)，相比链表的 O(n) 效率更高。</p>
<ul>
<li>当链表的长度超过阈值（8）时，<code>HashMap</code>
会自动将链表转换为红黑树。</li>
<li>如果红黑树的节点数量减少到 6
以下，树会被重新转换回链表，以节省内存开销。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// TREEIFY_THRESHOLD is 8</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>
<h3 id="扩容机制">5. <strong>扩容机制</strong></h3>
<p><code>HashMap</code>
的底层数组有容量限制，当数组的元素过多时，发生哈希冲突的概率增大，因此需要动态扩容来保持较低的冲突率。<code>HashMap</code>
的扩容机制如下：</p>
<ul>
<li><p><strong>触发条件</strong>：当哈希表中的元素数量超过数组容量与负载因子（<code>load factor</code>）的乘积时，会触发扩容操作。默认负载因子是
0.75。</p>
<ul>
<li>计算公式：<code>元素数量 &gt; 数组容量 * 负载因子</code></li>
</ul></li>
<li><p><strong>扩容过程</strong>：扩容时，<code>HashMap</code>
将数组的容量扩大为原来的两倍，并将旧数组中的所有元素重新哈希并放入新的数组中。这一过程称为<strong>rehash</strong>。</p></li>
<li><p><strong>rehash
的计算</strong>：重新计算所有键的哈希值并将它们放入新数组，键的位置可能会改变（因为数组容量变大了）。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> table.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCap</span> <span class="operator">=</span> oldCap * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 创建一个更大的新数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTable = <span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">// 将旧数组中的元素重新映射到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex</span> <span class="operator">=</span> e.hash &amp; (newCap - <span class="number">1</span>);</span><br><span class="line">            e.next = newTable[newIndex];</span><br><span class="line">            newTable[newIndex] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找过程">6. <strong>查找过程</strong></h3>
<p>查找操作通过键来查找相应的值，基本流程如下：</p>
<ol type="1">
<li>通过哈希函数计算出键的哈希值。</li>
<li>通过哈希值计算出数组中的索引位置。</li>
<li>在对应位置，如果是链表，遍历链表查找对应键；如果是红黑树，通过树的查找逻辑查找相应键。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 通过哈希值计算数组下标并查找</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 检查首节点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123; <span class="comment">// 检查链表或树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除操作">7. <strong>删除操作</strong></h3>
<p>删除操作的过程和查找类似，首先根据键计算哈希值，再通过索引找到对应的链表或树结构，找到后将其从链表中删除或从树中移除。</p>
<h3 id="hashmap-的性能">8. <strong><code>HashMap</code>
的性能</strong></h3>
<ul>
<li><strong>时间复杂度</strong>：在理想情况下，<code>HashMap</code>
的查找、插入和删除操作的时间复杂度是
O(1)。这是因为哈希表的设计使得每次操作都能快速通过哈希值定位到元素。
<ul>
<li>如果发生哈希冲突并且链表很长，时间复杂度可能退化为 O(n)，但在 JDK
1.8 之后，通过红黑树的引入，最坏情况下时间复杂度也只是 O(log n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：<code>HashMap</code>
的空间复杂度主要取决于其底层数组和存储的元素数量。当哈希冲</li>
</ul>
<p>突严重时，链表和树会占用额外的空间。</p>
<h3 id="总结-22">总结</h3>
<ul>
<li><code>HashMap</code>
是一种基于哈希表的数据结构，使用了哈希函数来实现快速的键值对存取。</li>
<li>它通过数组、链表和红黑树相结合的方式处理哈希冲突，提高查找和插入的效率。</li>
<li>它支持动态扩容，通过重新计算哈希值将元素分布到更大的数组中，以保持哈希表的性能。</li>
</ul>
<h2 id="jni中java如何调c">JNI中Java如何调C++</h2>
<p>在JNI（Java Native Interface）中，Java 调用 C++
代码的过程需要通过定义 Native 方法并进行 JNI
函数调用。以下是Java调用C++代码的详细步骤和机制：</p>
<h3 id="声明-native-方法">1. <strong>声明 Native 方法</strong></h3>
<p>在 Java 中，使用 <code>native</code>
关键字声明一个原生方法，这个方法的实现会在 C/C++ 代码中。Java
代码并不实现这个方法，而是依赖 JNI 来调用 C/C++ 代码。</p>
<p>例如，Java类中可以这样声明一个 Native 方法：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个本地(native)方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载本地库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>); <span class="comment">// 加载名为 native-lib 的库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>nativeMethod()</strong>：这是在 Java 中声明的原生方法。</li>
<li><strong>System.loadLibrary(“native-lib”)</strong>：这个方法会加载名为
<code>native-lib</code> 的本地库，确保 C/C++ 代码可以被调用。</li>
</ul>
<h3 id="生成-cc-头文件">2. <strong>生成 C/C++ 头文件</strong></h3>
<p>使用 <code>javac</code> 编译 Java 文件，然后使用 <code>javah</code>
工具生成对应的 C/C++ 头文件（<code>.h</code>
文件）。这个文件会为本地方法生成一个对应的函数声明。</p>
<p>例如：</p>
<p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac NativeExample.java   <span class="comment"># 编译 Java 文件</span></span><br><span class="line">javah NativeExample        <span class="comment"># 生成 JNI 头文件</span></span><br></pre></td></tr></table></figure></p>
<p><code>javah</code> 工具会生成一个头文件
<code>NativeExample.h</code>，其中包含对应的 C/C++ 函数声明，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Header for class NativeExample */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Included_NativeExample</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Included_NativeExample</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     NativeExample</span></span><br><span class="line"><span class="comment"> * Method:    nativeMethod</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_NativeExample_nativeMethod</span><span class="params">(JNIEnv *, jobject)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>Java_NativeExample_nativeMethod</code>: 这是由
<code>javah</code> 根据 Java 类名和方法名自动生成的 C 函数名。</li>
<li><code>JNIEnv *</code>: 这是 JNI 环境指针，提供了大量可以在 C/C++
中调用 Java API 的函数。</li>
<li><code>jobject</code>: 代表的是 Java 中调用这个方法的实例对象。</li>
</ul>
<h3 id="实现-native-方法-cc-实现">3. <strong>实现 Native 方法 (C/C++
实现)</strong></h3>
<p>在生成的头文件基础上，开发者需要实现这个 C/C++ 函数。</p>
<p>例如，可以在 <code>native-lib.cpp</code> 中实现这个函数：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现 nativeMethod 函数</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_NativeExample_nativeMethod</span><span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from C++!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键点：</p>
<ul>
<li><strong>JNIEXPORT</strong> 和 <strong>JNICALL</strong>
是修饰符，确保函数可以被 JNI 机制正确调用。</li>
<li><strong>JNIEnv</strong> 提供了丰富的接口，可以在 C/C++ 中操作 Java
对象或调用 Java 方法。</li>
<li><strong>jobject</strong> 是对 Java 对象的引用，通过它可以访问调用该
Native 方法的 Java 对象。</li>
</ul>
<h3 id="编译-cc-代码并生成库">4. <strong>编译 C/C++
代码并生成库</strong></h3>
<p>将 C/C++ 代码编译成动态库。这个库的名字需要与 Java 中通过
<code>System.loadLibrary()</code> 加载的库名一致。</p>
<p>在 Linux 中，可以这样编译 C++ 代码：</p>
<p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -shared -fPIC -o libnative-lib.so native-lib.cpp -I<span class="variable">$&#123;JAVA_HOME&#125;</span>/include -I<span class="variable">$&#123;JAVA_HOME&#125;</span>/include/linux</span><br></pre></td></tr></table></figure></p>
<p>关键参数：</p>
<ul>
<li><code>-shared</code>: 编译为共享库（即 <code>.so</code>
文件）。</li>
<li><code>-fPIC</code>:
生成与位置无关的代码，以便可以用于动态加载。</li>
<li><code>-o libnative-lib.so</code>: 指定输出文件为共享库
<code>libnative-lib.so</code>，Java 将加载此库。</li>
<li><code>-I</code>: 指定包含 JNI 头文件的路径。</li>
</ul>
<h3 id="运行-java-代码">5. <strong>运行 Java 代码</strong></h3>
<p>在 Java 中，通过 <code>System.loadLibrary("native-lib")</code>
加载编译后的共享库，然后可以直接调用定义的 <code>nativeMethod()</code>
方法。</p>
<p>例如，Java 类 <code>NativeExample</code> 可以这样调用：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NativeExample</span>().nativeMethod(); <span class="comment">// 调用C++实现的 nativeMethod</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序时，Java 将通过 JNI 调用 <code>native-lib</code> 中的
<code>nativeMethod()</code> 实现，最终执行 C/C++ 代码并输出结果。</p>
<h3 id="jni-调用机制的关键概念">6. <strong>JNI
调用机制的关键概念</strong></h3>
<ul>
<li><p><strong>JNIEnv</strong>：这是 JNI 环境的指针，JNI
提供了很多函数供 C/C++ 代码调用，例如，调用 Java 方法、访问 Java
对象、操作字符串等。通过 <code>JNIEnv</code>，可以实现很多 Java 和 C/C++
的交互。</p></li>
<li><p><strong>jobject</strong>：这是 Java 对象的引用，C/C++
可以通过这个对象调用 Java 中的成员方法或属性。</p></li>
<li><p><strong>类型映射</strong>：Java 和 C/C++
之间的数据类型不完全一致，JNI 提供了一些特定的数据类型，例如：</p>
<ul>
<li><code>jint</code> 对应于 Java 的 <code>int</code></li>
<li><code>jboolean</code> 对应于 Java 的 <code>boolean</code></li>
<li><code>jstring</code> 对应于 Java 的 <code>String</code></li>
</ul></li>
</ul>
<h3 id="调用java方法和访问字段">7.
<strong>调用Java方法和访问字段</strong></h3>
<p>在 C/C++ 中，不仅可以实现 Native 方法，还可以通过 JNI 机制调用 Java
对象的方法，或访问 Java 对象的字段。常用的函数包括：</p>
<ul>
<li><p><strong>调用Java方法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jclass clazz = env-&gt;<span class="built_in">GetObjectClass</span>(obj);</span><br><span class="line">jmethodID methodID = env-&gt;<span class="built_in">GetMethodID</span>(clazz, <span class="string">&quot;methodName&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">env-&gt;<span class="built_in">CallVoidMethod</span>(obj, methodID);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>访问Java字段</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jfieldID fieldID = env-&gt;<span class="built_in">GetFieldID</span>(clazz, <span class="string">&quot;fieldName&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">jint fieldValue = env-&gt;<span class="built_in">GetIntField</span>(obj, fieldID);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-23">总结：</h3>
<p>Java 调用 C/C++ 代码的流程可以总结为以下步骤：</p>
<ol type="1">
<li>在 Java 中声明 <code>native</code> 方法。</li>
<li>通过 <code>javah</code> 工具生成 C/C++ 头文件。</li>
<li>在 C/C++ 中实现这些头文件声明的函数。</li>
<li>编译 C/C++ 代码为动态库，并在 Java 中加载这个库。</li>
<li>通过 JNI 环境（<code>JNIEnv</code>）在 C/C++ 中调用 Java
方法、访问字段或进行对象交互。</li>
</ol>
<h2 id="jni中c如何调java">JNI中C++如何调Java</h2>
<p>在JNI（Java Native Interface）中，C++ 调用 Java
方法的过程称为”从Native代码调用Java代码”。这种调用通常发生在C++代码需要通知Java端事件，或使用Java提供的某些功能时。以下是C++调用Java代码的详细步骤和机制：</p>
<h3 id="获取jni环境指针-jnienv">1. <strong>获取JNI环境指针
(<code>JNIEnv</code>)</strong></h3>
<p>每个Native方法中，JNI环境指针<code>JNIEnv *</code>是一个非常重要的参数，它提供了调用Java方法的所有接口。在任何一个Native方法中，<code>JNIEnv *</code>都是自动提供的。可以通过它调用Java中的方法、访问类、对象等。</p>
<h3 id="获取java类">2. <strong>获取Java类</strong></h3>
<p>在调用Java方法之前，C++代码首先需要通过<code>JNIEnv</code>获取到相应的Java类。可以通过以下方式获取Java类的引用：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jclass clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/example/YourJavaClass&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>com/example/YourJavaClass</code>
是Java类的完全限定名（包名+类名）。此时，<code>clazz</code>
是对该Java类的引用。</p>
<h3 id="获取java方法id">3. <strong>获取Java方法ID</strong></h3>
<p>为了调用Java方法，C++代码需要通过<code>JNIEnv</code>获取方法的标识符（<code>jmethodID</code>）。调用Java的方法可能是实例方法（对象方法）或静态方法。</p>
<ul>
<li><p><strong>获取实例方法ID</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmethodID methodID = env-&gt;<span class="built_in">GetMethodID</span>(clazz, <span class="string">&quot;methodName&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>methodName</code>: 要调用的Java方法的名称。</li>
<li><code>"(I)V"</code>:
方法的签名，其中<code>(I)</code>表示方法参数为一个<code>int</code>类型，<code>V</code>表示返回类型为<code>void</code>。</li>
</ul></li>
<li><p><strong>获取静态方法ID</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmethodID staticMethodID = env-&gt;<span class="built_in">GetStaticMethodID</span>(clazz, <span class="string">&quot;staticMethodName&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>GetStaticMethodID</code> 用于获取静态方法的ID。</li>
<li><code>"(Ljava/lang/String;)V"</code>
是方法签名，表示参数为一个<code>String</code>类型，返回类型为<code>void</code>。</li>
</ul></li>
</ul>
<p>Java方法的签名格式：</p>
<ul>
<li>基本类型：
<ul>
<li><code>Z</code>：<code>boolean</code></li>
<li><code>B</code>：<code>byte</code></li>
<li><code>C</code>：<code>char</code></li>
<li><code>S</code>：<code>short</code></li>
<li><code>I</code>：<code>int</code></li>
<li><code>J</code>：<code>long</code></li>
<li><code>F</code>：<code>float</code></li>
<li><code>D</code>：<code>double</code></li>
<li><code>V</code>：<code>void</code></li>
</ul></li>
<li>引用类型（对象）使用全路径的形式表示，例如<code>Ljava/lang/String;</code>
表示<code>java.lang.String</code>。</li>
</ul>
<h3 id="调用java方法">4. <strong>调用Java方法</strong></h3>
<p>获取了Java类和方法ID后，C++代码可以调用该Java方法。具体方法取决于你调用的是实例方法还是静态方法。</p>
<ul>
<li><p><strong>调用实例方法</strong>：</p>
<ul>
<li>首先需要一个Java对象实例（<code>jobject</code>），可以通过传入的参数或者构造方法创建一个对象。</li>
<li>然后调用实例方法：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobject obj = <span class="comment">// 已有的Java对象或通过构造方法创建;</span></span><br><span class="line">env-&gt;<span class="built_in">CallVoidMethod</span>(obj, methodID, <span class="number">42</span>);  <span class="comment">// 传入参数42，调用Java方法</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>CallVoidMethod</code>
是用于调用返回类型为<code>void</code>的方法。类似地，有：</p>
<ul>
<li><code>CallIntMethod()</code>：调用返回<code>int</code>的方法</li>
<li><code>CallObjectMethod()</code>：调用返回Java对象的方法</li>
<li><code>CallBooleanMethod()</code> 等其他类型的方法调用函数。</li>
</ul></li>
<li><p><strong>调用静态方法</strong>：
如果调用的是静态方法，就不需要<code>jobject</code>，而是通过类的引用调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;<span class="built_in">CallStaticVoidMethod</span>(clazz, staticMethodID, env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello from C++&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建java对象实例">5. <strong>创建Java对象实例</strong></h3>
<p>如果需要在C++中创建一个Java对象，C++可以通过调用Java类的构造方法来实例化Java对象。过程如下：</p>
<ul>
<li><p><strong>获取构造方法ID</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmethodID constructorID = env-&gt;<span class="built_in">GetMethodID</span>(clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里<code>"&lt;init&gt;"</code>表示构造方法，<code>(Ljava/lang/String;)V</code>
表示构造方法的签名，即参数是<code>String</code>，返回值为<code>void</code>。</p></li>
<li><p><strong>创建对象</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobject obj = env-&gt;<span class="built_in">NewObject</span>(clazz, constructorID, env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>上述代码会创建一个新实例，并调用Java类的构造函数。</p></li>
</ul>
<h3 id="访问java字段">6. <strong>访问Java字段</strong></h3>
<p>除了调用Java方法，C++代码还可以访问Java对象的成员字段（包括静态字段和实例字段）。</p>
<ul>
<li><p><strong>获取实例字段ID</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jfieldID fieldID = env-&gt;<span class="built_in">GetFieldID</span>(clazz, <span class="string">&quot;fieldName&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>fieldName</code>是Java中的字段名，<code>"I"</code>表示该字段是<code>int</code>类型。</p></li>
<li><p><strong>读取字段值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jint fieldValue = env-&gt;<span class="built_in">GetIntField</span>(obj, fieldID);</span><br></pre></td></tr></table></figure>
<p>使用 <code>Get&lt;Type&gt;Field()</code> 来获取字段值，这里的
<code>&lt;Type&gt;</code>
是字段的类型，如<code>Int</code>、<code>Boolean</code>、<code>Object</code>等。</p></li>
<li><p><strong>设置字段值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;<span class="built_in">SetIntField</span>(obj, fieldID, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>Set&lt;Type&gt;Field()</code> 设置字段值。</p></li>
</ul>
<h3 id="完整示例c-调用-java-方法">7. <strong>完整示例：C++ 调用 Java
方法</strong></h3>
<p>假设我们在 Java 类 <code>JavaExample</code> 中有如下代码：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance method called with value: &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method called with message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C++中，可以如下调用这个Java类的方法：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT <span class="type">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_MyNativeClass_nativeMethod</span><span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 Java 类</span></span><br><span class="line">    jclass javaClass = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/example/JavaExample&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用实例方法</span></span><br><span class="line">    jmethodID instanceMethodID = env-&gt;<span class="built_in">GetMethodID</span>(javaClass, <span class="string">&quot;instanceMethod&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    jobject javaObj = env-&gt;<span class="built_in">NewObject</span>(javaClass, env-&gt;<span class="built_in">GetMethodID</span>(javaClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>));</span><br><span class="line">    env-&gt;<span class="built_in">CallVoidMethod</span>(javaObj, instanceMethodID, <span class="number">42</span>);  <span class="comment">// 传入42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用静态方法</span></span><br><span class="line">    jmethodID staticMethodID = env-&gt;<span class="built_in">GetStaticMethodID</span>(javaClass, <span class="string">&quot;staticMethod&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    jstring message = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello from C++&quot;</span>);</span><br><span class="line">    env-&gt;<span class="built_in">CallStaticVoidMethod</span>(javaClass, staticMethodID, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异常处理">8. <strong>异常处理</strong></h3>
<p>在使用 JNI 调用 Java 方法时，C++ 代码应该处理可能出现的 Java
异常。可以通过以下方法检查是否有异常抛出：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (env-&gt;<span class="built_in">ExceptionCheck</span>()) &#123;</span><br><span class="line">    env-&gt;<span class="built_in">ExceptionDescribe</span>();  <span class="comment">// 打印异常信息</span></span><br><span class="line">    env-&gt;<span class="built_in">ExceptionClear</span>();     <span class="comment">// 清除异常状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结-24">总结：</h3>
<p>C++ 调用 Java 方法的流程大致如下：</p>
<ol type="1">
<li><strong>获取JNI环境指针</strong>：使用<code>JNIEnv</code>来调用Java代码。</li>
<li><strong>获取Java类引用</strong>：通过<code>FindClass</code>获取Java类。</li>
<li><strong>获取方法ID</strong>：使用<code>GetMethodID</code>或<code>GetStaticMethodID</code>获取实例方法或静态方法的ID。</li>
<li><strong>调用方法</strong>：使用<code>Call&lt;Type&gt;Method</code>或<code>CallStatic&lt;Type&gt;Method</code>来调用实例方法或静态方法。</li>
<li><strong>访问Java字段</strong>：使用<code>GetFieldID</code>获取字段ID，然后通过<code>Get&lt;Type&gt;Field</code>或<code>Set&lt;Type&gt;Field</code>访问或修改字段值。</li>
</ol>
<p>通过这些步骤，C++代码可以灵活地与Java代码进行交互。</p>
<h2 id="内存模型">内存模型</h2>
<p>JVM（Java Virtual Machine，Java 虚拟机）的内存模型定义了 Java
程序运行时内存的管理方式，包括内存区域的划分、数据的存储方式以及垃圾回收机制等。JVM
内存模型可以划分为多个区域，这些区域用于存储不同类型的数据，并且各区域的生命周期和作用也有所不同。</p>
<h3 id="jvm-内存模型主要分为以下几个部分">JVM
内存模型主要分为以下几个部分：</h3>
<ol type="1">
<li><strong>程序计数器 (Program Counter Register)</strong>：
<ul>
<li>这是一块很小的内存区域，用来存储每个线程当前执行的字节码指令的地址。因为
JVM
是多线程的，每个线程都有一个独立的程序计数器，用于记录当前线程所执行的字节码指令的地址。</li>
<li>如果线程正在执行的是一个本地方法（native
method），程序计数器为空（undefined）。</li>
</ul></li>
<li><strong>Java 虚拟机栈 (Java Virtual Machine Stack)</strong>：
<ul>
<li>每个线程都有一个独立的 Java
虚拟机栈，栈中存放着每个方法调用的栈帧（Stack
Frame），包括局部变量、操作数栈、动态链接和方法的返回地址。</li>
<li><strong>局部变量表</strong> 存放方法的局部变量，包括基本数据类型（如
<code>int</code>, <code>long</code>, <code>float</code>,
<code>double</code>）和对象的引用。</li>
<li>每个方法被调用时，都会在虚拟机栈中创建一个栈帧，方法执行完毕后，栈帧出栈。</li>
<li>栈的大小可以通过启动参数 <code>-Xss</code> 来设置。</li>
</ul></li>
<li><strong>本地方法栈 (Native Method Stack)</strong>：
<ul>
<li>与 Java
虚拟机栈类似，但本地方法栈用于存储本地方法调用时的信息，本地方法是指使用
JNI（Java Native Interface）调用的非 Java 方法，如 C 或 C++ 代码。</li>
<li>这一部分内存区域是与平台相关的，主要用于处理平台相关的原生代码。</li>
</ul></li>
<li><strong>堆 (Heap)</strong>：
<ul>
<li>堆是 JVM
内存中最大的一块区域，几乎所有对象都存储在堆中，垃圾回收器主要关注的也是这个区域。</li>
<li>堆在 JVM
启动时创建，所有线程共享这一块内存，任何线程都可以访问堆中的对象。</li>
<li><strong>堆的结构</strong>：
<ul>
<li><strong>新生代 (Young Generation)</strong>:
新生代是对象最先创建的区域，分为三个部分：一个 “Eden” 区和两个
“Survivor” 区（S0 和 S1）。
<ul>
<li>当一个对象首次被创建时，会被分配到 Eden 区，当 Eden
区满时，存活下来的对象会被移到 Survivor 区。</li>
<li>在新生代经过几次垃圾回收依然存活的对象，会被晋升到老年代。</li>
</ul></li>
<li><strong>老年代 (Old Generation)</strong>:
老年代存储生命周期较长的对象，即从新生代中晋升过来的对象。老年代垃圾回收频率较低，但回收时耗时较长。</li>
</ul></li>
<li>堆内存的大小可以通过 <code>-Xms</code> 和 <code>-Xmx</code>
参数来设置。</li>
</ul></li>
<li><strong>方法区 (Method Area)</strong>：
<ul>
<li>方法区是所有线程共享的，用于存储类的元数据（Class
Metadata）、常量、静态变量、即时编译器编译后的代码（JIT 代码）等。</li>
<li>方法区可以看作是堆的逻辑部分，但它专门用于存储与类相关的结构数据。</li>
<li>在 HotSpot JVM 中，方法区是由 <strong>元空间 (Metaspace)</strong>
实现的。在 Java 8 之前，方法区也被称为永久代（PermGen），从 Java 8
开始，永久代被元空间取代。
<ul>
<li>元空间的内存空间是由系统的本地内存而非 JVM
堆来管理，因此相比之前版本的永久代，减少了 OutOfMemoryError
的问题。</li>
</ul></li>
</ul></li>
<li><strong>运行时常量池 (Runtime Constant Pool)</strong>：
<ul>
<li>运行时常量池是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。比如，字符串常量、数字常量、方法引用等。</li>
<li>它不仅包括 Java
源代码中的常量，还包含运行时才能确定的动态常量。</li>
</ul></li>
</ol>
<h3 id="jvm-内存模型的内存区域图示">JVM 内存模型的内存区域图示：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------+</span><br><span class="line">|       Method Area (Metaspace)      |</span><br><span class="line">|    - Class Metadata                |</span><br><span class="line">|    - Constant Pool                 |</span><br><span class="line">|    - Static Variables              |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|           Heap (Heap Space)        |</span><br><span class="line">|    - Young Generation              |</span><br><span class="line">|    - Old Generation                |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|    Java Virtual Machine Stack      |</span><br><span class="line">|    - Stack Frames                  |</span><br><span class="line">|    - Local Variables               |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|       Native Method Stack          |</span><br><span class="line">|    - Native Method Information     |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|      Program Counter Register      |</span><br><span class="line">+------------------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收-garbage-collection">垃圾回收 (Garbage Collection)</h3>
<p>JVM
提供了自动的垃圾回收机制，用来释放不再使用的对象。垃圾回收的主要目标是堆内存，特别是新生代和老年代。常用的垃圾回收算法有：</p>
<ol type="1">
<li><strong>标记-清除算法 (Mark and Sweep)</strong>：
<ul>
<li>垃圾回收器会首先遍历对象图，标记所有存活的对象。然后，它会清除未被标记的对象，回收相应的内存空间。</li>
</ul></li>
<li><strong>复制算法 (Copying)</strong>：
<ul>
<li>主要用于新生代。它将对象分配到 Eden 区和 Survivor
区之间，并在垃圾回收时将存活的对象复制到空的 Survivor
区，释放其他空间。</li>
</ul></li>
<li><strong>标记-压缩算法 (Mark-Compact)</strong>：
<ul>
<li>主要用于老年代。标记存活对象后，将存活对象压缩到堆的一端，释放连续的内存空间。</li>
</ul></li>
</ol>
<h3 id="总结-25">总结</h3>
<p>JVM
的内存模型通过堆、方法区、栈、程序计数器等多个区域的划分和管理，来保证
Java
程序的高效运行，同时通过垃圾回收机制实现内存自动管理。理解这些内存区域的工作原理有助于优化
Java 程序的性能和内存使用。</p>
<h2 id="垃圾回收">垃圾回收</h2>
<p>Java 的垃圾回收机制（Garbage Collection，简称 GC）是 Java
语言的一大优势之一，它自动管理内存分配和释放，程序员无需手动处理内存释放，减少了内存泄漏和程序崩溃的可能性。垃圾回收机制通过追踪对象的生命周期，回收不再被引用的对象所占用的内存。</p>
<h3 id="垃圾回收的基本原理">垃圾回收的基本原理</h3>
<p>垃圾回收的核心任务是找到并删除不再被程序使用的对象。JVM
使用<strong>根可达性算法</strong>（Reachability
Analysis）来判断对象是否可以被回收。该算法通过判断对象是否可以从<strong>GC
Root</strong>到达（即是否有引用链可达），如果一个对象从 GC Root
不可达，那么该对象就被认为是垃圾，可以被回收。</p>
<h4 id="gc-roots-常见的有">GC Roots 常见的有：</h4>
<ul>
<li>当前线程栈中的局部变量。</li>
<li>方法区中静态变量。</li>
<li>方法区中的常量。</li>
<li>JNI 引用的对象（Native 方法中的引用）。</li>
</ul>
<h3 id="垃圾回收的主要算法">垃圾回收的主要算法</h3>
<p>Java 的垃圾回收机制主要依赖以下几种算法：</p>
<ol type="1">
<li><strong>标记-清除算法 (Mark-Sweep)</strong>：
<ul>
<li><strong>过程</strong>：
<ul>
<li><strong>标记阶段</strong>：从 GC Root
开始，遍历所有的引用对象，标记活跃对象。</li>
<li><strong>清除阶段</strong>：遍历整个堆，回收未被标记的对象。</li>
</ul></li>
<li><strong>优点</strong>：不需要额外空间来存储对象。</li>
<li><strong>缺点</strong>：容易产生内存碎片，导致较大的对象无法分配连续的内存空间。</li>
</ul></li>
<li><strong>复制算法 (Copying)</strong>：
<ul>
<li><strong>过程</strong>：
<ul>
<li>将内存分为两块区域，每次只使用其中的一块。当一块内存空间用完时，将存活的对象复制到另一块空间，然后清空当前的内存空间。</li>
</ul></li>
<li><strong>优点</strong>：不产生内存碎片，分配内存效率较高。</li>
<li><strong>缺点</strong>：需要额外的内存空间（通常是将新生代内存分为
Eden 和两个 Survivor 区）。</li>
<li><strong>应用场景</strong>：主要用于 Java 堆中的新生代。</li>
</ul></li>
<li><strong>标记-整理算法 (Mark-Compact)</strong>：
<ul>
<li><strong>过程</strong>：
<ul>
<li>首先标记所有的活跃对象，之后将所有的存活对象压缩到内存的一端，保持内存的连续性，最后清除端边界外的空间。</li>
</ul></li>
<li><strong>优点</strong>：避免了内存碎片问题。</li>
<li><strong>缺点</strong>：整理过程需要移动对象，开销较大。</li>
<li><strong>应用场景</strong>：主要用于老年代。</li>
</ul></li>
<li><strong>分代收集算法</strong>：
<ul>
<li><strong>基本思想</strong>：Java
中的对象按其生命周期长短被分为不同的代，垃圾回收器采用不同的算法来管理不同区域的内存。</li>
<li><strong>分代结构</strong>：
<ul>
<li><strong>新生代 (Young
Generation)</strong>：新创建的对象会首先分配到新生代。新生代中的对象通常“朝生夕死”，垃圾回收频繁，回收速度较快。
<ul>
<li><strong>Eden 区</strong>：大多数新对象在这里分配。</li>
<li><strong>Survivor 区</strong>：包含两个区 (S0, S1)，存活的对象会从
Eden 区复制到其中一个 Survivor 区，当该 Survivor
区满时，活跃对象会复制到另一个 Survivor 区或进入老年代。</li>
</ul></li>
<li><strong>老年代 (Old
Generation)</strong>：存活时间较长、生命周期较长的对象会被晋升到老年代，老年代的垃圾回收频率较低，但耗时较长。</li>
<li><strong>永久代/元空间 (Permanent
Generation/Metaspace)</strong>：存储类的元数据（在 Java 8
之后，永久代被元空间取代）。</li>
</ul></li>
</ul></li>
</ol>
<h3 id="java-垃圾回收器">Java 垃圾回收器</h3>
<p>JVM 中有多种不同的垃圾回收器，适合不同的应用场景，常见的有：</p>
<ol type="1">
<li><strong>Serial GC</strong>：
<ul>
<li>单线程的垃圾回收器，适用于小型应用程序。</li>
<li>优点：简单、低内存开销。</li>
<li>缺点：GC 时会暂停所有应用线程（即所谓的“Stop the
World”），效率较低。</li>
</ul></li>
<li><strong>Parallel GC</strong>（也叫做 “吞吐量优先垃圾回收器”）：
<ul>
<li>多线程垃圾回收器，适合高吞吐量的应用程序。</li>
<li>优点：并行执行 GC，能够处理大量的对象分配。</li>
<li>缺点：在高响应需求的应用中，可能不够快速。</li>
</ul></li>
<li><strong>CMS GC (Concurrent Mark-Sweep Garbage Collector)</strong>：
<ul>
<li>低延迟的垃圾回收器，适用于需要低停顿时间的应用程序。</li>
<li>优点：标记和清除过程是并发执行的，减少了长时间的停顿。</li>
<li>缺点：会产生内存碎片，并且在高并发下，垃圾回收线程与应用线程可能会争抢资源。</li>
</ul></li>
<li><strong>G1 GC (Garbage First Garbage Collector)</strong>：
<ul>
<li>Java 7 引入的一种新的垃圾回收器，设计用于取代 CMS。</li>
<li><strong>分区收集</strong>：将堆划分为多个相同大小的区域，根据区域内的垃圾回收优先级进行回收，优先清理垃圾最多的区域。</li>
<li><strong>优点</strong>：能够提供更可预测的停顿时间，适合大内存、多处理器的系统，降低了大规模老年代
GC 的延迟。</li>
<li><strong>缺点</strong>：比 CMS 更复杂。</li>
</ul></li>
<li><strong>ZGC (Z Garbage Collector)</strong>：
<ul>
<li>在 Java 11
引入的一种超低延迟垃圾回收器，设计用于处理超大堆内存。</li>
<li><strong>优点</strong>：能处理 TB 级别的堆，并且 GC
停顿时间非常短（通常在 10 毫秒以下）。</li>
<li><strong>缺点</strong>：实现复杂，并且相比传统 GC
可能会占用更多的内存。</li>
</ul></li>
</ol>
<h3 id="垃圾回收的触发机制">垃圾回收的触发机制</h3>
<p>垃圾回收不是随时都可以发生的，通常会在以下情况下触发： 1.
当堆内存中的<strong>新生代</strong>（Eden
区）空间耗尽时，会触发<strong>Minor GC</strong>，它只清理新生代。 2.
当堆内存中的<strong>老年代</strong>空间耗尽时，会触发<strong>Major
GC</strong> 或 <strong>Full
GC</strong>，它会清理整个堆，包括新生代和老年代。Full GC
的代价较高，通常伴随长时间的暂停。</p>
<h3 id="垃圾回收的调优">垃圾回收的调优</h3>
<p>为了提高应用的性能，开发者可以根据实际需求调整垃圾回收器的策略。调优时可以根据以下参数进行设置：
- <strong>-Xms</strong> 和
<strong>-Xmx</strong>：设置堆的初始大小和最大大小。 -
<strong>-XX:NewSize</strong> 和
<strong>-XX:MaxNewSize</strong>：设置新生代的大小。 -
<strong>-XX:SurvivorRatio</strong>：设置 Eden 区与 Survivor 区的比例。 -
<strong>-XX:+UseG1GC</strong>：启用 G1 垃圾回收器。 -
<strong>-XX:+UseZGC</strong>：启用 ZGC 垃圾回收器。</p>
<h3 id="总结-26">总结</h3>
<p>Java
的垃圾回收机制通过自动回收不再使用的对象，简化了内存管理，同时不同的垃圾回收器和算法适应不同类型的应用场景。在高性能应用中，理解和调优垃圾回收机制是提升应用性能的重要手段。</p>
<h2 id="常用设计模式">常用设计模式</h2>
<p>设计模式是软件开发中的一种通用解决方案，用于解决某类常见的设计问题。设计模式并不是具体的代码，而是经过总结的、可复用的解决方案，可以帮助开发者编写高效、可维护和可扩展的代码。设计模式分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。以下是常用的设计模式及其解释和应用场景。</p>
<hr />
<h3 id="创建型模式">1. <strong>创建型模式</strong></h3>
<p>创建型模式关注对象的创建方式，目的是将对象的创建过程与其使用分离，以提高系统的灵活性和可扩展性。</p>
<h4 id="单例模式-singleton-pattern">1.1 <strong>单例模式 (Singleton
Pattern)</strong></h4>
<p><strong>意图</strong>：保证一个类只有一个实例，并提供一个全局访问点。</p>
<ul>
<li><strong>应用场景</strong>：用于需要一个类有且仅有一个实例的情况，比如全局配置对象、日志系统、线程池等。</li>
<li><strong>实现</strong>：通过私有化构造函数、提供一个静态方法来获取唯一的实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="工厂方法模式-factory-method-pattern">1.2 <strong>工厂方法模式
(Factory Method Pattern)</strong></h4>
<p><strong>意图</strong>：定义一个创建对象的接口，但让子类决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p>
<ul>
<li><strong>应用场景</strong>：需要根据不同的条件创建不同类型的对象时，可以使用工厂方法模式。</li>
<li><strong>实现</strong>：通过定义一个抽象工厂类，子类根据需要创建具体对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Product A created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Product B created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactoryA</span> <span class="keyword">extends</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象工厂模式-abstract-factory-pattern">1.3 <strong>抽象工厂模式
(Abstract Factory Pattern)</strong></h4>
<p><strong>意图</strong>：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体的类。</p>
<ul>
<li><strong>应用场景</strong>：当需要创建多个相关联的对象时，使用抽象工厂模式。</li>
<li><strong>实现</strong>：定义多个工厂接口，分别用于创建相关的产品族。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    Checkbox <span class="title function_">createCheckbox</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WinFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Checkbox <span class="title function_">createCheckbox</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinCheckbox</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Checkbox <span class="title function_">createCheckbox</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacCheckbox</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="建造者模式-builder-pattern">1.4 <strong>建造者模式 (Builder
Pattern)</strong></h4>
<p><strong>意图</strong>：将对象的创建与表示分离，使得相同的创建过程可以构建不同的对象。</p>
<ul>
<li><strong>应用场景</strong>：用于创建复杂对象，特别是当构建过程复杂时，如创建包含多个步骤的对象时。</li>
<li><strong>实现</strong>：通过一个 <code>Builder</code>
类逐步构造复杂对象，最后返回完整对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartA</span><span class="params">(String partA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartB</span><span class="params">(String partB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProductBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProductBuilder <span class="title function_">buildPartA</span><span class="params">(String partA)</span> &#123;</span><br><span class="line">        product.setPartA(partA);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProductBuilder <span class="title function_">buildPartB</span><span class="params">(String partB)</span> &#123;</span><br><span class="line">        product.setPartB(partB);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="结构型模式">2. <strong>结构型模式</strong></h3>
<p>结构型模式关注类和对象的组合，帮助我们更好地组织代码结构，特别是在类继承和对象组合方面提供更灵活的解决方案。</p>
<h4 id="适配器模式-adapter-pattern">2.1 <strong>适配器模式 (Adapter
Pattern)</strong></h4>
<p><strong>意图</strong>：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。</p>
<ul>
<li><strong>应用场景</strong>：当你需要使用一个已有的类，但它的接口与其他代码不兼容时，使用适配器模式。</li>
<li><strong>实现</strong>：通过创建一个适配器类，桥接客户类和需要适配的类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Specific Request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="装饰器模式-decorator-pattern">2.2 <strong>装饰器模式 (Decorator
Pattern)</strong></h4>
<p><strong>意图</strong>：动态地给对象添加额外的职责，而不是通过继承来扩展功能。</p>
<ul>
<li><strong>应用场景</strong>：用于需要动态地为对象添加功能的时候，例如对核心功能进行增强。</li>
<li><strong>实现</strong>：通过装饰器类包装原始对象，并在装饰器类中添加新功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Concrete Component operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;Additional functionality in decorator&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代理模式-proxy-pattern">2.3 <strong>代理模式 (Proxy
Pattern)</strong></h4>
<p><strong>意图</strong>：为其他对象提供一个代理，以控制对该对象的访问。</p>
<ul>
<li><strong>应用场景</strong>：用于延迟加载、控制访问权限、在访问对象时添加额外的逻辑等场景。</li>
<li><strong>实现</strong>：代理类实现目标接口，并控制对目标对象的访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Real Service Request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealService realService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realService == <span class="literal">null</span>) &#123;</span><br><span class="line">            realService = <span class="keyword">new</span> <span class="title class_">RealService</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Proxy Service Request&quot;</span>);</span><br><span class="line">        realService.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="行为型模式">3. <strong>行为型模式</strong></h3>
<p>行为型模式关注对象之间的交互及职责的划分，定义了对象之间如何通信和协作。</p>
<h4 id="观察者模式-observer-pattern">3.1 <strong>观察者模式 (Observer
Pattern)</strong></h4>
<p><strong>意图</strong>：定义对象间的一对多依赖，当一个对象的状态发生改变时，所有依赖于它的对象都会自动收到通知。</p>
<ul>
<li><strong>应用场景</strong>：用于事件处理机制，发布-订阅系统，典型的应用是
GUI 事件处理和消息系统。</li>
<li><strong>实现</strong>：通过维护观察者列表，在被观察者状态变化时通知所有观察者。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteObserver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; received message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="策略模式-strategy-pattern">3.2 <strong>策略模式 (Strategy
Pattern)</strong></h4>
<p><strong>意图</strong>：定义一系列算法，将每个算法封装起来，并使它们可以相互替换。策略模式使得算法的变化不会影响使用算法的客户。</p>
<ul>
<li><strong>应用场景</strong>：用于需要动态选择算法或行为的场景，例如支付方式的选择、排序算法的切换等。</li>
<li><strong>实现</strong>：将不同的算法实现封装到具体的策略类中，通过统一接口调用不同的策略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing Strategy A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing Strategy B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命令模式-command-pattern">3.3 <strong>命令模式 (Command
Pattern)</strong></h4>
<p><strong>意图</strong>：将请求封装成一个对象，从而可以用不同的请求对客户进行参数化，以及对请求排队或记录请求日志。</p>
<ul>
<li><strong>应用场景</strong>：用于执行请求操作的场景，如按钮点击、撤销操作等。</li>
<li><strong>实现</strong>：通过将请求封装为命令对象，然后在需要的时候调用这些命令对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOnCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressButton</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结-27">总结</h3>
<ul>
<li><strong>创建型模式</strong>
解决对象创建问题，确保系统中的对象创建过程灵活可控（如单例、工厂、建造者等）。</li>
<li><strong>结构型模式</strong>
解决类或对象的组合问题，确保系统的不同部分能灵活、有效地协作（如适配器、代理、装饰器等）。</li>
<li><strong>行为型模式</strong>
解决对象之间的交互问题，确保对象之间的职责分配合理且合作顺畅（如观察者、策略、命令等）。</li>
</ul>
<p>不同的设计模式有助于解决软件开发中的常见问题，通过合理选择合适的设计模式，可以提高代码的可维护性、可复用性和可扩展性。</p>
<h2 id="并发编程">并发编程</h2>
<p><strong>Java
并发编程</strong>是指在多线程环境下，协调多个线程并发执行任务的编程技术。并发编程是
Java
语言中的一个重要特性，它允许程序在多核处理器上充分利用计算资源，提高程序的运行效率。然而，并发编程也带来了线程同步、数据共享和竞态条件等挑战。Java
提供了一整套工具和类库来帮助开发者编写高效且安全的并发程序。</p>
<h3 id="为什么需要并发编程">为什么需要并发编程？</h3>
<ol type="1">
<li><strong>提高性能</strong>：在多核处理器上，通过并发编程可以让多个任务同时执行，提高程序的效率。</li>
<li><strong>优化资源使用</strong>：并发编程允许程序在 I/O
操作（如网络请求、文件读写）或其他阻塞操作期间执行其他任务，从而更好地利用系统资源。</li>
<li><strong>响应性</strong>：在 GUI
程序中，使用并发编程可以让主线程负责界面渲染，而后台线程执行耗时任务，避免用户界面卡顿。</li>
</ol>
<hr />
<h3 id="java-并发编程的基本概念">Java 并发编程的基本概念</h3>
<h4 id="线程">1. <strong>线程</strong></h4>
<p>线程是 Java
并发编程的基本单位。每个线程代表程序中的一个执行路径。Java 提供了
<code>Thread</code> 类和 <code>Runnable</code>
接口来创建和管理线程。</p>
<ul>
<li><strong>创建线程</strong>：
<ul>
<li>通过继承 <code>Thread</code> 类： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">thread.start();  <span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure></li>
<li>通过实现 <code>Runnable</code> 接口： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="线程的生命周期">2. <strong>线程的生命周期</strong></h4>
<p>Java 线程的生命周期通常包括以下几个阶段： -
<strong>新建（New）</strong>：线程被创建，但还没有启动。 -
<strong>就绪（Runnable）</strong>：线程已经准备好，并等待 CPU
资源进行执行。 - <strong>运行（Running）</strong>：线程正在执行中。 -
<strong>阻塞（Blocked）</strong>：线程在等待某个条件（如锁、I/O）时进入阻塞状态。
-
<strong>死亡（Terminated）</strong>：线程的任务完成，或因异常退出，线程进入终止状态。</p>
<hr />
<h3 id="线程同步与共享资源">线程同步与共享资源</h3>
<p>当多个线程共享同一个资源时，可能会发生<strong>竞态条件</strong>（Race
Condition），导致程序出现错误。Java
提供了多种机制来实现线程同步，以确保多个线程能够安全地访问共享资源。</p>
<h4 id="synchronized-关键字">1. <strong>synchronized
关键字</strong></h4>
<p><code>synchronized</code> 是 Java
中最基础的同步机制，它用于锁定某个对象，使得同一时间只有一个线程能够访问被锁定的代码块或方法。</p>
<ul>
<li><strong>同步方法</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 同步代码，确保同一时间只有一个线程执行此方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>同步代码块</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当线程进入 <code>synchronized</code>
方法或代码块时，会自动获取对象的锁，一旦线程完成执行或抛出异常，锁会被自动释放。</p>
<h4 id="volatile-关键字">2. <strong>volatile 关键字</strong></h4>
<p><code>volatile</code>
关键字用于标记变量，使其在多个线程间可见。它确保了变量的修改会立即被写入主内存，并且每次读取时都从主内存读取。</p>
<ul>
<li><strong>使用场景</strong>：适用于简单的共享变量（如状态标志）的场景，但不适合复杂的同步逻辑。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="lock-接口">3. <strong>Lock 接口</strong></h4>
<p><code>Lock</code> 是一种更灵活的锁机制，相比
<code>synchronized</code>，它提供了更多的控制和功能。例如，<code>Lock</code>
可以在获取不到锁时等待，也可以尝试非阻塞地获取锁。</p>
<ul>
<li><strong>ReentrantLock</strong>：常用的 <code>Lock</code>
实现类，支持可重入锁。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();   <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="线程间通信-1">线程间通信</h3>
<p>线程之间需要通过某种方式进行通信，以协调它们的执行顺序。Java
提供了多种线程间通信的机制。</p>
<h4 id="wait-notify-notifyall">1. <strong>wait() / notify() /
notifyAll()</strong></h4>
<p><code>wait()</code>、<code>notify()</code> 和
<code>notifyAll()</code> 是 Java
提供的原始线程通信方法，它们必须在同步块或同步方法中使用。</p>
<ul>
<li><code>wait()</code>：使当前线程进入等待状态，直到另一个线程调用
<code>notify()</code> 或 <code>notifyAll()</code>。</li>
<li><code>notify()</code>：唤醒等待该对象锁的某一个线程。</li>
<li><code>notifyAll()</code>：唤醒等待该对象锁的所有线程。</li>
</ul>
<p>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForCondition</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            wait();  <span class="comment">// 等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">changeCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        notify();  <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="condition-接口">2. <strong>Condition 接口</strong></h4>
<p><code>Condition</code> 是与 <code>Lock</code>
配合使用的线程通信机制，它提供了类似 <code>wait()</code> 和
<code>notify()</code> 的功能，但更为灵活。每个 <code>Lock</code>
对象可以创建多个 <code>Condition</code>
实例，实现更精细的线程通信控制。</p>
<ul>
<li>使用 <code>Condition</code>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    condition.await();  <span class="comment">// 当前线程等待</span></span><br><span class="line">    condition.signal(); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="java-并发工具类">Java 并发工具类</h3>
<p>Java 的 <code>java.util.concurrent</code>
包提供了许多用于并发编程的工具类，简化了线程的管理和调度。</p>
<h4 id="executor-框架">1. <strong>Executor 框架</strong></h4>
<p><code>Executor</code>
框架提供了一种更高级的管理线程池的方法，避免了直接操作线程。<code>ExecutorService</code>
是 <code>Executor</code>
的子接口，提供了更多的方法来管理线程池中的任务。</p>
<ul>
<li><p><strong>创建线程池</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);  <span class="comment">// 创建固定大小的线程池</span></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Task is running&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown();  <span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>常见线程池类型</strong>：</p>
<ul>
<li><code>newFixedThreadPool(int nThreads)</code>：固定大小的线程池。</li>
<li><code>newCachedThreadPool()</code>：根据需要创建新线程的线程池，但会重用先前的线程。</li>
<li><code>newSingleThreadExecutor()</code>：单线程池，确保所有任务按顺序执行。</li>
</ul></li>
</ul>
<h4 id="future-和-callable">2. <strong>Future 和 Callable</strong></h4>
<p><code>Callable</code> 是 <code>Runnable</code>
的增强版本，允许任务有返回值。<code>Future</code> 是
<code>Callable</code> 的返回值，表示一个异步计算的结果。</p>
<ul>
<li><strong>Callable</strong> 使用示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();  <span class="comment">// 阻塞等待任务完成并获取结果</span></span><br><span class="line">    System.out.println(result);  <span class="comment">// 输出 123</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="countdownlatch">3. <strong>CountDownLatch</strong></h4>
<p><code>CountDownLatch</code>
是一种同步工具，允许一个或多个线程等待其他线程完成某些操作。它使用一个计数器，线程调用
<code>countDown()</code>
递减计数器，直到计数器归零，等待的线程才会被唤醒。</p>
<ul>
<li><strong>示例</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; finished.&quot;</span>);</span><br><span class="line">        latch.countDown();  <span class="comment">// 计数器减一</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">latch.await();  <span class="comment">// 等待计数器归零</span></span><br><span class="line">System.out.println(<span class="string">&quot;All threads finished.&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="cyclicbarrier">4. <strong>CyclicBarrier</strong></h4>
<p><code>CyclicBarrier</code>
是一种允许一组线程彼此等待到达某个公共屏障点的同步工具。</p>
<ul>
<li><p><strong>使用场景</strong>：适用于多线程任务需要在某个时间点共同执行的场景。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; is waiting.&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              barrier.await();  <span class="comment">// 所有线程都等待，直到屏障被释放</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; is released.&quot;</span>);</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line"></span><br><span class="line">Java 并发编程是构建高效、多线程应用的核心技术。通过线程的创建、同步、通信和 `java.util.concurrent` 工具包，Java 提供了一个强大的并发编程框架。使用线程池、锁、并发集合、同步机制等工具，可以帮助开发者编写高效、安全的并发程序。开发者需要注意线程的生命周期、同步问题、死锁、并发性能等问题，以确保程序的稳定性和性能。</span><br><span class="line"></span><br><span class="line">## 常用的锁</span><br><span class="line"></span><br><span class="line">在并发编程中，锁是用于协调多个线程对共享资源的访问，防止线程间的竞态条件和数据不一致问题。Java 提供了多种锁的实现，每种锁适用于不同的场景，具有各自的特性和用法。下面是 Java 中常用的几种锁及其详细介绍。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### <span class="number">1.</span> **<span class="keyword">synchronized</span> 关键字**</span><br><span class="line"></span><br><span class="line">`<span class="keyword">synchronized</span>` 是 Java 中最基本的内置锁（也叫**监视器锁**），它可以修饰方法或代码块，用于确保同一时间只有一个线程能够执行该方法或代码块，保证线程安全。</span><br><span class="line"></span><br><span class="line">#### 特点：</span><br><span class="line">- **可重入**：`<span class="keyword">synchronized</span>` 是可重入锁，意味着同一个线程可以多次获得同一把锁，而不会发生死锁。</span><br><span class="line">- **内置锁**：`<span class="keyword">synchronized</span>` 是 JVM 层面提供的机制，不需要手动管理锁的获取和释放，JVM 会自动处理。</span><br><span class="line">- **效率较低**：在高并发场景下，`<span class="keyword">synchronized</span>` 的性能相对较低，尤其是在锁竞争激烈时，可能导致线程的频繁阻塞和唤醒。</span><br><span class="line"></span><br><span class="line">#### 用法：</span><br><span class="line">- 修饰实例方法：</span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 线程安全的代码</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>修饰代码块： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 线程安全的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h3 id="reentrantlock">2. <strong>ReentrantLock</strong></h3>
<p><code>ReentrantLock</code> 是 <code>Lock</code>
接口的常用实现类，它是一个<strong>可重入锁</strong>，类似于
<code>synchronized</code>，但它提供了更多的控制和功能。</p>
<h4 id="特点-3">特点：</h4>
<ul>
<li><strong>手动加锁与解锁</strong>：与 <code>synchronized</code>
不同，<code>ReentrantLock</code> 需要手动调用 <code>lock()</code>
获取锁，使用完后需要手动调用 <code>unlock()</code> 释放锁。</li>
<li><strong>可重入性</strong>：与 <code>synchronized</code>
类似，<code>ReentrantLock</code> 允许同一线程多次获取同一把锁。</li>
<li><strong>可中断性</strong>：在获取锁时，线程可以选择响应中断，这意味着线程可以被中断，从而避免永久等待锁。</li>
<li><strong>公平锁与非公平锁</strong>：<code>ReentrantLock</code>
支持公平锁和非公平锁，公平锁按照线程请求锁的顺序来分配锁，非公平锁则允许插队。</li>
</ul>
<h4 id="用法">用法：</h4>
<ul>
<li><p>非公平锁： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();  <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>公平锁： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);  <span class="comment">// 公平锁</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h3 id="reentrantreadwritelock">3.
<strong>ReentrantReadWriteLock</strong></h3>
<p><code>ReentrantReadWriteLock</code>
是一种读写锁，允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁设计的目的是提高并发读的性能，因为读操作不会互相阻塞。</p>
<h4 id="特点-4">特点：</h4>
<ul>
<li><strong>读锁和写锁分离</strong>：<code>ReentrantReadWriteLock</code>
提供了两种锁：<code>readLock()</code> 和
<code>writeLock()</code>。多个线程可以同时获取读锁，但只有一个线程可以获取写锁，并且写锁与读锁互斥。</li>
<li><strong>可重入性</strong>：读锁和写锁都是可重入的，意味着同一个线程可以多次获取读锁或写锁。</li>
<li><strong>写锁优先</strong>：默认情况下，写锁的优先级高于读锁，意味着写锁会在等待时阻止其他线程获取读锁。</li>
</ul>
<h4 id="用法-1">用法：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作</span></span><br><span class="line">readLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读操作，多个线程可同时执行</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    readLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写操作</span></span><br><span class="line">writeLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写操作，只有一个线程可以执行</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="stampedlock">4. <strong>StampedLock</strong></h3>
<p><code>StampedLock</code> 是 Java 8
引入的一种改进的读写锁。它提供了类似 <code>ReentrantReadWriteLock</code>
的读写锁功能，但在某些场景下提供了更高效的并发控制。<code>StampedLock</code>
通过使用时间戳（stamp）来管理锁状态。</p>
<h4 id="特点-5">特点：</h4>
<ul>
<li><strong>不可重入</strong>：与 <code>ReentrantReadWriteLock</code>
不同，<code>StampedLock</code>
是不可重入的，意味着线程在同一锁上不能重复加锁。</li>
<li><strong>乐观读锁</strong>：<code>StampedLock</code>
提供了一种乐观读锁机制，允许在没有加锁的情况下进行读取操作，但在执行完读取操作后需要确认锁的有效性。乐观读锁可以提高并发读的性能。</li>
<li><strong>传统读写锁</strong>：<code>StampedLock</code>
也提供传统的读锁和写锁。</li>
</ul>
<h4 id="用法-2">用法：</h4>
<ul>
<li><p><strong>乐观读锁</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行读取操作</span></span><br><span class="line"><span class="comment">// 验证锁的有效性</span></span><br><span class="line"><span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123;</span><br><span class="line">    <span class="comment">// 如果锁在读取过程中被修改，重新获取锁</span></span><br><span class="line">    stamp = stampedLock.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stampedLock.unlockRead(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>写锁</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    stampedLock.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<hr />
<h3 id="countdownlatch-1">5. <strong>CountDownLatch</strong></h3>
<p><code>CountDownLatch</code>
是一种用于线程同步的工具类，它允许一个或多个线程等待其他线程完成某些操作。<code>CountDownLatch</code>
通过一个计数器来控制线程的执行，当计数器减为零时，所有等待的线程将继续执行。</p>
<h4 id="特点-6">特点：</h4>
<ul>
<li><strong>一次性使用</strong>：<code>CountDownLatch</code>
是一次性的，计数器减为零后无法重置。</li>
<li><strong>线程等待</strong>：一个线程或多个线程可以调用
<code>await()</code> 方法等待，其他线程完成任务后调用
<code>countDown()</code> 减少计数器。</li>
</ul>
<h4 id="用法-3">用法：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        latch.countDown();  <span class="comment">// 任务完成，计数器减一</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">latch.await();  <span class="comment">// 等待所有任务完成</span></span><br><span class="line">System.out.println(<span class="string">&quot;所有任务完成&quot;</span>);</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="cyclicbarrier-1">6. <strong>CyclicBarrier</strong></h3>
<p><code>CyclicBarrier</code>
是另一种用于线程同步的工具类，允许一组线程相互等待，直到所有线程都到达某个屏障点。与
<code>CountDownLatch</code> 不同的是，<code>CyclicBarrier</code>
可以多次使用。</p>
<h4 id="特点-7">特点：</h4>
<ul>
<li><strong>可重复使用</strong>：<code>CyclicBarrier</code>
可以在所有线程到达屏障后重复使用，适用于需要多轮同步操作的场景。</li>
<li><strong>可执行回调</strong>：当所有线程到达屏障时，可以执行一个可选的回调操作。</li>
</ul>
<h4 id="用法-4">用法：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;所有线程已到达屏障，执行回调操作&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="semaphore">7. <strong>Semaphore</strong></h3>
<p><code>Semaphore</code>
是一种计数信号量，用于控制同时访问某个资源的线程数。它可以用于实现限流，限制同时访问共享资源的线程数量。</p>
<h4 id="特点-8">特点：</h4>
<ul>
<li><strong>控制访问数量</strong>：<code>Semaphore</code>
通过一个计数器来控制可用的资源数量，线程调用 <code>acquire()</code>
获取资源，调用 <code>release()</code> 释放资源。</li>
<li><strong>多线程访问控制</strong>：适用于限制多个线程同时访问共享资源的场景，如数据库连接池等。</li>
</ul>
<h4 id="用法-5">用法：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);  <span class="comment">// 允许同时有三个线程访问资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();  <span class="comment">// 获取资源</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在访问资源&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟资源访问</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();  <span class="comment">// 释放资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="readwritelock">8. <strong>ReadWriteLock</strong></h3>
<p><code>ReadWriteLock</code> 是一种特殊类型的锁，允许</p>
<p>多个读线程同时执行，但只允许一个写线程执行。适用于读多写少的场景，提高并发性能。</p>
<h4 id="特点-9">特点：</h4>
<ul>
<li><strong>读锁可共享</strong>：多个线程可以同时获取读锁。</li>
<li><strong>写锁独占</strong>：写锁只能被一个线程持有，且与读锁互斥。</li>
</ul>
<h4 id="用法-6">用法：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line">readLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行读操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    readLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line">writeLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行写操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结-28">总结</h3>
<p>Java 提供了多种并发编程中的锁和同步机制，以满足不同场景下的需求：</p>
<ul>
<li><strong><code>synchronized</code></strong>：最简单的同步机制，用于基本的互斥访问。</li>
<li><strong><code>ReentrantLock</code></strong>：提供了更多控制和功能的可重入锁。</li>
<li><strong><code>ReentrantReadWriteLock</code></strong> 和
<strong><code>StampedLock</code></strong>：适用于读多写少的场景，提供了读写分离的锁机制。</li>
<li><strong><code>CountDownLatch</code></strong> 和
<strong><code>CyclicBarrier</code></strong>：用于线程同步，前者是一次性使用，后者可重复使用。</li>
<li><strong><code>Semaphore</code></strong>：用于控制同时访问某个资源的线程数。</li>
<li><strong><code>ReadWriteLock</code></strong>：允许多个线程同时读取，但只允许一个线程写入。</li>
</ul>
<p>根据具体的应用场景，选择合适的锁机制可以有效提高并发程序的性能和可靠性。</p>
<h2 id="四种引用">四种引用</h2>
<p>在Java中，有四种引用类型：强引用、软引用、弱引用和虚引用。</p>
<ol type="1">
<li><p><strong>强引用</strong>：最常见的引用方式，Java垃圾回收器不会回收被强引用的对象。只要强引用存在，对象就会一直存在。</p></li>
<li><p><strong>软引用</strong>：主要用于缓存，当系统内存不足时，垃圾回收器会回收这些对象。适合用来实现内存敏感的缓存。</p></li>
<li><p><strong>弱引用</strong>：比软引用更弱，垃圾回收器在下一次回收时会回收所有只被弱引用的对象。这适用于描述一些非强依赖的对象。</p></li>
<li><p><strong>虚引用</strong>：也称为幽灵引用，不会影响对象的生命周期，只能用来跟踪对象被垃圾回收器回收的状态。通常和
<code>ReferenceQueue</code> 一起使用。 ## 线程间通信</p></li>
</ol>
<p>在 Java
中，线程间通信是一项关键技术，用于在多线程环境中协同处理数据和任务。Java
提供了多种线程间通信的方式，常见的方式如下：</p>
<h3 id="使用-waitnotify-和-notifyall">1. <strong>使用
<code>wait()</code>、<code>notify()</code> 和
<code>notifyAll()</code></strong></h3>
<p>这是 Java
中经典的线程间通信方式，基于对象的监视器锁（Monitor）。<code>wait()</code>、<code>notify()</code>
和 <code>notifyAll()</code> 是 <code>Object</code>
类中的方法，用于在线程间进行协调与通信。</p>
<ul>
<li><p><strong><code>wait()</code></strong>：当前线程进入等待状态，并释放持有的对象锁，直到另一个线程调用
<code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒它。</p></li>
<li><p><strong><code>notify()</code></strong>：唤醒在该对象监视器上等待的某一个线程。</p></li>
<li><p><strong><code>notifyAll()</code></strong>：唤醒在该对象监视器上等待的所有线程。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForResource</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!available) &#123;</span><br><span class="line">            wait();  <span class="comment">// 线程等待，直到被唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">        available = <span class="literal">false</span>;  <span class="comment">// 资源已被使用，重新设置为不可用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">releaseResource</span><span class="params">()</span> &#123;</span><br><span class="line">        available = <span class="literal">true</span>;</span><br><span class="line">        notify();  <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(SharedResource resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resource.waitForResource();  <span class="comment">// 等待资源</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Thread A acquired resource.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadB</span><span class="params">(SharedResource resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        resource.releaseResource();  <span class="comment">// 释放资源</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread B released resource.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，<code>ThreadA</code> 将等待资源的释放，而
<code>ThreadB</code> 负责释放资源。</p>
<h3 id="使用-synchronized-关键字">2. <strong>使用
<code>synchronized</code> 关键字</strong></h3>
<p><code>sychronized</code> 是 Java
中用于线程同步的关键字，它可以保证同一时间只有一个线程能访问被
<code>synchronized</code>
修饰的代码块或方法，从而避免线程间的竞争问题。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(Counter counter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            counter.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>increment()</code> 和 <code>getCount()</code>
方法是同步的，确保同一时刻只有一个线程能修改 <code>count</code>
的值，从而避免数据竞争。</p>
<h3 id="使用-lock-和-condition从-java.util.concurrent-包">3.
<strong>使用 <code>Lock</code> 和 <code>Condition</code>（从
<code>java.util.concurrent</code> 包）</strong></h3>
<p><code>Lock</code> 和 <code>Condition</code> 提供了比
<code>synchronized</code> 更灵活的线程同步机制。<code>Lock</code>
类允许手动获取和释放锁，而 <code>Condition</code> 类则类似于
<code>wait()</code> 和 <code>notify()</code>，但具有更大的灵活性。</p>
<ul>
<li><p><strong>Lock</strong>：提供显式的锁定和解锁操作，支持更复杂的同步控制。</p></li>
<li><p><strong>Condition</strong>：可以让线程等待某个条件满足，再继续执行，类似于
<code>Object.wait()</code> 和 <code>Object.notify()</code>。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitForResource</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!available) &#123;</span><br><span class="line">                condition.await();  <span class="comment">// 等待条件满足</span></span><br><span class="line">            &#125;</span><br><span class="line">            available = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseResource</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            available = <span class="literal">true</span>;</span><br><span class="line">            condition.signal();  <span class="comment">// 唤醒一个等待线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-blockingqueue">4. <strong>使用
<code>BlockingQueue</code></strong></h3>
<p><code>BlockingQueue</code> 是 Java
的并发包中的一种线程安全的队列，它提供了用于生产者-消费者模式的通信机制。多个线程可以安全地将元素放入或取出队列，<code>BlockingQueue</code>
会自动处理线程之间的同步问题。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                queue.put(i);  <span class="comment">// 放入队列</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">item</span> <span class="operator">=</span> queue.take();  <span class="comment">// 从队列中取出</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumed: &quot;</span> + item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(queue).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-semaphore">5. <strong>使用
<code>Semaphore</code></strong></h3>
<p><code>Semaphore</code>
是一种计数信号量，用于控制同时访问特定资源的线程数量。它可以用于限制某些资源的访问，例如限制一个文件同时只能被最多
3 个线程访问。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">access</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        semaphore.acquire();  <span class="comment">// 获取一个许可</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is accessing resource.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();  <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(SharedResource resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resource.access();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-exchanger">6. <strong>使用
<code>Exchanger</code></strong></h3>
<p><code>Exchanger</code> 用于两个线程之间交换数据。一个线程调用
<code>exchange()</code>
方法将数据传给另一个线程，同时接收对方的数据。</p>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExchangerExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> exchanger.exchange(<span class="string">&quot;Data from Thread 1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 received: &quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> exchanger.exchange(<span class="string">&quot;Data from Thread 2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 received: &quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-29"><strong>总结</strong></h3>
<p>Java 提供了多种线程间通信的机制，每种方式适合不同的场景： -
<code>wait()</code> / <code>notify()</code>
适合简单的生产者-消费者模型。 - <code>Lock</code> 和
<code>Condition</code> 提供了更加灵活的同步控制。 -
<code>BlockingQueue</code> 和 <code>Semaphore</code>
适用于并发资源管理。 - <code>Exchanger</code>
适合两个线程之间的数据交换。</p>
<p>选择适合的线程通信方式需要根据实际的应用场景和需求。</p>
<h2 id="jvm-中-java-对象的创建过程">JVM 中 Java 对象的创建过程</h2>
<p>在 JVM 中，Java
对象的创建是一个复杂且精细的过程，涉及多个步骤。以下是 Java
对象创建的主要流程：</p>
<h3 id="类加载检查">1. <strong>类加载检查</strong></h3>
<ul>
<li>在创建一个对象之前，JVM
会首先检查该对象所属的类是否已经被加载、解析和初始化。如果类还没有被加载，JVM
会触发类加载过程（包括加载、链接和初始化）。</li>
<li>类加载是通过类加载器（ClassLoader）完成的。这个过程确保了所有必要的类信息都已准备就绪，包含字段和方法等定义。</li>
</ul>
<h3 id="内存分配">2. <strong>内存分配</strong></h3>
<ul>
<li>在类加载完成后，JVM
会为新对象分配内存。对象的内存分配通常是在堆中进行的。具体分配内存的位置取决于堆的结构和垃圾收集器的实现。</li>
<li>JVM
会根据对象的大小，从堆中划分一块空间用于存储对象的实例变量、元数据等信息。一般来说，对象的内存大小由类中的字段（包括继承的字段）和对象头（Object
Header）共同决定。</li>
<li>JVM 中的内存分配方式有两种：
<ul>
<li><strong>指针碰撞</strong>：如果堆中的内存是规整的，没有被垃圾回收器整理过，那么
JVM 可以直接通过移动指针来分配内存。</li>
<li><strong>空闲列表</strong>：如果堆中内存不规整，有分散的空闲区域，JVM
会通过一个空闲列表来找到一块合适的内存区域分配给新对象。</li>
</ul></li>
</ul>
<h3 id="内存区域初始化为零值">3.
<strong>内存区域初始化为零值</strong></h3>
<ul>
<li>为了保证对象的安全性，JVM
会将新分配的内存空间初始化为零值。这意味着对象实例变量（包括基本类型和引用类型）在分配后默认为零或
<code>null</code>
值。这一过程确保了对象的默认值在构造方法之前被初始化。</li>
</ul>
<h3 id="设置对象头">4. <strong>设置对象头</strong></h3>
<ul>
<li>JVM 在对象内存中分配了一个对象头（Object
Header），用于存储对象的元数据。</li>
<li>对象头通常包括以下信息：
<ul>
<li><strong>Mark Word</strong>：包含对象的哈希码、GC
信息、锁状态等。</li>
<li><strong>类指针（Class
Pointer）</strong>：指向对象所属的类的元数据，表示该对象是哪个类的实例。</li>
</ul></li>
<li>如果是数组对象，JVM 还会在对象头中存储数组的长度信息。</li>
</ul>
<h3 id="执行构造方法-方法">5. <strong>执行构造方法（<init>
方法）</strong></h3>
<ul>
<li>JVM 完成对象的内存分配和初始化后，会调用对象的构造方法（即
<code>new</code> 语句后自动调用的 <code>&lt;init&gt;</code>
方法）。</li>
<li>构造方法用于进行对象的进一步初始化，可能包括显式赋值和其他逻辑操作。</li>
<li>构造方法调用结束后，JVM 完成了整个对象创建过程。</li>
</ul>
<h3 id="返回对象的引用">6. <strong>返回对象的引用</strong></h3>
<ul>
<li>构造方法执行完成后，对象的创建过程就结束了。JVM
返回对象的引用地址（或指针），并将其存储到变量中，从而可以在程序中访问和使用该对象。</li>
</ul>
<h3 id="补充锁与同步"><strong>补充：锁与同步</strong></h3>
<ul>
<li>对象创建完成后，JVM 会确保对象头中的锁状态处于“无锁”状态。</li>
<li>当对象用于同步操作（例如 <code>synchronized</code>
关键字）时，对象头中的 Mark Word 将被更新，以存储锁的信息。</li>
</ul>
<h3 id="总结-30"><strong>总结</strong></h3>
<p>Java
对象的创建过程涉及从类加载到内存分配，再到初始化和构造的多个步骤。这些步骤确保每个对象都是从其所属的类定义中产生的，并且初始值是安全的。这种流程体现了
JVM 对对象管理的精确控制和优化。</p>
<h2 id="动态代理">动态代理</h2>
<p>动态代理是一种在程序运行时动态创建代理对象的技术，主要用于拦截方法调用，以在不修改原始代码的情况下对方法调用进行增强或修改。Java
提供了两种主要的动态代理实现方式：<strong>JDK 动态代理</strong>和
<strong>CGLIB 动态代理</strong>。</p>
<h3 id="jdk-动态代理">1. <strong>JDK 动态代理</strong></h3>
<p>JDK 动态代理是 Java
内置的一种动态代理实现方式。它基于接口来生成代理对象，因此只适用于代理实现了接口的类。核心类是
<code>java.lang.reflect.Proxy</code> 和 <code>InvocationHandler</code>
接口。</p>
<h4 id="实现步骤">实现步骤</h4>
<ul>
<li><strong>定义接口</strong>：目标对象需要实现一个或多个接口，以便 JDK
动态代理能够基于接口生成代理对象。</li>
<li><strong>实现 InvocationHandler</strong>：创建一个类实现
<code>InvocationHandler</code> 接口，重写 <code>invoke</code>
方法。这个方法会在代理对象的方法被调用时触发，在 <code>invoke</code>
方法中可以添加增强逻辑。</li>
<li><strong>生成代理对象</strong>：使用
<code>Proxy.newProxyInstance</code>
方法生成代理对象。此方法需要提供类加载器、接口列表和
<code>InvocationHandler</code> 实例。</li>
</ul>
<h4 id="示例代码-2">示例代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Performing task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Service target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceInvocationHandler</span><span class="params">(Service target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理</span></span><br><span class="line"><span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl</span>();</span><br><span class="line"><span class="type">Service</span> <span class="variable">proxyService</span> <span class="operator">=</span> (Service) Proxy.newProxyInstance(</span><br><span class="line">        service.getClass().getClassLoader(),</span><br><span class="line">        service.getClass().getInterfaces(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServiceInvocationHandler</span>(service)</span><br><span class="line">);</span><br><span class="line">proxyService.performTask();</span><br></pre></td></tr></table></figure>
<h4 id="特点-10">特点</h4>
<ul>
<li><strong>基于接口</strong>：JDK
动态代理要求目标对象必须实现接口。</li>
<li><strong>性能较高</strong>：由于代理是基于接口实现的，通常运行速度较快。</li>
<li><strong>代理方法范围</strong>：只能代理实现了接口的方法，无法直接代理类中的具体方法。</li>
</ul>
<h3 id="cglib-动态代理">2. <strong>CGLIB 动态代理</strong></h3>
<p>CGLIB（Code Generation
Library）是一个第三方库，通过生成字节码的方式实现代理，它基于继承生成代理类，因此可以代理不实现接口的类。CGLIB
是通过继承目标类并重写其方法来实现代理的，这种方式使用了 ASM
字节码生成框架。</p>
<h4 id="实现步骤-1">实现步骤</h4>
<ul>
<li><strong>引入 CGLIB 库</strong>：CGLIB 不是 JDK
自带的库，需要手动添加依赖。</li>
<li><strong>实现 MethodInterceptor</strong>：创建一个实现
<code>MethodInterceptor</code> 接口的类，重写 <code>intercept</code>
方法。这个方法会在代理对象的方法被调用时执行，可以在此方法中添加增强逻辑。</li>
<li><strong>生成代理对象</strong>：使用 <code>Enhancer</code>
类生成代理对象。<code>Enhancer</code> 可以创建任何类的代理，除非该类是
<code>final</code> 类（因为 <code>final</code> 类不能被继承）。</li>
</ul>
<h4 id="示例代码-3">示例代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Performing task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 CGLIB 代理</span></span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(Service.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">ServiceMethodInterceptor</span>());</span><br><span class="line"><span class="type">Service</span> <span class="variable">proxyService</span> <span class="operator">=</span> (Service) enhancer.create();</span><br><span class="line">proxyService.performTask();</span><br></pre></td></tr></table></figure>
<h4 id="特点-11">特点</h4>
<ul>
<li><strong>基于继承</strong>：CGLIB
是通过继承目标类来实现代理的，因此可以代理不实现接口的类。</li>
<li><strong>性能相对较低</strong>：CGLIB 代理性能略低于 JDK
动态代理，但适用于无接口的情况。</li>
<li><strong>限制性</strong>：不能代理 <code>final</code> 类，因为 CGLIB
需要通过继承来实现动态代理。</li>
</ul>
<h3 id="动态代理的应用场景">3. <strong>动态代理的应用场景</strong></h3>
<p>动态代理在许多框架中广泛应用，尤其是
AOP（面向切面编程）和拦截器模式。常见的应用场景包括：</p>
<ul>
<li><strong>权限检查</strong>：在方法调用之前检查调用方是否具有相应权限。</li>
<li><strong>日志记录</strong>：在方法调用之前或之后添加日志记录逻辑。</li>
<li><strong>事务管理</strong>：在方法调用开始和结束时分别开启和关闭事务。</li>
<li><strong>远程调用代理</strong>：在客户端调用服务端的远程方法时，通过代理封装调用细节。</li>
<li><strong>缓存处理</strong>：在方法执行前后进行缓存查询或缓存更新，以提高效率。</li>
</ul>
<h3 id="jdk-动态代理和-cglib-代理的选择">4. <strong>JDK 动态代理和 CGLIB
代理的选择</strong></h3>
<ul>
<li><strong>JDK 动态代理</strong>：适用于代理实现了接口的对象，通常比
CGLIB 代理速度更快，且不需要额外依赖。</li>
<li><strong>CGLIB
动态代理</strong>：适用于没有接口的类代理，但代理创建速度相对较慢，且生成的代理对象较重。CGLIB
是通过字节码生成实现的，因此比 JDK 动态代理更灵活。</li>
</ul>
<p>在 Spring AOP 中，默认情况下会优先使用 JDK
动态代理，如果目标类没有实现接口，则会退而使用 CGLIB 动态代理。</p>
<h3 id="总结-31">总结</h3>
<p>动态代理为程序提供了强大的灵活性和可扩展性，特别适合需要对方法调用进行拦截和增强的场景。通过动态代理，开发者可以在运行时创建代理对象，实现如权限校验、日志、事务等切面功能，极大地提高了代码的解耦性和可维护性。</p>
<h1 id="c">C++</h1>
<h2 id="智能指针的类型">智能指针的类型</h2>
<p>C++
的智能指针是为了解决传统指针的内存管理问题而引入的，它们能够自动管理动态分配的内存，避免内存泄漏和悬挂指针问题。C++11
标准引入了三种主要的智能指针类型：<code>std::unique_ptr</code>、<code>std::shared_ptr</code>
和 <code>std::weak_ptr</code>，它们分别适用于不同的内存管理场景。</p>
<h3 id="stdunique_ptr">1.
<strong><code>std::unique_ptr</code></strong></h3>
<h4 id="概述-13">概述：</h4>
<p><code>std::unique_ptr</code>
是一种独占所有权的智能指针，即一个对象只能被一个 <code>unique_ptr</code>
拥有。当 <code>unique_ptr</code>
被销毁时，它所管理的对象也会自动销毁。<code>unique_ptr</code>
不允许复制，但可以通过移动语义将所有权转移给另一个
<code>unique_ptr</code>。</p>
<h4 id="主要特点-4">主要特点：</h4>
<ul>
<li><strong>独占所有权</strong>：一个对象只能被一个
<code>unique_ptr</code> 拥有，不能共享。</li>
<li><strong>移动语义支持</strong>：可以通过 <code>std::move</code> 将
<code>unique_ptr</code> 转移到另一个 <code>unique_ptr</code>。</li>
<li><strong>自动销毁</strong>：当 <code>unique_ptr</code>
退出作用域或被销毁时，自动调用 <code>delete</code> 来释放内存。</li>
</ul>
<h4 id="示例-10">示例：</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有权转移给 ptr2</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="keyword">if</span> (!ptr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 is null after move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; *ptr2 &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 ptr2 离开作用域时，内存会被自动释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景-9">使用场景：</h4>
<ul>
<li>独占资源的场景，比如文件句柄、网络连接、动态分配的内存等。</li>
<li>当不希望多个指针共享同一个对象时，使用 <code>unique_ptr</code>
来确保对象的唯一所有权。</li>
</ul>
<h3 id="stdshared_ptr">2.
<strong><code>std::shared_ptr</code></strong></h3>
<h4 id="概述-14">概述：</h4>
<p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，多个
<code>shared_ptr</code>
可以同时指向同一个对象，并通过引用计数来管理对象的生命周期。只有当最后一个
<code>shared_ptr</code> 被销毁时，所管理的对象才会被释放。</p>
<h4 id="主要特点-5">主要特点：</h4>
<ul>
<li><strong>共享所有权</strong>：多个 <code>shared_ptr</code>
可以共享同一个对象，每个 <code>shared_ptr</code> 都增加引用计数。</li>
<li><strong>引用计数</strong>：每次复制
<code>shared_ptr</code>，引用计数会增加，销毁时引用计数会减少，当引用计数降为
0 时，对象会被释放。</li>
<li><strong>线程安全</strong>：引用计数的增加和减少是线程安全的，但对象本身的操作并不是线程安全的。</li>
</ul>
<h4 id="示例-11">示例：</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use count: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 共享 ptr1 的所有权</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 use count: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 use count: &quot;</span> &lt;&lt; ptr<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">    &#125; <span class="comment">// ptr2 离开作用域，引用计数减少</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use count: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br><span class="line">    <span class="comment">// 当 ptr1 离开作用域时，内存会被释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景-10">使用场景：</h4>
<ul>
<li>当需要多个对象共享同一个资源时，比如在图结构、树结构中，多个节点可以共享相同的子节点。</li>
<li>适合动态分配的资源需要在多个对象之间共享，且不确定资源何时释放的场景。</li>
</ul>
<h3 id="stdweak_ptr">3. <strong><code>std::weak_ptr</code></strong></h3>
<h4 id="概述-15">概述：</h4>
<p><code>std::weak_ptr</code> 是一种不参与引用计数的智能指针，用于解决
<code>std::shared_ptr</code> 循环引用的问题。<code>weak_ptr</code>
不会影响引用计数，它提供了一种弱引用的机制，允许访问对象但不会控制对象的生命周期。<code>weak_ptr</code>
必须通过 <code>lock()</code> 方法提升为 <code>shared_ptr</code>
才能访问对象。</p>
<h4 id="主要特点-6">主要特点：</h4>
<ul>
<li><strong>不增加引用计数</strong>：<code>weak_ptr</code> 只是对
<code>shared_ptr</code> 的弱引用，不会增加对象的引用计数。</li>
<li><strong>解决循环引用问题</strong>：在 <code>shared_ptr</code>
循环引用的场景中，使用 <code>weak_ptr</code> 可以打破循环引用。</li>
<li><strong>检查对象是否仍然存在</strong>：通过 <code>expired()</code>
方法可以判断对象是否已经被释放。</li>
</ul>
<h4 id="示例-12">示例：</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 weak_ptr 指向 shared_ptr</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wptr = sptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 weak_ptr 是否仍然指向有效对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> tmp = wptr.<span class="built_in">lock</span>()) &#123;  <span class="comment">// lock() 提升为 shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shared object is still alive, value: &quot;</span> &lt;&lt; *tmp &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shared object has been destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sptr.<span class="built_in">reset</span>(); <span class="comment">// 手动销毁 shared_ptr 管理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查 weak_ptr 是否指向有效对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> tmp = wptr.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shared object is still alive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shared object has been destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景-11">使用场景：</h4>
<ul>
<li>解决 <code>shared_ptr</code>
的循环引用问题，例如双向链表或父子对象之间的引用。</li>
<li>当需要观察一个对象的生命周期但不希望参与其管理时，可以使用
<code>weak_ptr</code>。</li>
</ul>
<h3 id="stdauto_ptr已废弃">4.
<strong><code>std::auto_ptr</code>（已废弃）</strong></h3>
<p><code>std::auto_ptr</code> 是 C++98
引入的一种早期智能指针类型，但由于它的所有权语义不清晰（复制时所有权会转移）和不支持
C++11 的现代功能（如移动语义），已在 C++11 中被废弃，并由
<code>unique_ptr</code> 取而代之。现代 C++ 应避免使用
<code>auto_ptr</code>，转而使用 <code>unique_ptr</code>。</p>
<h3 id="各类智能指针对比">各类智能指针对比</h3>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 8%" />
<col style="width: 21%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>智能指针类型</th>
<th>所有权</th>
<th>引用计数</th>
<th>线程安全</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>unique_ptr</code></td>
<td>独占所有权</td>
<td>不支持</td>
<td>不支持</td>
<td>适合独占的资源管理，不需要多个指针共享对象</td>
</tr>
<tr class="even">
<td><code>shared_ptr</code></td>
<td>共享所有权</td>
<td>支持</td>
<td>增减计数是线程安全的</td>
<td>适合需要多个指针共享同一个对象的场景</td>
</tr>
<tr class="odd">
<td><code>weak_ptr</code></td>
<td>无所有权</td>
<td>不支持</td>
<td>不支持</td>
<td>解决 <code>shared_ptr</code> 的循环引用问题，弱引用对象</td>
</tr>
</tbody>
</table>
<h3 id="总结-32">总结</h3>
<p>C++
提供了多种智能指针来管理动态内存，它们各有不同的应用场景和使用特点：</p>
<ul>
<li><strong><code>std::unique_ptr</code></strong>：独占所有权，适用于不需要共享的资源管理。</li>
<li><strong><code>std::shared_ptr</code></strong>：共享所有权，适用于需要多个对象共享同一资源的场景。</li>
<li><strong><code>std::weak_ptr</code></strong>：弱引用，用于解决循环引用问题或需要观察对象但不参与管理的场景。</li>
</ul>
<p>通过智能指针的合理使用，可以有效地避免手动内存管理中的常见错误，如内存泄漏、悬挂指针等问题。</p>
<h1 id="kotlin">Kotlin</h1>
<h2
id="协程为什么在io操作上优于线程池">协程为什么在IO操作上优于线程池</h2>
<p>协程优于线程的关键在于它的调度算法使得它在IO操作下对于线程资源的利用更充分更饱和，没有阻塞，同时切换成本更低（因为挂起恢复时可能在同一个线程上）。</p>
<p>是的，你的总结非常到位！协程相较于线程的关键优势确实可以归纳为<strong>调度算法的优化</strong>、<strong>线程资源的高效利用</strong>以及<strong>切换成本的降低</strong>，尤其在
I/O
操作场景下表现尤为突出。让我进一步梳理和确认你的理解，同时补充一些细节，确保这个概念更清晰。</p>
<hr />
<h3 id="调度算法的优化">1. 调度算法的优化</h3>
<h4 id="协程的调度机制">协程的调度机制</h4>
<ul>
<li><strong>用户态调度</strong>: 协程的调度由
<code>kotlinx.coroutines</code>
库控制，而不是依赖操作系统的线程调度器。这种用户态调度让协程能够根据任务状态（运行、挂起、恢复）灵活分配线程。</li>
<li><strong>挂起与恢复</strong>: 协程遇到 I/O 操作时（如
<code>delay</code>
或异步网络请求），会挂起并释放当前线程，调度器立即将线程分配给其他就绪的协程。这种协作式调度避免了线程空闲等待。</li>
</ul>
<h4 id="对比线程池">对比线程池</h4>
<ul>
<li><strong>线程池的调度</strong>: 线程池（如 Java 的
<code>ExecutorService</code>）依赖操作系统和 JVM
的线程管理。任务分配到线程后，如果遇到 I/O
阻塞，线程会停下来等待，无法动态调整。</li>
<li><strong>资源利用不足</strong>:
阻塞的线程无法处理其他任务，导致线程池中的线程利用率低下，尤其在 I/O
密集型场景（如 100 个网络请求）。</li>
</ul>
<h4 id="为什么更饱和">为什么更饱和？</h4>
<ul>
<li>协程通过挂起机制，确保线程在等待 I/O
时不会闲置，而是立即执行其他协程。例如，在 <code>Dispatchers.IO</code>
上，64 个线程可以服务于数百甚至数千个协程，线程利用率接近 100%。</li>
<li>线程池则受限于线程数，阻塞时资源浪费严重。</li>
</ul>
<hr />
<h3 id="线程资源的充分利用">2. 线程资源的充分利用</h3>
<h4 id="协程的高效利用">协程的高效利用</h4>
<ul>
<li><strong>线程复用</strong>:
协程在挂起时释放线程，调度器将线程分配给其他协程。同一线程可以顺序执行多个协程的任务，最大化线程的“忙碌时间”。</li>
<li><strong>高并发支持</strong>: 因为协程是轻量级的（内存占用仅几
KB），可以在有限线程上运行大量协程（比如 100、1000
个），而无需创建等量的线程。</li>
</ul>
<h4 id="io-操作下的体现">I/O 操作下的体现</h4>
<ul>
<li><strong>无阻塞</strong>: 在 I/O 场景中，协程通过挂起函数（如
Retrofit 的 <code>suspend</code> 请求）与异步 I/O
框架配合，发起请求后挂起，线程不等待响应，而是去处理其他任务。</li>
<li><strong>饱和度</strong>: 假设 100 个协程发起网络请求，每个请求耗时 1
秒，线程池的 64
个线程可以并发处理所有请求，挂起期间线程持续工作，整体效率远高于线程阻塞。</li>
</ul>
<h4 id="示例对比">示例对比</h4>
<ul>
<li><strong>线程池</strong>: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    executor.submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 阻塞 I/O</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4 个线程处理 100 个任务，每线程阻塞 1 秒，总耗时约 25
秒，线程利用率低。</li>
</ul></li>
<li><strong>协程</strong>: <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">    repeat(<span class="number">100</span>) &#123;</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>) <span class="comment">// 挂起 I/O</span></span><br><span class="line">            println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>64 个线程处理 100 个协程，挂起时线程复用，总耗时约 1-2
秒，线程利用率高。</li>
</ul></li>
</ul>
<hr />
<h3 id="切换成本更低">3. 切换成本更低</h3>
<h4 id="协程的切换机制">协程的切换机制</h4>
<ul>
<li><strong>用户态切换</strong>: 协程的挂起和恢复由协程库管理，保存的是
Continuation（协程状态），开销仅为函数调用级别（纳秒级）。</li>
<li><strong>同一线程内</strong>:
如果挂起和恢复发生在同一线程（常见于单线程调度器如
<code>Dispatchers.Main</code>
或线程池中的复用），完全没有操作系统级别的上下文切换。</li>
<li><strong>跨线程切换</strong>: 即使恢复时切换线程（比如从
<code>Dispatchers.IO</code> 到
<code>Dispatchers.Main</code>），也只是线程池内的调度，频率和开销远低于线程池中大量线程的竞争。</li>
</ul>
<h4 id="对比线程切换">对比线程切换</h4>
<ul>
<li><strong>操作系统调度</strong>:
线程切换涉及保存寄存器、栈指针等，开销在微秒级，且受系统负载影响。</li>
<li><strong>阻塞浪费</strong>:
线程池中的线程如果阻塞，操作系统可能频繁切换到其他线程，增加上下文切换成本。</li>
</ul>
<h4 id="io-操作下的优势">I/O 操作下的优势</h4>
<ul>
<li>在 I/O
场景中，协程挂起时线程不阻塞，恢复时可能仍在原线程（取决于调度器和任务状态），避免了不必要的切换。</li>
<li>即使跨线程，协程数量远超线程，调度器优化了分配，切换次数远少于线程池。</li>
</ul>
<hr />
<h3 id="关键在于-io-操作的特性">4. 关键在于 I/O 操作的特性</h3>
<h4 id="io-操作的等待特性">I/O 操作的等待特性</h4>
<ul>
<li>I/O
操作（如网络请求、数据库查询）大部分时间在等待外部资源（如服务器响应、磁盘读取），实际计算时间很少。</li>
<li>线程池中，阻塞等待浪费线程资源；协程中，挂起释放线程，等待期间线程处理其他任务。</li>
</ul>
<h4 id="协程的适配性">协程的适配性</h4>
<ul>
<li><strong>异步 I/O 集成</strong>:
协程与现代异步框架（Retrofit、OkHttp）配合，I/O
操作天然非阻塞，挂起机制完美契合。</li>
<li><strong>无阻塞</strong>:
挂起函数将等待时间“隐藏”，线程始终处于活跃状态，资源利用更饱和。</li>
</ul>
<hr />
<h3 id="你的总结的准确性">5. 你的总结的准确性</h3>
<p>你提到： &gt; 协程优于线程的关键在于它的调度算法使得它在 I/O
操作下对于线程资源的利用更充分更饱和，没有阻塞，同时切换成本更低（因为挂起恢复时可能在同一个线程上）。</p>
<ul>
<li><strong>完全正确</strong>，并可以进一步概括为：
<ol type="1">
<li><strong>调度算法</strong>: 用户态调度 +
挂起机制，优化了线程分配。</li>
<li><strong>资源利用饱和</strong>:
挂起释放线程，复用率高，无阻塞浪费。</li>
<li><strong>切换成本低</strong>:
用户态切换（纳秒级）远低于线程切换（微秒级），同一线程内无切换成本。</li>
</ol></li>
</ul>
<h4 id="补充细节">补充细节</h4>
<ul>
<li><strong>“可能在同一个线程上”</strong>:
是的，同一线程内的挂起/恢复是常见情况，尤其在单线程调度器（如
<code>Dispatchers.Main</code>）或线程池复用时。但在
<code>Dispatchers.IO</code>
上，恢复可能发生在不同线程，不过调度器优化确保成本最低。</li>
<li><strong>I/O 的前提</strong>: 协程的优势在 I/O
密集型任务中更明显，因为挂起机制与等待特性契合。CPU
密集型任务则可能更依赖线程并行。</li>
</ul>
<hr />
<h3 id="直观示例android-中的-io">6. 直观示例：Android 中的 I/O</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    repeat(<span class="number">100</span>) &#123;</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = apiService.getData() <span class="comment">// 异步网络请求</span></span><br><span class="line">            withContext(Dispatchers.Main) &#123;</span><br><span class="line">                textView.text = <span class="string">&quot;Task <span class="variable">$it</span>: <span class="variable">$data</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>调度</strong>: 100 个协程在 <code>Dispatchers.IO</code> 的
64 个线程上运行。</li>
<li><strong>协作</strong>:
每个协程发起请求后挂起，线程复用，等待响应时处理其他协程。</li>
<li><strong>成本</strong>:
挂起/恢复成本低，线程利用饱和，总耗时接近单个请求时间。</li>
</ul>
<hr />
<h3 id="结论-1">7. 结论</h3>
<p>协程优于线程的关键确实在于： - <strong>调度算法</strong>:
用户态控制，挂起释放线程，优化分配。 - <strong>线程利用更饱和</strong>:
无阻塞，复用率高，适合 I/O 等待。 - <strong>切换成本低</strong>:
同一线程内无切换，跨线程时调度优化。</p>
<p>在 I/O
操作下，这些特性让协程能以更少的线程高效处理更多任务，避免了线程池的阻塞浪费和频繁切换。这正是协程在
Android
中处理网络请求、数据库操作等场景的核心优势！如果还有细节想深挖（比如调度器源码），随时告诉我！</p>
<h1 id="音视频">音视频</h1>
<h2 id="视频播放器的实现原理">视频播放器的实现原理</h2>
<p>视频播放器的基本实现原理包括了音视频文件的解码、同步播放、显示和用户交互等过程。一个完整的视频播放器通常由多个模块协作完成，从读取媒体数据到音视频的同步输出。以下是视频播放器的基本实现原理和关键模块：</p>
<h3 id="媒体文件的读取和解封装">1. 媒体文件的读取和解封装</h3>
<h4 id="容器格式和封装格式">容器格式和封装格式：</h4>
<p>视频文件通常包含视频流、音频流和其他数据，如字幕等，这些数据被封装在容器格式中（如
MP4、AVI、MKV、FLV
等）。播放器的第一步就是将这些封装格式打开，提取出音频、视频和其他流。</p>
<ul>
<li><strong>解封装
(Demuxing)</strong>：解封装是指将多媒体容器文件中的不同流（视频流、音频流等）分离出来。这个过程依赖于容器的解析器（Demuxer）。常见的库有
FFmpeg，它可以处理多种封装格式。</li>
<li><strong>流的分离</strong>：解封装后，视频和音频流会被分别提取，用于后续的解码操作。</li>
</ul>
<h3 id="音视频的解码">2. 音视频的解码</h3>
<h4 id="编码格式">编码格式：</h4>
<p>音频和视频流通常是压缩的，以节省存储空间和带宽。视频通常使用
H.264、H.265（HEVC）等编码格式，音频则可能使用 AAC、MP3
等。播放器需要对这些压缩的音视频流进行解码。</p>
<ul>
<li><strong>视频解码器</strong>：解码器（Codec）将压缩的视频流解码为原始的帧数据（如
YUV 格式的图像帧）。</li>
<li><strong>音频解码器</strong>：解码音频流，将压缩的音频数据解码为可播放的音频采样数据（如
PCM 格式）。</li>
</ul>
<p>解码的复杂性取决于视频和音频的编码格式，现代播放器通常使用第三方库（如
FFmpeg）来支持多种解码方式。解码过程的性能需求较高，解码速度必须足够快才能保证实时播放。</p>
<h3 id="音视频同步">3. 音视频同步</h3>
<h4 id="时间戳-ptsdts">时间戳 (PTS/DTS)：</h4>
<p>为了确保音频和视频同步播放，每个音频帧和视频帧都带有时间戳。播放器根据这些时间戳进行音视频同步。
- <strong>PTS (Presentation Time
Stamp)</strong>：表示该帧需要在什么时候进行播放。 - <strong>DTS
(Decoding Time
Stamp)</strong>：表示该帧需要在什么时候进行解码。对于一些编解码格式，DTS
和 PTS 可能不一样。</p>
<h4 id="音视频同步算法">音视频同步算法：</h4>
<p>通常，播放器会以音频播放为基准，通过音频输出的时间来控制视频帧的显示。如果发现音频和视频不同步，播放器会调整视频帧的播放时间，或丢弃/重复某些视频帧，以确保播放的流畅性和同步性。</p>
<h3 id="渲染和播放">4. 渲染和播放</h3>
<h4 id="视频渲染">视频渲染：</h4>
<ul>
<li><strong>视频帧的显示</strong>：视频帧数据通常是 YUV 格式，需要转换为
RGB
格式，然后交由显示设备（如屏幕）渲染。转换和渲染过程依赖于图形处理单元
(GPU)，现代视频播放器通常会使用硬件加速技术（如 OpenGL、DirectX 或
Vulkan）来提高渲染效率。</li>
<li><strong>显示刷新率匹配</strong>：为了确保播放平滑，播放器需要将视频的帧率与显示器的刷新率进行匹配。例如，如果视频是
24fps，而显示器是 60Hz，播放器需要适当插入或重复帧，保证播放平滑。</li>
</ul>
<h4 id="音频播放">音频播放：</h4>
<ul>
<li><strong>音频输出</strong>：解码后的音频数据（通常是 PCM
格式）需要送到音频设备进行播放。常用的音频输出接口有
OpenAL、ALSA、DirectSound 等。</li>
<li><strong>音频缓冲</strong>：音频播放通常需要使用缓冲区来存储待播放的音频数据。播放器会将解码好的音频数据填充到缓冲区，音频硬件则从缓冲区中取出数据进行播放。音频缓冲的大小需要合适，如果过大，会导致音画不同步，过小则可能导致音频播放卡顿。</li>
</ul>
<h3 id="控制逻辑和用户交互">5. 控制逻辑和用户交互</h3>
<p>播放器还需要处理用户输入的各种控制指令，例如： -
<strong>播放</strong>、<strong>暂停</strong>、<strong>停止</strong>：播放器需要在解码和渲染时对这些命令做出响应，控制音视频的解码和输出过程。
-
<strong>快进</strong>、<strong>快退</strong>：播放器需要快速跳过未播放的部分，重新读取和解码目标位置的音视频帧。
-
<strong>音量控制</strong>、<strong>静音</strong>：控制音频播放时的音量。
-
<strong>字幕显示</strong>：如果视频文件带有字幕，播放器需要将字幕文件解析出来，并在适当的时间同步显示在视频画面上。</p>
<h3 id="缓冲和网络播放">6. 缓冲和网络播放</h3>
<p>对于在线视频播放器，还需要处理网络延迟和不稳定性。网络播放器会预先从网络缓冲一定量的数据，以保证播放流畅性。
-
<strong>缓冲机制</strong>：在网络播放中，播放器需要下载并缓存音视频数据。缓冲的大小和策略可以根据网络带宽和视频编码的特性来调整。
- <strong>自适应码率
(ABR)</strong>：对于流媒体播放，播放器需要根据网络状况调整播放视频的码率，以便在网络状况恶化时能维持流畅的播放。</p>
<h3 id="硬件加速">7. 硬件加速</h3>
<p>现代视频播放器通常使用硬件加速来提升性能，特别是在处理高分辨率视频（如
4K、8K）时。硬件加速的常见形式包括： - <strong>硬件解码</strong>：通过
GPU 或专用解码芯片进行视频解码，减轻 CPU 负担。 -
<strong>硬件渲染</strong>：使用 GPU
渲染视频帧，提升渲染效率和显示效果。</p>
<p>常见的硬件解码接口包括： - <strong>VDPAU</strong>：适用于 Linux
平台的硬件加速解码接口。 - <strong>DXVA</strong>：用于 Windows
的硬件解码接口。 - <strong>MediaCodec</strong>：Android
平台的硬件解码接口。</p>
<h3 id="视频播放器实现流程总结">视频播放器实现流程总结</h3>
<ol type="1">
<li><strong>读取和解析文件</strong>：播放器打开媒体文件，解封装得到音视频流。</li>
<li><strong>音视频解码</strong>：通过解码器解码音视频流，得到可用的音频采样和视频帧数据。</li>
<li><strong>音视频同步</strong>：根据音频和视频的时间戳，保持音视频同步播放。</li>
<li><strong>视频渲染</strong>：将解码的原始视频帧渲染到屏幕上，通常使用
GPU 进行加速渲染。</li>
<li><strong>音频播放</strong>：将解码后的音频数据送到音频设备进行播放。</li>
<li><strong>用户交互</strong>：响应用户的播放、暂停、快进、音量调节等操作。</li>
<li><strong>流媒体支持</strong>：通过网络缓冲和自适应码率调整，确保在线播放的流畅性。</li>
</ol>
<h3 id="总结-33">总结</h3>
<p>一个视频播放器的基本实现原理主要包括媒体数据的解封装、解码、音视频同步、渲染和播放。为了保证播放的流畅性和性能，现代播放器通常依赖硬件加速、优化的解码算法和用户友好的交互设计。对于在线视频，播放器还需要处理网络延迟、码率调整等问题。</p>
<h2 id="视频直播的实现原理">视频直播的实现原理</h2>
<p>视频直播是一种实时将视频数据从一个或多个源传输到远程观众的技术。它的实现涉及多个关键步骤，包括视频采集、编码、传输、解码和播放，依赖于多个技术协议和优化手段来确保低延迟和高质量的实时视频体验。以下是视频直播的基本实现原理和关键技术。</p>
<h3 id="视频直播的基本流程">视频直播的基本流程</h3>
<ol type="1">
<li><strong>视频采集</strong>
<ul>
<li>视频直播从采集视频和音频数据开始。数据可以来自摄像头、麦克风或其他音视频设备。</li>
<li>采集设备会将原始的视频和音频数据传送给直播服务器或直播软件进行处理。</li>
<li>视频采集通常以帧为单位进行，常见的帧率有 24fps、30fps 或
60fps。</li>
</ul></li>
<li><strong>视频编码</strong>
<ul>
<li>原始视频数据通常体积庞大，未经压缩的音视频数据直接传输会占用大量带宽。为了减少传输带宽，视频采集后需要进行压缩处理，这就是<strong>视频编码</strong>。</li>
<li>常见的视频编码格式包括
H.264、H.265（HEVC），而音频编码格式则常见的有 AAC、MP3 等。</li>
<li><strong>编码的目的是</strong>：在保证视频质量的前提下，压缩视频数据大小，使其可以在网络上实时传输。</li>
<li><strong>实时编码</strong>需要考虑延迟问题，因此通常选择具备快速编码能力的编解码器。</li>
</ul></li>
<li><strong>封装</strong>
<ul>
<li>编码后的音视频数据会被封装成特定格式的流文件，用于网络传输。</li>
<li>封装协议决定了音视频如何打包以及数据的传输顺序。常见的封装格式有
FLV、MP4 等。</li>
<li><strong>FLV</strong>
是视频直播中最常见的封装格式之一，因为它支持流媒体播放，适合直播应用。</li>
</ul></li>
<li><strong>推流</strong>
<ul>
<li>视频编码和封装后，数据通过网络传输到直播服务器，称为<strong>推流</strong>（Publishing
Stream）。</li>
<li>常见的推流协议有：
<ul>
<li><strong>RTMP (Real-Time Messaging
Protocol)</strong>：最常用的直播推流协议，低延迟，广泛支持。</li>
<li><strong>HLS (HTTP Live
Streaming)</strong>：适用于跨平台播放，延迟较高，但兼容性好，适合点播和直播。</li>
<li><strong>SRT (Secure Reliable
Transport)</strong>：低延迟，高可靠性，适合在不稳定网络下传输。</li>
<li><strong>WebRTC (Web Real-Time
Communication)</strong>：用于实现浏览器端的实时音视频通信，延迟极低。</li>
</ul></li>
</ul></li>
<li><strong>直播服务器和分发</strong>
<ul>
<li><strong>直播服务器</strong>：接收推流并进行处理（如转码、多码率处理、流的分发等）。直播服务器还会维护与观众的连接，并将流数据分发到观众端。</li>
<li><strong>内容分发网络
(CDN)</strong>：为了解决大量用户同时观看时的带宽和负载问题，直播流通常通过
CDN 分发。CDN
在全球各地部署服务器，通过缓存和负载均衡来加速直播内容的分发，减少延迟并提高可用性。</li>
<li><strong>转码</strong>：为了适应不同网络条件和设备，直播服务器通常会对原始视频流进行多码率转码。不同质量的流可以满足用户的不同带宽和设备条件。</li>
</ul></li>
<li><strong>拉流和播放</strong>
<ul>
<li><strong>拉流</strong>（Pulling
Stream）：观众端的播放器通过特定的协议向直播服务器请求视频流，称为拉流。</li>
<li>播放器根据接收到的视频流数据进行解码和播放。</li>
<li>播放器需要支持直播使用的协议，如 RTMP、HLS 或
WebRTC。通常播放器内部实现了缓冲机制，确保即使网络有波动，也能提供连续的播放体验。</li>
</ul></li>
</ol>
<h3 id="关键技术和优化">关键技术和优化</h3>
<h4 id="编码优化">1. <strong>编码优化</strong></h4>
<ul>
<li>在直播中，编码器的选择至关重要，既要确保较高的压缩效率，又要控制延迟。</li>
<li><strong>硬件加速</strong>：为了减少编码的延迟，现代直播系统往往使用硬件加速编码器（如
GPU 加速）来提高编码效率，减少编码延迟。</li>
<li><strong>自适应码率</strong>：视频直播系统通常支持自适应码率（ABR），根据用户当前的网络状况，自动调整视频流的质量，以保证播放的流畅性和低延迟。</li>
</ul>
<h4 id="传输协议的选择">2. <strong>传输协议的选择</strong></h4>
<ul>
<li><strong>RTMP</strong>：低延迟的实时传输协议，支持推流到服务器并在观众端实时播放，延迟通常在
1-3 秒范围内。</li>
<li><strong>HLS</strong>：基于 HTTP
的直播协议，兼容性好但延迟较高（通常在 6-30 秒）。HLS
通过将视频分割成若干小的 TS 文件进行传输。</li>
<li><strong>SRT</strong>：提供更好的传输可靠性和抗网络抖动能力，适合复杂网络条件下的低延迟传输。</li>
<li><strong>WebRTC</strong>：浏览器端实时音视频通信协议，延迟通常在毫秒级，非常适合对延迟敏感的场景（如互动直播、视频会议等）。</li>
</ul>
<h4 id="cdn-和边缘节点优化">3. <strong>CDN 和边缘节点优化</strong></h4>
<ul>
<li>CDN
通过在全球多个节点部署缓存服务器，将直播内容分发到离观众最近的服务器节点，减少网络延迟和带宽压力。</li>
<li><strong>边缘计算</strong>：某些直播服务在 CDN
的边缘节点上进行实时处理和转码，减少直播服务器的负载，并提高分发效率。</li>
</ul>
<h4 id="延迟控制">4. <strong>延迟控制</strong></h4>
<ul>
<li>低延迟是直播技术的一个重要目标，尤其是在互动性较强的场景中（如在线游戏直播、体育赛事、在线教育等）。通过以下手段可以减少直播的延迟：
<ul>
<li><strong>减少编码延迟</strong>：使用快速编码器或硬件加速。</li>
<li><strong>减少传输延迟</strong>：使用低延迟传输协议，如 WebRTC、SRT
或低延迟 RTMP。</li>
<li><strong>减少播放器的缓冲</strong>：尽量减少播放器端的缓冲时间，虽然这可能会增加播放过程中的卡顿风险，但可以显著降低延迟。</li>
</ul></li>
</ul>
<h4 id="网络抖动与丢包处理">5. <strong>网络抖动与丢包处理</strong></h4>
<ul>
<li>在网络不稳定的环境下（如移动网络），直播系统需要应对网络抖动和丢包问题。</li>
<li><strong>FEC (Forward Error
Correction)</strong>：通过在传输数据中增加冗余信息来修复丢失的数据包。</li>
<li><strong>ARQ (Automatic Repeat
reQuest)</strong>：当检测到数据包丢失时，接收端请求发送端重新发送丢失的数据包。</li>
<li><strong>自适应传输机制</strong>：根据网络带宽的变化，自动调整视频流的码率，确保流畅性。</li>
</ul>
<h3 id="实现原理的示例流程">实现原理的示例流程</h3>
<p>假设有一个主播使用 RTMP 协议推流至直播平台，观众通过 HLS
协议观看的典型流程：</p>
<ol type="1">
<li>主播通过摄像头和麦克风采集音视频数据。</li>
<li>音视频数据经过编码（H.264 视频编码，AAC 音频编码），并封装成 FLV
格式，通过 RTMP 协议推送到直播平台服务器。</li>
<li>直播平台服务器接收流后，可能对流进行转码，生成不同清晰度的版本，以适应不同网络状况的观众。</li>
<li>转码后的流通过 CDN
分发到各个边缘节点，离观众最近的节点提供服务。</li>
<li>观众使用支持 HLS 的播放器向 CDN 请求视频流，并按顺序播放收到的 HLS
切片文件（.ts 文件）。</li>
<li>播放器对视频流进行解码，将解码后的画面和音频同步输出，实现直播观看。</li>
</ol>
<h3 id="总结-34">总结</h3>
<p>视频直播的实现涉及多个环节，从视频采集到推流、服务器处理、内容分发和最终播放，每个环节都影响着直播的质量和延迟。选择合适的编码方式、传输协议以及内容分发策略对于实现高质量、低延迟的直播体验至关重要。</p>
<h2 id="网速差如何保证流畅">网速差如何保证流畅</h2>
<p>在网络状况不理想时，直播画面可能会卡顿或画质下降。为了保证在网络条件差的情况下仍然能够提供流畅的观看体验，可以采取多种技术手段进行优化。以下是一些常用的策略：</p>
<h3 id="自适应码率流-adaptive-bitrate-streaming-abr">1. 自适应码率流
(Adaptive Bitrate Streaming, ABR)</h3>
<p>自适应码率技术是目前直播系统最常用的优化手段。它根据用户的网络状况动态调整视频流的码率，以保证观看流畅性。</p>
<ul>
<li><strong>原理</strong>：直播平台通常会将同一个直播视频流生成多种不同清晰度的版本（不同的分辨率和码率），如
480p、720p、1080p
等。当网络带宽变差时，播放器会自动切换到低清晰度、低码率的流，从而减少带宽占用，确保视频播放流畅。</li>
<li><strong>技术实现</strong>：
<ul>
<li>对于 HLS 或 DASH
等协议，播放器端可以自动选择适合当前带宽的流进行播放。</li>
<li>CDN
或服务器端在推送视频流时，会根据带宽监控情况为用户推送合适码率的视频。</li>
</ul></li>
</ul>
<h3 id="降低视频分辨率和帧率">2. 降低视频分辨率和帧率</h3>
<p>当网络条件变差时，适当降低视频的分辨率和帧率可以减少需要传输的数据量，从而提高流畅性。</p>
<ul>
<li><strong>降低分辨率</strong>：比如从 1080p 降低到 720p 或
480p。低分辨率视频所需的带宽更少，可以在较差的网络环境中流畅播放。</li>
<li><strong>降低帧率</strong>：通过减少每秒传输的帧数（例如从 60fps
降低到 30fps 或
15fps），可以大幅减少需要传输的数据量。虽然帧率降低会影响视频的细节流畅度，但在网络条件极差时，降低帧率是非常有效的手段。</li>
</ul>
<h3 id="视频编码器优化">3. 视频编码器优化</h3>
<p>选择合适的编码器和优化编码参数，能够在较低码率下保持较高的视频质量。</p>
<ul>
<li><strong>H.265 (HEVC)</strong> 或 <strong>VP9</strong>：相比
H.264，H.265 和 VP9
编解码器在同等画质下具有更高的压缩效率，适合在低带宽环境下使用。</li>
<li><strong>动态码率调整</strong>：实时编码时，编码器可以根据当前场景复杂度动态调整码率。例如，视频中变化较少的静态场景可以使用较低的码率，而运动较多的场景可以使用较高码率。</li>
<li><strong>编码参数调整</strong>：减少关键帧频率（如 I
帧间隔）等编码设置，能够减少需要传输的关键帧数量，从而减少带宽占用。</li>
</ul>
<h3 id="提高缓冲策略">4. 提高缓冲策略</h3>
<p>适当增加播放器的缓冲区大小，使其在网络波动时仍能继续播放缓存中的视频数据，减少卡顿。</p>
<ul>
<li><strong>增大缓冲区</strong>：在网络抖动较大时，适当增加缓冲区的大小（如将几秒的缓冲时间增加到
10
秒），可以让播放器预加载更多的视频数据，从而应对网络的暂时中断或抖动问题。</li>
<li><strong>逐步加载策略</strong>：在缓冲区不足时，播放器可以动态调整加载策略，首先下载关键帧和低质量数据，确保视频不会卡顿。</li>
</ul>
<h3 id="使用低延迟传输协议">5. 使用低延迟传输协议</h3>
<p>选择合适的低延迟传输协议来减少视频传输时的延迟，尤其是在网络条件不稳定时，可以使用以下协议：</p>
<ul>
<li><strong>SRT (Secure Reliable Transport)</strong>：SRT
协议具有抗网络抖动和丢包的功能，能够在低带宽和高延迟的环境下提供更稳定的流传输效果。</li>
<li><strong>WebRTC</strong>：WebRTC
是一种超低延迟传输协议，适合需要极低延迟的直播场景。WebRTC
能够在不稳定的网络环境下通过自适应码率、拥塞控制等机制保持较流畅的视频体验。</li>
<li><strong>低延迟 HLS</strong>：低延迟 HLS
通过减少切片的大小和缓存时间，使直播延迟缩短，同时保持一定流畅性。</li>
</ul>
<h3 id="网络丢包与错误修正">6. 网络丢包与错误修正</h3>
<p>在差网络环境下，网络丢包是常见问题，通过一些错误修正和丢包重传机制可以提升传输效果。</p>
<ul>
<li><strong>FEC (Forward Error
Correction)</strong>：前向纠错技术会在数据传输中加入冗余数据，以便在一定程度上修复丢失的包，而无需重传，减少由于网络丢包导致的卡顿。</li>
<li><strong>ARQ (Automatic Repeat
Request)</strong>：当传输过程中数据包丢失时，通过 ARQ
机制请求重新发送丢失的数据包，确保数据的完整性。</li>
</ul>
<h3 id="优化直播的网络环境">7. 优化直播的网络环境</h3>
<p>虽然技术手段可以在一定程度上提高流畅性，但优化网络环境也是至关重要的手段。</p>
<ul>
<li><strong>选择合适的 CDN</strong>：通过全球分布的内容分发网络
(CDN)，直播流可以通过就近的服务器节点传输到用户端，减少网络延迟。</li>
<li><strong>网络带宽管理</strong>：对于移动设备，建议使用 4G 或 5G
网络，避免使用 Wi-Fi
网络不稳定的环境。在宽带不高的网络条件下，可以通过限制其他应用程序的网络使用，确保直播有足够的带宽。</li>
</ul>
<h3 id="使用预加载和智能缓存">8. 使用预加载和智能缓存</h3>
<ul>
<li><strong>智能缓存机制</strong>：通过智能分析用户的带宽情况和当前的视频播放进度，提前加载未来几秒的视频流数据。即使网络突然波动，用户仍能利用缓存的数据，继续播放视频，避免卡顿。</li>
<li><strong>渐进式加载</strong>：在加载视频时，优先加载低分辨率的内容并逐渐切换到高分辨率。这种方式能确保即使网络不稳定，用户也能快速开始观看直播。</li>
</ul>
<h3 id="降低非必要开销">9. 降低非必要开销</h3>
<ul>
<li><strong>去除非关键数据流</strong>：在网络条件差时，可以暂停或去掉非关键的数据流，例如关闭不必要的字幕、统计信息等，减少带宽占用。</li>
<li><strong>优化交互逻辑</strong>：在一些互动性较强的直播场景中，降低实时互动频率，减少数据的往返传输，可以保证视频和音频的流畅性。</li>
</ul>
<h3 id="总结-35">总结</h3>
<p>为了在网络条件较差的情况下保持视频直播的流畅性，可以通过自适应码率流、降低分辨率和帧率、优化编码器、提高缓冲、使用低延迟协议、网络丢包处理等技术手段来优化直播体验。同时，选择合适的网络传输架构（如
CDN）和改善本地网络环境也非常重要。</p>
<h2 id="常用流媒体协议">常用流媒体协议</h2>
<p>流媒体协议是指在网络上传输音频、视频等多媒体内容的协议，它们定义了如何在不同设备和网络条件下高效地传输数据。常见的流媒体协议有多个，每个协议都有其独特的特点和应用场景，主要用于视频点播、直播、实时通信等领域。下面是常用的几种流媒体协议的详细介绍：</p>
<hr />
<h3 id="rtmpreal-time-messaging-protocol">1. <strong>RTMP（Real-Time
Messaging Protocol）</strong></h3>
<h4 id="概述-16">概述</h4>
<p>RTMP 是 Adobe 公司开发的一种用于音视频数据传输的流媒体协议，最初用于
Flash 播放器。虽然 Flash 已经逐渐被淘汰，但 RTMP
仍然在视频直播中得到广泛应用，特别是在推流和传输中。</p>
<h4 id="特点-12">特点：</h4>
<ul>
<li><strong>低延迟</strong>：RTMP
提供了较低的传输延迟，通常用于实时直播场景。</li>
<li><strong>TCP 协议</strong>：RTMP 基于 TCP
协议，提供可靠的数据传输，保证数据的完整性。</li>
<li><strong>适用于推流</strong>：RTMP
常用于从客户端推送视频流到服务器，或者从服务器向播放器分发直播视频。</li>
<li><strong>逐渐被 HLS 替代</strong>：随着 HLS 等协议的普及，RTMP
的应用正在逐渐减少，特别是在终端播放器上，但它仍广泛应用于服务器端的推流过程。</li>
</ul>
<h4 id="使用场景-12">使用场景：</h4>
<ul>
<li>视频直播推流：RTMP 常用于客户端（如 OBS）向服务器推送直播流。</li>
<li>视频点播：一些旧的 Flash 视频点播系统仍然使用 RTMP。</li>
</ul>
<h4 id="架构示例">架构示例：</h4>
<ul>
<li><strong>推流</strong>：客户端（如摄像头或编码器）通过 RTMP
协议将音视频数据推送到流媒体服务器（如 Wowza、NGINX-RTMP）。</li>
<li><strong>拉流</strong>：观众设备通过 RTMP
拉取音视频流，实现低延迟观看。</li>
</ul>
<hr />
<h3 id="hlshttp-live-streaming">2. <strong>HLS（HTTP Live
Streaming）</strong></h3>
<h4 id="概述-17">概述</h4>
<p>HLS 是由苹果公司开发的一种基于 HTTP
的流媒体传输协议。它通过将媒体流分割成若干小的文件（TS
切片），并通过标准 HTTP 协议进行传输。这种方式使得 HLS 可以在任意支持
HTTP 的平台上工作，且具备良好的兼容性。</p>
<h4 id="特点-13">特点：</h4>
<ul>
<li><strong>广泛支持</strong>：HLS
是移动设备上最常用的流媒体协议，iOS、macOS 原生支持 HLS。</li>
<li><strong>基于 HTTP 传输</strong>：HLS 通过 HTTP
进行传输，具备很好的兼容性，可以利用现有的 HTTP 服务器和
CDN（内容分发网络）进行分发。</li>
<li><strong>适应性流媒体</strong>：HLS
支持自适应比特率流（ABR），可以根据网络条件动态切换视频质量，保证在不同带宽下的流畅播放。</li>
<li><strong>高延迟</strong>：HLS 的一个主要缺点是延迟较高，通常在 10-30
秒，主要是由于每个切片的时长（通常为 2-6 秒）和缓冲机制所致。</li>
</ul>
<h4 id="使用场景-13">使用场景：</h4>
<ul>
<li>视频点播（VOD）：HLS 常用于视频点播服务，如 Netflix 和
YouTube。</li>
<li>直播流媒体：HLS
也用于实时直播，但在一些对低延迟要求较高的场景（如在线教育、游戏直播）中效果不佳。</li>
</ul>
<h4 id="工作原理-5">工作原理：</h4>
<ul>
<li><strong>切片</strong>：将视频文件切分为多个 TS 小文件，并生成一个
<code>.m3u8</code> 文件来索引这些切片。</li>
<li><strong>传输</strong>：客户端根据 <code>.m3u8</code> 文件，通过 HTTP
协议逐个下载 TS 切片并进行播放。</li>
<li><strong>自适应</strong>：客户端根据网络带宽和播放情况动态选择合适的切片质量。</li>
</ul>
<hr />
<h3 id="dashdynamic-adaptive-streaming-over-http">3.
<strong>DASH（Dynamic Adaptive Streaming over HTTP）</strong></h3>
<h4 id="概述-18">概述</h4>
<p>DASH 是一种与 HLS 类似的流媒体传输协议，也基于 HTTP 传输。它是由 MPEG
组织开发的标准协议，旨在提供自适应的流媒体传输。</p>
<h4 id="特点-14">特点：</h4>
<ul>
<li><strong>跨平台支持</strong>：DASH 是开放标准，相较于 HLS
在苹果平台的主导地位，DASH 在 Android 和 Windows
等平台上也有广泛支持。</li>
<li><strong>自适应比特率流</strong>：与 HLS 类似，DASH
支持自适应比特率流，可以根据网络带宽切换不同清晰度的流。</li>
<li><strong>基于 HTTP</strong>：DASH 通过 HTTP 进行传输，兼容 HTTP
服务器和 CDN。</li>
<li><strong>更灵活的编码支持</strong>：DASH 支持多种编码格式，如
H.264、H.265、VP9 等，具有更高的灵活性。</li>
</ul>
<h4 id="使用场景-14">使用场景：</h4>
<ul>
<li>视频点播：DASH 常用于高清视频点播服务，支持 4K、HDR
等高质量视频内容。</li>
<li>实时流媒体：DASH 支持实时流媒体，但与 HLS 一样，延迟通常较高。</li>
</ul>
<h4 id="工作原理-6">工作原理：</h4>
<ul>
<li><strong>切片与索引文件</strong>：DASH 将视频切片为若干小段，并通过
MPD（Media Presentation Description）文件进行索引，类似于 HLS 的
<code>.m3u8</code> 文件。</li>
<li><strong>动态适应</strong>：客户端根据网络状况选择不同质量的切片，进行动态适应，提供最佳播放体验。</li>
</ul>
<hr />
<h3 id="rtspreal-time-streaming-protocol">4. <strong>RTSP（Real-Time
Streaming Protocol）</strong></h3>
<h4 id="概述-19">概述</h4>
<p>RTSP 是一种用于控制多媒体流的网络协议，它与 RTP
协议配合使用，用于流媒体播放控制。RTSP
定义了如何在客户端和服务器之间建立和管理流媒体会话，但实际的数据传输通常通过
RTP 进行。</p>
<h4 id="特点-15">特点：</h4>
<ul>
<li><strong>实时流媒体传输</strong>：RTSP
常用于实时视频传输场景，尤其是在视频监控、IP 摄像机中广泛应用。</li>
<li><strong>基于 RTP</strong>：RTSP 本身不传输数据，数据传输由
RTP（Real-Time Transport Protocol）完成。RTP 使用 UDP
进行传输，具备低延迟的优势。</li>
<li><strong>复杂的控制功能</strong>：RTSP
提供了丰富的控制功能，如播放、暂停、快进、倒退等操作。</li>
<li><strong>灵活性</strong>：RTSP
非常灵活，适用于实时媒体流的传输和控制。</li>
</ul>
<h4 id="使用场景-15">使用场景：</h4>
<ul>
<li>视频监控：RTSP 是许多 IP 摄像机、监控系统中传输视频的主要协议。</li>
<li>视频会议：RTSP 被广泛应用于视频会议系统中，提供实时音视频传输。</li>
</ul>
<h4 id="工作原理-7">工作原理：</h4>
<ul>
<li><strong>会话管理</strong>：RTSP 定义了会话控制命令，如
<code>PLAY</code>、<code>PAUSE</code>、<code>SETUP</code>
等，用于控制媒体流的播放。</li>
<li><strong>数据传输</strong>：RTSP 通过 RTP 协议传输音视频数据。RTP
通常基于 UDP 传输，能够实现低延迟的视频播放。</li>
</ul>
<hr />
<h3 id="webrtcweb-real-time-communication">5. <strong>WebRTC（Web
Real-Time Communication）</strong></h3>
<h4 id="概述-20">概述</h4>
<p>WebRTC
是一种用于实时音视频通信的开源协议，支持点对点的低延迟音视频传输。它主要用于实时通信场景，例如视频聊天、视频会议和直播互动。</p>
<h4 id="特点-16">特点：</h4>
<ul>
<li><strong>超低延迟</strong>：WebRTC
的延迟通常在毫秒级，非常适合实时通信场景。</li>
<li><strong>点对点通信</strong>：WebRTC 支持通过
P2P（点对点）进行音视频传输，可以减少服务器的压力，并提供更快的传输速度。</li>
<li><strong>跨平台支持</strong>：WebRTC 在现代浏览器中得到了广泛支持，如
Chrome、Firefox 等。</li>
<li><strong>安全性</strong>：WebRTC 默认使用加密传输（DTLS 和
SRTP），确保数据的安全性。</li>
</ul>
<h4 id="使用场景-16">使用场景：</h4>
<ul>
<li>视频聊天和会议：例如 Google Meet、Zoom 等视频会议工具使用 WebRTC
实现点对点通信。</li>
<li>实时直播：WebRTC
也用于超低延迟的互动直播场景，特别是在需要观众和主播实时互动的场景中。</li>
<li>游戏直播与多人互动：如需要极低延迟的场景，例如多人游戏直播和在线协作应用。</li>
</ul>
<h4 id="工作原理-8">工作原理：</h4>
<ul>
<li><strong>信令交换</strong>：在建立 WebRTC
连接之前，客户端通过信令交换（如通过
WebSocket）传递会话描述信息（SDP），确定媒体格式和传输方式。</li>
<li><strong>点对点通信</strong>：一旦连接建立，音视频数据通过 P2P
进行传输，减少中转服务器的负载和延迟。</li>
</ul>
<hr />
<h3 id="srtsecure-reliable-transport">6. <strong>SRT（Secure Reliable
Transport）</strong></h3>
<h4 id="概述-21">概述</h4>
<p>SRT
是一种开源的传输协议，专为在不稳定网络条件下进行安全和低延迟的音视频传输设计。SRT
具有抗丢包、抗抖动的特性，适合在复杂网络环境下的直播流媒体传输。</p>
<h4 id="特点-17">特点：</h4>
<ul>
<li><strong>低延迟</strong>：SRT 专为低延迟传输设计，适合高质量</li>
</ul>
<p>直播。 - <strong>安全性</strong>：SRT
提供了端到端的加密，确保数据传输的安全性。 -
<strong>抗丢包与抖动</strong>：SRT
内置了丢包重传机制和网络抖动缓冲，能够在网络状况不佳的情况下保证音视频流的完整性和质量。
- <strong>基于 UDP</strong>：SRT 基于 UDP
协议，但通过丢包重传等机制，实现了可靠的数据传输。</p>
<h4 id="使用场景-17">使用场景：</h4>
<ul>
<li>远程直播：SRT
适合用于跨国直播、远程摄像机传输等需要高质量和低延迟的视频传输场景。</li>
<li>复杂网络环境下的直播：在丢包率较高的网络中，SRT
能够提供较好的传输性能。</li>
</ul>
<h4 id="工作原理-9">工作原理：</h4>
<ul>
<li><strong>丢包重传</strong>：SRT 使用 NACK
反馈机制检测丢包，并重新传输丢失的数据包。</li>
<li><strong>加密传输</strong>：SRT 提供 AES
加密，确保传输过程中的数据安全。</li>
</ul>
<hr />
<h3 id="总结-36">总结</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 22%" />
<col style="width: 5%" />
<col style="width: 8%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>协议</th>
<th>传输方式</th>
<th>延迟</th>
<th>安全性</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>RTMP</strong></td>
<td>基于 TCP</td>
<td>低</td>
<td>无</td>
<td>直播推流、低延迟视频传输</td>
</tr>
<tr class="even">
<td><strong>HLS</strong></td>
<td>基于 HTTP</td>
<td>高</td>
<td>支持</td>
<td>视频点播、直播（延迟容忍度较高）</td>
</tr>
<tr class="odd">
<td><strong>DASH</strong></td>
<td>基于 HTTP</td>
<td>中等</td>
<td>支持</td>
<td>高清视频点播、自适应流传输</td>
</tr>
<tr class="even">
<td><strong>RTSP</strong></td>
<td>基于 UDP（RTP）</td>
<td>低</td>
<td>无</td>
<td>视频监控、视频会议</td>
</tr>
<tr class="odd">
<td><strong>WebRTC</strong></td>
<td>基于 P2P/UDP</td>
<td>超低</td>
<td>支持</td>
<td>视频聊天、视频会议、互动直播</td>
</tr>
<tr class="even">
<td><strong>SRT</strong></td>
<td>基于 UDP</td>
<td>低</td>
<td>支持</td>
<td>跨国直播、远程视频传输</td>
</tr>
</tbody>
</table>
<p>不同的流媒体协议有各自的优缺点，开发者需要根据具体的应用场景（如延迟需求、网络环境、传输稳定性等）选择合适的协议。</p>
<h2 id="dts-和-pts-有什么区别">DTS 和 PTS 有什么区别</h2>
<p>DTS（Decoding Time Stamp，解码时间戳）和 PTS（Presentation Time
Stamp，显示时间戳）是视频和音频流中两个重要的时间戳概念，通常用于多媒体容器格式如
MPEG、MKV
等，目的是同步音视频的播放。它们的区别主要体现在解码和播放的时序上：</p>
<ol type="1">
<li><strong>DTS（解码时间戳）</strong>：
<ul>
<li>作用：告诉解码器什么时候开始解码某一帧的数据。</li>
<li>含义：当视频流中的某一帧可能需要提前解码（例如在有 B
帧的情况下），解码器会根据 DTS 值进行解码，但不一定立刻显示。</li>
<li>应用：在包含帧重排序的视频编码（如 H.264）中，DTS
代表该帧应当被解码的时刻。</li>
</ul></li>
<li><strong>PTS（显示时间戳）</strong>：
<ul>
<li>作用：告诉播放器什么时候把解码后的帧显示到屏幕上。</li>
<li>含义：PTS 决定了解码后的帧何时被呈现给观众或播放出来。PTS
通常和播放的时间轴直接相关。</li>
<li>应用：PTS
用于确保帧按照正确的顺序和时间展示，尤其是对于具有复杂帧类型（如 I 帧、P
帧和 B 帧）的流。</li>
</ul></li>
</ol>
<h3 id="总结-37">总结：</h3>
<ul>
<li><strong>DTS</strong> 控制解码时间，<strong>PTS</strong>
控制显示时间。</li>
<li>DTS 不一定总是存在，特别是在没有帧重排序的流中。</li>
<li>PTS 是多媒体流中最常见的时间戳，用于保持音视频同步。</li>
</ul>
<p>对于大多数视频播放场景，播放器会优先使用 PTS 确保音视频的同步播放，而
DTS 则更多地在视频解码过程中起作用。</p>
<h1 id="数据结构和算法">数据结构和算法</h1>
<p>数据结构和算法是计算机科学的核心，它们帮助我们以有效的方式存储、组织和处理数据。掌握常用的数据结构和算法对编写高效程序至关重要。下面将介绍一些常用的数据结构和算法，并提供相应的示例代码。</p>
<hr />
<h2 id="常用数据结构">1. <strong>常用数据结构</strong></h2>
<h3 id="数组-array">1.1 <strong>数组 (Array)</strong></h3>
<p><strong>数组</strong>是一种固定大小的线性数据结构，存储相同类型的元素。它支持通过索引快速访问元素，但由于大小固定，插入和删除操作相对复杂。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>访问元素：O(1)</li>
<li>插入/删除元素：O(n) （最坏情况下，需要移动元素）</li>
</ul></li>
</ul>
<h4 id="示例java">示例（Java）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);  <span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure>
<h3 id="链表-linked-list">1.2 <strong>链表 (Linked List)</strong></h3>
<p><strong>链表</strong>是一种动态的数据结构，由节点组成，每个节点包含数据部分和指向下一个节点的指针。链表分为单链表和双链表。与数组不同，链表支持动态扩展，插入和删除操作高效，但随机访问性能较差。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>访问元素：O(n)</li>
<li>插入/删除元素：O(1)（当给定节点位置时）</li>
</ul></li>
</ul>
<h4 id="示例java-单链表">示例（Java 单链表）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> data) &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">    Node head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(current.data + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈-stack">1.3 <strong>栈 (Stack)</strong></h3>
<p><strong>栈</strong>是一种后进先出（LIFO）的数据结构。栈支持在栈顶进行插入和删除操作，常用于递归、括号匹配等问题。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>压栈/出栈：O(1)</li>
<li>访问元素：O(n)</li>
</ul></li>
</ul>
<h4 id="示例java-使用栈">示例（Java 使用栈）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="number">1</span>);  <span class="comment">// 压入元素</span></span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">System.out.println(stack.pop());  <span class="comment">// 弹出元素，输出：2</span></span><br><span class="line">System.out.println(stack.peek()); <span class="comment">// 查看栈顶元素，输出：1</span></span><br></pre></td></tr></table></figure>
<h3 id="队列-queue">1.4 <strong>队列 (Queue)</strong></h3>
<p><strong>队列</strong>是一种先进先出（FIFO）的数据结构，常用于排队处理任务。队列支持在队尾插入数据，并在队首删除数据。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>入队/出队：O(1)</li>
<li>访问元素：O(n)</li>
</ul></li>
</ul>
<h4 id="示例java-使用队列">示例（Java 使用队列）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="number">1</span>);  <span class="comment">// 入队</span></span><br><span class="line">queue.offer(<span class="number">2</span>);</span><br><span class="line">System.out.println(queue.poll());  <span class="comment">// 出队，输出：1</span></span><br><span class="line">System.out.println(queue.peek());  <span class="comment">// 查看队首元素，输出：2</span></span><br></pre></td></tr></table></figure>
<h3 id="哈希表-hash-table">1.5 <strong>哈希表 (Hash Table)</strong></h3>
<p><strong>哈希表</strong>是一种基于哈希函数的数据结构，用于快速查找、插入和删除数据。哈希表通过将键映射到特定的存储位置，能够实现接近
O(1) 时间复杂度的查找。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>查找/插入/删除：平均 O(1)，最坏 O(n)</li>
</ul></li>
</ul>
<h4 id="示例java-使用哈希表">示例（Java 使用哈希表）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">map.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;Alice&quot;</span>));  <span class="comment">// 输出：25</span></span><br><span class="line">map.remove(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">System.out.println(map.containsKey(<span class="string">&quot;Bob&quot;</span>));  <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure>
<h3 id="树-tree">1.6 <strong>树 (Tree)</strong></h3>
<p><strong>树</strong>是一种层次结构的非线性数据结构，包含节点，每个节点有一个父节点和若干子节点。<strong>二叉树</strong>是树的特殊形式，每个节点最多有两个子节点。<strong>二叉搜索树（BST）</strong>是一种特殊的二叉树，其中每个节点的左子节点都小于该节点，右子节点都大于该节点。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>查找/插入/删除：O(log n)（在平衡二叉树中）</li>
</ul></li>
</ul>
<h4 id="示例二叉树的遍历">示例（二叉树的遍历）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        left = right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="常用算法">2. <strong>常用算法</strong></h2>
<h3 id="排序算法">2.1 <strong>排序算法</strong></h3>
<h4 id="快速排序-quick-sort">2.1.1 <strong>快速排序 (Quick
Sort)</strong></h4>
<p><strong>思想</strong>：快速排序是基于分治思想的排序算法，通过选择一个基准元素，将数组分成两部分，使得基准元素左边的元素都小于它，右边的元素都大于它，然后递归地对两部分进行排序。</p>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>最优/平均情况：O(n log n)</li>
<li>最坏情况：O(n²)</li>
</ul></li>
</ul>
<h4 id="示例java-快速排序">示例（Java 快速排序）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pi</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">        arr[high] = temp;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));  <span class="comment">// 输出排序后的数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找算法">2.2 <strong>查找算法</strong></h3>
<h4 id="二分查找-binary-search">2.2.1 <strong>二分查找 (Binary
Search)</strong></h4>
<p><strong>思想</strong>：二分查找用于在有序数组中查找元素，通过不断将查找范围减半，直到找到目标元素或范围为空。</p>
<ul>
<li><strong>时间复杂度</strong>：O(log n)</li>
</ul>
<h4 id="示例java-二分查找">示例（Java 二分查找）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(arr, <span class="number">4</span>);</span><br><span class="line">        System.out.println(index);  <span class="comment">// 输出：3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="贪心算法-greedy-algorithm">2.3 <strong>贪心算法 (Greedy
Algorithm)</strong></h3>
<p><strong>思想</strong>：贪心算法通过每一步选择当前最优解来构建全局最优解，常用于解决优化问题，如背包问题、最小生成树等。</p>
<ul>
<li><strong>时间复杂度</strong>：取决于具体问题</li>
</ul>
<h4 id="示例java-找零问题">示例（Java 找零问题）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreedyChange</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">makeChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        Arrays.sort(coins);  <span class="comment">// 从小到大排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coins.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (amount &gt;= coins[i]) &#123;</span><br><span class="line">               </span><br><span class="line"></span><br><span class="line"> amount -= coins[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        System.out.println(makeChange(coins, <span class="number">63</span>));  <span class="comment">// 输出：6（25 + 25 + 10 + 1 + 1 + 1）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划-dynamic-programming">2.4 <strong>动态规划 (Dynamic
Programming)</strong></h3>
<p><strong>思想</strong>：动态规划通过将复杂问题分解为更小的子问题来解决，每个子问题的结果都会被保存，以便后续重用，避免重复计算。</p>
<ul>
<li><strong>时间复杂度</strong>：取决于问题的规模和状态数</li>
</ul>
<h4 id="示例java-求解斐波那契数列">示例（Java 求解斐波那契数列）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fib(<span class="number">10</span>));  <span class="comment">// 输出：55</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结-38">总结</h3>
<ul>
<li><strong>数据结构</strong>提供了组织和存储数据的方式，如数组、链表、栈、队列、树、哈希表等。</li>
<li><strong>算法</strong>提供了解决问题的步骤或过程，如排序（快速排序）、查找（二分查找）、贪心算法和动态规划等。</li>
</ul>
<p>通过选择合适的数据结构和算法，可以显著提高程序的性能和可扩展性。</p>
<h2 id="链表常用算法">链表常用算法</h2>
<p>好的！链表（Linked
List）是一种基础且重要的数据结构，在算法和数据处理中有着广泛应用。相比数组，链表的优势在于动态性和插入/删除的效率，但也带来了一些挑战，比如查找和反转的复杂性。以下我将详细讲解链表的主要算法，包括<strong>遍历、反转、合并、检测环、删除节点</strong>等，针对每种算法提供原理、Java
代码示例和分析。这些算法涵盖了常见的链表操作，适用于算法学习和面试准备。</p>
<hr />
<h3 id="定义链表节点">1. 定义链表节点</h3>
<p>首先定义一个单向链表节点类，作为示例的基础： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;         <span class="comment">// 数据域</span></span><br><span class="line">    ListNode next;   <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表的辅助方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(curr.val + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="主要算法及实现">2. 主要算法及实现</h3>
<h4 id="遍历链表">2.1 遍历链表</h4>
<h5 id="原理">原理</h5>
<ul>
<li>从头节点开始，沿 <code>next</code> 指针依次访问每个节点，直到遇到
<code>null</code>。</li>
<li>用于统计长度、查找节点或打印链表。</li>
</ul>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Length: &quot;</span> + getLength(head)); <span class="comment">// 输出: 3</span></span><br><span class="line">        ListNode.printList(head); <span class="comment">// 输出: 1 -&gt; 2 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度">复杂度</h5>
<ul>
<li><strong>时间复杂度</strong>: O(n)，n 是链表长度。</li>
<li><strong>空间复杂度</strong>: O(1)，只用一个指针。</li>
</ul>
<hr />
<h4 id="反转链表">2.2 反转链表</h4>
<h5 id="原理-1">原理</h5>
<ul>
<li>使用三个指针（<code>prev</code>、<code>curr</code>、<code>next</code>）迭代反转每个节点的
<code>next</code> 指针。</li>
<li>核心思想：逐步调整指针方向，原地完成反转。</li>
</ul>
<h5 id="代码-1">代码</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;  <span class="comment">// 保存下一个节点</span></span><br><span class="line">            curr.next = prev;           <span class="comment">// 反转指针</span></span><br><span class="line">            prev = curr;                <span class="comment">// 前移 prev</span></span><br><span class="line">            curr = next;                <span class="comment">// 前移 curr</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;                    <span class="comment">// 新头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reversed</span> <span class="operator">=</span> reverseList(head);</span><br><span class="line">        ListNode.printList(reversed); <span class="comment">// 输出: 3 -&gt; 2 -&gt; 1 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-1">复杂度</h5>
<ul>
<li><strong>时间复杂度</strong>: O(n)，一次遍历。</li>
<li><strong>空间复杂度</strong>: O(1)，原地操作。</li>
</ul>
<hr />
<h4 id="合并两个有序链表">2.3 合并两个有序链表</h4>
<h5 id="原理-2">原理</h5>
<ul>
<li>类似归并排序的合并过程，比较两个链表的节点值，逐步构建新链表。</li>
<li>使用哑节点（dummy node）简化边界处理。</li>
</ul>
<h5 id="代码-2">代码</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 哑节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理剩余节点</span></span><br><span class="line">        curr.next = (l1 != <span class="literal">null</span>) ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        l1.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        l1.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        l2.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        l2.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> mergeTwoLists(l1, l2);</span><br><span class="line">        ListNode.printList(merged); <span class="comment">// 输出: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-2">复杂度</h5>
<ul>
<li><strong>时间复杂度</strong>: O(n + m)，n 和 m 是两个链表长度。</li>
<li><strong>空间复杂度</strong>: O(1)，仅用哑节点，不计输出空间。</li>
</ul>
<hr />
<h4 id="检测链表中的环">2.4 检测链表中的环</h4>
<h5 id="原理-3">原理</h5>
<ul>
<li>使用<strong>快慢指针法</strong>（Floyd 判圈算法）：
<ul>
<li>慢指针每次走 1 步，快指针每次走 2 步。</li>
<li>若有环，快慢指针会在环内相遇；若无环，快指针先到
<code>null</code>。</li>
</ul></li>
</ul>
<h5 id="代码-3">代码</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;         <span class="comment">// 慢指针走 1 步</span></span><br><span class="line">            fast = fast.next.next;    <span class="comment">// 快指针走 2 步</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 相遇说明有环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = head.next; <span class="comment">// 创建环: 1 -&gt; 2 -&gt; 3 -&gt; 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hasCycle(head)); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-3">复杂度</h5>
<ul>
<li><strong>时间复杂度</strong>: O(n)，快指针最多跑完环的长度。</li>
<li><strong>空间复杂度</strong>: O(1)，只用两个指针。</li>
</ul>
<hr />
<h4 id="删除链表中的节点">2.5 删除链表中的节点</h4>
<h5 id="原理-4">原理</h5>
<ul>
<li><strong>普通删除</strong>:
找到目标节点的前驱，调整指针跳过目标。</li>
<li><strong>特殊情况</strong>:
如果只给定要删除的节点（无前驱引用），将其值替换为下个节点的值，再删除下个节点。</li>
</ul>
<h5 id="代码-4">代码</h5>
<h6 id="删除指定值的节点">删除指定值的节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 哑节点处理头节点删除</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next; <span class="comment">// 跳过目标节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> deleteNode(head, <span class="number">2</span>);</span><br><span class="line">        ListNode.printList(result); <span class="comment">// 输出: 1 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="只给定节点删除无前驱">只给定节点删除（无前驱）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设 node 是要删除的节点，且不是尾节点</span></span><br><span class="line">        node.val = node.next.val;    <span class="comment">// 复制下个节点的值</span></span><br><span class="line">        node.next = node.next.next;  <span class="comment">// 跳过下个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeToDelete</span> <span class="operator">=</span> head.next; <span class="comment">// 删除 2</span></span><br><span class="line"></span><br><span class="line">        deleteNode(nodeToDelete);</span><br><span class="line">        ListNode.printList(head); <span class="comment">// 输出: 1 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-4">复杂度</h5>
<ul>
<li><strong>普通删除</strong>: O(n) 时间，O(1) 空间。</li>
<li><strong>给定节点删除</strong>: O(1) 时间，O(1) 空间。</li>
</ul>
<hr />
<h4 id="查找中间节点">2.6 查找中间节点</h4>
<h5 id="原理-5">原理</h5>
<ul>
<li>使用快慢指针：快指针走 2 步，慢指针走 1
步，快指针到尾时，慢指针在中间。</li>
</ul>
<h5 id="代码-5">代码</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">middle</span> <span class="operator">=</span> middleNode(head);</span><br><span class="line">        System.out.println(middle.val); <span class="comment">// 输出: 3 (偶数长度取后半中间)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-5">复杂度</h5>
<ul>
<li><strong>时间复杂度</strong>: O(n)。</li>
<li><strong>空间复杂度</strong>: O(1)。</li>
</ul>
<hr />
<h3 id="复杂度总结">3. 复杂度总结</h3>
<table>
<thead>
<tr class="header">
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>关键技术</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
<td>指针移动</td>
</tr>
<tr class="even">
<td>反转</td>
<td>O(n)</td>
<td>O(1)</td>
<td>三指针迭代</td>
</tr>
<tr class="odd">
<td>合并有序链表</td>
<td>O(n + m)</td>
<td>O(1)</td>
<td>哑节点、双指针</td>
</tr>
<tr class="even">
<td>检测环</td>
<td>O(n)</td>
<td>O(1)</td>
<td>快慢指针</td>
</tr>
<tr class="odd">
<td>删除节点</td>
<td>O(n) / O(1)</td>
<td>O(1)</td>
<td>前驱指针 / 值替换</td>
</tr>
<tr class="even">
<td>查找中间节点</td>
<td>O(n)</td>
<td>O(1)</td>
<td>快慢指针</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="算法应用场景">4. 算法应用场景</h3>
<ul>
<li><strong>遍历</strong>: 统计、搜索基础操作。</li>
<li><strong>反转</strong>: 翻转数据顺序（如打印倒序）。</li>
<li><strong>合并</strong>: 归并排序、合并数据流。</li>
<li><strong>检测环</strong>: 检查循环依赖、死循环。</li>
<li><strong>删除</strong>: 数据清理、动态调整。</li>
<li><strong>中间节点</strong>: 分治法、分段处理。</li>
</ul>
<hr />
<h3 id="总结-39">5. 总结</h3>
<p>链表的主要算法围绕指针操作展开，核心是<strong>指针的移动与调整</strong>。通过快慢指针、三指针、哑节点等技巧，可以高效解决常见问题。Java
实现中要注意： - <strong>边界条件</strong>: 处理空链表或单节点。 -
<strong>内存管理</strong>: 确保不留悬空引用（Java
垃圾回收会处理，但逻辑需清晰）。</p>
<p>如果想深入某个算法（比如递归反转、双向链表操作）或有具体问题（比如链表排序），告诉我，我可以进一步展开！有什么想问的吗？</p>
<h1 id="网络">网络</h1>
<h2 id="https-进行连接的过程">Https 进行连接的过程</h2>
<p>我来详细讲解 HTTPS 的连接过程，用简洁的语言梳理清楚它的步骤。HTTPS 是
HTTP 的安全版本，通过在 HTTP 和 TCP 之间加入 TLS/SSL
层来实现加密通信。整个过程主要分为 <strong>TCP 连接建立</strong> 和
<strong>TLS 握手</strong> 两个阶段。下面是逐步拆解：</p>
<hr />
<h3 id="tcp-三次握手">1. TCP 三次握手</h3>
<p>HTTPS 基于 TCP，所以先要建立一个可靠的 TCP
连接。这通过三次握手完成：</p>
<ul>
<li><strong>客户端发送 SYN</strong>：<br />
客户端向服务器发送一个 SYN（同步）包，带一个随机序列号（如
<code>Seq = x</code>），表示想建立连接。</li>
<li><strong>服务器回复 SYN-ACK</strong>：<br />
服务器收到后，回应一个 SYN-ACK（同步-确认）包，包含自己的序列号（如
<code>Seq = y</code>）和对客户端的确认（<code>Ack = x + 1</code>）。</li>
<li><strong>客户端发送 ACK</strong>：<br />
客户端再回一个
ACK（确认）包，确认服务器的序列号（<code>Ack = y + 1</code>）。这时，TCP
连接就建好了，双向通信通道准备就绪。</li>
</ul>
<hr />
<h3 id="tls-握手">2. TLS 握手</h3>
<p>TCP 连接建立后，开始 TLS
握手，目的是协商加密参数、验证身份并建立安全通道。过程如下：</p>
<ul>
<li><strong>步骤 1：Client Hello</strong><br />
客户端发起握手，发送 “Client Hello” 消息，包含：
<ul>
<li>支持的 TLS 版本（如 TLS 1.2 或 1.3）。</li>
<li>支持的加密算法组合（比如 AES_256_GCM + SHA256）。</li>
<li>一个随机数（Client Random），用于后续密钥生成。</li>
</ul></li>
<li><strong>步骤 2：Server Hello</strong><br />
服务器回应 “Server Hello” 消息，包含：
<ul>
<li>选定的 TLS 版本和加密算法。</li>
<li>另一个随机数（Server Random）。</li>
<li>服务器的数字证书（包含公钥，由权威机构 CA 签名）。</li>
</ul></li>
<li><strong>步骤 3：证书验证</strong><br />
客户端拿到证书后：
<ul>
<li>检查证书是否可信（验证 CA 签名、证书有效期、域名匹配）。</li>
<li>如果通过，提取服务器公钥。</li>
</ul></li>
<li><strong>步骤 4：密钥交换</strong>
<ul>
<li>客户端生成一个随机值（Pre-Master Secret）。</li>
<li>用服务器公钥加密这个值，发给服务器。</li>
<li>双方用 Client Random、Server Random 和 Pre-Master Secret
计算出对称密钥（Master Secret）。<br />
（注：TLS 1.3 用更安全的 Diffie-Hellman
密钥交换替代这个方式，但目标一致：生成对称密钥。）</li>
</ul></li>
<li><strong>步骤 5：完成握手</strong>
<ul>
<li>客户端发送 “Finished”
消息，用刚生成的对称密钥加密，证明握手成功。</li>
<li>服务器也发送 “Finished” 消息，同样加密，确认双方密钥一致。</li>
<li>TLS 握手结束，安全通道建立。</li>
</ul></li>
</ul>
<hr />
<h3 id="加密通信">3. 加密通信</h3>
<p>握手完成后，客户端和服务器用协商好的对称密钥（比如 AES）加密所有 HTTP
数据，包括请求和响应，确保通信内容不被窃听或篡改。</p>
<hr />
<h3 id="流程图-2">流程图</h3>
<pre><code class="highlight mermaid">sequenceDiagram
    participant C as 客户端
    participant S as 服务器

    %% TCP 三次握手
    C-&gt;&gt;S: SYN (Seq = x)
    S--&gt;&gt;C: SYN-ACK (Seq = y, Ack = x + 1)
    C-&gt;&gt;S: ACK (Ack = y + 1)
    Note right of S: TCP 连接建立

    %% TLS 握手
    C-&gt;&gt;S: Client Hello&lt;br&gt;(版本、算法、Client Random)
    S--&gt;&gt;C: Server Hello&lt;br&gt;(版本、算法、Server Random、证书)
    C-&gt;&gt;C: 验证证书
    C-&gt;&gt;S: Pre-Master Secret&lt;br&gt;(用公钥加密)
    Note over C,S: 双方计算对称密钥
    C-&gt;&gt;S: Finished&lt;br&gt;(加密)
    S--&gt;&gt;C: Finished&lt;br&gt;(加密)
    Note right of S: TLS 握手完成

    %% 加密通信
    C-&gt;&gt;S: HTTP 请求 (加密)
    S--&gt;&gt;C: HTTP 响应 (加密)</code></pre>
<h3 id="完整流程总结">完整流程总结</h3>
<ol type="1">
<li><strong>TCP 三次握手</strong>：建立底层连接（SYN → SYN-ACK →
ACK）。</li>
<li><strong>TLS 握手</strong>：
<ul>
<li>协商版本和算法（Client Hello ↔︎ Server Hello）。</li>
<li>验证服务器身份（证书）。</li>
<li>交换密钥材料并生成对称密钥。</li>
<li>双方确认握手完成（Finished）。</li>
</ul></li>
<li><strong>加密通信</strong>：用对称密钥保护后续 HTTP 数据。</li>
</ol>
<hr />
<h3 id="为什么这么设计">为什么这么设计？</h3>
<ul>
<li><strong>安全性</strong>：证书验证防中间人攻击，加密保护数据隐私。</li>
<li><strong>效率</strong>：对称加密（通信阶段）比非对称加密（握手阶段）快，结合使用兼顾安全和性能。</li>
<li><strong>灵活性</strong>：支持多种算法和版本，适应不同场景。</li>
</ul>
<hr />
<h2 id="https-连接过程中使用对称和非对称加密的场景">Https
连接过程中使用对称和非对称加密的场景</h2>
<p>在 HTTPS
的连接过程中，对称加密和非对称加密各司其职，用在不同的阶段。下面我详细说明
HTTPS（包括 TCP 握手和 TLS 握手）中这两类加密的用途和具体位置：</p>
<hr />
<h3 id="对称加密和非对称加密的定义">对称加密和非对称加密的定义</h3>
<ul>
<li><strong>对称加密</strong>：加密和解密用同一个密钥（如
AES、ChaCha20），速度快，适合大数据量加密。</li>
<li><strong>非对称加密</strong>：使用一对密钥（公钥加密，私钥解密，或反之），如
RSA、ECC，速度慢但安全，用于密钥交换或身份验证。</li>
</ul>
<hr />
<h3 id="https-连接过程中加密的使用">HTTPS 连接过程中加密的使用</h3>
<h4 id="tcp-三次握手-1">1. TCP 三次握手</h4>
<ul>
<li><strong>加密使用</strong>：无<br />
TCP 三次握手（SYN → SYN-ACK →
ACK）只是建立连接，不涉及任何加密。对称和非对称加密都不在这里使用，数据是明文传输的。</li>
</ul>
<h4 id="tls-握手-1">2. TLS 握手</h4>
<p>TLS 握手是 HTTPS 的核心，这里会用到 <strong>非对称加密</strong> 和
<strong>对称加密的准备工作</strong>：</p>
<ul>
<li><strong>步骤 1：Client Hello</strong>
<ul>
<li><strong>加密使用</strong>：无<br />
客户端发送支持的版本、算法和 Client
Random，这些是明文传输的，没有加密。</li>
</ul></li>
<li><strong>步骤 2：Server Hello</strong>
<ul>
<li><strong>加密使用</strong>：无<br />
服务器返回版本、算法、Server Random
和证书，同样是明文。证书包含公钥，但此时还没用它加密数据。</li>
</ul></li>
<li><strong>步骤 3：证书验证</strong>
<ul>
<li><strong>加密使用</strong>：无（但涉及非对称加密的验证）<br />
客户端验证证书时，检查 CA 的数字签名。签名是用 CA
的私钥对证书内容加密生成的，客户端用 CA
的公钥解密验证。这是非对称加密的应用，但属于证书本身的验证过程，不是客户端和服务器之间的通信加密。</li>
</ul></li>
<li><strong>步骤 4：密钥交换</strong>
<ul>
<li><strong>非对称加密</strong>：这里是主要使用场景
<ul>
<li>客户端生成 Pre-Master
Secret，用服务器证书中的公钥（非对称加密算法，如
RSA）加密后发送给服务器。</li>
<li>服务器用自己的私钥解密，拿到 Pre-Master Secret。</li>
<li>双方用 Client Random、Server Random 和 Pre-Master Secret
通过密钥派生函数（如 HMAC）生成对称密钥（Master Secret）。</li>
<li>（注：如果是 TLS 1.3，使用 Diffie-Hellman 密钥交换，不直接用 RSA
加密 Pre-Master
Secret，但仍是非对称加密的一种变体，确保密钥安全交换。）</li>
</ul></li>
<li><strong>作用</strong>：非对称加密保护 Pre-Master Secret
的传输，避免被窃听。对称密钥还未使用。</li>
</ul></li>
<li><strong>步骤 5：完成握手</strong>
<ul>
<li><strong>对称加密</strong>：首次使用
<ul>
<li>客户端发送 “Finished” 消息，用刚刚生成的对称密钥（如
AES）加密，包含握手数据的校验值。</li>
<li>服务器收到后用相同的对称密钥解密，验证一致性。</li>
<li>服务器也发送 “Finished” 消息，同样用对称密钥加密。</li>
</ul></li>
<li><strong>作用</strong>：对称加密确认双方密钥一致，并保护握手结束消息。这是
TLS 握手中对称加密的起点。</li>
</ul></li>
</ul>
<h4 id="加密通信-1">3. 加密通信</h4>
<ul>
<li><strong>对称加密</strong>：主要使用场景
<ul>
<li>TLS 握手完成后，客户端和服务器用协商好的对称密钥（如
AES_256_GCM）加密所有 HTTP 请求和响应数据。</li>
<li>比如，客户端发送 <code>GET /index.html</code>，服务器返回 HTML
内容，全程用对称密钥加密和解密。</li>
</ul></li>
<li><strong>作用</strong>：对称加密速度快，适合大数据量传输，确保通信内容保密。</li>
</ul>
<hr />
<h3 id="对称加密和非对称加密的分工">对称加密和非对称加密的分工</h3>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 34%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>阶段</th>
<th>对称加密</th>
<th>非对称加密</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>TCP 三次握手</strong></td>
<td>无</td>
<td>无</td>
</tr>
<tr class="even">
<td><strong>Client Hello</strong></td>
<td>无</td>
<td>无</td>
</tr>
<tr class="odd">
<td><strong>Server Hello</strong></td>
<td>无</td>
<td>无（证书签名验证用非对称，但不算通信）</td>
</tr>
<tr class="even">
<td><strong>证书验证</strong></td>
<td>无</td>
<td>用于验证 CA 签名</td>
</tr>
<tr class="odd">
<td><strong>密钥交换</strong></td>
<td>生成对称密钥，但尚未使用</td>
<td>用于加密 Pre-Master Secret</td>
</tr>
<tr class="even">
<td><strong>完成握手</strong></td>
<td>用对称密钥加密 Finished 消息</td>
<td>无</td>
</tr>
<tr class="odd">
<td><strong>加密通信</strong></td>
<td>用对称密钥加密所有 HTTP 数据</td>
<td>无</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="为什么这样分工">为什么这样分工？</h3>
<ol type="1">
<li><strong>非对称加密</strong>：
<ul>
<li><strong>用处</strong>：密钥交换和身份验证（证书）。</li>
<li><strong>原因</strong>：非对称加密安全但慢，只用来传输少量数据（如
Pre-Master Secret，几十字节），避免直接暴露对称密钥。</li>
</ul></li>
<li><strong>对称加密</strong>：
<ul>
<li><strong>用处</strong>：保护握手完成消息和后续通信。</li>
<li><strong>原因</strong>：对称加密快，适合加密大量数据（如网页内容、视频流），但需要先安全交换密钥。</li>
</ul></li>
</ol>
<hr />
<h2 id="浏览器输入-url-后发生了什么">浏览器输入 Url 后发生了什么</h2>
<p>当你在浏览器输入一个 URL（比如
<code>https://www.example.com</code>）并按下回车后，浏览器会触发一系列复杂的步骤，从解析
URL
到最终渲染页面。以下是详细的过程，我会尽量清晰地分解每个环节，包括网络通信、DNS
解析、HTTPS 连接、页面加载和渲染等。</p>
<hr />
<h3 id="url-解析">1. URL 解析</h3>
<ul>
<li><strong>输入处理</strong>：<br />
浏览器首先检查你输入的 URL 是否合法。如果缺少协议（如
<code>www.example.com</code>），浏览器会默认补全为
<code>https://</code>（现代浏览器优先 HTTPS）。</li>
<li><strong>分解 URL</strong>：<br />
URL 被拆成几个部分：
<ul>
<li>协议：<code>https</code></li>
<li>域名：<code>www.example.com</code></li>
<li>路径：默认 <code>/</code>（如果没指定）</li>
<li>参数/锚点：如 <code>?id=123</code> 或
<code>#section1</code>（可选）</li>
</ul></li>
</ul>
<hr />
<h3 id="dns-解析">2. DNS 解析</h3>
<ul>
<li><strong>检查缓存</strong>：<br />
浏览器先查看本地缓存（浏览器缓存、操作系统缓存）是否有
<code>www.example.com</code> 的 IP 地址记录。如果有，直接使用。</li>
<li><strong>发起 DNS 请求</strong>：<br />
如果缓存没找到：
<ol type="1">
<li>浏览器向操作系统的 DNS 客户端（通常通过 <code>getaddrinfo</code>
调用）请求解析。</li>
<li>系统检查 hosts 文件（如 <code>/etc/hosts</code>）。</li>
<li>如果没有，系统向配置的 DNS 服务器（通常是路由器或 ISP
提供的）发送查询。</li>
</ol></li>
<li><strong>递归解析</strong>：<br />
DNS 服务器执行递归查询：
<ul>
<li>查询根域名服务器（<code>.</code>），获取 <code>.com</code>
的顶级域名服务器地址。</li>
<li>查询 <code>.com</code> 服务器，获取 <code>example.com</code>
的权威服务器地址。</li>
<li>查询 <code>example.com</code> 服务器，获取
<code>www.example.com</code> 的 IP 地址（如
<code>93.184.216.34</code>）。</li>
</ul></li>
<li><strong>返回 IP</strong>：<br />
DNS 服务器将 IP 返回给浏览器，通常还会附带
TTL（生存时间），供缓存使用。</li>
</ul>
<hr />
<h3 id="建立-tcp-连接">3. 建立 TCP 连接</h3>
<ul>
<li><strong>目标</strong>：浏览器拿到 IP
后，向服务器（<code>93.184.216.34</code>）的 443 端口（HTTPS
默认端口）发起连接。</li>
<li><strong>三次握手</strong>：
<ol type="1">
<li>客户端发送 SYN 包（<code>Seq = x</code>）。</li>
<li>服务器回复 SYN-ACK（<code>Seq = y, Ack = x + 1</code>）。</li>
<li>客户端发送 ACK（<code>Ack = y + 1</code>）。</li>
</ol>
<ul>
<li>完成后，TCP 连接建立，双向通信通道就绪。</li>
</ul></li>
</ul>
<hr />
<h3 id="tls-握手https-特有">4. TLS 握手（HTTPS 特有）</h3>
<p>因为是 <code>https://</code>，需要建立加密通道： - <strong>Client
Hello</strong>：<br />
客户端发送支持的 TLS 版本（如 TLS 1.3）、加密算法和随机数（Client
Random）。 - <strong>Server Hello</strong>：<br />
服务器返回选定的版本、算法、随机数（Server Random）和证书（含公钥）。 -
<strong>证书验证</strong>：<br />
客户端用 CA 公钥验证证书，确保服务器身份可信。 -
<strong>密钥交换</strong>：<br />
- 客户端生成 Pre-Master Secret，用服务器公钥加密后发送。 -
双方计算对称密钥（Master Secret）。 - <strong>完成握手</strong>：<br />
- 双方用对称密钥发送 “Finished” 消息，确认握手成功。 -
<strong>结果</strong>：安全通道建立，通信加密。</p>
<hr />
<h3 id="发送-http-请求">5. 发送 HTTP 请求</h3>
<ul>
<li><strong>构造请求</strong>：<br />
浏览器生成 HTTP 请求： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 ...</span><br><span class="line">Accept: text/html, ...</span><br></pre></td></tr></table></figure></li>
<li><strong>加密发送</strong>：<br />
请求用 TLS 对称密钥（如 AES）加密，通过 TCP 发送到服务器。</li>
</ul>
<hr />
<h3 id="服务器处理请求">6. 服务器处理请求</h3>
<ul>
<li><strong>接收和解密</strong>：<br />
服务器用对称密钥解密请求。</li>
<li><strong>处理逻辑</strong>：
<ul>
<li>Web 服务器（如 Nginx、Apache）解析请求。</li>
<li>如果是动态页面，可能调用后端代码（如 PHP、Java）生成响应。</li>
<li>如果是静态文件，直接读取（如 <code>index.html</code>）。</li>
</ul></li>
<li><strong>生成响应</strong>：<br />
服务器返回 HTTP 响应： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1234</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="接收和解析-http-响应">7. 接收和解析 HTTP 响应</h3>
<ul>
<li><strong>接收数据</strong>：<br />
浏览器通过 TCP 接收加密响应，用对称密钥解密。</li>
<li><strong>检查状态码</strong>：
<ul>
<li><code>200 OK</code>：正常，继续处理。</li>
<li><code>301/302</code>：重定向，跳转到新 URL。</li>
<li><code>404</code>：页面不存在，显示错误。</li>
</ul></li>
<li><strong>解析 HTML</strong>：
<ul>
<li>浏览器将 HTML 交给渲染引擎（如 WebKit、Blink），构建 DOM
树（Document Object Model）。</li>
</ul></li>
</ul>
<hr />
<h3 id="资源加载">8. 资源加载</h3>
<ul>
<li><strong>发现资源</strong>：<br />
解析 HTML 时，遇到
<code>&lt;link&gt;</code>（CSS）、<code>&lt;script&gt;</code>（JS）、<code>&lt;img&gt;</code>（图片）等标签，触发额外请求。</li>
<li><strong>并行请求</strong>：<br />
浏览器为每个资源重复步骤
3-7（DNS、TCP、TLS、HTTP），通常并行处理（现代浏览器支持 6-8
个并发连接）。</li>
<li><strong>缓存检查</strong>：<br />
如果资源有缓存（如通过 <code>Cache-Control</code> 或
<code>ETag</code>），可能直接使用本地副本。</li>
</ul>
<hr />
<h3 id="页面渲染">9. 页面渲染</h3>
<ul>
<li><strong>构建 DOM 和 CSSOM</strong>：
<ul>
<li>DOM 树：从 HTML 解析出节点树。</li>
<li>CSSOM 树：从 CSS 解析出样式树。</li>
</ul></li>
<li><strong>合并渲染树</strong>：<br />
将 DOM 和 CSSOM 结合，生成渲染树（只包含可见元素）。</li>
<li><strong>布局（Layout）</strong>：<br />
计算每个元素的位置和大小（Reflow）。</li>
<li><strong>绘制（Paint）</strong>：<br />
将渲染树转为像素，生成图层。</li>
<li><strong>合成（Composite）</strong>：<br />
将图层组合，交给 GPU 显示到屏幕。</li>
</ul>
<hr />
<h3 id="执行-javascript">10. 执行 JavaScript</h3>
<ul>
<li><strong>加载 JS</strong>：<br />
<code>&lt;script&gt;</code> 执行时，可能修改 DOM 或 CSSOM。</li>
<li><strong>重新渲染</strong>：<br />
JS 动态更改会导致重布局或重绘制。</li>
<li><strong>事件监听</strong>：<br />
绑定交互逻辑（如点击事件），等待用户操作。</li>
</ul>
<hr />
<h3 id="完整流程总结-1">完整流程总结</h3>
<ol type="1">
<li><strong>URL 解析</strong>：分解协议、域名、路径。</li>
<li><strong>DNS 解析</strong>：域名 → IP。</li>
<li><strong>TCP 连接</strong>：三次握手。</li>
<li><strong>TLS 握手</strong>：建立 HTTPS 安全通道。</li>
<li><strong>HTTP 请求</strong>：发送请求。</li>
<li><strong>服务器响应</strong>：处理并返回数据。</li>
<li><strong>解析响应</strong>：解密并构建 DOM。</li>
<li><strong>资源加载</strong>：下载 CSS、JS、图片。</li>
<li><strong>渲染页面</strong>：布局、绘制、合成。</li>
<li><strong>执行 JS</strong>：动态交互。</li>
</ol>
<hr />

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Bruce Yao
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://cmder.github.io/Android/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.html" title="Android 应用开发">https://cmder.github.io/Android/应用开发/Android-应用开发.html</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%99%E8%82%B2.html" rel="prev" title="什么是教育">
                  <i class="fa fa-angle-left"></i> 什么是教育
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E6%88%91.html" rel="next" title="我">
                  我 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2022 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bruce Yao</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/cmder" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: false,
  label: '🌓',
  autoMatchOsTheme: false
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
if (window.darkmode && !window.darkmode.isActivated()) {
  window.darkmode.toggle();
  var toggleButtons = document.getElementsByClassName("darkmode-toggle");
  if (toggleButtons && toggleButtons.length > 0) {
    for (i = 0; i < toggleButtons.length; i++) {
      toggleButtons[i].classList.add("darkmode-toggle--white");
    }
  }
}
</script>

</body>
</html>
