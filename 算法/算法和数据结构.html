<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cmder.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="知识树">
<meta property="og:type" content="article">
<meta property="og:title" content="算法和数据结构">
<meta property="og:url" content="https://cmder.github.io/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">
<meta property="og:site_name" content="说码解字">
<meta property="og:description" content="知识树">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-09T03:05:57.000Z">
<meta property="article:modified_time" content="2025-10-14T14:00:23.767Z">
<meta property="article:author" content="Bruce Yao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://cmder.github.io/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://cmder.github.io/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","path":"算法/算法和数据结构.html","title":"算法和数据结构"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>算法和数据结构 | 说码解字</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"forest","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">说码解字</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">知识树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">基础数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.1.1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE-linear-search"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">1. 线性查找 (Linear Search)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-binary-search"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">2. 二分查找 (Binary Search)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-bubble-sort"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">3. 冒泡排序 (Bubble Sort)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">4. 快速排序 (Quick Sort)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%8F%8D%E8%BD%AC-reverse-array"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">5. 数组反转 (Reverse Array)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC-find-maximum"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">6. 查找最大值 (Find Maximum)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-remove-duplicates-from-sorted-array"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">7.
删除重复元素 (Remove Duplicates from Sorted Array)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84-rotate-array"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">8. 旋转数组 (Rotate Array)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-two-sum"><span class="nav-number">2.1.1.9.</span> <span class="nav-text">9. 两数之和 (Two Sum)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-merge-sort"><span class="nav-number">2.1.1.10.</span> <span class="nav-text">10. 归并排序 (Merge Sort)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C-prefix-sum"><span class="nav-number">2.1.1.11.</span> <span class="nav-text">11. 前缀和 (Prefix Sum)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-sliding-window-maximum"><span class="nav-number">2.1.1.12.</span> <span class="nav-text">12. 滑动窗口最大值
(Sliding Window Maximum)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-merge-two-sorted-arrays"><span class="nav-number">2.1.1.13.</span> <span class="nav-text">13. 合并两个有序数组
(Merge Two Sorted Arrays)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%AC-k-%E5%A4%A7%E5%85%83%E7%B4%A0-kth-largest-element"><span class="nav-number">2.1.1.14.</span> <span class="nav-text">14. 数组中第 k 大元素
(Kth Largest Element)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%E9%9B%B6-move-zeroes"><span class="nav-number">2.1.1.15.</span> <span class="nav-text">15. 数组元素移动零 (Move
Zeroes)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.1.1.</span> <span class="nav-text">1. 定义单链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.1.2.</span> <span class="nav-text">2. 遍历链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.1.3.</span> <span class="nav-text">3. 反转链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4"><span class="nav-number">2.1.2.1.4.</span> <span class="nav-text">4. 反转链表指定区间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.1.5.</span> <span class="nav-text">5. 合并两个有序链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%8E%AF"><span class="nav-number">2.1.2.1.6.</span> <span class="nav-text">6. 检测链表中的环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.2.1.7.</span> <span class="nav-text">7. 删除链表中的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.2.1.8.</span> <span class="nav-text">8. 查找中间节点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">双链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.2.2.1.</span> <span class="nav-text">1. 双链表节点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB"><span class="nav-number">2.1.2.2.2.</span> <span class="nav-text">2. 双链表基本类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%A4%B4%E9%83%A8%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.2.2.3.</span> <span class="nav-text">3. 在头部添加节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%B0%BE%E9%83%A8%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.2.2.4.</span> <span class="nav-text">4. 在尾部添加节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.2.2.5.</span> <span class="nav-text">5. 删除指定值的第一个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.2.6.</span> <span class="nav-text">6. 打印链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.2.7.</span> <span class="nav-text">7. 反转双链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9-1"><span class="nav-number">2.1.2.2.8.</span> <span class="nav-text">8. 查找中间节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.1.2.2.9.</span> <span class="nav-text">9. 检测循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.2.10.</span> <span class="nav-text">10. 合并两个有序双链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.2.2.11.</span> <span class="nav-text">11. 使用示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">单向循环链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.2.3.1.</span> <span class="nav-text">1. 循环链表节点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB"><span class="nav-number">2.1.2.3.2.</span> <span class="nav-text">2. 循环链表基本类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%B0%BE%E9%83%A8%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9-1"><span class="nav-number">2.1.2.3.3.</span> <span class="nav-text">3. 在尾部添加节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%A4%B4%E9%83%A8%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9-1"><span class="nav-number">2.1.2.3.4.</span> <span class="nav-text">4. 在头部添加节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9-1"><span class="nav-number">2.1.2.3.5.</span> <span class="nav-text">5. 删除指定值的第一个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.3.6.</span> <span class="nav-text">6. 打印循环链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%BE%AA%E7%8E%AF%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%E5%BD%A2%E6%88%90%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.3.7.</span> <span class="nav-text">7.
检测循环（验证是否正确形成循环链表）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6"><span class="nav-number">2.1.2.3.8.</span> <span class="nav-text">8. 查找链表长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E4%B8%BA%E4%B8%A4%E4%B8%AA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.3.9.</span> <span class="nav-text">9. 分割循环链表为两个循环链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">2.1.2.3.10.</span> <span class="nav-text">使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">2.1.3.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">1. 基于数组的栈实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.3.1.1.</span> <span class="nav-text">栈的基本类（数组实现）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E6%A0%88push"><span class="nav-number">2.1.3.1.2.</span> <span class="nav-text">1.1 入栈（push）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E6%A0%88pop"><span class="nav-number">2.1.3.1.3.</span> <span class="nav-text">1.2 出栈（pop）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0peek"><span class="nav-number">2.1.3.1.4.</span> <span class="nav-text">1.3 查看栈顶元素（peek）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="nav-number">2.1.3.1.5.</span> <span class="nav-text">1.4 判断栈是否为空</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E5%B7%B2%E6%BB%A1"><span class="nav-number">2.1.3.1.6.</span> <span class="nav-text">1.5 判断栈是否已满</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">2. 基于链表的栈实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.3.2.1.</span> <span class="nav-text">栈节点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.3.2.2.</span> <span class="nav-text">栈的基本类（链表实现）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E6%A0%88push-1"><span class="nav-number">2.1.3.2.3.</span> <span class="nav-text">2.1 入栈（push）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E6%A0%88pop-1"><span class="nav-number">2.1.3.2.4.</span> <span class="nav-text">2.2 出栈（pop）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0peek-1"><span class="nav-number">2.1.3.2.5.</span> <span class="nav-text">2.3 查看栈顶元素（peek）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-1"><span class="nav-number">2.1.3.2.6.</span> <span class="nav-text">2.4 判断栈是否为空</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">3. 栈的常用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E6%A0%88"><span class="nav-number">2.1.3.3.1.</span> <span class="nav-text">3.1 反转栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="nav-number">2.1.3.3.2.</span> <span class="nav-text">3.2 检查括号匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.1.3.3.3.</span> <span class="nav-text">3.3
计算后缀表达式（逆波兰表达式）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88%E8%8E%B7%E5%8F%96%E6%A0%88%E4%B8%AD%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="nav-number">2.1.3.3.4.</span> <span class="nav-text">3.4 最小栈（获取栈中最小元素）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">2.1.4.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">1. 基于数组的队列实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.4.1.1.</span> <span class="nav-text">队列的基本类（数组实现）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E9%98%9Fenqueue"><span class="nav-number">2.1.4.1.2.</span> <span class="nav-text">1.1 入队（enqueue）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E9%98%9Fdequeue"><span class="nav-number">2.1.4.1.3.</span> <span class="nav-text">1.2 出队（dequeue）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0peek"><span class="nav-number">2.1.4.1.4.</span> <span class="nav-text">1.3 查看队首元素（peek）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="nav-number">2.1.4.1.5.</span> <span class="nav-text">1.4 判断队列是否为空</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E5%B7%B2%E6%BB%A1"><span class="nav-number">2.1.4.1.6.</span> <span class="nav-text">1.5 判断队列是否已满</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">2. 基于链表的队列实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.4.2.1.</span> <span class="nav-text">队列节点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.4.2.2.</span> <span class="nav-text">队列的基本类（链表实现）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E9%98%9Fenqueue-1"><span class="nav-number">2.1.4.2.3.</span> <span class="nav-text">2.1 入队（enqueue）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E9%98%9Fdequeue-1"><span class="nav-number">2.1.4.2.4.</span> <span class="nav-text">2.2 出队（dequeue）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0peek-1"><span class="nav-number">2.1.4.2.5.</span> <span class="nav-text">2.3 查看队首元素（peek）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-1"><span class="nav-number">2.1.4.2.6.</span> <span class="nav-text">2.4 判断队列是否为空</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">3. 队列的常用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96"><span class="nav-number">2.1.4.3.1.</span> <span class="nav-text">3.1 循环队列（基于数组优化）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque"><span class="nav-number">2.1.4.3.2.</span> <span class="nav-text">3.2 双端队列（Deque）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%9C%80%E5%B0%8F%E5%A0%86%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.4.3.3.</span> <span class="nav-text">3.3 优先队列（最小堆实现）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">树形结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.1.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">普通二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.1.1.1.</span> <span class="nav-text">二叉树节点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-preorder-traversal"><span class="nav-number">2.2.1.1.2.</span> <span class="nav-text">1. 前序遍历 (Preorder
Traversal)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-inorder-traversal"><span class="nav-number">2.2.1.1.3.</span> <span class="nav-text">2. 中序遍历 (Inorder Traversal)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-postorder-traversal"><span class="nav-number">2.2.1.1.4.</span> <span class="nav-text">3. 后序遍历 (Postorder
Traversal)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-level-order-traversal"><span class="nav-number">2.2.1.1.5.</span> <span class="nav-text">4. 层序遍历 (Level Order
Traversal)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6-maximum-depth"><span class="nav-number">2.2.1.1.6.</span> <span class="nav-text">5. 计算二叉树深度 (Maximum
Depth)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-check-balanced-binary-tree"><span class="nav-number">2.2.1.1.7.</span> <span class="nav-text">6.
判断是否平衡二叉树 (Check Balanced Binary Tree)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-path-sum"><span class="nav-number">2.2.1.1.8.</span> <span class="nav-text">7. 二叉树路径总和 (Path Sum)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-invert-binary-tree"><span class="nav-number">2.2.1.1.9.</span> <span class="nav-text">8. 反转二叉树 (Invert Binary
Tree)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%AA%8C%E8%AF%81-validate-binary-search-tree"><span class="nav-number">2.2.1.1.10.</span> <span class="nav-text">9. 二叉搜索树验证
(Validate Binary Search Tree)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-lowest-common-ancestor"><span class="nav-number">2.2.1.1.11.</span> <span class="nav-text">10. 最低公共祖先 (Lowest
Common Ancestor)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92preorder-traversal---iterative"><span class="nav-number">2.2.1.1.12.</span> <span class="nav-text">11.
前序遍历（非递归）(Preorder Traversal - Iterative)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92inorder-traversal---iterative"><span class="nav-number">2.2.1.1.13.</span> <span class="nav-text">12.
中序遍历（非递归）(Inorder Traversal - Iterative)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92postorder-traversal---iterative"><span class="nav-number">2.2.1.1.14.</span> <span class="nav-text">13.
后序遍历（非递归）(Postorder Traversal - Iterative)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92level-order-traversal---iterative"><span class="nav-number">2.2.1.1.15.</span> <span class="nav-text">14.
层序遍历（非递归）(Level Order Traversal - Iterative)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-binary-search-tree-bst"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">二叉搜索树 (Binary Search
Tree, BST)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="nav-number">2.2.1.2.1.</span> <span class="nav-text">结构图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.1.2.2.</span> <span class="nav-text">1. 二叉搜索树节点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%B1%BB"><span class="nav-number">2.2.1.2.3.</span> <span class="nav-text">2. 二叉搜索树基本类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.1.2.4.</span> <span class="nav-text">3. 二叉搜索树常用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.1.2.4.1.</span> <span class="nav-text">3.1 插入节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.1.2.4.2.</span> <span class="nav-text">3.2 删除节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.1.2.4.3.</span> <span class="nav-text">3.3 查找节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86preorder-traversal"><span class="nav-number">2.2.1.2.4.4.</span> <span class="nav-text">3.4 前序遍历（Preorder
Traversal）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86inorder-traversal"><span class="nav-number">2.2.1.2.4.5.</span> <span class="nav-text">3.5 中序遍历（Inorder
Traversal）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86postorder-traversal"><span class="nav-number">2.2.1.2.4.6.</span> <span class="nav-text">3.6 后序遍历（Postorder
Traversal）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">2.2.1.2.4.7.</span> <span class="nav-text">3.7 查找最小值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">2.2.1.2.4.8.</span> <span class="nav-text">3.8 查找最大值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="nav-number">2.2.1.2.4.9.</span> <span class="nav-text">3.9 计算树的高度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84bst"><span class="nav-number">2.2.1.2.4.10.</span> <span class="nav-text">3.10 验证是否是有效的BST</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-4"><span class="nav-number">2.2.1.2.5.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">2.2.1.2.6.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#avl%E6%A0%91-%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">2.2.1.3.1.</span> <span class="nav-text">AVL树 (自平衡二叉搜索树)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#avl-%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.1.3.1.1.</span> <span class="nav-text">AVL 树节点定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#avl-%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%B1%BB"><span class="nav-number">2.2.1.3.1.2.</span> <span class="nav-text">AVL 树基本类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E9%AB%98%E5%BA%A6"><span class="nav-number">2.2.1.3.1.3.</span> <span class="nav-text">获取节点高度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90"><span class="nav-number">2.2.1.3.1.4.</span> <span class="nav-text">获取平衡因子</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9%E9%AB%98%E5%BA%A6"><span class="nav-number">2.2.1.3.1.5.</span> <span class="nav-text">更新节点高度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%B3%E6%97%8B%E8%BD%ACright-rotation"><span class="nav-number">2.2.1.3.1.6.</span> <span class="nav-text">右旋转（Right Rotation）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%ACleft-rotation"><span class="nav-number">2.2.1.3.1.7.</span> <span class="nav-text">左旋转（Left Rotation）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-1"><span class="nav-number">2.2.1.3.1.8.</span> <span class="nav-text">插入节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-1"><span class="nav-number">2.2.1.3.1.9.</span> <span class="nav-text">删除节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9-1"><span class="nav-number">2.2.1.3.1.10.</span> <span class="nav-text">查找节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86inorder-traversal-1"><span class="nav-number">2.2.1.3.1.11.</span> <span class="nav-text">中序遍历（Inorder Traversal）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81-avl-%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="nav-number">2.2.1.3.1.12.</span> <span class="nav-text">验证 AVL 树性质</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-5"><span class="nav-number">2.2.1.3.1.13.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-1"><span class="nav-number">2.2.1.3.1.14.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91-red-black-tree"><span class="nav-number">2.2.1.3.2.</span> <span class="nav-text">红黑树 (Red-Black Tree)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.1.3.2.1.</span> <span class="nav-text">红黑树节点定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%B1%BB"><span class="nav-number">2.2.1.3.2.2.</span> <span class="nav-text">红黑树基本类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%ACleft-rotation-1"><span class="nav-number">2.2.1.3.2.3.</span> <span class="nav-text">左旋转（Left Rotation）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%B3%E6%97%8B%E8%BD%ACright-rotation-1"><span class="nav-number">2.2.1.3.2.4.</span> <span class="nav-text">右旋转（Right Rotation）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-2"><span class="nav-number">2.2.1.3.2.5.</span> <span class="nav-text">插入节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-2"><span class="nav-number">2.2.1.3.2.6.</span> <span class="nav-text">删除节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9-2"><span class="nav-number">2.2.1.3.2.7.</span> <span class="nav-text">查找节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86inorder-traversal-2"><span class="nav-number">2.2.1.3.2.8.</span> <span class="nav-text">中序遍历（Inorder Traversal）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC-1"><span class="nav-number">2.2.1.3.2.9.</span> <span class="nav-text">查找最小值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-6"><span class="nav-number">2.2.1.3.2.10.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-2"><span class="nav-number">2.2.1.3.2.11.</span> <span class="nav-text">说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">完全二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.1.4.1.</span> <span class="nav-text">1. 完全二叉树节点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.1.4.2.</span> <span class="nav-text">2.
完全二叉树基本类（基于数组实现）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.1.4.3.</span> <span class="nav-text">3. 完全二叉树常用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5"><span class="nav-number">2.2.1.4.3.1.</span> <span class="nav-text">3.1 插入节点（尾部插入）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.1.4.3.2.</span> <span class="nav-text">3.2 删除最后一个节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%88%B6%E8%8A%82%E7%82%B9%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.1.4.3.3.</span> <span class="nav-text">3.3 获取父节点索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%B7%A6%E5%AD%90%E8%8A%82%E7%82%B9%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.1.4.3.4.</span> <span class="nav-text">3.4 获取左子节点索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%8F%B3%E5%AD%90%E8%8A%82%E7%82%B9%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.1.4.3.5.</span> <span class="nav-text">3.5 获取右子节点索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.1.4.3.6.</span> <span class="nav-text">3.6
检查是否为完全二叉树（基于链表实现）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6-1"><span class="nav-number">2.2.1.4.3.7.</span> <span class="nav-text">3.7 计算树的高度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86level-order-traversal"><span class="nav-number">2.2.1.4.3.8.</span> <span class="nav-text">3.8 层序遍历（Level Order
Traversal）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86%E5%8C%96heapify--%E6%9C%80%E5%B0%8F%E5%A0%86%E8%B0%83%E6%95%B4"><span class="nav-number">2.2.1.4.3.9.</span> <span class="nav-text">3.9 堆化（Heapify）- 最小堆调整</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="nav-number">2.2.1.4.3.10.</span> <span class="nav-text">3.10 构建最小堆</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%A0%86%E5%8C%96max-heapify"><span class="nav-number">2.2.1.4.3.11.</span> <span class="nav-text">3.11 最大堆化（Max Heapify）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%9C%80%E5%A4%A7%E5%A0%86"><span class="nav-number">2.2.1.4.3.12.</span> <span class="nav-text">3.12 构建最大堆</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%B9%B6%E8%B0%83%E6%95%B4%E4%B8%BA%E6%9C%80%E5%A4%A7%E5%A0%86"><span class="nav-number">2.2.1.4.3.13.</span> <span class="nav-text">3.13 插入并调整为最大堆</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%A7%E5%80%BC%E6%A0%B9%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.1.4.3.14.</span> <span class="nav-text">3.14 删除最大值（根节点）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-7"><span class="nav-number">2.2.1.4.4.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-3"><span class="nav-number">2.2.1.4.5.</span> <span class="nav-text">说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.2.</span> <span class="nav-text">多叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">多路平衡树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#b%E6%A0%91"><span class="nav-number">2.2.2.1.1.</span> <span class="nav-text">B树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.2.1.1.1.</span> <span class="nav-text">B 树节点定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%B1%BB"><span class="nav-number">2.2.2.1.1.2.</span> <span class="nav-text">B 树基本类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E9%94%AE"><span class="nav-number">2.2.2.1.1.3.</span> <span class="nav-text">搜索键</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E9%94%AE"><span class="nav-number">2.2.2.1.1.4.</span> <span class="nav-text">插入键</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%94%AE"><span class="nav-number">2.2.2.1.1.5.</span> <span class="nav-text">删除键</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.2.1.1.6.</span> <span class="nav-text">遍历（中序遍历）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-8"><span class="nav-number">2.2.2.1.1.7.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-4"><span class="nav-number">2.2.2.1.1.8.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E6%A0%91"><span class="nav-number">2.2.2.1.2.</span> <span class="nav-text">B+ 树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89-1"><span class="nav-number">2.2.2.1.2.1.</span> <span class="nav-text">B+ 树节点定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%B1%BB-1"><span class="nav-number">2.2.2.1.2.2.</span> <span class="nav-text">B+ 树基本类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E9%94%AE-1"><span class="nav-number">2.2.2.1.2.3.</span> <span class="nav-text">搜索键</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E9%94%AE-1"><span class="nav-number">2.2.2.1.2.4.</span> <span class="nav-text">插入键</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%94%AE-1"><span class="nav-number">2.2.2.1.2.5.</span> <span class="nav-text">删除键</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.2.2.1.2.6.</span> <span class="nav-text">范围查询</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E9%A1%BA%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.2.1.2.7.</span> <span class="nav-text">遍历（叶子节点顺序遍历）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-9"><span class="nav-number">2.2.2.1.2.8.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-5"><span class="nav-number">2.2.2.1.2.9.</span> <span class="nav-text">说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">Trie (前缀树)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#trie-%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.2.2.1.</span> <span class="nav-text">1. Trie 节点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trie-%E5%9F%BA%E6%9C%AC%E7%B1%BB"><span class="nav-number">2.2.2.2.2.</span> <span class="nav-text">2. Trie 基本类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trie-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.2.2.3.</span> <span class="nav-text">3. Trie 常用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.2.2.2.3.1.</span> <span class="nav-text">3.1 插入字符串</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E5%AE%8C%E6%95%B4%E5%8D%95%E8%AF%8D"><span class="nav-number">2.2.2.2.3.2.</span> <span class="nav-text">3.2 搜索完整单词</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%89%8D%E7%BC%80"><span class="nav-number">2.2.2.2.3.3.</span> <span class="nav-text">3.3 检查前缀</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.2.2.2.3.4.</span> <span class="nav-text">3.4 删除字符串</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%89%80%E6%9C%89%E4%BB%A5%E6%9F%90%E5%89%8D%E7%BC%80%E5%BC%80%E5%A4%B4%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-number">2.2.2.2.3.5.</span> <span class="nav-text">3.5 查找所有以某前缀开头的单词</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97-trie-%E4%B8%AD%E5%8D%95%E8%AF%8D%E6%80%BB%E6%95%B0"><span class="nav-number">2.2.2.2.3.6.</span> <span class="nav-text">3.6 计算 Trie 中单词总数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-10"><span class="nav-number">2.2.2.2.4.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-6"><span class="nav-number">2.2.2.2.5.</span> <span class="nav-text">说明</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">哈希结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">哈希表节点定义（链地址法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB"><span class="nav-number">2.3.2.</span> <span class="nav-text">哈希表基本类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-number">2.3.3.</span> <span class="nav-text">插入键值对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-number">2.3.4.</span> <span class="nav-text">查找键值对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-number">2.3.5.</span> <span class="nav-text">删除键值对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-number">2.3.6.</span> <span class="nav-text">检查键是否存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%94%AE"><span class="nav-number">2.3.7.</span> <span class="nav-text">获取所有键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E5%AE%B9%E9%87%8F%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="nav-number">2.3.8.</span> <span class="nav-text">调整容量（动态扩容）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-11"><span class="nav-number">2.3.9.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-7"><span class="nav-number">2.3.10.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81"><span class="nav-number">2.3.11.</span> <span class="nav-text">开放寻址法处理冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95%E9%80%9A%E7%94%A8"><span class="nav-number">2.3.11.1.</span> <span class="nav-text">哈希表基本类（开放寻址法通用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8Blinear-probing%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.11.2.</span> <span class="nav-text">线性探测（Linear Probing）实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8Bquadratic-probing%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.11.3.</span> <span class="nav-text">二次探测（Quadratic
Probing）实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E9%87%8D%E5%93%88%E5%B8%8Cdouble-hashing%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.11.4.</span> <span class="nav-text">双重哈希（Double Hashing）实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-12"><span class="nav-number">2.3.11.5.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-8"><span class="nav-number">2.3.11.6.</span> <span class="nav-text">说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.</span> <span class="nav-text">图结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">2.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.4.2.</span> <span class="nav-text">图的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">邻接矩阵表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">2.4.2.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">2.4.2.1.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.2.1.3.</span> <span class="nav-text">遍历算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-dfs"><span class="nav-number">2.4.2.1.3.1.</span> <span class="nav-text">1. 深度优先搜索 (DFS)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-bfs"><span class="nav-number">2.4.2.1.3.2.</span> <span class="nav-text">2. 广度优先搜索 (BFS)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-13"><span class="nav-number">2.4.2.1.4.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.2.1.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">邻接表表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-number">2.4.2.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">2.4.2.2.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">2.4.2.2.3.</span> <span class="nav-text">遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-dfs-1"><span class="nav-number">2.4.2.2.3.1.</span> <span class="nav-text">深度优先搜索 (DFS)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-bfs-1"><span class="nav-number">2.4.2.2.3.2.</span> <span class="nav-text">广度优先搜索 (BFS)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-14"><span class="nav-number">2.4.2.2.4.</span> <span class="nav-text">使用示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">总结对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.3.</span> <span class="nav-text">图的常见算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dijkstra%E9%9D%9E%E8%B4%9F%E6%9D%83%E5%9B%BEoe-log-v"><span class="nav-number">2.4.3.1.1.</span> <span class="nav-text">Dijkstra（非负权图，O(E log V)）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E7%8E%B0ov%C2%B2"><span class="nav-number">2.4.3.1.1.1.</span> <span class="nav-text">1. 邻接矩阵实现（O(V²)）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8-%E6%9C%80%E5%B0%8F%E5%A0%86%E5%AE%9E%E7%8E%B0oe-log-v"><span class="nav-number">2.4.3.1.1.2.</span> <span class="nav-text">2. 邻接表 + 最小堆实现（O(E log
V)）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.3.1.1.3.</span> <span class="nav-text">对比总结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bellman-ford%E6%94%AF%E6%8C%81%E8%B4%9F%E6%9D%83ove"><span class="nav-number">2.4.3.1.2.</span> <span class="nav-text">Bellman-Ford（支持负权，O(VE)）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E7%8E%B0ov%C2%B3"><span class="nav-number">2.4.3.1.2.1.</span> <span class="nav-text">1. 邻接矩阵实现（O(V³)）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AE%9E%E7%8E%B0ove"><span class="nav-number">2.4.3.1.2.2.</span> <span class="nav-text">2. 邻接表实现（O(VE)）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.4.3.1.2.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-mst"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">最小生成树 (MST)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#prim%E9%80%82%E5%90%88%E7%A8%A0%E5%AF%86%E5%9B%BE"><span class="nav-number">2.4.3.2.1.</span> <span class="nav-text">Prim（适合稠密图）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E7%8E%B0ov%C2%B2-1"><span class="nav-number">2.4.3.2.1.1.</span> <span class="nav-text">1. 邻接矩阵实现（O(V²)）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8-%E6%9C%80%E5%B0%8F%E5%A0%86%E5%AE%9E%E7%8E%B0oe-log-v-1"><span class="nav-number">2.4.3.2.1.2.</span> <span class="nav-text">2. 邻接表 + 最小堆实现（O(E log
V)）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94-1"><span class="nav-number">2.4.3.2.1.3.</span> <span class="nav-text">总结对比</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kruskal%E9%80%82%E5%90%88%E7%A8%80%E7%96%8F%E5%9B%BE%E7%BB%93%E5%90%88%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">2.4.3.2.2.</span> <span class="nav-text">Kruskal（适合稀疏图，结合并查集）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="nav-number">2.4.3.2.2.1.</span> <span class="nav-text">核心思路</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#java-%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.3.2.2.2.</span> <span class="nav-text">Java 实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E8%BE%93%E5%87%BA"><span class="nav-number">2.4.3.2.2.3.</span> <span class="nav-text">📌 示例输出</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94-mst-%E4%B8%89%E5%A4%A7%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.3.2.3.</span> <span class="nav-text">对比 MST 三大算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#kahn-%E7%AE%97%E6%B3%95bfs-%E5%85%A5%E5%BA%A6%E6%B3%95"><span class="nav-number">2.4.3.3.1.</span> <span class="nav-text">Kahn 算法（BFS 入度法）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dfs-%E9%80%86%E5%90%8E%E5%BA%8F"><span class="nav-number">2.4.3.3.2.</span> <span class="nav-text">DFS 逆后序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.4.3.3.3.</span> <span class="nav-text">对比总结</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.</span> <span class="nav-text">高级数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8-skip-list"><span class="nav-number">2.5.1.</span> <span class="nav-text">1. 跳表 (Skip List)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-union-find"><span class="nav-number">2.5.2.</span> <span class="nav-text">2. 并查集 (Union-Find)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91-segment-tree"><span class="nav-number">2.5.3.</span> <span class="nav-text">3. 线段树 (Segment Tree)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-fenwick-tree-binary-indexed-tree"><span class="nav-number">2.5.4.</span> <span class="nav-text">4. 树状数组 (Fenwick
Tree &#x2F; Binary Indexed Tree)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95sorting"><span class="nav-number">3.1.</span> <span class="nav-text">1. 排序算法（Sorting）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%90%9C%E7%B4%A2searching"><span class="nav-number">3.2.</span> <span class="nav-text">2. 查找与搜索（Searching）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E4%B8%8E%E9%80%92%E5%BD%92divide-and-conquer"><span class="nav-number">3.3.</span> <span class="nav-text">3. 分治与递归（Divide and
Conquer）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dynamic-programming-dp"><span class="nav-number">3.4.</span> <span class="nav-text">4. 动态规划（Dynamic
Programming, DP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95greedy"><span class="nav-number">3.5.</span> <span class="nav-text">5. 贪心算法（Greedy）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95graph-algorithms"><span class="nav-number">3.6.</span> <span class="nav-text">6. 图论算法（Graph Algorithms）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95string-algorithms"><span class="nav-number">3.7.</span> <span class="nav-text">7. 字符串算法（String
Algorithms）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%95%B0%E8%AE%BAmath-number-theory"><span class="nav-number">3.8.</span> <span class="nav-text">8. 数学与数论（Math &amp; Number
Theory）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3advanced-paradigms"><span class="nav-number">3.9.</span> <span class="nav-text">9. 高级算法思想（Advanced
Paradigms）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98"><span class="nav-number">3.10.</span> <span class="nav-text">10. 经典综合问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7algorithmic-techniques"><span class="nav-number">3.11.</span> <span class="nav-text">11. 算法技巧（Algorithmic
Techniques）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">3.12.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Yao"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Yao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cmder" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cmder" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cmd100000@gmail.com" title="E-Mail → mailto:cmd100000@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cmder.github.io/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Bruce Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="说码解字">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="算法和数据结构 | 说码解字">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法和数据结构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-09 11:05:57" itemprop="dateCreated datePublished" datetime="2025-03-09T11:05:57+08:00">2025-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-14 22:00:23" itemprop="dateModified" datetime="2025-10-14T22:00:23+08:00">2025-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="知识树">知识树</h1>
<pre><code class="highlight mermaid">graph LR
    A[算法与数据结构]
    
    A --&gt; B[数据结构]
    B --&gt; B1[线性结构]
    B1 --&gt; B1a[数组 Array]
    B1 --&gt; B1b[链表 Linked List]
    B1 --&gt; B1c[栈 Stack]
    B1 --&gt; B1d[队列 Queue]
    
    B --&gt; B2[树结构]
    B2 --&gt; B2a[二叉树 Binary Tree]
    B2 --&gt; B2b[二叉搜索树 BST]
    B2 --&gt; B2c[AVL 树]
    B2 --&gt; B2d[红黑树 Red-Black Tree]
    B2 --&gt; B2e[B 树 B-Tree]
    B2 --&gt; B2f[堆 Heap]
    B2 --&gt; B2g[Trie 前缀树]
    
    B --&gt; B3[图结构]
    B3 --&gt; B3a[有向图 Directed Graph]
    B3 --&gt; B3b[无向图 Undirected Graph]
    B3 --&gt; B3c[加权图 Weighted Graph]
    
    B --&gt; B4[集合结构]
    B4 --&gt; B4a[哈希表 Hash Table]
    B4 --&gt; B4b[集合 Set]
    B4 --&gt; B4c[位图 Bitmap]
    
    B --&gt; B5[其他结构]
    B5 --&gt; B5a[跳表 Skip List]
    B5 --&gt; B5b[并查集 Union-Find]
    B5 --&gt; B5c[线段树 Segment Tree]
    B5 --&gt; B5d[树状数组 Fenwick Tree]
    
    A --&gt; C[算法]
    C --&gt; C1[排序算法]
    C1 --&gt; C1a[冒泡排序 Bubble Sort]
    C1 --&gt; C1b[选择排序 Selection Sort]
    C1 --&gt; C1c[插入排序 Insertion Sort]
    C1 --&gt; C1d[快速排序 Quick Sort]
    C1 --&gt; C1e[归并排序 Merge Sort]
    C1 --&gt; C1f[堆排序 Heap Sort]
    C1 --&gt; C1g[计数排序 Counting Sort]
    
    C --&gt; C2[搜索算法]
    C2 --&gt; C2a[线性搜索 Linear Search]
    C2 --&gt; C2b[二分搜索 Binary Search]
    C2 --&gt; C2c[深度优先搜索 DFS]
    C2 --&gt; C2d[广度优先搜索 BFS]
    
    C --&gt; C3[图算法]
    C3 --&gt; C3a[最短路径 Dijkstra/Bellman-Ford]
    C3 --&gt; C3b[最小生成树 Prim/Kruskal]
    C3 --&gt; C3c[拓扑排序 Topological Sort]
    
    C --&gt; C4[动态规划 DP]
    C4 --&gt; C4a[背包问题 Knapsack]
    C4 --&gt; C4b[最长公共子序列 LCS]
    C4 --&gt; C4c[最长递增子序列 LIS]
    
    C --&gt; C5[贪心算法]
    C5 --&gt; C5a[活动选择 Activity Selection]
    C5 --&gt; C5b[哈夫曼编码 Huffman Coding]
    
    C --&gt; C6[分治算法]
    C6 --&gt; C6a[归并排序 Merge Sort]
    C6 --&gt; C6b[快速排序 Quick Sort]
    
    C --&gt; C7[数学与计算几何]
    C7 --&gt; C7a[最大公约数 GCD]
    C7 --&gt; C7b[快速幂 Fast Power]
    C7 --&gt; C7c[凸包 Convex Hull]
    
    C --&gt; C8[字符串算法]
    C8 --&gt; C8a[KMP 算法]
    C8 --&gt; C8b[Rabin-Karp]
    C8 --&gt; C8c[Manacher]
    
    C --&gt; C9[其他算法]
    C9 --&gt; C9a[随机化算法 Randomized]
    C9 --&gt; C9b[回溯算法 Backtracking]</code></pre>
<h1 id="数据结构">数据结构</h1>
<h2 id="基础数据结构">基础数据结构</h2>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 38%" />
<col style="width: 24%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>数据结构</th>
<th>特点</th>
<th>操作</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>数组 (Array)</strong></td>
<td>连续内存存储，固定大小，元素类型相同</td>
<td>随机访问：O(1)<br>插入/删除：O(n)</td>
<td>快速查找<br>静态数据存储</td>
</tr>
<tr class="even">
<td><strong>链表 (Linked List)</strong></td>
<td>非连续内存，动态大小，节点包含数据和指针<br>类型：单向链表、双向链表、循环链表</td>
<td>插入/删除：O(1)<br>查找：O(n)</td>
<td>频繁增删的场景（如LRU缓存）</td>
</tr>
<tr class="odd">
<td><strong>栈 (Stack)</strong></td>
<td>后进先出（LIFO），仅允许一端操作</td>
<td>入栈（push）：O(1)<br>出栈（pop）：O(1)</td>
<td>函数调用栈<br>括号匹配<br>表达式求值</td>
</tr>
<tr class="even">
<td><strong>队列 (Queue)</strong></td>
<td>先进先出（FIFO），允许两端操作<br>变种：双端队列（Deque）、优先队列（Priority
Queue）</td>
<td>入队/出队：O(1)（普通队列）</td>
<td>任务调度<br>广度优先搜索（BFS）</td>
</tr>
</tbody>
</table>
<h3 id="数组">数组</h3>
<h4 id="线性查找-linear-search">1. 线性查找 (Linear Search)</h4>
<ul>
<li><strong>功能描述</strong>：在数组中逐个检查元素，找到目标值并返回其索引，若不存在返回
-1。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">linearSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="二分查找-binary-search">2. 二分查找 (Binary Search)</h4>
<ul>
<li><strong>功能描述</strong>：在有序数组中通过不断折半查找目标值，返回其索引，若不存在返回
-1。</li>
<li><strong>时间复杂度</strong>：O(log n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="冒泡排序-bubble-sort">3. 冒泡排序 (Bubble Sort)</h4>
<ul>
<li><strong>功能描述</strong>：通过相邻元素两两比较并交换，将较大元素逐步“冒泡”到数组末尾，实现排序。</li>
<li><strong>时间复杂度</strong>：O(n²)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="快速排序-quick-sort">4. 快速排序 (Quick Sort)</h4>
<ul>
<li><strong>功能描述</strong>：选择一个基准值（pivot），将数组分区并递归排序，适用于大多数情况的高效排序算法。</li>
<li><strong>时间复杂度</strong>：O(n log n) 平均，O(n²) 最坏</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pi</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];</span><br><span class="line">    arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">    arr[high] = temp;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数组反转-reverse-array">5. 数组反转 (Reverse Array)</h4>
<ul>
<li><strong>功能描述</strong>：使用双指针从两端向中间交换元素，将数组顺序反转。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="查找最大值-find-maximum">6. 查找最大值 (Find Maximum)</h4>
<ul>
<li><strong>功能描述</strong>：遍历数组，比较每个元素，找出最大值。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Array is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="删除重复元素-remove-duplicates-from-sorted-array">7.
删除重复元素 (Remove Duplicates from Sorted Array)</h4>
<ul>
<li><strong>功能描述</strong>：在有序数组中删除重复元素，返回新长度，原地修改数组。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">writeIndex</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            arr[writeIndex] = arr[i];</span><br><span class="line">            writeIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> writeIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="旋转数组-rotate-array">8. 旋转数组 (Rotate Array)</h4>
<ul>
<li><strong>功能描述</strong>：将数组向右旋转 k
个位置，使用三次反转法实现。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k %= arr.length; <span class="comment">// 处理 k 大于数组长度的情况</span></span><br><span class="line">    reverse(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 反转整个数组</span></span><br><span class="line">    reverse(arr, <span class="number">0</span>, k - <span class="number">1</span>);          <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">    reverse(arr, k, arr.length - <span class="number">1</span>); <span class="comment">// 反转剩余元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="两数之和-two-sum">9. 两数之和 (Two Sum)</h4>
<ul>
<li><strong>功能描述</strong>：找到数组中两个元素的索引，其和等于目标值，使用哈希表优化。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] arr, <span class="type">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - arr[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(complement), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(arr[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;&#125;; <span class="comment">// 未找到返回空数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="归并排序-merge-sort">10. 归并排序 (Merge Sort)</h4>
<ul>
<li><strong>功能描述</strong>：使用分治法将数组分成小块，分别排序后合并，稳定且适用于大数据。</li>
<li><strong>时间复杂度</strong>：O(n log n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> right - mid;</span><br><span class="line">    <span class="type">int</span>[] leftArr = <span class="keyword">new</span> <span class="title class_">int</span>[n1];</span><br><span class="line">    <span class="type">int</span>[] rightArr = <span class="keyword">new</span> <span class="title class_">int</span>[n2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充临时数组</span></span><br><span class="line">    <span class="comment">// 将原数组的左子数组（arr[left..mid]）复制到 leftArr。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">        leftArr[i] = arr[left + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将原数组的右子数组（arr[mid+1..right]）复制到 rightArr。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n2; j++) &#123;</span><br><span class="line">        rightArr[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;</span><br><span class="line">            arr[k++] = leftArr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k++] = rightArr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k++] = leftArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k++] = rightArr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="前缀和-prefix-sum">11. 前缀和 (Prefix Sum)</h4>
<ul>
<li><strong>功能描述</strong>：计算数组的前缀和，用于快速求解子数组和的问题。</li>
<li><strong>时间复杂度</strong>：O(n) 预处理，O(1) 查询</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] prefixSum(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    prefix[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询子数组和 [left, right]</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSum</span><span class="params">(<span class="type">int</span>[] prefix, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix[right];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix[right] - prefix[left - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="滑动窗口最大值-sliding-window-maximum">12. 滑动窗口最大值
(Sliding Window Maximum)</h4>
<ul>
<li><strong>功能描述</strong>：使用双端队列在固定窗口大小 k
内找到每个窗口的最大值。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length - k + <span class="number">1</span>];</span><br><span class="line">    ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); <span class="comment">// 存储索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 移除超出窗口的元素</span></span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt;= i - k) &#123;</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除小于当前元素的值</span></span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; arr[deque.peekLast()] &lt; arr[i]) &#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offerLast(i);</span><br><span class="line">        <span class="comment">// 窗口形成后记录最大值</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            result[i - k + <span class="number">1</span>] = arr[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="合并两个有序数组-merge-two-sorted-arrays">13. 合并两个有序数组
(Merge Two Sorted Arrays)</h4>
<ul>
<li><strong>功能描述</strong>：将两个有序数组合并为一个有序数组，原地修改第一个数组。</li>
<li><strong>时间复杂度</strong>：O(m + n)，其中 m 和 n
是两个数组的长度</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> m - <span class="number">1</span>; <span class="comment">// nums1 的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> n - <span class="number">1</span>; <span class="comment">// nums2 的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> m + n - <span class="number">1</span>; <span class="comment">// 合并后数组的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p2 &gt;= <span class="number">0</span> &amp;&amp; p1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">            nums1[p--] = nums1[p1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[p--] = nums2[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 nums2 还有剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[p--] = nums2[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数组中第-k-大元素-kth-largest-element">14. 数组中第 k 大元素
(Kth Largest Element)</h4>
<ul>
<li><strong>功能描述</strong>：使用快速选择算法（QuickSelect）找到数组中第
k 大的元素。</li>
<li><strong>时间复杂度</strong>：O(n) 平均，O(n²) 最坏</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, arr.length - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">    <span class="keyword">if</span> (k == pivotIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[k];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; pivotIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(arr, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(arr, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数组元素移动零-move-zeroes">15. 数组元素移动零 (Move
Zeroes)</h4>
<ul>
<li><strong>功能描述</strong>：将数组中的所有零移动到末尾，保持非零元素相对顺序。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nonZeroIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将非零元素移到前面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            arr[nonZeroIndex++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充剩余位置为零</span></span><br><span class="line">    <span class="keyword">while</span> (nonZeroIndex &lt; arr.length) &#123;</span><br><span class="line">        arr[nonZeroIndex++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="链表">链表</h3>
<h4 id="单链表">单链表</h4>
<h5 id="定义单链表">1. 定义单链表</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;         <span class="comment">// 数据域</span></span><br><span class="line">    ListNode next;   <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历链表">2. 遍历链表</h5>
<p>原理</p>
<ul>
<li>从头节点开始，沿 <code>next</code> 指针依次访问每个节点，直到遇到
<code>null</code>。</li>
<li>用于统计长度、查找节点或打印链表。</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(curr.val + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        ListNode.printList(head); <span class="comment">// 输出: 1 -&gt; 2 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)，n 是链表长度。</li>
<li><strong>空间复杂度</strong>: O(1)，只用一个指针。</li>
</ul>
<hr />
<h5 id="反转链表">3. 反转链表</h5>
<p>原理</p>
<ul>
<li>使用三个指针（<code>prev</code>、<code>curr</code>、<code>next</code>）迭代反转每个节点的
<code>next</code> 指针。</li>
<li>核心思想：逐步调整指针方向，原地完成反转。</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;  <span class="comment">// 保存下一个节点</span></span><br><span class="line">            curr.next = prev;           <span class="comment">// 反转指针</span></span><br><span class="line">            prev = curr;                <span class="comment">// 前移 prev</span></span><br><span class="line">            curr = next;                <span class="comment">// 前移 curr</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;                    <span class="comment">// 新头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reversed</span> <span class="operator">=</span> reverseList(head);</span><br><span class="line">        ListNode.printList(reversed); <span class="comment">// 输出: 3 -&gt; 2 -&gt; 1 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)，一次遍历。</li>
<li><strong>空间复杂度</strong>: O(1)，原地操作。</li>
</ul>
<hr />
<h5 id="反转链表指定区间">4. 反转链表指定区间</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; left; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> start.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">        start.next = curr.next;</span><br><span class="line">        curr.next = pre.next;</span><br><span class="line">        pre.next =curr;</span><br><span class="line">        curr = start.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)，一次遍历。</li>
<li><strong>空间复杂度</strong>: O(1)，原地操作。</li>
</ul>
<hr />
<h5 id="合并两个有序链表">5. 合并两个有序链表</h5>
<p>原理</p>
<ul>
<li>类似归并排序的合并过程，比较两个链表的节点值，逐步构建新链表。</li>
<li>使用哑节点（dummy node）简化边界处理。</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 哑节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理剩余节点</span></span><br><span class="line">        curr.next = (l1 != <span class="literal">null</span>) ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        l1.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        l1.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        l2.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        l2.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> mergeTwoLists(l1, l2);</span><br><span class="line">        ListNode.printList(merged); <span class="comment">// 输出: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n + m)，n 和 m 是两个链表长度。</li>
<li><strong>空间复杂度</strong>: O(1)，仅用哑节点，不计输出空间。</li>
</ul>
<hr />
<h5 id="检测链表中的环">6. 检测链表中的环</h5>
<p>原理</p>
<ul>
<li>使用<strong>快慢指针法</strong>（Floyd 判圈算法）：
<ul>
<li>慢指针每次走 1 步，快指针每次走 2 步。</li>
<li>若有环，快慢指针会在环内相遇；若无环，快指针先到
<code>null</code>。</li>
</ul></li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;         <span class="comment">// 慢指针走 1 步</span></span><br><span class="line">            fast = fast.next.next;    <span class="comment">// 快指针走 2 步</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 相遇说明有环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = head.next; <span class="comment">// 创建环: 1 -&gt; 2 -&gt; 3 -&gt; 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hasCycle(head)); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)，快指针最多跑完环的长度。</li>
<li><strong>空间复杂度</strong>: O(1)，只用两个指针。</li>
</ul>
<hr />
<h5 id="删除链表中的节点">7. 删除链表中的节点</h5>
<p>原理</p>
<ul>
<li><strong>普通删除</strong>:
找到目标节点的前驱，调整指针跳过目标。</li>
<li><strong>特殊情况</strong>:
如果只给定要删除的节点（无前驱引用），将其值替换为下个节点的值，再删除下个节点。</li>
</ul>
<p>代码</p>
<p>删除指定值的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 哑节点处理头节点删除</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next; <span class="comment">// 跳过目标节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> deleteNode(head, <span class="number">2</span>);</span><br><span class="line">        ListNode.printList(result); <span class="comment">// 输出: 1 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只给定节点删除（无前驱）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设 node 是要删除的节点，且不是尾节点</span></span><br><span class="line">        node.val = node.next.val;    <span class="comment">// 复制下个节点的值</span></span><br><span class="line">        node.next = node.next.next;  <span class="comment">// 跳过下个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeToDelete</span> <span class="operator">=</span> head.next; <span class="comment">// 删除 2</span></span><br><span class="line"></span><br><span class="line">        deleteNode(nodeToDelete);</span><br><span class="line">        ListNode.printList(head); <span class="comment">// 输出: 1 -&gt; 3 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>普通删除</strong>: O(n) 时间，O(1) 空间。</li>
<li><strong>给定节点删除</strong>: O(1) 时间，O(1) 空间。</li>
</ul>
<hr />
<h5 id="查找中间节点">8. 查找中间节点</h5>
<p>原理</p>
<ul>
<li>使用快慢指针：快指针走 2 步，慢指针走 1
步，快指针到尾时，慢指针在中间。</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">middle</span> <span class="operator">=</span> middleNode(head);</span><br><span class="line">        System.out.println(middle.val); <span class="comment">// 输出: 3 (偶数长度取后半中间)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)。</li>
<li><strong>空间复杂度</strong>: O(1)。</li>
</ul>
<h4 id="双链表">双链表</h4>
<h5 id="双链表节点定义">1. 双链表节点定义</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    DoublyListNode prev;</span><br><span class="line">    DoublyListNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双链表基本类">2. 双链表基本类</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DoublyListNode head;</span><br><span class="line">    <span class="keyword">private</span> DoublyListNode tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> DoublyListNode <span class="title function_">getHead</span><span class="params">()</span> &#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">    <span class="keyword">public</span> DoublyListNode <span class="title function_">getTail</span><span class="params">()</span> &#123; <span class="keyword">return</span> tail; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(DoublyListNode head)</span> &#123; <span class="built_in">this</span>.head = head; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTail</span><span class="params">(DoublyListNode tail)</span> &#123; <span class="built_in">this</span>.tail = tail; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在头部添加节点">3. 在头部添加节点</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(DoublyLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (list.getHead() == <span class="literal">null</span>) &#123;</span><br><span class="line">        list.setHead(newNode);</span><br><span class="line">        list.setTail(newNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode.next = list.getHead();</span><br><span class="line">        list.getHead().prev = newNode;</span><br><span class="line">        list.setHead(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在尾部添加节点">4. 在尾部添加节点</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(DoublyLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) &#123;</span><br><span class="line">        list.setHead(newNode);</span><br><span class="line">        list.setTail(newNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode.prev = list.getTail();</span><br><span class="line">        list.getTail().next = newNode;</span><br><span class="line">        list.setTail(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除指定值的第一个节点">5. 删除指定值的第一个节点</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(DoublyLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.val == val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current == list.getHead()) &#123;</span><br><span class="line">                list.setHead(list.getHead().next);</span><br><span class="line">                <span class="keyword">if</span> (list.getHead() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    list.getHead().prev = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.setTail(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == list.getTail()) &#123;</span><br><span class="line">                list.setTail(list.getTail().prev);</span><br><span class="line">                list.getTail().next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                current.prev.next = current.next;</span><br><span class="line">                current.next.prev = current.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="打印链表">6. 打印链表</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(DoublyLinkedList list)</span> &#123;</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.print(current.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="反转双链表">7. 反转双链表</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(DoublyLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getHead() == <span class="literal">null</span> || list.getHead().next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        temp = current.prev;</span><br><span class="line">        current.prev = current.next;</span><br><span class="line">        current.next = temp;</span><br><span class="line">        current = current.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    temp = list.getHead();</span><br><span class="line">    list.setHead(list.getTail());</span><br><span class="line">    list.setTail(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找中间节点-1">8. 查找中间节点</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> DoublyListNode <span class="title function_">findMiddle</span><span class="params">(DoublyLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getHead() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">slow</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">fast</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检测循环">9. 检测循环</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(DoublyLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getHead() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">slow</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">fast</span> <span class="operator">=</span> list.getHead();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="合并两个有序双链表">10. 合并两个有序双链表</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n + m), 空间复杂度: O(n + m)</span></span><br><span class="line"><span class="keyword">public</span> DoublyLinkedList <span class="title function_">mergeSortedLists</span><span class="params">(DoublyLinkedList list1, DoublyLinkedList list2)</span> &#123;</span><br><span class="line">    <span class="type">DoublyLinkedList</span> <span class="variable">merged</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">p1</span> <span class="operator">=</span> list1.getHead();</span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">p2</span> <span class="operator">=</span> list2.getHead();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt;= p2.val) &#123;</span><br><span class="line">            addLast(merged, p1.val);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addLast(merged, p2.val);</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        addLast(merged, p1.val);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        addLast(merged, p2.val);</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用示例">11. 使用示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DoublyLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line">    </span><br><span class="line">    addLast(list, <span class="number">1</span>);</span><br><span class="line">    addLast(list, <span class="number">2</span>);</span><br><span class="line">    addLast(list, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Original list:&quot;</span>);</span><br><span class="line">    printList(list);  <span class="comment">// 输出: 1 2 3</span></span><br><span class="line">    </span><br><span class="line">    reverse(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;Reversed list:&quot;</span>);</span><br><span class="line">    printList(list);  <span class="comment">// 输出: 3 2 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">DoublyListNode</span> <span class="variable">middle</span> <span class="operator">=</span> findMiddle(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;Middle node value: &quot;</span> + middle.val);  <span class="comment">// 输出: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单向循环链表">单向循环链表</h4>
<ul>
<li>循环链表的特点是尾节点的 next 指向头节点，形成闭环。</li>
<li>这些算法适用于单向循环链表，操作时需要特别注意循环的维护。</li>
<li>分割算法假设链表长度为偶数时分成相等两半，奇数时第一部分少一个节点。</li>
</ul>
<h5 id="循环链表节点定义">1. 循环链表节点定义</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircularListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    CircularListNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircularListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="循环链表基本类">2. 循环链表基本类</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircularLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CircularListNode tail;  <span class="comment">// 指向最后一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircularLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> CircularListNode <span class="title function_">getTail</span><span class="params">()</span> &#123; <span class="keyword">return</span> tail; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTail</span><span class="params">(CircularListNode tail)</span> &#123; <span class="built_in">this</span>.tail = tail; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在尾部添加节点-1">3. 在尾部添加节点</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(CircularLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) &#123;</span><br><span class="line">        list.setTail(newNode);</span><br><span class="line">        newNode.next = newNode;  <span class="comment">// 指向自己形成循环</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode.next = list.getTail().next;  <span class="comment">// 新节点指向头节点</span></span><br><span class="line">        list.getTail().next = newNode;       <span class="comment">// 原尾节点指向新节点</span></span><br><span class="line">        list.setTail(newNode);              <span class="comment">// 更新尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在头部添加节点-1">4. 在头部添加节点</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(CircularLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) &#123;</span><br><span class="line">        list.setTail(newNode);</span><br><span class="line">        newNode.next = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode.next = list.getTail().next;  <span class="comment">// 新节点指向原头节点</span></span><br><span class="line">        list.getTail().next = newNode;       <span class="comment">// 尾节点指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除指定值的第一个节点-1">5. 删除指定值的第一个节点</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(CircularLinkedList list, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getTail().next;  <span class="comment">// 从头开始</span></span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">prev</span> <span class="operator">=</span> list.getTail();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.val == val) &#123;</span><br><span class="line">            <span class="comment">// 只有一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (current == list.getTail() &amp;&amp; current.next == current) &#123;</span><br><span class="line">                list.setTail(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == list.getTail().next) &#123;</span><br><span class="line">                list.getTail().next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == list.getTail()) &#123;</span><br><span class="line">                prev.next = list.getTail().next;</span><br><span class="line">                list.setTail(prev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除中间节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != list.getTail().next);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="打印循环链表">6. 打印循环链表</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(CircularLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;List is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        System.out.print(current.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != list.getTail().next);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检测循环验证是否正确形成循环链表">7.
检测循环（验证是否正确形成循环链表）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCircular</span><span class="params">(CircularLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 空链表认为是循环的</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">slow</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">fast</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 快慢指针相遇说明有环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 理论上循环链表总是返回true，除非链表损坏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找链表长度">8. 查找链表长度</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(CircularLinkedList list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">current</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        length++;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != list.getTail().next);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分割循环链表为两个循环链表">9. 分割循环链表为两个循环链表</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 将链表分成两半，前半部分和后半部分分别形成新的循环链表</span></span><br><span class="line"><span class="keyword">public</span> CircularLinkedList[] splitList(CircularLinkedList list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.getTail() == <span class="literal">null</span> || list.getTail().next == list.getTail()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>[]&#123;list, <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">slow</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">fast</span> <span class="operator">=</span> list.getTail().next;</span><br><span class="line">    <span class="type">CircularListNode</span> <span class="variable">prev</span> <span class="operator">=</span> list.getTail();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到中间节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != list.getTail().next || fast.next != list.getTail().next) &#123;</span><br><span class="line">        prev = slow;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分割</span></span><br><span class="line">    <span class="type">CircularLinkedList</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>();</span><br><span class="line">    <span class="type">CircularLinkedList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>();</span><br><span class="line">    </span><br><span class="line">    list1.setTail(prev);</span><br><span class="line">    list2.setTail(list.getTail());</span><br><span class="line">    </span><br><span class="line">    prev.next = list.getTail().next;  <span class="comment">// 第一部分形成循环</span></span><br><span class="line">    list2.getTail().next = slow;      <span class="comment">// 第二部分形成循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>[]&#123;list1, list2&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用示例-1">使用示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CircularLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularLinkedList</span>();</span><br><span class="line">    </span><br><span class="line">    addLast(list, <span class="number">1</span>);</span><br><span class="line">    addLast(list, <span class="number">2</span>);</span><br><span class="line">    addLast(list, <span class="number">3</span>);</span><br><span class="line">    addLast(list, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Original list:&quot;</span>);</span><br><span class="line">    printList(list);  <span class="comment">// 输出: 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Length: &quot;</span> + getLength(list));  <span class="comment">// 输出: 4</span></span><br><span class="line">    </span><br><span class="line">    remove(list, <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After removing 2:&quot;</span>);</span><br><span class="line">    printList(list);  <span class="comment">// 输出: 1 3 4</span></span><br><span class="line">    </span><br><span class="line">    CircularLinkedList[] splitLists = splitList(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;First half:&quot;</span>);</span><br><span class="line">    printList(splitLists[<span class="number">0</span>]);  <span class="comment">// 输出: 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Second half:&quot;</span>);</span><br><span class="line">    printList(splitLists[<span class="number">1</span>]);  <span class="comment">// 输出: 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈">栈</h3>
<p>栈是一种后进先出（LIFO）的数据结构</p>
<ul>
<li><strong>数组实现</strong>：适合固定大小的场景，空间利用率高但不灵活。</li>
<li><strong>链表实现</strong>：动态大小，无需预定义容量，适合不确定大小的场景。</li>
</ul>
<hr />
<h4 id="基于数组的栈实现">1. 基于数组的栈实现</h4>
<h5 id="栈的基本类数组实现">栈的基本类（数组实现）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;  <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        capacity = size;</span><br><span class="line">        top = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="入栈push">1.1 入栈（push）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ArrayStack stack, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.top == stack.capacity - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.arr[++stack.top] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="出栈pop">1.2 出栈（pop）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">(ArrayStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.top == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.arr[stack.top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查看栈顶元素peek">1.3 查看栈顶元素（peek）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">(ArrayStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.top == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.arr[stack.top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断栈是否为空">1.4 判断栈是否为空</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(ArrayStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断栈是否已满">1.5 判断栈是否已满</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">(ArrayStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.top == stack.capacity - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="基于链表的栈实现">2. 基于链表的栈实现</h4>
<h5 id="栈节点定义">栈节点定义</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    StackNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="栈的基本类链表实现">栈的基本类（链表实现）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StackNode top;  <span class="comment">// 栈顶指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedStack</span><span class="params">()</span> &#123;</span><br><span class="line">        top = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> StackNode <span class="title function_">getTop</span><span class="params">()</span> &#123; <span class="keyword">return</span> top; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTop</span><span class="params">(StackNode top)</span> &#123; <span class="built_in">this</span>.top = top; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="入栈push-1">2.1 入栈（push）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(LinkedStack stack, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">StackNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackNode</span>(val);</span><br><span class="line">    newNode.next = stack.getTop();</span><br><span class="line">    stack.setTop(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="出栈pop-1">2.2 出栈（pop）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.getTop() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> stack.getTop().val;</span><br><span class="line">    stack.setTop(stack.getTop().next);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查看栈顶元素peek-1">2.3 查看栈顶元素（peek）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">(LinkedStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.getTop() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.getTop().val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断栈是否为空-1">2.4 判断栈是否为空</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(LinkedStack stack)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.getTop() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="栈的常用算法">3. 栈的常用算法</h4>
<h5 id="反转栈">3.1 反转栈</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(n)</span></span><br><span class="line"><span class="comment">// 使用辅助栈反转原栈</span></span><br><span class="line"><span class="keyword">public</span> LinkedStack <span class="title function_">reverseStack</span><span class="params">(LinkedStack stack)</span> &#123;</span><br><span class="line">    <span class="type">LinkedStack</span> <span class="variable">reversed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(stack)) &#123;</span><br><span class="line">        push(reversed, pop(stack));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reversed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检查括号匹配">3.2 检查括号匹配</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(n)</span></span><br><span class="line"><span class="comment">// 检查字符串中的括号是否匹配</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">LinkedStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            push(stack, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span> || c == <span class="string">&#x27;&#125;&#x27;</span> || c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(stack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> pop(stack);</span><br><span class="line">            <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>) ||</span><br><span class="line">                (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEmpty(stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计算后缀表达式逆波兰表达式">3.3
计算后缀表达式（逆波兰表达式）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(n)</span></span><br><span class="line"><span class="comment">// 计算后缀表达式的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evaluatePostfix</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    <span class="type">LinkedStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (token.matches(<span class="string">&quot;-?\\d+&quot;</span>)) &#123;  <span class="comment">// 是数字</span></span><br><span class="line">            push(stack, Integer.parseInt(token));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 是运算符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> pop(stack);</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> pop(stack);</span><br><span class="line">            <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>: push(stack, a + b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>: push(stack, a - b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>: push(stack, a * b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>: push(stack, a / b); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pop(stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最小栈获取栈中最小元素">3.4 最小栈（获取栈中最小元素）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持在 O(1) 时间获取最小元素的栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedStack mainStack;</span><br><span class="line">    <span class="keyword">private</span> LinkedStack minStack;  <span class="comment">// 辅助栈存储最小值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        mainStack = <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        push(mainStack, val);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(minStack) || val &lt;= peek(minStack)) &#123;</span><br><span class="line">            push(minStack, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> pop(mainStack);</span><br><span class="line">        <span class="keyword">if</span> (val == peek(minStack)) &#123;</span><br><span class="line">            pop(minStack);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(minStack)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> peek(minStack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="使用示例-2">使用示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组栈示例</span></span><br><span class="line">    <span class="type">ArrayStack</span> <span class="variable">arrayStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">5</span>);</span><br><span class="line">    push(arrayStack, <span class="number">1</span>);</span><br><span class="line">    push(arrayStack, <span class="number">2</span>);</span><br><span class="line">    push(arrayStack, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Array Stack top: &quot;</span> + peek(arrayStack));  <span class="comment">// 输出: 3</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Popped: &quot;</span> + pop(arrayStack));           <span class="comment">// 输出: 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表栈示例</span></span><br><span class="line">    <span class="type">LinkedStack</span> <span class="variable">linkedStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedStack</span>();</span><br><span class="line">    push(linkedStack, <span class="number">1</span>);</span><br><span class="line">    push(linkedStack, <span class="number">2</span>);</span><br><span class="line">    push(linkedStack, <span class="number">3</span>);</span><br><span class="line">    <span class="type">LinkedStack</span> <span class="variable">reversed</span> <span class="operator">=</span> reverseStack(linkedStack);</span><br><span class="line">    System.out.println(<span class="string">&quot;Reversed Stack top: &quot;</span> + peek(reversed));  <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 括号匹配</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;[()]&#125;&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;Parentheses valid: &quot;</span> + isValidParentheses(s));  <span class="comment">// 输出: true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后缀表达式</span></span><br><span class="line">    String[] postfix = &#123;<span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;+&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;*&quot;</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;Postfix result: &quot;</span> + evaluatePostfix(postfix));  <span class="comment">// 输出: 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最小栈</span></span><br><span class="line">    <span class="type">MinStack</span> <span class="variable">minStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinStack</span>();</span><br><span class="line">    minStack.push(<span class="number">3</span>);</span><br><span class="line">    minStack.push(<span class="number">5</span>);</span><br><span class="line">    minStack.push(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Min value: &quot;</span> + minStack.getMin());  <span class="comment">// 输出: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列">队列</h3>
<p>队列是一种先进先出（FIFO）的数据结构</p>
<ul>
<li><strong>数组队列</strong>：简单实现，但空间利用率低，出队后空间不可复用。</li>
<li><strong>链表队列</strong>：动态大小，适合不确定长度的场景。</li>
<li><strong>循环队列</strong>：优化数组队列，复用空间，适合固定大小场景。</li>
<li><strong>双端队列</strong>：支持两端操作，灵活性更高。</li>
<li><strong>优先队列</strong>：基于最小堆实现，保证每次出队的是最小元素。</li>
</ul>
<hr />
<h4 id="基于数组的队列实现">1. 基于数组的队列实现</h4>
<h5 id="队列的基本类数组实现">队列的基本类（数组实现）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;  <span class="comment">// 队首指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;   <span class="comment">// 队尾指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        capacity = size;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="入队enqueue">1.1 入队（enqueue）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(ArrayQueue queue, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.rear == queue.capacity - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    queue.arr[++queue.rear] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="出队dequeue">1.2 出队（dequeue）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(ArrayQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.front &gt; queue.rear) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.arr[queue.front++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查看队首元素peek">1.3 查看队首元素（peek）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">(ArrayQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.front &gt; queue.rear) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.arr[queue.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断队列是否为空">1.4 判断队列是否为空</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(ArrayQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.front &gt; queue.rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断队列是否已满">1.5 判断队列是否已满</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">(ArrayQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.rear == queue.capacity - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="基于链表的队列实现">2. 基于链表的队列实现</h4>
<h5 id="队列节点定义">队列节点定义</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QueueNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    QueueNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueueNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="队列的基本类链表实现">队列的基本类（链表实现）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> QueueNode front;  <span class="comment">// 队首指针</span></span><br><span class="line">    <span class="keyword">private</span> QueueNode rear;   <span class="comment">// 队尾指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        front = <span class="literal">null</span>;</span><br><span class="line">        rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> QueueNode <span class="title function_">getFront</span><span class="params">()</span> &#123; <span class="keyword">return</span> front; &#125;</span><br><span class="line">    <span class="keyword">public</span> QueueNode <span class="title function_">getRear</span><span class="params">()</span> &#123; <span class="keyword">return</span> rear; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFront</span><span class="params">(QueueNode front)</span> &#123; <span class="built_in">this</span>.front = front; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRear</span><span class="params">(QueueNode rear)</span> &#123; <span class="built_in">this</span>.rear = rear; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="入队enqueue-1">2.1 入队（enqueue）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(LinkedQueue queue, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">QueueNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueueNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (queue.getRear() == <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.setFront(newNode);</span><br><span class="line">        queue.setRear(newNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue.getRear().next = newNode;</span><br><span class="line">        queue.setRear(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="出队dequeue-1">2.2 出队（dequeue）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(LinkedQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.getFront() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> queue.getFront().val;</span><br><span class="line">    queue.setFront(queue.getFront().next);</span><br><span class="line">    <span class="keyword">if</span> (queue.getFront() == <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.setRear(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查看队首元素peek-1">2.3 查看队首元素（peek）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">(LinkedQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.getFront() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.getFront().val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断队列是否为空-1">2.4 判断队列是否为空</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(LinkedQueue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.getFront() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="队列的常用算法">3. 队列的常用算法</h4>
<h5 id="循环队列基于数组优化">3.1 循环队列（基于数组优化）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircularQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        capacity = size;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear + <span class="number">1</span>) % capacity == front) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = val;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双端队列deque">3.2 双端队列（Deque）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> QueueNode front;</span><br><span class="line">    <span class="keyword">private</span> QueueNode rear;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Deque</span><span class="params">()</span> &#123;</span><br><span class="line">        front = <span class="literal">null</span>;</span><br><span class="line">        rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFront</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">QueueNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueueNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>) &#123;</span><br><span class="line">            front = rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.next = front;</span><br><span class="line">            front = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addRear</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">QueueNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueueNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (rear == <span class="literal">null</span>) &#123;</span><br><span class="line">            front = rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rear.next = newNode;</span><br><span class="line">            rear = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> front.val;</span><br><span class="line">        front = front.next;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>) rear = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeRear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rear == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> rear.val;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            front = rear = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">QueueNode</span> <span class="variable">current</span> <span class="operator">=</span> front;</span><br><span class="line">            <span class="keyword">while</span> (current.next != rear) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            rear = current;</span><br><span class="line">            rear.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="优先队列最小堆实现">3.3 优先队列（最小堆实现）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Priority Queue is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[size] = val;</span><br><span class="line">        heapifyUp(size);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Priority Queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[--size];</span><br><span class="line">        heapifyDown(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapifyUp</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[parent] &gt; arr[index]) &#123;</span><br><span class="line">                swap(arr, parent, index);</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapifyDown</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> index;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; size &amp;&amp; arr[left] &lt; arr[smallest]) smallest = left;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp; arr[right] &lt; arr[smallest]) smallest = right;</span><br><span class="line">            <span class="keyword">if</span> (smallest == index) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, index, smallest);</span><br><span class="line">            index = smallest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="使用示例-3">使用示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组队列</span></span><br><span class="line">    <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">5</span>);</span><br><span class="line">    enqueue(arrayQueue, <span class="number">1</span>);</span><br><span class="line">    enqueue(arrayQueue, <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Array Queue front: &quot;</span> + peek(arrayQueue));  <span class="comment">// 输出: 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Dequeued: &quot;</span> + dequeue(arrayQueue));       <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表队列</span></span><br><span class="line">    <span class="type">LinkedQueue</span> <span class="variable">linkedQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedQueue</span>();</span><br><span class="line">    enqueue(linkedQueue, <span class="number">1</span>);</span><br><span class="line">    enqueue(linkedQueue, <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Linked Queue front: &quot;</span> + peek(linkedQueue));  <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环队列</span></span><br><span class="line">    <span class="type">CircularQueue</span> <span class="variable">circularQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularQueue</span>(<span class="number">3</span>);</span><br><span class="line">    circularQueue.enqueue(<span class="number">1</span>);</span><br><span class="line">    circularQueue.enqueue(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Circular Queue dequeued: &quot;</span> + circularQueue.dequeue());  <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双端队列</span></span><br><span class="line">    <span class="type">Deque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Deque</span>();</span><br><span class="line">    deque.addFront(<span class="number">1</span>);</span><br><span class="line">    deque.addRear(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Deque front: &quot;</span> + deque.removeFront());  <span class="comment">// 输出: 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Deque rear: &quot;</span> + deque.removeRear());    <span class="comment">// 输出: 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优先队列</span></span><br><span class="line">    <span class="type">PriorityQueue</span> <span class="variable">pq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">5</span>);</span><br><span class="line">    pq.enqueue(<span class="number">3</span>);</span><br><span class="line">    pq.enqueue(<span class="number">1</span>);</span><br><span class="line">    pq.enqueue(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Priority Queue min: &quot;</span> + pq.dequeue());  <span class="comment">// 输出: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树形结构">树形结构</h2>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 16%" />
<col style="width: 27%" />
<col style="width: 27%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th>数据结构</th>
<th>特点</th>
<th>变种/类型</th>
<th>操作</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>二叉树 (Binary Tree)</strong></td>
<td>每个节点最多两个子节点</td>
<td>- <strong>二叉搜索树 (BST)</strong>：左子树值 &lt; 根 &lt;
右子树值<br>- <strong>平衡二叉树
(AVL树/红黑树)</strong>：自动平衡高度</td>
<td>查找/插入（BST平均O(log n)，平衡树O(log n)）</td>
<td>快速查找<br>排序</td>
</tr>
<tr class="even">
<td><strong>堆 (Heap)</strong></td>
<td>完全二叉树，父节点与子节点有大小关系</td>
<td>- <strong>最大堆</strong>：父节点≥子节点<br>-
<strong>最小堆</strong>：父节点≤子节点</td>
<td>插入：O(log n)<br>取最值：O(1)</td>
<td>优先队列<br>堆排序</td>
</tr>
<tr class="odd">
<td><strong>多叉树</strong></td>
<td>支持多个子节点的树结构</td>
<td>- <strong>B树/B+树</strong>：多路平衡树，减少磁盘I/O<br>-
<strong>字典树 (Trie)</strong>：前缀树，存储字符串集合</td>
<td>依赖具体类型（如B树查找O(log
n)，Trie前缀查询O(m)，m为字符串长度）</td>
<td>B树/B+树：数据库索引<br>Trie：自动补全</td>
</tr>
</tbody>
</table>
<h3 id="二叉树">二叉树</h3>
<h4 id="普通二叉树">普通二叉树</h4>
<h5 id="二叉树节点定义">二叉树节点定义</h5>
<p>所有算法基于以下二叉树节点类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="前序遍历-preorder-traversal">1. 前序遍历 (Preorder
Traversal)</h5>
<ul>
<li><strong>功能描述</strong>：按照“根-左-右”的顺序递归遍历二叉树。</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是节点数</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">    preorderTraversal(root.left);     <span class="comment">// 遍历左子树</span></span><br><span class="line">    preorderTraversal(root.right);    <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历-inorder-traversal">2. 中序遍历 (Inorder Traversal)</h5>
<ul>
<li><strong>功能描述</strong>：按照“左-根-右”的顺序递归遍历二叉树，对于二叉搜索树（BST）会输出有序序列。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderTraversal(root.left);      <span class="comment">// 遍历左子树</span></span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">    inorderTraversal(root.right);     <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历-postorder-traversal">3. 后序遍历 (Postorder
Traversal)</h5>
<ul>
<li><strong>功能描述</strong>：按照“左-右-根”的顺序递归遍历二叉树，常用于释放节点内存。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorderTraversal(root.left);    <span class="comment">// 遍历左子树</span></span><br><span class="line">    postorderTraversal(root.right);   <span class="comment">// 遍历右子树</span></span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层序遍历-level-order-traversal">4. 层序遍历 (Level Order
Traversal)</h5>
<ul>
<li><strong>功能描述</strong>：使用队列按层从上到下、从左到右遍历二叉树。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计算二叉树深度-maximum-depth">5. 计算二叉树深度 (Maximum
Depth)</h5>
<ul>
<li><strong>功能描述</strong>：递归计算二叉树的最大深度（根到最远叶节点的路径长度）。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断是否平衡二叉树-check-balanced-binary-tree">6.
判断是否平衡二叉树 (Check Balanced Binary Tree)</h5>
<ul>
<li><strong>功能描述</strong>：检查二叉树是否平衡，即任意节点的左右子树高度差不超过
1。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> height(root.left);</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 左子树不平衡</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> height(root.right);</span><br><span class="line">    <span class="keyword">if</span> (rightHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 右子树不平衡</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 当前节点不平衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树路径总和-path-sum">7. 二叉树路径总和 (Path Sum)</h5>
<ul>
<li><strong>功能描述</strong>：判断是否存在从根到叶节点的路径，其节点值之和等于目标值。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123; <span class="comment">// 叶节点</span></span><br><span class="line">        <span class="keyword">return</span> targetSum == root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || </span><br><span class="line">           hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="反转二叉树-invert-binary-tree">8. 反转二叉树 (Invert Binary
Tree)</h5>
<ul>
<li><strong>功能描述</strong>：将二叉树的左右子树交换，递归反转整棵树。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉搜索树验证-validate-binary-search-tree">9. 二叉搜索树验证
(Validate Binary Search Tree)</h5>
<ul>
<li><strong>功能描述</strong>：验证二叉树是否为二叉搜索树（BST），即左子树值
&lt; 根 &lt; 右子树值。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= min || root.val &gt;= max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root.val) &amp;&amp; </span><br><span class="line">           isValidBST(root.right, root.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最低公共祖先-lowest-common-ancestor">10. 最低公共祖先 (Lowest
Common Ancestor)</h5>
<ul>
<li><strong>功能描述</strong>：在二叉树中找到两个节点的最低公共祖先（LCA）。</li>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// p 和 q 分居两侧，root 是 LCA</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right; <span class="comment">// p 和 q 在同一侧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="前序遍历非递归preorder-traversal---iterative">11.
前序遍历（非递归）(Preorder Traversal - Iterative)</h5>
<ul>
<li><strong>功能描述</strong>：使用栈模拟递归，按照“根-左-右”的顺序遍历二叉树。</li>
<li><strong>时间复杂度</strong>：O(n)，空间复杂度 O(h)，h 为树高</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;         <span class="comment">// 先压右子树（后访问）</span></span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;          <span class="comment">// 后压左子树（先访问）</span></span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历非递归inorder-traversal---iterative">12.
中序遍历（非递归）(Inorder Traversal - Iterative)</h5>
<ul>
<li><strong>功能描述</strong>：使用栈模拟递归，按照“左-根-右”的顺序遍历二叉树，先将左子树压栈到底。</li>
<li><strong>时间复杂度</strong>：O(n)，空间复杂度 O(h)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 压入所有左子节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        System.out.print(current.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">        current = current.right;             <span class="comment">// 处理右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历非递归postorder-traversal---iterative">13.
后序遍历（非递归）(Postorder Traversal - Iterative)</h5>
<ul>
<li><strong>功能描述</strong>：使用栈模拟递归，按照“左-右-根”的顺序遍历二叉树，需记录上一次访问的节点以区分回溯路径。</li>
<li><strong>时间复杂度</strong>：O(n)，空间复杂度 O(h)</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">lastVisited</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 压入所有左子节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">peekNode</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="comment">// 如果没有右子树或右子树已访问，访问当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (peekNode.right == <span class="literal">null</span> || peekNode.right == lastVisited) &#123;</span><br><span class="line">            System.out.print(peekNode.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            lastVisited = stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = peekNode.right; <span class="comment">// 处理右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层序遍历非递归level-order-traversal---iterative">14.
层序遍历（非递归）(Level Order Traversal - Iterative)</h5>
<ul>
<li><strong>功能描述</strong>：使用队列按层从上到下、从左到右遍历二叉树（已在之前提供，这里重复列出以保持完整性）。</li>
<li><strong>时间复杂度</strong>：O(n)，空间复杂度 O(w)，w
为树的最大宽度</li>
<li><strong>Java 代码实现</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树-binary-search-tree-bst">二叉搜索树 (Binary Search
Tree, BST)</h4>
<ul>
<li><strong>定义</strong>: 左子树所有节点值 &lt; 根节点值 &lt;
右子树所有节点值。</li>
<li><strong>特性</strong>:
支持高效的查找、插入和删除，但可能退化为链表。</li>
<li><strong>应用场景</strong>:
<ul>
<li>数据库索引</li>
<li>动态集合管理</li>
<li>符号表</li>
</ul></li>
</ul>
<h5 id="结构图">结构图</h5>
<pre><code class="highlight mermaid">graph TD
    A[10] --&gt; B[5]
    A --&gt; C[15]
    B --&gt; D[3]
    B --&gt; E[7]
    C --&gt; F[13]</code></pre>
<hr />
<h5 id="二叉搜索树节点定义">1. 二叉搜索树节点定义</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    BSTNode left;</span><br><span class="line">    BSTNode right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉搜索树基本类">2. 二叉搜索树基本类</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BSTNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinarySearchTree</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> BSTNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(BSTNode root)</span> &#123; <span class="built_in">this</span>.root = root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="二叉搜索树常用算法">3. 二叉搜索树常用算法</h5>
<h6 id="插入节点">3.1 插入节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(h) 其中 h 是树高，平均 O(log n)，最坏 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(BinarySearchTree bst, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    bst.setRoot(insertRec(bst.getRoot(), val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BSTNode <span class="title function_">insertRec</span><span class="params">(BSTNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BSTNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = insertRec(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = insertRec(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除节点">3.2 删除节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(h) 其中 h 是树高，平均 O(log n)，最坏 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(BinarySearchTree bst, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    bst.setRoot(deleteRec(bst.getRoot(), val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BSTNode <span class="title function_">deleteRec</span><span class="params">(BSTNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = deleteRec(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = deleteRec(root.right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 节点找到，处理删除</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 有两个子节点，找到右子树最小值替换</span></span><br><span class="line">        root.val = findMin(root.right).val;</span><br><span class="line">        root.right = deleteRec(root.right, root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BSTNode <span class="title function_">findMin</span><span class="params">(BSTNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找节点">3.3 查找节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(h) 其中 h 是树高，平均 O(log n)，最坏 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(BinarySearchTree bst, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchRec(bst.getRoot(), val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">searchRec</span><span class="params">(BSTNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchRec(root.left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchRec(root.right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="前序遍历preorder-traversal">3.4 前序遍历（Preorder
Traversal）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n) 其中 n 是节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    preorderRec(bst.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preorderRec</span><span class="params">(BSTNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preorderRec(root.left);</span><br><span class="line">        preorderRec(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="中序遍历inorder-traversal">3.5 中序遍历（Inorder
Traversal）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n) 其中 n 是节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    inorderRec(bst.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderRec</span><span class="params">(BSTNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        inorderRec(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inorderRec(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="后序遍历postorder-traversal">3.6 后序遍历（Postorder
Traversal）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n) 其中 n 是节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    postorderRec(bst.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postorderRec</span><span class="params">(BSTNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        postorderRec(root.left);</span><br><span class="line">        postorderRec(root.right);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找最小值">3.7 查找最小值</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(h) 其中 h 是树高，平均 O(log n)，最坏 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bst.getRoot() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">current</span> <span class="operator">=</span> bst.getRoot();</span><br><span class="line">    <span class="keyword">while</span> (current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        current = current.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找最大值">3.8 查找最大值</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(h) 其中 h 是树高，平均 O(log n)，最坏 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bst.getRoot() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">current</span> <span class="operator">=</span> bst.getRoot();</span><br><span class="line">    <span class="keyword">while</span> (current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="计算树的高度">3.9 计算树的高度</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n) 其中 n 是节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> heightRec(bst.getRoot());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">heightRec</span><span class="params">(BSTNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> heightRec(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> heightRec(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="验证是否是有效的bst">3.10 验证是否是有效的BST</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n) 其中 n 是节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(BinarySearchTree bst)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBSTRec(bst.getRoot(), Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidBSTRec</span><span class="params">(BSTNode root, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= min || root.val &gt;= max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBSTRec(root.left, min, root.val) &amp;&amp; </span><br><span class="line">           isValidBSTRec(root.right, root.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="使用示例-4">使用示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BinarySearchTree</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    insert(bst, <span class="number">5</span>);</span><br><span class="line">    insert(bst, <span class="number">3</span>);</span><br><span class="line">    insert(bst, <span class="number">7</span>);</span><br><span class="line">    insert(bst, <span class="number">1</span>);</span><br><span class="line">    insert(bst, <span class="number">9</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Inorder:&quot;</span>);</span><br><span class="line">    inorder(bst);    <span class="comment">// 输出: 1 3 5 7 9</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Preorder:&quot;</span>);</span><br><span class="line">    preorder(bst);   <span class="comment">// 输出: 5 3 1 7 9</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Postorder:&quot;</span>);</span><br><span class="line">    postorder(bst);  <span class="comment">// 输出: 1 3 9 7 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 3: &quot;</span> + search(bst, <span class="number">3</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 4: &quot;</span> + search(bst, <span class="number">4</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最小值和最大值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Min: &quot;</span> + findMin(bst));  <span class="comment">// 输出: 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Max: &quot;</span> + findMax(bst));  <span class="comment">// 输出: 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    delete(bst, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After deleting 3, Inorder:&quot;</span>);</span><br><span class="line">    inorder(bst);    <span class="comment">// 输出: 1 5 7 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 高度</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Height: &quot;</span> + height(bst));  <span class="comment">// 输出: 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证BST</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Is valid BST: &quot;</span> + isValidBST(bst));  <span class="comment">// 输出: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="说明">说明</h5>
<ul>
<li><strong>时间复杂度</strong>：大多数操作依赖树高 h，在平衡 BST 中 h ≈
log n，在退化为链表时 h = n。</li>
<li><strong>插入、删除、查找</strong>：核心操作，利用 BST
的性质快速定位。</li>
<li><strong>遍历</strong>：前序、中序、后序是基本的树遍历方式，中序遍历
BST 会得到有序序列。</li>
<li><strong>最小值和最大值</strong>：利用 BST
左子树最小、右子树最大的特性。</li>
<li><strong>高度和验证</strong>：辅助功能，用于分析树结构和正确性。</li>
</ul>
<hr />
<h4 id="平衡二叉树">平衡二叉树</h4>
<h5 id="avl树-自平衡二叉搜索树">AVL树 (自平衡二叉搜索树)</h5>
<p>AVL 树通过在插入和删除时保持平衡因子（左右子树高度差不超过
1）来确保树的高度始终接近 log n，从而保证操作的高效性。</p>
<ul>
<li><strong>定义</strong>:
BST的改进，任何节点的左右子树高度差不超过1。</li>
<li><strong>特性</strong>: 通过旋转保持平衡，保证O(log n)操作。</li>
<li><strong>应用场景</strong>:
<ul>
<li>需要频繁查找的实时系统</li>
<li>内存管理中的动态分配</li>
</ul></li>
</ul>
<hr />
<h6 id="avl-树节点定义">AVL 树节点定义</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AVLNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    AVLNode left;</span><br><span class="line">    AVLNode right;</span><br><span class="line">    <span class="type">int</span> height;  <span class="comment">// 节点高度，用于平衡计算</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AVLNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="avl-树基本类">AVL 树基本类</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AVLNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AVLTree</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> AVLNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(AVLNode root)</span> &#123; <span class="built_in">this</span>.root = root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="获取节点高度">获取节点高度</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(AVLNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">null</span> ? -<span class="number">1</span> : node.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取平衡因子">获取平衡因子</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(AVLNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">null</span> ? <span class="number">0</span> : getHeight(node.left) - getHeight(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="更新节点高度">更新节点高度</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(AVLNode node)</span> &#123;</span><br><span class="line">    node.height = Math.max(getHeight(node.left), getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="右旋转right-rotation">右旋转（Right Rotation）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> AVLNode <span class="title function_">rightRotate</span><span class="params">(AVLNode y)</span> &#123;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">x</span> <span class="operator">=</span> y.left;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">T2</span> <span class="operator">=</span> x.right;</span><br><span class="line">    </span><br><span class="line">    x.right = y;</span><br><span class="line">    y.left = T2;</span><br><span class="line">    </span><br><span class="line">    updateHeight(y);</span><br><span class="line">    updateHeight(x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="左旋转left-rotation">左旋转（Left Rotation）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> AVLNode <span class="title function_">leftRotate</span><span class="params">(AVLNode x)</span> &#123;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">y</span> <span class="operator">=</span> x.right;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">T2</span> <span class="operator">=</span> y.left;</span><br><span class="line">    </span><br><span class="line">    y.left = x;</span><br><span class="line">    x.right = T2;</span><br><span class="line">    </span><br><span class="line">    updateHeight(x);</span><br><span class="line">    updateHeight(y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入节点-1">插入节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(AVLTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    tree.setRoot(insertRec(tree.getRoot(), val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">insertRec</span><span class="params">(AVLNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AVLNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = insertRec(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = insertRec(root.right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;  <span class="comment">// 不允许重复值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    updateHeight(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalanceFactor(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &lt; root.left.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; val &gt; root.right.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &gt; root.left.val) &#123;</span><br><span class="line">        root.left = leftRotate(root.left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; val &lt; root.right.val) &#123;</span><br><span class="line">        root.right = rightRotate(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除节点-1">删除节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(AVLTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    tree.setRoot(deleteRec(tree.getRoot(), val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">deleteRec</span><span class="params">(AVLNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = deleteRec(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = deleteRec(root.right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        </span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">minNode</span> <span class="operator">=</span> findMin(root.right);</span><br><span class="line">        root.val = minNode.val;</span><br><span class="line">        root.right = deleteRec(root.right, minNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    updateHeight(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalanceFactor(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(root.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(root.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        root.left = leftRotate(root.left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(root.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(root.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root.right = rightRotate(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">findMin</span><span class="params">(AVLNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找节点-1">查找节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(AVLTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchRec(tree.getRoot(), val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">searchRec</span><span class="params">(AVLNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchRec(root.left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchRec(root.right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="中序遍历inorder-traversal-1">中序遍历（Inorder Traversal）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(AVLTree tree)</span> &#123;</span><br><span class="line">    inorderRec(tree.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderRec</span><span class="params">(AVLNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        inorderRec(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inorderRec(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="验证-avl-树性质">验证 AVL 树性质</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAVLTree</span><span class="params">(AVLTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isAVLRec(tree.getRoot());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAVLRec</span><span class="params">(AVLNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalanceFactor(root);</span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> || balance &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isAVLRec(root.left) &amp;&amp; isAVLRec(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="使用示例-5">使用示例</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AVLTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    insert(tree, <span class="number">10</span>);</span><br><span class="line">    insert(tree, <span class="number">20</span>);</span><br><span class="line">    insert(tree, <span class="number">30</span>);</span><br><span class="line">    insert(tree, <span class="number">40</span>);</span><br><span class="line">    insert(tree, <span class="number">50</span>);</span><br><span class="line">    insert(tree, <span class="number">25</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Inorder traversal:&quot;</span>);</span><br><span class="line">    inorder(tree);  <span class="comment">// 输出: 10 20 25 30 40 50</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    delete(tree, <span class="number">30</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After deleting 30:&quot;</span>);</span><br><span class="line">    inorder(tree);  <span class="comment">// 输出: 10 20 25 40 50</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 20: &quot;</span> + search(tree, <span class="number">20</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 30: &quot;</span> + search(tree, <span class="number">30</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证 AVL 性质</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Is AVL Tree: &quot;</span> + isAVLTree(tree));  <span class="comment">// 输出: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="说明-1">说明</h6>
<ul>
<li><strong>平衡因子</strong>：AVL 树通过平衡因子（左子树高度 -
右子树高度）保持平衡，范围在 [-1, 1]。</li>
<li><strong>旋转操作</strong>：
<ul>
<li><strong>右旋转</strong>：处理左子树过高的情况（左左或左右）。</li>
<li><strong>左旋转</strong>：处理右子树过高的情况（右右或右左）。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>插入、删除、查找为 O(log n)，因为 AVL 树始终保持平衡。</li>
<li>遍历和验证为 O(n)，需要访问所有节点。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>递归操作依赖树高 h，由于 AVL 树平衡，h ≈ log n。</li>
</ul></li>
<li><strong>特点</strong>：
<ul>
<li>相比普通 BST，AVL
树通过旋转操作保证了高效性，但增加了维护成本。</li>
</ul></li>
</ul>
<hr />
<h5 id="红黑树-red-black-tree">红黑树 (Red-Black Tree)</h5>
<p>红黑树是一种自平衡二叉搜索树，通过颜色（红/黑）和五条性质保持平衡，确保操作时间复杂度为
O(log n)。</p>
<ul>
<li><strong>定义</strong>:
自平衡BST，具有颜色属性（红/黑），遵循特定规则：
<ol type="1">
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>红色节点的子节点必须是黑色</li>
<li>从根到叶的每条路径黑色节点数相同</li>
</ol></li>
<li><strong>红黑树性质</strong>：
<ol type="1">
<li>每个节点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>所有叶子（NIL）是黑色。</li>
<li>红色节点的子节点必须是黑色（不能有连续红色节点）。</li>
<li>从根到任一叶子的路径上黑色节点数量相同。</li>
</ol></li>
<li><strong>特性</strong>: 保证O(log n)操作，广泛用于系统实现。</li>
<li><strong>应用场景</strong>:
<ul>
<li>Java的TreeMap/TreeSet</li>
<li>Linux内核调度</li>
<li>数据库B+树基础</li>
</ul></li>
</ul>
<hr />
<h6 id="红黑树节点定义">红黑树节点定义</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RBNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    RBNode left;</span><br><span class="line">    RBNode right;</span><br><span class="line">    RBNode parent;</span><br><span class="line">    <span class="type">boolean</span> isRed;  <span class="comment">// true 表示红色，false 表示黑色</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RBNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.isRed = <span class="literal">true</span>;  <span class="comment">// 新节点默认为红色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="红黑树基本类">红黑树基本类</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedBlackTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RBNode root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RBNode</span> <span class="variable">NIL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RBNode</span>(<span class="number">0</span>);  <span class="comment">// 哨兵节点，代表空节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedBlackTree</span><span class="params">()</span> &#123;</span><br><span class="line">        NIL.isRed = <span class="literal">false</span>;  <span class="comment">// NIL 节点始终为黑色</span></span><br><span class="line">        NIL.left = NIL.right = NIL.parent = NIL;</span><br><span class="line">        root = NIL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> RBNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(RBNode root)</span> &#123; <span class="built_in">this</span>.root = root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="左旋转left-rotation-1">左旋转（Left Rotation）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(RedBlackTree tree, RBNode x)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">y</span> <span class="operator">=</span> x.right;</span><br><span class="line">    x.right = y.left;</span><br><span class="line">    <span class="keyword">if</span> (y.left != RedBlackTree.NIL) &#123;</span><br><span class="line">        y.left.parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y.parent = x.parent;</span><br><span class="line">    <span class="keyword">if</span> (x.parent == RedBlackTree.NIL) &#123;</span><br><span class="line">        tree.setRoot(y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line">        x.parent.left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x.parent.right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y.left = x;</span><br><span class="line">    x.parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="右旋转right-rotation-1">右旋转（Right Rotation）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(RedBlackTree tree, RBNode y)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">x</span> <span class="operator">=</span> y.left;</span><br><span class="line">    y.left = x.right;</span><br><span class="line">    <span class="keyword">if</span> (x.right != RedBlackTree.NIL) &#123;</span><br><span class="line">        x.right.parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    x.parent = y.parent;</span><br><span class="line">    <span class="keyword">if</span> (y.parent == RedBlackTree.NIL) &#123;</span><br><span class="line">        tree.setRoot(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y.parent.left) &#123;</span><br><span class="line">        y.parent.left = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y.parent.right = x;</span><br><span class="line">    &#125;</span><br><span class="line">    x.right = y;</span><br><span class="line">    y.parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入节点-2">插入节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(RedBlackTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RBNode</span>(val);</span><br><span class="line">    node.left = node.right = node.parent = RedBlackTree.NIL;</span><br><span class="line">    </span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">y</span> <span class="operator">=</span> RedBlackTree.NIL;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">x</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BST 插入</span></span><br><span class="line">    <span class="keyword">while</span> (x != RedBlackTree.NIL) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node.val &lt; x.val) &#123;</span><br><span class="line">            x = x.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = x.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node.parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y == RedBlackTree.NIL) &#123;</span><br><span class="line">        tree.setRoot(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &lt; y.val) &#123;</span><br><span class="line">        y.left = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y.right = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修复红黑树性质</span></span><br><span class="line">    insertFixup(tree, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertFixup</span><span class="params">(RedBlackTree tree, RBNode z)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (z.parent.isRed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z.parent == z.parent.parent.left) &#123;</span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">y</span> <span class="operator">=</span> z.parent.parent.right;  <span class="comment">// 叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (y.isRed) &#123;  <span class="comment">// 情况 1：叔叔是红色</span></span><br><span class="line">                z.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                y.isRed = <span class="literal">false</span>;</span><br><span class="line">                z.parent.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                z = z.parent.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z.parent.right) &#123;  <span class="comment">// 情况 2：叔叔是黑色，z 是右孩子</span></span><br><span class="line">                    z = z.parent;</span><br><span class="line">                    leftRotate(tree, z);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况 3：叔叔是黑色，z 是左孩子</span></span><br><span class="line">                z.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                z.parent.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                rightRotate(tree, z.parent.parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 对称情况</span></span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">y</span> <span class="operator">=</span> z.parent.parent.left;</span><br><span class="line">            <span class="keyword">if</span> (y.isRed) &#123;</span><br><span class="line">                z.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                y.isRed = <span class="literal">false</span>;</span><br><span class="line">                z.parent.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                z = z.parent.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z.parent.left) &#123;</span><br><span class="line">                    z = z.parent;</span><br><span class="line">                    rightRotate(tree, z);</span><br><span class="line">                &#125;</span><br><span class="line">                z.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                z.parent.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                leftRotate(tree, z.parent.parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tree.getRoot().isRed = <span class="literal">false</span>;  <span class="comment">// 根节点始终为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除节点-2">删除节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(RedBlackTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">z</span> <span class="operator">=</span> searchNode(tree.getRoot(), val);</span><br><span class="line">    <span class="keyword">if</span> (z == RedBlackTree.NIL) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">y</span> <span class="operator">=</span> z;</span><br><span class="line">    RBNode x;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">yOriginalColor</span> <span class="operator">=</span> y.isRed;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (z.left == RedBlackTree.NIL) &#123;</span><br><span class="line">        x = z.right;</span><br><span class="line">        transplant(tree, z, z.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z.right == RedBlackTree.NIL) &#123;</span><br><span class="line">        x = z.left;</span><br><span class="line">        transplant(tree, z, z.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = findMin(z.right);</span><br><span class="line">        yOriginalColor = y.isRed;</span><br><span class="line">        x = y.right;</span><br><span class="line">        <span class="keyword">if</span> (y.parent == z) &#123;</span><br><span class="line">            x.parent = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transplant(tree, y, y.right);</span><br><span class="line">            y.right = z.right;</span><br><span class="line">            y.right.parent = y;</span><br><span class="line">        &#125;</span><br><span class="line">        transplant(tree, z, y);</span><br><span class="line">        y.left = z.left;</span><br><span class="line">        y.left.parent = y;</span><br><span class="line">        y.isRed = z.isRed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!yOriginalColor) &#123;</span><br><span class="line">        deleteFixup(tree, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transplant</span><span class="params">(RedBlackTree tree, RBNode u, RBNode v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (u.parent == RedBlackTree.NIL) &#123;</span><br><span class="line">        tree.setRoot(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u.parent.left) &#123;</span><br><span class="line">        u.parent.left = v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u.parent.right = v;</span><br><span class="line">    &#125;</span><br><span class="line">    v.parent = u.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteFixup</span><span class="params">(RedBlackTree tree, RBNode x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (x != tree.getRoot() &amp;&amp; !x.isRed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">w</span> <span class="operator">=</span> x.parent.right;  <span class="comment">// 兄弟节点</span></span><br><span class="line">            <span class="keyword">if</span> (w.isRed) &#123;  <span class="comment">// 情况 1</span></span><br><span class="line">                w.isRed = <span class="literal">false</span>;</span><br><span class="line">                x.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                leftRotate(tree, x.parent);</span><br><span class="line">                w = x.parent.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!w.left.isRed &amp;&amp; !w.right.isRed) &#123;  <span class="comment">// 情况 2</span></span><br><span class="line">                w.isRed = <span class="literal">true</span>;</span><br><span class="line">                x = x.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!w.right.isRed) &#123;  <span class="comment">// 情况 3</span></span><br><span class="line">                    w.left.isRed = <span class="literal">false</span>;</span><br><span class="line">                    w.isRed = <span class="literal">true</span>;</span><br><span class="line">                    rightRotate(tree, w);</span><br><span class="line">                    w = x.parent.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况 4</span></span><br><span class="line">                w.isRed = x.parent.isRed;</span><br><span class="line">                x.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                w.right.isRed = <span class="literal">false</span>;</span><br><span class="line">                leftRotate(tree, x.parent);</span><br><span class="line">                x = tree.getRoot();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 对称情况</span></span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">w</span> <span class="operator">=</span> x.parent.left;</span><br><span class="line">            <span class="keyword">if</span> (w.isRed) &#123;</span><br><span class="line">                w.isRed = <span class="literal">false</span>;</span><br><span class="line">                x.parent.isRed = <span class="literal">true</span>;</span><br><span class="line">                rightRotate(tree, x.parent);</span><br><span class="line">                w = x.parent.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!w.right.isRed &amp;&amp; !w.left.isRed) &#123;</span><br><span class="line">                w.isRed = <span class="literal">true</span>;</span><br><span class="line">                x = x.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!w.left.isRed) &#123;</span><br><span class="line">                    w.right.isRed = <span class="literal">false</span>;</span><br><span class="line">                    w.isRed = <span class="literal">true</span>;</span><br><span class="line">                    leftRotate(tree, w);</span><br><span class="line">                    w = x.parent.left;</span><br><span class="line">                &#125;</span><br><span class="line">                w.isRed = x.parent.isRed;</span><br><span class="line">                x.parent.isRed = <span class="literal">false</span>;</span><br><span class="line">                w.left.isRed = <span class="literal">false</span>;</span><br><span class="line">                rightRotate(tree, x.parent);</span><br><span class="line">                x = tree.getRoot();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x.isRed = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找节点-2">查找节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(RedBlackTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchNode(tree.getRoot(), val) != RedBlackTree.NIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RBNode <span class="title function_">searchNode</span><span class="params">(RBNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (current != RedBlackTree.NIL &amp;&amp; current.val != val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; current.val) &#123;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="中序遍历inorder-traversal-2">中序遍历（Inorder Traversal）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(log n) 递归调用栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(RedBlackTree tree)</span> &#123;</span><br><span class="line">    inorderRec(tree.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderRec</span><span class="params">(RBNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != RedBlackTree.NIL) &#123;</span><br><span class="line">        inorderRec(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inorderRec(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找最小值-1">查找最小值</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(RedBlackTree tree)</span> &#123;</span><br><span class="line">    <span class="type">RBNode</span> <span class="variable">minNode</span> <span class="operator">=</span> findMin(tree.getRoot());</span><br><span class="line">    <span class="keyword">if</span> (minNode == RedBlackTree.NIL) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNode.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RBNode <span class="title function_">findMin</span><span class="params">(RBNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != RedBlackTree.NIL) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="使用示例-6">使用示例</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RedBlackTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedBlackTree</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    insert(tree, <span class="number">10</span>);</span><br><span class="line">    insert(tree, <span class="number">20</span>);</span><br><span class="line">    insert(tree, <span class="number">30</span>);</span><br><span class="line">    insert(tree, <span class="number">15</span>);</span><br><span class="line">    insert(tree, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Inorder traversal:&quot;</span>);</span><br><span class="line">    inorder(tree);  <span class="comment">// 输出: 5 10 15 20 30</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    delete(tree, <span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After deleting 20:&quot;</span>);</span><br><span class="line">    inorder(tree);  <span class="comment">// 输出: 5 10 15 30</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 15: &quot;</span> + search(tree, <span class="number">15</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Search 20: &quot;</span> + search(tree, <span class="number">20</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最小值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Min value: &quot;</span> + findMin(tree));  <span class="comment">// 输出: 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="说明-2">说明</h6>
<ul>
<li><strong>旋转操作</strong>：
<ul>
<li><strong>左旋转</strong>和<strong>右旋转</strong>用于调整树结构，保持平衡。</li>
</ul></li>
<li><strong>插入和删除</strong>：
<ul>
<li>插入后通过调整颜色和旋转修复红黑性质。</li>
<li>删除后通过四种情况修复，确保黑色高度一致。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>插入、删除、查找为 O(log n)，因为红黑树高度始终保持在 2log(n+1)
以内。</li>
<li>遍历为 O(n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>大多数操作只需常数额外空间，递归调用栈为 O(log n)。</li>
</ul></li>
</ul>
<hr />
<h4 id="完全二叉树">完全二叉树</h4>
<p>完全二叉树是一种特殊的二叉树，所有层（除可能的最底层）都被填满，最底层的节点尽量靠左排列。完全二叉树常用于实现堆。</p>
<hr />
<h5 id="完全二叉树节点定义">1. 完全二叉树节点定义</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CBTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    CBTNode left;</span><br><span class="line">    CBTNode right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CBTNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="完全二叉树基本类基于数组实现">2.
完全二叉树基本类（基于数组实现）</h5>
<p>由于完全二叉树可以用数组高效存储（无需显式指针），以下实现主要基于数组形式，适用于堆等场景。如果需要基于链表的实现，可以另行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompleteBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;    <span class="comment">// 数组存储完全二叉树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;     <span class="comment">// 当前节点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity; <span class="comment">// 最大容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CompleteBinaryTree</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getArr() &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> size)</span> &#123; <span class="built_in">this</span>.size = size; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="完全二叉树常用算法">3. 完全二叉树常用算法</h5>
<h6 id="插入节点尾部插入">3.1 插入节点（尾部插入）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 在完全二叉树末尾插入节点（不调整堆序性）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(CompleteBinaryTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() &gt;= tree.capacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tree.getArr()[tree.getSize()] = val;</span><br><span class="line">    tree.setSize(tree.getSize() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除最后一个节点">3.2 删除最后一个节点</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeLast</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> tree.getArr()[tree.getSize() - <span class="number">1</span>];</span><br><span class="line">    tree.setSize(tree.getSize() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取父节点索引">3.3 获取父节点索引</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 根节点无父节点</span></span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取左子节点索引">3.4 获取左子节点索引</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index, CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left &lt; tree.getSize() ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取右子节点索引">3.5 获取右子节点索引</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index, CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> right &lt; tree.getSize() ? right : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="检查是否为完全二叉树基于链表实现">3.6
检查是否为完全二叉树（基于链表实现）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(w), w 是树的最大宽度（队列空间）</span></span><br><span class="line"><span class="comment">// 使用层序遍历检查是否满足完全二叉树性质</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteBinaryTree</span><span class="params">(CBTNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;CBTNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">mustBeLeaf</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">// 标记后续节点必须是叶子</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">CBTNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果之前遇到过空节点，后续节点必须是叶子</span></span><br><span class="line">        <span class="keyword">if</span> (mustBeLeaf &amp;&amp; (node.left != <span class="literal">null</span> || node.right != <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;  <span class="comment">// 有右无左，不是完全二叉树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mustBeLeaf = <span class="literal">true</span>;  <span class="comment">// 后续节点必须没有子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="计算树的高度-1">3.7 计算树的高度</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(1), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 对于完全二叉树，高度可以通过节点数直接计算</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) Math.floor(Math.log(tree.getSize()) / Math.log(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="层序遍历level-order-traversal">3.8 层序遍历（Level Order
Traversal）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(w), w 是树的最大宽度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tree.getSize(); i++) &#123;</span><br><span class="line">        System.out.print(tree.getArr()[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="堆化heapify--最小堆调整">3.9 堆化（Heapify）- 最小堆调整</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 从指定节点向下调整为最小堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">minHeapify</span><span class="params">(CompleteBinaryTree tree, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> index;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getLeftChildIndex(index, tree);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getRightChildIndex(index, tree);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left != -<span class="number">1</span> &amp;&amp; tree.getArr()[left] &lt; tree.getArr()[smallest]) &#123;</span><br><span class="line">        smallest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right != -<span class="number">1</span> &amp;&amp; tree.getArr()[right] &lt; tree.getArr()[smallest]) &#123;</span><br><span class="line">        smallest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">        swap(tree.getArr(), index, smallest);</span><br><span class="line">        minHeapify(tree, smallest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="构建最小堆">3.10 构建最小堆</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 将整个数组调整为最小堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMinHeap</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> tree.getSize() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        minHeapify(tree, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="最大堆化max-heapify">3.11 最大堆化（Max Heapify）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 从指定节点向下调整为最大堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(CompleteBinaryTree tree, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> index;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getLeftChildIndex(index, tree);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getRightChildIndex(index, tree);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left != -<span class="number">1</span> &amp;&amp; tree.getArr()[left] &gt; tree.getArr()[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right != -<span class="number">1</span> &amp;&amp; tree.getArr()[right] &gt; tree.getArr()[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (largest != index) &#123;</span><br><span class="line">        swap(tree.getArr(), index, largest);</span><br><span class="line">        maxHeapify(tree, largest);  <span class="comment">// 递归调整子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="构建最大堆">3.12 构建最大堆</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 将整个数组调整为最大堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> tree.getSize() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxHeapify(tree, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入并调整为最大堆">3.13 插入并调整为最大堆</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 插入新元素并上浮调整为最大堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertMaxHeap</span><span class="params">(CompleteBinaryTree tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() &gt;= tree.capacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tree.getArr()[tree.getSize()] = val;</span><br><span class="line">    tree.setSize(tree.getSize() + <span class="number">1</span>);</span><br><span class="line">    siftUpMax(tree, tree.getSize() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpMax</span><span class="params">(CompleteBinaryTree tree, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> getParentIndex(index);</span><br><span class="line">        <span class="keyword">if</span> (tree.getArr()[parent] &lt; tree.getArr()[index]) &#123;</span><br><span class="line">            swap(tree.getArr(), parent, index);</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除最大值根节点">3.14 删除最大值（根节点）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="comment">// 删除并返回最大值，然后调整为最大堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">extractMax</span><span class="params">(CompleteBinaryTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Tree is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> tree.getArr()[<span class="number">0</span>];</span><br><span class="line">    tree.getArr()[<span class="number">0</span>] = tree.getArr()[tree.getSize() - <span class="number">1</span>];</span><br><span class="line">    tree.setSize(tree.getSize() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (tree.getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxHeapify(tree, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="使用示例-7">使用示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 基于数组的完全二叉树</span></span><br><span class="line">        <span class="type">CompleteBinaryTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompleteBinaryTree</span>(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入节点</span></span><br><span class="line">        insert(tree, <span class="number">5</span>);</span><br><span class="line">        insert(tree, <span class="number">3</span>);</span><br><span class="line">        insert(tree, <span class="number">7</span>);</span><br><span class="line">        insert(tree, <span class="number">1</span>);</span><br><span class="line">        insert(tree, <span class="number">9</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Level order before heapify:&quot;</span>);</span><br><span class="line">        levelOrder(tree);  <span class="comment">// 输出: 5 3 7 1 9</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建最小堆</span></span><br><span class="line">        buildMinHeap(tree);</span><br><span class="line">        System.out.println(<span class="string">&quot;Level order after min heapify:&quot;</span>);</span><br><span class="line">        levelOrder(tree);  <span class="comment">// 输出: 1 3 7 5 9</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Height: &quot;</span> + getHeight(tree));  <span class="comment">// 输出: 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除最后一个节点</span></span><br><span class="line">        removeLast(tree);</span><br><span class="line">        System.out.println(<span class="string">&quot;After removing last node:&quot;</span>);</span><br><span class="line">        levelOrder(tree);  <span class="comment">// 输出: 1 3 7 5</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 基于链表的完全二叉树检查</span></span><br><span class="line">        <span class="type">CBTNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CBTNode</span>(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> <span class="title class_">CBTNode</span>(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> <span class="title class_">CBTNode</span>(<span class="number">3</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> <span class="title class_">CBTNode</span>(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Is complete binary tree: &quot;</span> + isCompleteBinaryTree(root));  <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="说明-3">说明</h5>
<ul>
<li><strong>实现方式</strong>：
<ul>
<li>主要基于数组实现，因为完全二叉树可以用数组连续存储，适合堆等应用。</li>
<li>提供了基于链表的 <code>isCompleteBinaryTree</code>
检查算法，展示树结构的验证。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>插入和删除最后一个节点为 O(1)，因为只操作数组末尾。</li>
<li>堆化操作（如 <code>minHeapify</code>）为 O(log n)，构建堆为
O(n)。</li>
<li>遍历和检查为 O(n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>数组实现大多为 O(1) 额外空间。</li>
<li>层序遍历和检查使用队列，空间为 O(w)，w 是树的最大宽度。</li>
</ul></li>
<li><strong>与堆的关系</strong>：
<ul>
<li>完全二叉树常用于实现堆（如最小堆、最大堆），因此包含了堆化相关算法。</li>
<li>如果不考虑堆序性，完全二叉树仅关注结构完整性。</li>
</ul></li>
<li><strong>扩展</strong>：
<ul>
<li>如果需要最大堆调整、前序/中序遍历等其他算法，可以告诉我，我会补充。</li>
</ul></li>
</ul>
<p>完全二叉树的算法相对简单，主要优势在于其结构特性便于数组存储和高效操作，尤其在堆的实现中应用广泛。</p>
<h3 id="多叉树">多叉树</h3>
<h4 id="多路平衡树">多路平衡树</h4>
<h5 id="b树">B树</h5>
<p>B
树是一种自平衡的多路搜索树，广泛用于数据库和文件系统，能够高效处理大量数据。B
树的每个节点可以有多个键和子节点，保持树的平衡以确保操作时间为 O(log
n)。</p>
<p><strong>B 树性质</strong>：</p>
<ol type="1">
<li>每个节点最多有 2t-1 个键，最多 2t 个子节点。</li>
<li>每个非根节点至少有 t-1 个键，至少 t 个子节点。</li>
<li>根节点至少有 1 个键（除非树为空）。</li>
<li>所有叶子节点在同一层。</li>
</ol>
<hr />
<h6 id="b-树节点定义">B 树节点定义</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BTreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] keys;           <span class="comment">// 键数组</span></span><br><span class="line">    BTreeNode[] children; <span class="comment">// 子节点数组</span></span><br><span class="line">    <span class="type">int</span> keyCount;         <span class="comment">// 当前键数量</span></span><br><span class="line">    <span class="type">boolean</span> isLeaf;       <span class="comment">// 是否为叶子节点</span></span><br><span class="line">    <span class="type">int</span> t;                <span class="comment">// 最小度数（定义 B 树的阶）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTreeNode</span><span class="params">(<span class="type">int</span> t, <span class="type">boolean</span> isLeaf)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.isLeaf = isLeaf;</span><br><span class="line">        <span class="built_in">this</span>.keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * t - <span class="number">1</span>];      <span class="comment">// 最多 2t-1 个键</span></span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">BTreeNode</span>[<span class="number">2</span> * t]; <span class="comment">// 最多 2t 个子节点</span></span><br><span class="line">        <span class="built_in">this</span>.keyCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="b-树基本类">B 树基本类</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BTreeNode root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> t;  <span class="comment">// 最小度数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">BTreeNode</span>(t, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BTreeNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(BTreeNode root)</span> &#123; <span class="built_in">this</span>.root = root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="搜索键">搜索键</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 其中 t 是度数，n 是键总数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> BTreeNode <span class="title function_">search</span><span class="params">(BTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchRec(tree.getRoot(), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BTreeNode <span class="title function_">searchRec</span><span class="params">(BTreeNode node, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; node.keyCount &amp;&amp; key == node.keys[i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;  <span class="comment">// 找到键</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 未找到且是叶子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchRec(node.children[i], key);  <span class="comment">// 递归搜索子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入键">插入键</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 空间复杂度: O(t) 递归栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(BTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    <span class="keyword">if</span> (root.keyCount == <span class="number">2</span> * tree.t - <span class="number">1</span>) &#123;  <span class="comment">// 根节点已满</span></span><br><span class="line">        <span class="type">BTreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeNode</span>(tree.t, <span class="literal">false</span>);</span><br><span class="line">        newRoot.children[<span class="number">0</span>] = root;</span><br><span class="line">        splitChild(newRoot, <span class="number">0</span>, root, tree.t);</span><br><span class="line">        insertNonFull(newRoot, key, tree.t);</span><br><span class="line">        tree.setRoot(newRoot);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertNonFull(root, key, tree.t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertNonFull</span><span class="params">(BTreeNode node, <span class="type">int</span> key, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> node.keyCount - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; key &lt; node.keys[i]) &#123;</span><br><span class="line">            node.keys[i + <span class="number">1</span>] = node.keys[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        node.keys[i + <span class="number">1</span>] = key;</span><br><span class="line">        node.keyCount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; key &lt; node.keys[i]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (node.children[i].keyCount == <span class="number">2</span> * t - <span class="number">1</span>) &#123;</span><br><span class="line">            splitChild(node, i, node.children[i], t);</span><br><span class="line">            <span class="keyword">if</span> (key &gt; node.keys[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNonFull(node.children[i], key, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">splitChild</span><span class="params">(BTreeNode parent, <span class="type">int</span> i, BTreeNode fullChild, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeNode</span>(t, fullChild.isLeaf);</span><br><span class="line">    newNode.keyCount = t - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制后半部分键到新节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; t - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        newNode.keys[j] = fullChild.keys[j + t];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是叶子节点，复制子节点</span></span><br><span class="line">    <span class="keyword">if</span> (!fullChild.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">            newNode.children[j] = fullChild.children[j + t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fullChild.keyCount = t - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整父节点的子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> parent.keyCount; j &gt; i; j--) &#123;</span><br><span class="line">        parent.children[j + <span class="number">1</span>] = parent.children[j];</span><br><span class="line">    &#125;</span><br><span class="line">    parent.children[i + <span class="number">1</span>] = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提升中间键到父节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> parent.keyCount - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">        parent.keys[j + <span class="number">1</span>] = parent.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    parent.keys[i] = fullChild.keys[t - <span class="number">1</span>];</span><br><span class="line">    parent.keyCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除键">删除键</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 空间复杂度: O(t) 递归栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(BTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    deleteRec(tree.getRoot(), key, tree.t);</span><br><span class="line">    <span class="keyword">if</span> (tree.getRoot().keyCount == <span class="number">0</span> &amp;&amp; !tree.getRoot().isLeaf) &#123;</span><br><span class="line">        tree.setRoot(tree.getRoot().children[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteRec</span><span class="params">(BTreeNode node, <span class="type">int</span> key, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &lt; node.keyCount &amp;&amp; key == node.keys[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.isLeaf) &#123;</span><br><span class="line">            removeFromLeaf(node, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeFromNonLeaf(node, i, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node.isLeaf) &#123;</span><br><span class="line">        deleteFromSubtree(node, i, key, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeFromLeaf</span><span class="params">(BTreeNode node, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; node.keyCount; j++) &#123;</span><br><span class="line">        node.keys[j - <span class="number">1</span>] = node.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    node.keyCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeFromNonLeaf</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> node.keys[i];</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">pred</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">succ</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pred.keyCount &gt;= t) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">predKey</span> <span class="operator">=</span> getPredecessor(pred);</span><br><span class="line">        node.keys[i] = predKey;</span><br><span class="line">        deleteRec(pred, predKey, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (succ.keyCount &gt;= t) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">succKey</span> <span class="operator">=</span> getSuccessor(succ);</span><br><span class="line">        node.keys[i] = succKey;</span><br><span class="line">        deleteRec(succ, succKey, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mergeNodes(node, i, t);</span><br><span class="line">        deleteRec(node.children[i], key, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteFromSubtree</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> key, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="keyword">if</span> (child.keyCount &lt; t) &#123;</span><br><span class="line">        fillChild(node, i, t);</span><br><span class="line">    &#125;</span><br><span class="line">    deleteRec(child, key, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPredecessor</span><span class="params">(BTreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!node.isLeaf) &#123;</span><br><span class="line">        node = node.children[node.keyCount];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.keys[node.keyCount - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSuccessor</span><span class="params">(BTreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!node.isLeaf) &#123;</span><br><span class="line">        node = node.children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.keys[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeNodes</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">left</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">right</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    left.keys[left.keyCount] = node.keys[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; right.keyCount; j++) &#123;</span><br><span class="line">        left.keys[left.keyCount + <span class="number">1</span> + j] = right.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!left.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= right.keyCount; j++) &#123;</span><br><span class="line">            left.children[left.keyCount + <span class="number">1</span> + j] = right.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left.keyCount += right.keyCount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; node.keyCount; j++) &#123;</span><br><span class="line">        node.keys[j - <span class="number">1</span>] = node.keys[j];</span><br><span class="line">        node.children[j] = node.children[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.keyCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fillChild</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; node.children[i - <span class="number">1</span>].keyCount &gt;= t) &#123;</span><br><span class="line">        borrowFromPrev(node, i, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != node.keyCount &amp;&amp; node.children[i + <span class="number">1</span>].keyCount &gt;= t) &#123;</span><br><span class="line">        borrowFromNext(node, i, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != node.keyCount) &#123;</span><br><span class="line">            mergeNodes(node, i, t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeNodes(node, i - <span class="number">1</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowFromPrev</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">sibling</span> <span class="operator">=</span> node.children[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> child.keyCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        child.keys[j + <span class="number">1</span>] = child.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!child.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> child.keyCount; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            child.children[j + <span class="number">1</span>] = child.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    child.keys[<span class="number">0</span>] = node.keys[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!child.isLeaf) &#123;</span><br><span class="line">        child.children[<span class="number">0</span>] = sibling.children[sibling.keyCount];</span><br><span class="line">    &#125;</span><br><span class="line">    node.keys[i - <span class="number">1</span>] = sibling.keys[sibling.keyCount - <span class="number">1</span>];</span><br><span class="line">    child.keyCount++;</span><br><span class="line">    sibling.keyCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowFromNext</span><span class="params">(BTreeNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BTreeNode</span> <span class="variable">sibling</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    child.keys[child.keyCount] = node.keys[i];</span><br><span class="line">    <span class="keyword">if</span> (!child.isLeaf) &#123;</span><br><span class="line">        child.children[child.keyCount + <span class="number">1</span>] = sibling.children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.keys[i] = sibling.keys[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; sibling.keyCount; j++) &#123;</span><br><span class="line">        sibling.keys[j - <span class="number">1</span>] = sibling.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!sibling.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= sibling.keyCount; j++) &#123;</span><br><span class="line">            sibling.children[j - <span class="number">1</span>] = sibling.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    child.keyCount++;</span><br><span class="line">    sibling.keyCount--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="遍历中序遍历">遍历（中序遍历）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(t) 递归栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">    inorderRec(tree.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderRec</span><span class="params">(BTreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; node.keyCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.isLeaf) &#123;</span><br><span class="line">                inorderRec(node.children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(node.keys[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!node.isLeaf) &#123;</span><br><span class="line">            inorderRec(node.children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="使用示例-8">使用示例</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTree</span>(<span class="number">3</span>);  <span class="comment">// 最小度数 t=3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入键</span></span><br><span class="line">        insert(tree, <span class="number">10</span>);</span><br><span class="line">        insert(tree, <span class="number">20</span>);</span><br><span class="line">        insert(tree, <span class="number">5</span>);</span><br><span class="line">        insert(tree, <span class="number">6</span>);</span><br><span class="line">        insert(tree, <span class="number">12</span>);</span><br><span class="line">        insert(tree, <span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Inorder traversal:&quot;</span>);</span><br><span class="line">        inorder(tree);  <span class="comment">// 输出: 5 6 10 12 20 30</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 搜索</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search 6: &quot;</span> + (search(tree, <span class="number">6</span>) != <span class="literal">null</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search 15: &quot;</span> + (search(tree, <span class="number">15</span>) != <span class="literal">null</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        delete(tree, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After deleting 6:&quot;</span>);</span><br><span class="line">        inorder(tree);  <span class="comment">// 输出: 5 10 12 20 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="说明-4">说明</h6>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>搜索、插入、删除为 O(t log_t n)，其中 t 是度数，n 是键总数。</li>
<li>遍历为 O(n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>每个节点占用 O(t) 空间，递归栈为 O(t)。</li>
</ul></li>
<li><strong>算法特点</strong>：
<ul>
<li><strong>插入</strong>：通过分裂满节点保持平衡。</li>
<li><strong>删除</strong>：通过借用或合并子节点保持最小键数。</li>
<li><strong>搜索</strong>：利用有序键快速定位。</li>
</ul></li>
<li><strong>应用</strong>：
<ul>
<li>B 树适用于磁盘存储系统，因其多路结构减少了 I/O 操作。</li>
</ul></li>
<li><strong>扩展</strong>：
<ul>
<li>如果需要范围查询、最小/最大值等其他算法，可以告诉我，我会补充。</li>
</ul></li>
</ul>
<p>这个实现假设键为整数，t 为固定值。如果需要动态调整 t
或支持其他数据类型，可以进一步修改。有什么具体需求，请告诉我！</p>
<h5 id="b-树">B+ 树</h5>
<p>B+ 树是 B
树的变种，广泛用于数据库和文件系统，特点是所有键值存储在叶子节点，非叶子节点仅用于索引，且叶子节点通过链表连接，便于范围查询。</p>
<p><strong>B+ 树性质</strong>：</p>
<ol type="1">
<li>所有键值存储在叶子节点，非叶子节点仅存储索引。</li>
<li>每个节点最多有 2t-1 个键，最多 2t 个子节点。</li>
<li>每个非根节点至少有 t-1 个键，至少 t 个子节点。</li>
<li>叶子节点通过链表连接。</li>
</ol>
<hr />
<h6 id="b-树节点定义-1">B+ 树节点定义</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusNode</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] keys;           <span class="comment">// 键数组</span></span><br><span class="line">    BPlusNode[] children; <span class="comment">// 子节点数组（仅非叶子节点使用）</span></span><br><span class="line">    <span class="type">int</span> keyCount;         <span class="comment">// 当前键数量</span></span><br><span class="line">    <span class="type">boolean</span> isLeaf;       <span class="comment">// 是否为叶子节点</span></span><br><span class="line">    BPlusNode next;       <span class="comment">// 叶子节点的下一个指针</span></span><br><span class="line">    <span class="type">int</span> t;                <span class="comment">// 最小度数（定义 B+ 树的阶）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BPlusNode</span><span class="params">(<span class="type">int</span> t, <span class="type">boolean</span> isLeaf)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.isLeaf = isLeaf;</span><br><span class="line">        <span class="built_in">this</span>.keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * t - <span class="number">1</span>];      <span class="comment">// 最多 2t-1 个键</span></span><br><span class="line">        <span class="built_in">this</span>.children = isLeaf ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">BPlusNode</span>[<span class="number">2</span> * t]; <span class="comment">// 最多 2t 个子节点</span></span><br><span class="line">        <span class="built_in">this</span>.keyCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="b-树基本类-1">B+ 树基本类</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BPlusNode root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> t;  <span class="comment">// 最小度数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BPlusTree</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">BPlusNode</span>(t, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BPlusNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(BPlusNode root)</span> &#123; <span class="built_in">this</span>.root = root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="搜索键-1">搜索键</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 其中 t 是度数，n 是键总数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> BPlusNode <span class="title function_">search</span><span class="params">(BPlusTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">node</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    <span class="keyword">while</span> (!node.isLeaf) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (i &lt; node.keyCount &amp;&amp; node.keys[i] == key) ? node : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入键-1">插入键</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 空间复杂度: O(t) 递归栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(BPlusTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">root</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    <span class="keyword">if</span> (root.keyCount == <span class="number">2</span> * tree.t - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">BPlusNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BPlusNode</span>(tree.t, <span class="literal">false</span>);</span><br><span class="line">        newRoot.children[<span class="number">0</span>] = root;</span><br><span class="line">        splitChild(newRoot, <span class="number">0</span>, root, tree.t);</span><br><span class="line">        tree.setRoot(newRoot);</span><br><span class="line">        insertNonFull(tree.getRoot(), key, tree.t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertNonFull(root, key, tree.t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertNonFull</span><span class="params">(BPlusNode node, <span class="type">int</span> key, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.isLeaf) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> node.keyCount - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; key &lt; node.keys[i]) &#123;</span><br><span class="line">            node.keys[i + <span class="number">1</span>] = node.keys[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        node.keys[i + <span class="number">1</span>] = key;</span><br><span class="line">        node.keyCount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BPlusNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">        <span class="keyword">if</span> (child.keyCount == <span class="number">2</span> * t - <span class="number">1</span>) &#123;</span><br><span class="line">            splitChild(node, i, child, t);</span><br><span class="line">            <span class="keyword">if</span> (key &gt; node.keys[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNonFull(node.children[i], key, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">splitChild</span><span class="params">(BPlusNode parent, <span class="type">int</span> i, BPlusNode fullChild, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BPlusNode</span>(t, fullChild.isLeaf);</span><br><span class="line">    newNode.keyCount = t - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制后半部分键到新节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; t - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        newNode.keys[j] = fullChild.keys[j + t];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是叶子节点，设置链表指针</span></span><br><span class="line">    <span class="keyword">if</span> (fullChild.isLeaf) &#123;</span><br><span class="line">        newNode.next = fullChild.next;</span><br><span class="line">        fullChild.next = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是叶子节点，复制子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">            newNode.children[j] = fullChild.children[j + t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fullChild.keyCount = t - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整父节点的子节点和键</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> parent.keyCount; j &gt; i; j--) &#123;</span><br><span class="line">        parent.children[j + <span class="number">1</span>] = parent.children[j];</span><br><span class="line">    &#125;</span><br><span class="line">    parent.children[i + <span class="number">1</span>] = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> parent.keyCount - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">        parent.keys[j + <span class="number">1</span>] = parent.keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    parent.keys[i] = fullChild.keys[t - <span class="number">1</span>];  <span class="comment">// 中间键提升到父节点</span></span><br><span class="line">    parent.keyCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除键-1">删除键</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n), 空间复杂度: O(t) 递归栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(BPlusTree tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    deleteRec(tree.getRoot(), key, tree.t);</span><br><span class="line">    <span class="keyword">if</span> (tree.getRoot().keyCount == <span class="number">0</span> &amp;&amp; !tree.getRoot().isLeaf) &#123;</span><br><span class="line">        tree.setRoot(tree.getRoot().children[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteRec</span><span class="params">(BPlusNode node, <span class="type">int</span> key, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; key &gt; node.keys[i]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; node.keyCount &amp;&amp; node.keys[i] == key) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; node.keyCount; j++) &#123;</span><br><span class="line">                node.keys[j - <span class="number">1</span>] = node.keys[j];</span><br><span class="line">            &#125;</span><br><span class="line">            node.keyCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">BPlusNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">        <span class="keyword">if</span> (child.keyCount &lt; t) &#123;</span><br><span class="line">            fillChild(node, i, t);</span><br><span class="line">            <span class="keyword">if</span> (i &gt; node.keyCount) i--;  <span class="comment">// 合并可能导致索引调整</span></span><br><span class="line">        &#125;</span><br><span class="line">        deleteRec(node.children[i], key, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fillChild</span><span class="params">(BPlusNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; node.children[i - <span class="number">1</span>].keyCount &gt;= t) &#123;</span><br><span class="line">        borrowFromPrev(node, i, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != node.keyCount &amp;&amp; node.children[i + <span class="number">1</span>].keyCount &gt;= t) &#123;</span><br><span class="line">        borrowFromNext(node, i, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != node.keyCount) &#123;</span><br><span class="line">            mergeNodes(node, i, t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeNodes(node, i - <span class="number">1</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowFromPrev</span><span class="params">(BPlusNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">sibling</span> <span class="operator">=</span> node.children[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> child.keyCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            child.keys[j + <span class="number">1</span>] = child.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">        child.keys[<span class="number">0</span>] = sibling.keys[sibling.keyCount - <span class="number">1</span>];</span><br><span class="line">        node.keys[i - <span class="number">1</span>] = sibling.keys[sibling.keyCount - <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> child.keyCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            child.keys[j + <span class="number">1</span>] = child.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">        child.keys[<span class="number">0</span>] = node.keys[i - <span class="number">1</span>];</span><br><span class="line">        node.keys[i - <span class="number">1</span>] = sibling.keys[sibling.keyCount - <span class="number">1</span>];</span><br><span class="line">        child.children[child.keyCount + <span class="number">1</span>] = child.children[child.keyCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> child.keyCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            child.children[j + <span class="number">1</span>] = child.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">        child.children[<span class="number">0</span>] = sibling.children[sibling.keyCount];</span><br><span class="line">    &#125;</span><br><span class="line">    child.keyCount++;</span><br><span class="line">    sibling.keyCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowFromNext</span><span class="params">(BPlusNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">child</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">sibling</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child.isLeaf) &#123;</span><br><span class="line">        child.keys[child.keyCount] = sibling.keys[<span class="number">0</span>];</span><br><span class="line">        node.keys[i] = sibling.keys[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; sibling.keyCount; j++) &#123;</span><br><span class="line">            sibling.keys[j - <span class="number">1</span>] = sibling.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.keys[child.keyCount] = node.keys[i];</span><br><span class="line">        node.keys[i] = sibling.keys[<span class="number">0</span>];</span><br><span class="line">        child.children[child.keyCount + <span class="number">1</span>] = sibling.children[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; sibling.keyCount; j++) &#123;</span><br><span class="line">            sibling.keys[j - <span class="number">1</span>] = sibling.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= sibling.keyCount; j++) &#123;</span><br><span class="line">            sibling.children[j - <span class="number">1</span>] = sibling.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    child.keyCount++;</span><br><span class="line">    sibling.keyCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeNodes</span><span class="params">(BPlusNode node, <span class="type">int</span> i, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">left</span> <span class="operator">=</span> node.children[i];</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">right</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; right.keyCount; j++) &#123;</span><br><span class="line">            left.keys[left.keyCount + j] = right.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = right.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left.keys[left.keyCount] = node.keys[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; right.keyCount; j++) &#123;</span><br><span class="line">            left.keys[left.keyCount + <span class="number">1</span> + j] = right.keys[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= right.keyCount; j++) &#123;</span><br><span class="line">            left.children[left.keyCount + <span class="number">1</span> + j] = right.children[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left.keyCount += right.keyCount + (left.isLeaf ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; node.keyCount; j++) &#123;</span><br><span class="line">        node.keys[j - <span class="number">1</span>] = node.keys[j];</span><br><span class="line">        node.children[j] = node.children[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.keyCount--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="范围查询">范围查询</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(t log_t n + k), 其中 k 是范围内的键数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(k) 用于存储结果</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rangeSearch</span><span class="params">(BPlusTree tree, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">node</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到第一个大于等于 low 的叶子节点</span></span><br><span class="line">    <span class="keyword">while</span> (!node.isLeaf) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; node.keyCount &amp;&amp; low &gt; node.keys[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历叶子节点链表</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; node.keyCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.keys[i] &gt;= low &amp;&amp; node.keys[i] &lt;= high) &#123;</span><br><span class="line">                result.add(node.keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.keys[i] &gt; high) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="遍历叶子节点顺序遍历">遍历（叶子节点顺序遍历）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(BPlusTree tree)</span> &#123;</span><br><span class="line">    <span class="type">BPlusNode</span> <span class="variable">node</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">    <span class="keyword">while</span> (!node.isLeaf) &#123;</span><br><span class="line">        node = node.children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; node.keyCount; i++) &#123;</span><br><span class="line">            System.out.print(node.keys[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="使用示例-9">使用示例</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BPlusTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BPlusTree</span>(<span class="number">3</span>);  <span class="comment">// 最小度数 t=3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入键</span></span><br><span class="line">        insert(tree, <span class="number">10</span>);</span><br><span class="line">        insert(tree, <span class="number">20</span>);</span><br><span class="line">        insert(tree, <span class="number">5</span>);</span><br><span class="line">        insert(tree, <span class="number">6</span>);</span><br><span class="line">        insert(tree, <span class="number">12</span>);</span><br><span class="line">        insert(tree, <span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Traversal:&quot;</span>);</span><br><span class="line">        traverse(tree);  <span class="comment">// 输出: 5 6 10 12 20 30</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 搜索</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search 6: &quot;</span> + (search(tree, <span class="number">6</span>) != <span class="literal">null</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search 15: &quot;</span> + (search(tree, <span class="number">15</span>) != <span class="literal">null</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        delete(tree, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After deleting 6:&quot;</span>);</span><br><span class="line">        traverse(tree);  <span class="comment">// 输出: 5 10 12 20 30</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 范围查询</span></span><br><span class="line">        List&lt;Integer&gt; range = rangeSearch(tree, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Range [10, 20]: &quot;</span> + range);  <span class="comment">// 输出: [10, 12, 20]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="说明-5">说明</h6>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>搜索、插入、删除为 O(t log_t n)，t 是度数，n 是键总数。</li>
<li>范围查询为 O(t log_t n + k)，k 是范围内的键数。</li>
<li>遍历为 O(n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>每个节点占用 O(t) 空间，递归栈为 O(t)。</li>
<li>范围查询结果占用 O(k) 空间。</li>
</ul></li>
<li><strong>算法特点</strong>：
<ul>
<li><strong>插入</strong>：分裂时将中间键提升到父节点，叶子节点保持链表。</li>
<li><strong>删除</strong>：仅从叶子节点删除，通过借用或合并保持平衡。</li>
<li><strong>范围查询</strong>：利用叶子节点链表高效实现。</li>
</ul></li>
<li><strong>与 B 树的区别</strong>：
<ul>
<li>B+ 树叶子节点存储所有数据，非叶子节点仅用于导航。</li>
<li>叶子节点链表支持顺序访问和范围查询。</li>
</ul></li>
<li><strong>应用</strong>：
<ul>
<li>数据库索引（如 MySQL InnoDB），因其支持高效范围查询和顺序访问。</li>
</ul></li>
</ul>
<p>这个实现假设键为整数，t 为固定值。如果需要支持其他数据类型或动态
t，可以进一步修改。有什么具体需求，请告诉我！</p>
<h4 id="trie-前缀树">Trie (前缀树)</h4>
<p>Trie 是一种树形数据结构，特别适合处理字符串的前缀查询和搜索问题。</p>
<ul>
<li><strong>定义</strong>:
多叉树，用于存储字符串集合，每个节点代表一个字符。</li>
<li><strong>特性</strong>: 高效前缀查询，空间换时间。</li>
<li><strong>应用场景</strong>:
<ul>
<li>自动补全（如搜索引擎）</li>
<li>拼写检查</li>
<li>IP路由表</li>
</ul></li>
</ul>
<hr />
<h5 id="trie-节点定义">1. Trie 节点定义</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    TrieNode[] children;  <span class="comment">// 子节点数组，通常大小为字符集大小</span></span><br><span class="line">    <span class="type">boolean</span> isEnd;        <span class="comment">// 标记是否为单词结尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];  <span class="comment">// 假设只处理小写字母 a-z</span></span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="trie-基本类">2. Trie 基本类</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TrieNode <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="trie-常用算法">3. Trie 常用算法</h5>
<h6 id="插入字符串">3.1 插入字符串</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(m), 其中 m 是字符串长度</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(m), 最坏情况下为每个字符创建一个新节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Trie trie, String word)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> trie.getRoot();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 假设小写字母</span></span><br><span class="line">        <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.children[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="literal">true</span>;  <span class="comment">// 标记单词结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="搜索完整单词">3.2 搜索完整单词</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(m), 其中 m 是单词长度</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(Trie trie, String word)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> trie.getRoot();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.isEnd;  <span class="comment">// 必须是单词结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="检查前缀">3.3 检查前缀</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(m), 其中 m 是前缀长度</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(Trie trie, String prefix)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> trie.getRoot();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 只要前缀存在即可，不要求是单词结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除字符串">3.4 删除字符串</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(m), 其中 m 是字符串长度</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1) 不考虑递归栈，递归栈为 O(m)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Trie trie, String word)</span> &#123;</span><br><span class="line">    deleteRec(trie.getRoot(), word, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">deleteRec</span><span class="params">(TrieNode node, String word, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == word.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node.isEnd) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不是单词结尾，无需删除</span></span><br><span class="line">        node.isEnd = <span class="literal">false</span>;  <span class="comment">// 取消单词结尾标记</span></span><br><span class="line">        <span class="keyword">return</span> isEmpty(node);  <span class="comment">// 检查是否可以删除该节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(depth) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">shouldDeleteCurrent</span> <span class="operator">=</span> deleteRec(node.children[index], word, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (shouldDeleteCurrent) &#123;</span><br><span class="line">        node.children[index] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> isEmpty(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(TrieNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (TrieNode child : node.children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !node.isEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找所有以某前缀开头的单词">3.5 查找所有以某前缀开头的单词</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(p + n), 其中 p 是前缀长度，n 是以该前缀开头的单词总数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(n), 用于存储结果</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWordsWithPrefix</span><span class="params">(Trie trie, String prefix)</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> trie.getRoot();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定位到前缀节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;  <span class="comment">// 前缀不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从该节点开始 DFS 收集所有单词</span></span><br><span class="line">    findWordsRec(node, prefix, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findWordsRec</span><span class="params">(TrieNode node, String prefix, List&lt;String&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.isEnd) &#123;</span><br><span class="line">        result.add(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.children[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            findWordsRec(node.children[i], prefix + (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + i), result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="计算-trie-中单词总数">3.6 计算 Trie 中单词总数</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 其中 n 是 Trie 中所有节点数</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(h), 其中 h 是 Trie 高度（递归栈）</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWords</span><span class="params">(Trie trie)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> countWordsRec(trie.getRoot());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countWordsRec</span><span class="params">(TrieNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> node.isEnd ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TrieNode child : node.children) &#123;</span><br><span class="line">        count += countWordsRec(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="使用示例-10">使用示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入单词</span></span><br><span class="line">        insert(trie, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        insert(trie, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        insert(trie, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 搜索单词</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search &#x27;apple&#x27;: &quot;</span> + search(trie, <span class="string">&quot;apple&quot;</span>));    <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search &#x27;app&#x27;: &quot;</span> + search(trie, <span class="string">&quot;app&quot;</span>));        <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Search &#x27;appl&#x27;: &quot;</span> + search(trie, <span class="string">&quot;appl&quot;</span>));      <span class="comment">// 输出: false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查前缀</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Starts with &#x27;app&#x27;: &quot;</span> + startsWith(trie, <span class="string">&quot;app&quot;</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Starts with &#x27;ban&#x27;: &quot;</span> + startsWith(trie, <span class="string">&quot;ban&quot;</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除单词</span></span><br><span class="line">        delete(trie, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After deleting &#x27;app&#x27;, search &#x27;app&#x27;: &quot;</span> + search(trie, <span class="string">&quot;app&quot;</span>));  <span class="comment">// 输出: false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找前缀单词</span></span><br><span class="line">        List&lt;String&gt; words = findWordsWithPrefix(trie, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Words with prefix &#x27;a&#x27;: &quot;</span> + words);  <span class="comment">// 输出: [apple]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计单词数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Total words: &quot;</span> + countWords(trie));  <span class="comment">// 输出: 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h5 id="说明-6">说明</h5>
<ul>
<li><strong>Trie 特点</strong>：
<ul>
<li>每个节点表示一个字符，路径表示字符串。</li>
<li>适合前缀查询、自动补全等场景。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>插入、搜索、检查前缀为 O(m)，m 是字符串长度。</li>
<li>删除为 O(m)，但涉及递归清理。</li>
<li>查找前缀单词为 O(p + n)，p 是前缀长度，n 是匹配单词数。</li>
<li>统计单词为 O(n)，n 是所有节点数。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>插入可能需要 O(m) 空间来存储新节点。</li>
<li>其他操作通常为 O(1) 或 O(h)，h 是 Trie 高度。</li>
</ul></li>
<li><strong>假设</strong>：
<ul>
<li>这里假设只处理小写字母（26 个字符）。如果需要支持更多字符（如 ASCII
或 Unicode），可以调整 <code>children</code> 数组大小。</li>
</ul></li>
<li><strong>扩展</strong>：
<ul>
<li>如果需要支持大小写、数字等，可以将 <code>children</code> 改为
<code>Map&lt;Character, TrieNode&gt;</code>。</li>
<li>如果需要其他算法（如最长公共前缀、模糊匹配等），可以告诉我，我会补充。</li>
</ul></li>
</ul>
<h2 id="哈希结构">哈希结构</h2>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 16%" />
<col style="width: 30%" />
<col style="width: 26%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th>数据结构</th>
<th>特点</th>
<th>冲突解决方法</th>
<th>操作</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>哈希表 (Hash Table)</strong></td>
<td>键值对存储，通过哈希函数快速定位</td>
<td>- <strong>链地址法</strong>：链表存储冲突元素<br>-
<strong>开放寻址法</strong>：探测下一个空位<br>包括线性探测、二次探测和双重哈希</td>
<td>插入：O(1)<br>删除：O(1)<br>查找：O(1)（理想情况下）</td>
<td>缓存（如Redis）<br>快速去重</td>
</tr>
</tbody>
</table>
<p>哈希表是一种基于键值对（Key-Value
Pair）的高效数据结构，通过哈希函数将键映射到存储位置，支持快速的插入、查找和删除操作。实现一个简单的哈希表，处理冲突使用<strong>链地址法</strong>（Separate
Chaining）。</p>
<hr />
<h3 id="哈希表节点定义链地址法">哈希表节点定义（链地址法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    HashNode next;  <span class="comment">// 链表指针，处理冲突</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈希表基本类">哈希表基本类</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashNode[] table;  <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;      <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;          <span class="comment">// 当前键值对数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTable</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">HashNode</span>[capacity];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简单哈希函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(key) % capacity;  <span class="comment">// 取模运算</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入键值对">插入键值对</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: 平均 O(1), 最坏 O(n)（冲突严重时）</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)（不计链表节点）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(HashTable ht, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ht.hash(key);</span><br><span class="line">    <span class="keyword">if</span> (ht.table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">        ht.table[index] = <span class="keyword">new</span> <span class="title class_">HashNode</span>(key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">HashNode</span> <span class="variable">current</span> <span class="operator">=</span> ht.table[index];</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.key == key) &#123;  <span class="comment">// 键已存在，更新值</span></span><br><span class="line">                current.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = <span class="keyword">new</span> <span class="title class_">HashNode</span>(key, value);  <span class="comment">// 插入到链表末尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    ht.size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找键值对">查找键值对</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: 平均 O(1), 最坏 O(n)（冲突严重时）</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(HashTable ht, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ht.hash(key);</span><br><span class="line">    <span class="type">HashNode</span> <span class="variable">current</span> <span class="operator">=</span> ht.table[index];</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> current.value;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除键值对">删除键值对</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: 平均 O(1), 最坏 O(n)（冲突严重时）</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(HashTable ht, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ht.hash(key);</span><br><span class="line">    <span class="type">HashNode</span> <span class="variable">current</span> <span class="operator">=</span> ht.table[index];</span><br><span class="line">    <span class="type">HashNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.key == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">                ht.table[index] = current.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ht.size--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检查键是否存在">检查键是否存在</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: 平均 O(1), 最坏 O(n)（冲突严重时）</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(HashTable ht, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ht.hash(key);</span><br><span class="line">    <span class="type">HashNode</span> <span class="variable">current</span> <span class="operator">=</span> ht.table[index];</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取所有键">获取所有键</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n + m), 其中 n 是键值对数，m 是数组容量</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(n)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getAllKeys</span><span class="params">(HashTable ht)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ht.capacity; i++) &#123;</span><br><span class="line">        <span class="type">HashNode</span> <span class="variable">current</span> <span class="operator">=</span> ht.table[i];</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            keys.add(current.key);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整容量动态扩容">调整容量（动态扩容）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n), 空间复杂度: O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(HashTable ht, <span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    HashNode[] oldTable = ht.table;</span><br><span class="line">    ht.table = <span class="keyword">new</span> <span class="title class_">HashNode</span>[newCapacity];</span><br><span class="line">    ht.capacity = newCapacity;</span><br><span class="line">    ht.size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (HashNode node : oldTable) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            put(ht, node.key, node.value);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="使用示例-11">使用示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashTable</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTable</span>(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入键值对</span></span><br><span class="line">        put(ht, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        put(ht, <span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">        put(ht, <span class="number">6</span>, <span class="number">600</span>);  <span class="comment">// 可能与 1 冲突（6 % 5 = 1）</span></span><br><span class="line">        put(ht, <span class="number">3</span>, <span class="number">300</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Get 2: &quot;</span> + get(ht, <span class="number">2</span>));    <span class="comment">// 输出: 200</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Get 6: &quot;</span> + get(ht, <span class="number">6</span>));    <span class="comment">// 输出: 600</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Get 5: &quot;</span> + get(ht, <span class="number">5</span>));    <span class="comment">// 输出: null</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Contains 1: &quot;</span> + containsKey(ht, <span class="number">1</span>));  <span class="comment">// 输出: true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        remove(ht, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After removing 2, get 2: &quot;</span> + get(ht, <span class="number">2</span>));  <span class="comment">// 输出: null</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取所有键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;All keys: &quot;</span> + getAllKeys(ht));  <span class="comment">// 输出: [1, 6, 3]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        resize(ht, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After resize, get 6: &quot;</span> + get(ht, <span class="number">6</span>));  <span class="comment">// 输出: 600</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="说明-7">说明</h3>
<ul>
<li><strong>链地址法特点</strong>：
<ul>
<li>使用链表处理冲突，适合动态负载。</li>
<li>平均时间复杂度为 O(1)，但冲突严重时退化为 O(n)。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>插入、查找、删除：平均 O(1)，最坏 O(n)。</li>
<li>获取所有键和扩容：O(n)。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>基本操作 O(1)，存储所有键值对为 O(n)。</li>
<li>扩容时临时需要 O(n) 额外空间。</li>
</ul></li>
<li><strong>哈希函数</strong>：
<ul>
<li>这里使用简单的模运算，可根据需求优化（如乘法散列）。</li>
</ul></li>
<li><strong>负载因子</strong>：
<ul>
<li>当 size/capacity 超过某个阈值（如 0.7），应调用 <code>resize</code>
扩容以保持性能。</li>
</ul></li>
<li><strong>应用</strong>：
<ul>
<li>哈希表用于键值存储（如 HashMap）、缓存、数据库索引等。</li>
</ul></li>
</ul>
<h3 id="开放寻址法处理冲突">开放寻址法处理冲突</h3>
<hr />
<h4 id="哈希表基本类开放寻址法通用">哈希表基本类（开放寻址法通用）</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAddressingHashTable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">boolean</span> isDeleted;  <span class="comment">// 懒删除标记</span></span><br><span class="line"></span><br><span class="line">        Entry(<span class="type">int</span> key, <span class="type">int</span> value) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.isDeleted = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">LOAD_FACTOR_THRESHOLD</span> <span class="operator">=</span> <span class="number">0.75</span>;  <span class="comment">// 负载因子阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAddressingHashTable</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始哈希函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(key) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个哈希函数（用于双重哈希）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash2</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> - (key % <span class="number">7</span>);  <span class="comment">// 确保步长不为 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCapacity</span><span class="params">()</span> &#123; <span class="keyword">return</span> capacity; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容 - 时间复杂度: O(n)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">        capacity = newCapacity;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : oldTable) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; !entry.isDeleted) &#123;</span><br><span class="line">                putLinear(entry.key, entry.value);  <span class="comment">// 选择一种方法重新插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查负载因子并扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkLoadFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">double</span>) size / capacity &gt;= LOAD_FACTOR_THRESHOLD) &#123;</span><br><span class="line">            resize(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="线性探测linear-probing实现">线性探测（Linear Probing）实现</h4>
<p>发生冲突时，线性向后查找下一个空位。时间复杂度：平均
O(1)，但随着负载因子增加，可能退化为 O(n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性探测函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">probeLinear</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (hash(key) + i) % capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putLinear</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    checkLoadFactor();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeLinear(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span> || table[index].isDeleted) &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (table[index].key == key) &#123;</span><br><span class="line">            table[index].value = value;  <span class="comment">// 更新值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Hash table is full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getLinear</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeLinear(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> table[index].value;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeLinear</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeLinear(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">            table[index].isDeleted = <span class="literal">true</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="二次探测quadratic-probing实现">二次探测（Quadratic
Probing）实现</h4>
<p>冲突时按二次函数（i²）偏移查找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二次探测函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">probeQuadratic</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (hash(key) + i * i) % capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putQuadratic</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    checkLoadFactor();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeQuadratic(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span> || table[index].isDeleted) &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (table[index].key == key) &#123;</span><br><span class="line">            table[index].value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Hash table is full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getQuadratic</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeQuadratic(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> table[index].value;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeQuadratic</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        index = probeQuadratic(key, i);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">            table[index].isDeleted = <span class="literal">true</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="双重哈希double-hashing实现">双重哈希（Double Hashing）实现</h4>
<p>使用第二个哈希函数确定探测步长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 双重哈希探测函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">probeDouble</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (hash(key) + i * hash2(key)) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putDouble</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        checkLoadFactor();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            index = probeDouble(key, i);</span><br><span class="line">            <span class="keyword">if</span> (table[index] == <span class="literal">null</span> || table[index].isDeleted) &#123;</span><br><span class="line">                table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (table[index].key == key) &#123;</span><br><span class="line">                table[index].value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; capacity);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Hash table is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getDouble</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            index = probeDouble(key, i);</span><br><span class="line">            <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> table[index].value;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 - 时间复杂度: 平均 O(1), 最坏 O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeDouble</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            index = probeDouble(key, i);</span><br><span class="line">            <span class="keyword">if</span> (table[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!table[index].isDeleted &amp;&amp; table[index].key == key) &#123;</span><br><span class="line">                table[index].isDeleted = <span class="literal">true</span>;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; capacity &amp;&amp; table[index] != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="使用示例-12">使用示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="type">OpenAddressingHashTable</span> <span class="variable">htLinear</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenAddressingHashTable</span>(<span class="number">5</span>);</span><br><span class="line">        htLinear.putLinear(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        htLinear.putLinear(<span class="number">6</span>, <span class="number">600</span>);  <span class="comment">// 冲突：6 % 5 = 1</span></span><br><span class="line">        htLinear.putLinear(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Linear Probing - Get 6: &quot;</span> + htLinear.getLinear(<span class="number">6</span>));  <span class="comment">// 输出: 600</span></span><br><span class="line">        htLinear.removeLinear(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Linear Probing - After remove 6: &quot;</span> + htLinear.getLinear(<span class="number">6</span>));  <span class="comment">// 输出: null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二次探测</span></span><br><span class="line">        <span class="type">OpenAddressingHashTable</span> <span class="variable">htQuadratic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenAddressingHashTable</span>(<span class="number">5</span>);</span><br><span class="line">        htQuadratic.putQuadratic(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        htQuadratic.putQuadratic(<span class="number">6</span>, <span class="number">600</span>);</span><br><span class="line">        htQuadratic.putQuadratic(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Quadratic Probing - Get 6: &quot;</span> + htQuadratic.getQuadratic(<span class="number">6</span>));  <span class="comment">// 输出: 600</span></span><br><span class="line">        htQuadratic.removeQuadratic(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Quadratic Probing - After remove 6: &quot;</span> + htQuadratic.getQuadratic(<span class="number">6</span>));  <span class="comment">// 输出: null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双重哈希</span></span><br><span class="line">        <span class="type">OpenAddressingHashTable</span> <span class="variable">htDouble</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenAddressingHashTable</span>(<span class="number">5</span>);</span><br><span class="line">        htDouble.putDouble(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        htDouble.putDouble(<span class="number">6</span>, <span class="number">600</span>);</span><br><span class="line">        htDouble.putDouble(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Double Hashing - Get 6: &quot;</span> + htDouble.getDouble(<span class="number">6</span>));  <span class="comment">// 输出: 600</span></span><br><span class="line">        htDouble.removeDouble(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Double Hashing - After remove 6: &quot;</span> + htDouble.getDouble(<span class="number">6</span>));  <span class="comment">// 输出: null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="说明-8">说明</h4>
<ul>
<li><strong>负载因子控制</strong>：
<ul>
<li>设置 <code>LOAD_FACTOR_THRESHOLD = 0.75</code>，当 size/capacity ≥
0.75 时，自动扩容为两倍容量。</li>
<li>扩容通过 <code>resize</code> 方法实现，时间复杂度 O(n)。</li>
</ul></li>
<li><strong>冲突处理方法</strong>：
<ul>
<li><strong>线性探测</strong>：简单，但容易主聚集。</li>
<li><strong>二次探测</strong>：减少主聚集，但可能次聚集，需确保容量为素数以覆盖所有位置。</li>
<li><strong>双重哈希</strong>：最优，避免聚集，但需设计合适的第二个哈希函数。</li>
</ul></li>
<li><strong>时间复杂度</strong>：
<ul>
<li>平均 O(1)（负载因子低时），最坏 O(n)（表满或聚集严重）。</li>
</ul></li>
<li><strong>空间复杂度</strong>：
<ul>
<li>O(1) 额外空间（不计数组本身），扩容时临时需要 O(n)。</li>
</ul></li>
<li><strong>优化点</strong>：
<ul>
<li>这里使用懒删除（标记删除），避免破坏探测序列。</li>
<li>哈希函数简单，可根据实际需求优化（如乘法散列）。</li>
<li>二次探测和双重哈希未强制容量为素数，实际应用中建议调整。</li>
</ul></li>
</ul>
<h2 id="图结构">图结构</h2>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 24%" />
<col style="width: 43%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>类别</th>
<th>内容</th>
<th>描述</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>表示方式</strong></td>
<td><strong>邻接矩阵</strong></td>
<td>二维数组表示顶点关系，<code>matrix[i][j]</code>表示边权重或是否存在边</td>
<td>适合稠密图（边较多）</td>
</tr>
<tr class="even">
<td></td>
<td><strong>邻接表</strong></td>
<td>链表数组表示顶点关系，每个顶点关联一个邻接顶点链表</td>
<td>适合稀疏图（边较少）</td>
</tr>
<tr class="odd">
<td><strong>算法场景</strong></td>
<td><strong>最短路径 (Dijkstra算法)</strong></td>
<td>从单一源点计算到所有顶点的最短路径，基于贪心策略</td>
<td>网络路由、路径规划</td>
</tr>
<tr class="even">
<td></td>
<td><strong>最小生成树 (Prim/Kruskal算法)</strong></td>
<td>- <strong>Prim</strong>：从某顶点扩展生成树<br>-
<strong>Kruskal</strong>：按边权重排序合并</td>
<td>网络设计（如电缆布线）</td>
</tr>
<tr class="odd">
<td></td>
<td><strong>拓扑排序</strong></td>
<td>对有向无环图（DAG）排序，输出顶点线性序列</td>
<td>任务调度、依赖解析（如编译顺序）</td>
</tr>
</tbody>
</table>
<h3 id="定义">定义</h3>
<p>图（Graph）是由 <strong>顶点 (Vertex)</strong> 和 <strong>边
(Edge)</strong> 构成的数据结构，可以用来表示对象之间的关系。</p>
<ul>
<li><strong>有向图 (Directed Graph)</strong>：边有方向。</li>
<li><strong>无向图 (Undirected Graph)</strong>：边无方向。</li>
<li><strong>加权图 (Weighted Graph)</strong>：边带有权值。</li>
<li><strong>邻接矩阵</strong>：适合稠密图，存储空间 O(V²)。</li>
<li><strong>邻接表</strong>：适合稀疏图，存储空间 O(V + E)。</li>
</ul>
<h3 id="图的表示">图的表示</h3>
<p>在实际工程中，图算法几乎都用 <strong>邻接表</strong>
而不是邻接矩阵，因为邻接表只占 <strong>O(V+E)</strong>
空间，适合现实中的稀疏图；遍历效率高（O(V+E) vs
O(V²)）；实现更贴近实际场景如社交网络、路网、依赖图，而邻接矩阵仅在小规模稠密图或需要
O(1) 判断边存在时才会用。</p>
<h4 id="邻接矩阵表示">邻接矩阵表示</h4>
<h5 id="定义-1">定义</h5>
<p>邻接矩阵 (Adjacency Matrix) 用一个二维数组 <code>matrix[V][V]</code>
表示图：</p>
<ul>
<li><strong>无向图</strong>：如果存在边 (u, v)，则
<code>matrix[u][v] = matrix[v][u] = 1</code>。</li>
<li><strong>有向图</strong>：如果存在边 u → v，则
<code>matrix[u][v] = 1</code>。</li>
<li><strong>加权图</strong>：边权值存储在 <code>matrix[u][v]</code>
中，没有边则用 <code>0</code> 或 <code>∞</code> 表示。</li>
<li><strong>空间复杂度</strong>：O(V²)，适合稠密图。</li>
<li><strong>时间复杂度</strong>：判断是否存在一条边为 O(1)。</li>
</ul>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;  <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;           <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphMatrix</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        matrix = <span class="keyword">new</span> <span class="title class_">int</span>[V][V];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边 (无向图)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        matrix[u][v] = <span class="number">1</span>;</span><br><span class="line">        matrix[v][u] = <span class="number">1</span>; <span class="comment">// 如果是有向图，这行去掉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加加权边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWeightedEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        matrix[u][v] = weight;</span><br><span class="line">        matrix[v][u] = weight; <span class="comment">// 无向图对称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[u][v] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印邻接矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">                System.out.print(matrix[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历算法">遍历算法</h5>
<h6 id="深度优先搜索-dfs">1. 深度优先搜索 (DFS)</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    System.out.print(start + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[start][v] != <span class="number">0</span> &amp;&amp; !visited[v]) &#123;</span><br><span class="line">            dfs(v, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(V²)</li>
<li><strong>空间复杂度</strong>：O(V)</li>
</ul>
<hr />
<h6 id="广度优先搜索-bfs">2. 广度优先搜索 (BFS)</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    queue.offer(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(u + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[u][v] != <span class="number">0</span> &amp;&amp; !visited[v]) &#123;</span><br><span class="line">                visited[v] = <span class="literal">true</span>;</span><br><span class="line">                queue.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(V²)</li>
<li><strong>空间复杂度</strong>：O(V)</li>
</ul>
<hr />
<h5 id="使用示例-13">使用示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GraphMatrix</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphMatrix</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;邻接矩阵:&quot;</span>);</span><br><span class="line">    g.printGraph();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;DFS 遍历:&quot;</span>);</span><br><span class="line">    g.dfs(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">4</span>]);  <span class="comment">// 输出: 0 1 2 3</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\nBFS 遍历:&quot;</span>);</span><br><span class="line">    g.bfs(<span class="number">0</span>);  <span class="comment">// 输出: 0 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结">总结</h5>
<ul>
<li>邻接矩阵适合 <strong>稠密图</strong>，判断边是否存在很快 O(1)。</li>
<li>但空间开销大 (O(V²))，不适合稀疏图。</li>
<li>遍历复杂度 O(V²)，在稠密图和顶点不太多的情况下效果很好。</li>
</ul>
<h4 id="邻接表表示">邻接表表示</h4>
<h5 id="定义-2">定义</h5>
<p>邻接表 (Adjacency List) 是用 <strong>链表 / 动态数组</strong>
存储每个顶点的相邻顶点集合。</p>
<ul>
<li><strong>空间复杂度</strong>：O(V + E)，适合
<strong>稀疏图</strong>。</li>
<li><strong>时间复杂度</strong>：判断是否存在边需要
O(度(v))，不如邻接矩阵快。</li>
<li><strong>常见实现</strong>：
<ul>
<li>数组 + 链表（C/C++ 常见）</li>
<li><code>ArrayList&lt;List&lt;Integer&gt;&gt;</code>（Java 常用）</li>
</ul></li>
</ul>
<h5 id="代码-1">代码</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;  <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; adj;  <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphList</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); <span class="comment">// 每个顶点有一个邻接链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边 (无向图)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        adj.get(u).add(v);</span><br><span class="line">        adj.get(v).add(u); <span class="comment">// 如果是有向图，这行去掉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取邻居</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNeighbors</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adj.get(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(i)) &#123;</span><br><span class="line">                System.out.print(neighbor + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历">遍历</h5>
<h6 id="深度优先搜索-dfs-1">深度优先搜索 (DFS)</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    System.out.print(u + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(u)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            dfs(neighbor, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(V + E)</li>
<li><strong>空间复杂度</strong>：O(V)</li>
</ul>
<h6 id="广度优先搜索-bfs-1">广度优先搜索 (BFS)</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    queue.offer(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(u + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                queue.offer(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(V + E)</li>
<li><strong>空间复杂度</strong>：O(V)</li>
</ul>
<h5 id="使用示例-14">使用示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GraphList</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphList</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.addEdge(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;邻接表表示:&quot;</span>);</span><br><span class="line">    g.printGraph();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;DFS 遍历:&quot;</span>);</span><br><span class="line">    g.dfs(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">5</span>]);  <span class="comment">// 输出: 0 1 3 2 4</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\nBFS 遍历:&quot;</span>);</span><br><span class="line">    g.bfs(<span class="number">0</span>);  <span class="comment">// 输出: 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="总结对比">总结对比</h4>
<ul>
<li><strong>邻接矩阵</strong>：O(1) 判断边是否存在，空间
O(V²)，适合稠密图。</li>
<li><strong>邻接表</strong>：空间 O(V + E)，遍历高效，适合稀疏图。</li>
</ul>
<hr />
<h3 id="图的常见算法">图的常见算法</h3>
<h4 id="最短路径">最短路径</h4>
<h5 id="dijkstra非负权图oe-log-v">Dijkstra（非负权图，O(E log V)）</h5>
<ul>
<li><strong>邻接矩阵版</strong>（适合稠密图，复杂度 O(V²)）</li>
<li><strong>邻接表 + 最小堆版</strong>（适合稀疏图，复杂度 O(E log
V)）</li>
</ul>
<h6 id="邻接矩阵实现ov²">1. 邻接矩阵实现（O(V²)）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DijkstraMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DijkstraMatrix</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        graph = <span class="keyword">new</span> <span class="title class_">int</span>[V][V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            Arrays.fill(graph[i], Integer.MAX_VALUE); <span class="comment">// 无边记为无穷大</span></span><br><span class="line">            graph[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        graph[u][v] = w;</span><br><span class="line">        graph[v][u] = w; <span class="comment">// 如果是有向图就去掉这行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> src)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> minDistance(dist, visited);</span><br><span class="line">            visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; graph[u][v] != Integer.MAX_VALUE </span><br><span class="line">                    &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                    dist[v] = dist[u] + graph[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printSolution(dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(<span class="type">int</span>[] dist, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE, minIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class="line">                min = dist[v];</span><br><span class="line">                minIndex = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printSolution</span><span class="params">(<span class="type">int</span>[] dist)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vertex Distance from Source:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; \t &quot;</span> + dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DijkstraMatrix</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DijkstraMatrix</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        g.dijkstra(<span class="number">0</span>); <span class="comment">// 从 0 号点开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="邻接表-最小堆实现oe-log-v">2. 邻接表 + 最小堆实现（O(E log
V)）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DijkstraList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Node&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> vertex, weight;</span><br><span class="line">        Node(<span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">            vertex = v;</span><br><span class="line">            weight = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DijkstraList</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        adj.get(u).add(<span class="keyword">new</span> <span class="title class_">Node</span>(v, w));</span><br><span class="line">        adj.get(v).add(<span class="keyword">new</span> <span class="title class_">Node</span>(u, w)); <span class="comment">// 如果是有向图就去掉这行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> src)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(n -&gt; n.weight));</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(src, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> node.vertex;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node neighbor : adj.get(u)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> neighbor.vertex;</span><br><span class="line">                <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> neighbor.weight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dist[u] + weight &lt; dist[v]) &#123;</span><br><span class="line">                    dist[v] = dist[u] + weight;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(v, dist[v]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printSolution(dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printSolution</span><span class="params">(<span class="type">int</span>[] dist)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vertex Distance from Source:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; \t &quot;</span> + dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DijkstraList</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DijkstraList</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        g.dijkstra(<span class="number">0</span>); <span class="comment">// 从 0 号点开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="对比总结">对比总结</h6>
<table>
<thead>
<tr class="header">
<th>实现方式</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>适合场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>邻接矩阵</td>
<td>O(V²)</td>
<td>O(V²)</td>
<td>稠密图（边接近 V²）</td>
</tr>
<tr class="even">
<td>邻接表 + 堆</td>
<td>O(E log V)</td>
<td>O(V+E)</td>
<td>稀疏图（边远小于 V²）</td>
</tr>
</tbody>
</table>
<h5 id="bellman-ford支持负权ove">Bellman-Ford（支持负权，O(VE)）</h5>
<h6 id="邻接矩阵实现ov³">1. 邻接矩阵实现（O(V³)）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BellmanFordMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BellmanFordMatrix</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        graph = <span class="keyword">new</span> <span class="title class_">int</span>[V][V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            Arrays.fill(graph[i], Integer.MAX_VALUE);</span><br><span class="line">            graph[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        graph[u][v] = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bellmanFord</span><span class="params">(<span class="type">int</span> src)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行 V-1 轮松弛</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; V - <span class="number">1</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (graph[u][v] != Integer.MAX_VALUE &amp;&amp; dist[u] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                            dist[v] = dist[u] + graph[u][v];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测负权回路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[u][v] != Integer.MAX_VALUE &amp;&amp; dist[u] != Integer.MAX_VALUE</span><br><span class="line">                    &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;图中包含负权回路！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printSolution(dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printSolution</span><span class="params">(<span class="type">int</span>[] dist)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vertex Distance from Source:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; \t &quot;</span> + dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BellmanFordMatrix</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BellmanFordMatrix</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">3</span>, -<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        g.bellmanFord(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="邻接表实现ove">2. 邻接表实现（O(VE)）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BellmanFordList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> src, dest, weight;</span><br><span class="line">        Edge(<span class="type">int</span> s, <span class="type">int</span> d, <span class="type">int</span> w) &#123;</span><br><span class="line">            src = s;</span><br><span class="line">            dest = d;</span><br><span class="line">            weight = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BellmanFordList</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">Edge</span>(u, v, w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bellmanFord</span><span class="params">(<span class="type">int</span> src)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// V-1 轮松弛</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[edge.src] != Integer.MAX_VALUE </span><br><span class="line">                    &amp;&amp; dist[edge.src] + edge.weight &lt; dist[edge.dest]) &#123;</span><br><span class="line">                    dist[edge.dest] = dist[edge.src] + edge.weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测负权回路</span></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[edge.src] != Integer.MAX_VALUE </span><br><span class="line">                &amp;&amp; dist[edge.src] + edge.weight &lt; dist[edge.dest]) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;图中包含负权回路！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printSolution(dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printSolution</span><span class="params">(<span class="type">int</span>[] dist)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vertex Distance from Source:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; \t &quot;</span> + dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BellmanFordList</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BellmanFordList</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">3</span>, -<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        g.bellmanFord(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="总结-1">总结</h6>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th>实现方式</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>邻接矩阵版</td>
<td>O(V³)</td>
<td>O(V²)</td>
<td>三重循环，适合稠密图，但性能差</td>
</tr>
<tr class="even">
<td>邻接表版</td>
<td>O(VE)</td>
<td>O(V+E)</td>
<td>实际常用，性能更好，便于处理边集</td>
</tr>
</tbody>
</table>
<h4 id="最小生成树-mst">最小生成树 (MST)</h4>
<h5 id="prim适合稠密图">Prim（适合稠密图）</h5>
<h6 id="邻接矩阵实现ov²-1">1. 邻接矩阵实现（O(V²)）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrimMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrimMatrix</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        graph = <span class="keyword">new</span> <span class="title class_">int</span>[V][V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            Arrays.fill(graph[i], Integer.MAX_VALUE);</span><br><span class="line">            graph[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        graph[u][v] = w;</span><br><span class="line">        graph[v][u] = w; <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primMST</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] key = <span class="keyword">new</span> <span class="title class_">int</span>[V];        <span class="comment">// 最小边权</span></span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[V];     <span class="comment">// 记录生成树结构</span></span><br><span class="line">        <span class="type">boolean</span>[] inMST = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(key, Integer.MAX_VALUE);</span><br><span class="line">        key[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 从顶点0开始</span></span><br><span class="line">        parent[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; count &lt; V - <span class="number">1</span>; count++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> minKey(key, inMST);</span><br><span class="line">            inMST[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[u][v] != Integer.MAX_VALUE &amp;&amp; !inMST[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class="line">                    parent[v] = u;</span><br><span class="line">                    key[v] = graph[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printMST(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">minKey</span><span class="params">(<span class="type">int</span>[] key, <span class="type">boolean</span>[] inMST)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE, minIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inMST[v] &amp;&amp; key[v] &lt; min) &#123;</span><br><span class="line">                min = key[v];</span><br><span class="line">                minIndex = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMST</span><span class="params">(<span class="type">int</span>[] parent)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Edge \tWeight&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(parent[i] + <span class="string">&quot; - &quot;</span> + i + <span class="string">&quot;\t&quot;</span> + graph[i][parent[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrimMatrix</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimMatrix</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        g.primMST();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="邻接表-最小堆实现oe-log-v-1">2. 邻接表 + 最小堆实现（O(E log
V)）</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrimList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Node&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> vertex, weight;</span><br><span class="line">        Node(<span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">            vertex = v;</span><br><span class="line">            weight = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrimList</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        adj.get(u).add(<span class="keyword">new</span> <span class="title class_">Node</span>(v, w));</span><br><span class="line">        adj.get(v).add(<span class="keyword">new</span> <span class="title class_">Node</span>(u, w)); <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primMST</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] inMST = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        <span class="type">int</span>[] key = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        Arrays.fill(key, Integer.MAX_VALUE);</span><br><span class="line">        key[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        parent[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(n -&gt; n.weight));</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> node.vertex;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inMST[u]) <span class="keyword">continue</span>;</span><br><span class="line">            inMST[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node neighbor : adj.get(u)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> neighbor.vertex;</span><br><span class="line">                <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> neighbor.weight;</span><br><span class="line">                <span class="keyword">if</span> (!inMST[v] &amp;&amp; w &lt; key[v]) &#123;</span><br><span class="line">                    key[v] = w;</span><br><span class="line">                    parent[v] = u;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(v, w));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printMST(parent, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMST</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span>[] key)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Edge \tWeight&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.println(parent[i] + <span class="string">&quot; - &quot;</span> + i + <span class="string">&quot;\t&quot;</span> + key[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrimList</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimList</span>(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        g.primMST();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="总结对比-1">总结对比</h6>
<table>
<thead>
<tr class="header">
<th>实现方式</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>适合场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>邻接矩阵版</td>
<td>O(V²)</td>
<td>O(V²)</td>
<td>稠密图</td>
</tr>
<tr class="even">
<td>邻接表 + 堆版</td>
<td>O(E log V)</td>
<td>O(V+E)</td>
<td>稀疏图</td>
</tr>
</tbody>
</table>
<h5
id="kruskal适合稀疏图结合并查集">Kruskal（适合稀疏图，结合并查集）</h5>
<p>和 Prim 不同，Kruskal 不依赖邻接矩阵/邻接表，而是依赖 <strong>边集
(Edge List)</strong>，再结合 <strong>并查集 (Union-Find)</strong>
来避免成环</p>
<h6 id="核心思路">核心思路</h6>
<ol type="1">
<li>将所有边按照 <strong>权值从小到大排序</strong>。</li>
<li>从小到大遍历边 <code>(u, v)</code>：
<ul>
<li>如果 <code>u</code> 和 <code>v</code> 不在同一个连通分量（即
<code>find(u) != find(v)</code>），则选中这条边，并合并集合。</li>
<li>否则跳过（避免成环）。</li>
</ul></li>
<li>直到选中 <code>V-1</code> 条边。</li>
</ol>
<ul>
<li><strong>时间复杂度</strong>：O(E log E)，主要来自边排序。</li>
<li><strong>空间复杂度</strong>：O(V + E)。</li>
<li><strong>适合场景</strong>：稀疏图 / 需要直接操作边集。</li>
</ul>
<hr />
<h6 id="java-实现">Java 实现</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KruskalMST</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> u, v, weight;</span><br><span class="line">        Edge(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">            <span class="built_in">this</span>.u = u;</span><br><span class="line">            <span class="built_in">this</span>.v = v;</span><br><span class="line">            <span class="built_in">this</span>.weight = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] parent, rank;</span><br><span class="line">        UnionFind(<span class="type">int</span> n) &#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x), rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) parent[rootX] = rootY;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) parent[rootY] = rootX;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">                rank[rootX]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KruskalMST</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">Edge</span>(u, v, w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kruskalMST</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 按照权值升序排序</span></span><br><span class="line">        edges.sort(Comparator.comparingInt(e -&gt; e.weight));</span><br><span class="line"></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(V);</span><br><span class="line">        List&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf.find(edge.u) != uf.find(edge.v)) &#123;</span><br><span class="line">                result.add(edge);</span><br><span class="line">                uf.union(edge.u, edge.v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Edge \tWeight&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Edge e : result) &#123;</span><br><span class="line">            System.out.println(e.u + <span class="string">&quot; - &quot;</span> + e.v + <span class="string">&quot;\t&quot;</span> + e.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">KruskalMST</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KruskalMST</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        g.kruskalMST();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="示例输出">📌 示例输出</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Edge    Weight</span><br><span class="line">2 - 3   4</span><br><span class="line">0 - 3   5</span><br><span class="line">0 - 1   10</span><br></pre></td></tr></table></figure>
<p>说明选中的边构成最小生成树，总权值最小。</p>
<hr />
<h5 id="对比-mst-三大算法">对比 MST 三大算法</h5>
<table>
<thead>
<tr class="header">
<th>算法</th>
<th>时间复杂度</th>
<th>适合场景</th>
<th>依赖结构</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Prim(矩阵)</td>
<td>O(V²)</td>
<td>稠密图</td>
<td>邻接矩阵</td>
</tr>
<tr class="even">
<td>Prim(堆+表)</td>
<td>O(E log V)</td>
<td>稀疏图</td>
<td>邻接表</td>
</tr>
<tr class="odd">
<td>Kruskal</td>
<td>O(E log E)</td>
<td>稀疏图</td>
<td>边集+并查集</td>
</tr>
</tbody>
</table>
<h4 id="拓扑排序">拓扑排序</h4>
<p>适用范围：<strong>有向无环图 (DAG)</strong></p>
<p>作用：线性排序，使得每条有向边 <code>(u → v)</code>
中，<code>u</code> 在排序结果中出现在 <code>v</code> 之前。</p>
<p>常见应用：任务调度、编译依赖顺序、课程安排等。</p>
<h5 id="kahn-算法bfs-入度法">Kahn 算法（BFS 入度法）</h5>
<ul>
<li>思路：
<ol type="1">
<li>统计所有顶点的入度。</li>
<li>将入度为 0 的节点入队。</li>
<li>每次出队一个节点，把它加入结果，同时减少其邻居的入度。</li>
<li>若邻居入度降为 0，则入队。</li>
</ol></li>
<li>时间复杂度：O(V + E)</li>
<li>空间复杂度：O(V + E)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopoSortKahn</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TopoSortKahn</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        adj.get(u).add(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topoSort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) &#123;</span><br><span class="line">                inDegree[v]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            result.add(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) queue.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.size() != V) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;图中存在环，无法进行拓扑排序！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;拓扑排序结果: &quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TopoSortKahn</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopoSortKahn</span>(<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        g.topoSort(); <span class="comment">// 可能输出: [4, 5, 0, 2, 3, 1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dfs-逆后序">DFS 逆后序</h5>
<ul>
<li>思路：
<ol type="1">
<li>用 DFS 遍历每个顶点。</li>
<li>当某个顶点的所有邻居都访问完成后，把该顶点压栈。</li>
<li>最终输出栈中的元素（即逆后序遍历）。</li>
</ol></li>
<li>时间复杂度：O(V + E)</li>
<li>空间复杂度：O(V + E)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopoSortDFS</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TopoSortDFS</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        adj.get(u).add(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topoSort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                dfs(i, visited, stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;拓扑排序结果: &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">boolean</span>[] visited, Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                dfs(v, visited, stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(u); <span class="comment">// 后序压栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TopoSortDFS</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopoSortDFS</span>(<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        g.topoSort(); <span class="comment">// 可能输出: 5 4 2 3 1 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对比总结-1">对比总结</h5>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Kahn(BFS)</td>
<td>O(V+E)</td>
<td>O(V+E)</td>
<td>直观、可检测环（若结果顶点数 &lt; V，则有环）</td>
</tr>
<tr class="even">
<td>DFS逆后序</td>
<td>O(V+E)</td>
<td>O(V+E)</td>
<td>实现简洁，天然给出拓扑序</td>
</tr>
</tbody>
</table>
<h2 id="高级数据结构">高级数据结构</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 17%" />
<col style="width: 28%" />
<col style="width: 35%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th>数据结构</th>
<th>特点</th>
<th>操作</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>并查集 (Union-Find)</strong></td>
<td>管理元素分组，支持合并集合和查询所属集合</td>
<td>合并（Union）：近似O(1)<br>查找（Find）：近似O(1)（路径压缩优化后）</td>
<td>连通性问题（如社交网络好友关系）</td>
</tr>
<tr class="even">
<td><strong>跳表 (Skip List)</strong></td>
<td>多层链表结构，利用概率平衡，提升查询效率</td>
<td>插入：O(log n)<br>删除：O(log n)<br>查找：O(log n)</td>
<td>Redis有序集合实现</td>
</tr>
<tr class="odd">
<td><strong>布隆过滤器 (Bloom Filter)</strong></td>
<td>概率型数据结构，判断元素“可能存在”或“一定不存在”</td>
<td>添加：O(1)<br>查询：O(1)</td>
<td>缓存穿透防护<br>垃圾邮件过滤</td>
</tr>
</tbody>
</table>
<h3 id="跳表-skip-list">1. 跳表 (Skip List)</h3>
<ul>
<li><strong>特点</strong>：基于多层链表的概率型数据结构，支持 O(log n)
查找。</li>
<li><strong>操作</strong>：插入、删除、查找。</li>
<li><strong>场景</strong>：替代平衡树（如 Redis 的有序集合）。</li>
</ul>
<p>下面给出一个<strong>可运行的 Java 跳表 (Skip List)</strong>
实现，包含：查找、插入（可更新）、删除三大操作，均期望 <strong>O(log
n)</strong>。为避免泛型数组带来的繁琐，这里用
<code>int key / int val</code> 版本，逻辑清晰好改造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_LEVEL</span> <span class="operator">=</span> <span class="number">32</span>;   <span class="comment">// 允许的最大层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">P</span> <span class="operator">=</span> <span class="number">0.5</span>;       <span class="comment">// 提升层数的概率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳表节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key, val;</span><br><span class="line">        Node[] next; <span class="comment">// 各层前进指针</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> level, <span class="type">int</span> key, <span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="keyword">new</span> <span class="title class_">Node</span>[level];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(MAX_LEVEL, Integer.MIN_VALUE, <span class="number">0</span>); <span class="comment">// 头哨兵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 当前实际层数（至少为 1）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机决定新节点的层数（几何分布）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lv</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lv &lt; MAX_LEVEL &amp;&amp; rnd.nextDouble() &lt; P) lv++;</span><br><span class="line">        <span class="keyword">return</span> lv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找：存在返回对应值，不存在返回 null</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p.next[i] != <span class="literal">null</span> &amp;&amp; p.next[i].key &lt; key) &#123;</span><br><span class="line">                p = p.next[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> (p != <span class="literal">null</span> &amp;&amp; p.key == key) ? p.val : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或更新：若 key 已存在则更新 val；否则按随机层数插入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        Node[] update = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX_LEVEL];</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p.next[i] != <span class="literal">null</span> &amp;&amp; p.next[i].key &lt; key) &#123;</span><br><span class="line">                p = p.next[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> p.next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; x.key == key) &#123;</span><br><span class="line">            <span class="comment">// 已存在 → 更新</span></span><br><span class="line">            x.val = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lv</span> <span class="operator">=</span> randomLevel();</span><br><span class="line">        <span class="keyword">if</span> (lv &gt; level) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level; i &lt; lv; i++) &#123;</span><br><span class="line">                update[i] = head;</span><br><span class="line">            &#125;</span><br><span class="line">            level = lv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(lv, key, val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">            newNode.next[i] = update[i].next[i];</span><br><span class="line">            update[i].next[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除：存在返回 true，不存在返回 false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        Node[] update = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX_LEVEL];</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p.next[i] != <span class="literal">null</span> &amp;&amp; p.next[i].key &lt; key) &#123;</span><br><span class="line">                p = p.next[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> p.next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || x.key != key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i].next[i] != x) <span class="keyword">break</span>;</span><br><span class="line">            update[i].next[i] = x.next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缩减当前层数（若最高层已空）</span></span><br><span class="line">        <span class="keyword">while</span> (level &gt; <span class="number">1</span> &amp;&amp; head.next[level - <span class="number">1</span>] == <span class="literal">null</span>) level--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试打印（从底层打印）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.next[i];</span><br><span class="line">            System.out.print(<span class="string">&quot;L&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span> + p.key + <span class="string">&quot;,&quot;</span> + p.val + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">                p = p.next[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SkipList</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkipList</span>();</span><br><span class="line">        sl.put(<span class="number">3</span>, <span class="number">30</span>);</span><br><span class="line">        sl.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        sl.put(<span class="number">7</span>, <span class="number">70</span>);</span><br><span class="line">        sl.put(<span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line">        sl.put(<span class="number">9</span>, <span class="number">90</span>);</span><br><span class="line">        sl.print();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;search(7) = &quot;</span> + sl.search(<span class="number">7</span>)); <span class="comment">// 70</span></span><br><span class="line">        System.out.println(<span class="string">&quot;search(2) = &quot;</span> + sl.search(<span class="number">2</span>)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        sl.put(<span class="number">5</span>, <span class="number">500</span>); <span class="comment">// 更新</span></span><br><span class="line">        System.out.println(<span class="string">&quot;search(5) = &quot;</span> + sl.search(<span class="number">5</span>)); <span class="comment">// 500</span></span><br><span class="line"></span><br><span class="line">        sl.remove(<span class="number">3</span>);</span><br><span class="line">        sl.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong>（期望）：</p>
<ul>
<li>查找 / 插入 / 删除：<strong>O(log n)</strong></li>
<li>空间：<strong>O(n)</strong>（每个节点期望有常数条“提升”指针）</li>
</ul>
<hr />
<h3 id="并查集-union-find">2. 并查集 (Union-Find)</h3>
<ul>
<li><strong>特点</strong>：用于集合划分，支持快速合并与查找。</li>
<li><strong>操作</strong>：<code>find</code>（查找根节点）、<code>union</code>（合并集合）。</li>
<li><strong>优化</strong>：路径压缩 + 按秩合并。</li>
<li><strong>场景</strong>：连通分量、最小生成树 Kruskal 算法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x), rootY = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX == rootY) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) parent[rootX] = rootY;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) parent[rootY] = rootX;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">            rank[rootX]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>无优化</th>
<th>路径压缩 + 按秩合并</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>初始化</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr class="even">
<td><code>find</code></td>
<td>O(n)</td>
<td>O(α(n)) ≈ O(1)</td>
</tr>
<tr class="odd">
<td><code>union</code></td>
<td>O(n)</td>
<td>O(α(n)) ≈ O(1)</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="线段树-segment-tree">3. 线段树 (Segment Tree)</h3>
<ul>
<li><strong>特点</strong>：树形结构，通常用数组存储（堆式存储，根在索引
1），区间查询与修改高效。</li>
<li><strong>操作复杂度</strong>：O(log n)。</li>
<li><strong>场景</strong>：区间最值 / 区间和 / 区间更新。</li>
</ul>
<p>Java 实现：区间和 &amp; 单点更新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] tree;   <span class="comment">// 线段树数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;        <span class="comment">// 原始数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        n = arr.length;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n]; <span class="comment">// 安全空间</span></span><br><span class="line">        build(arr, <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建线段树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tree[node] = arr[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            build(arr, node * <span class="number">2</span>, l, mid);</span><br><span class="line">            build(arr, node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">            tree[node] = tree[node * <span class="number">2</span>] + tree[node * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间查询 [ql, qr]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (qr &lt; l || ql &gt; r) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不相交</span></span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> tree[node]; <span class="comment">// 完全覆盖</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> query(node * <span class="number">2</span>, l, mid, ql, qr) + query(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单点更新：arr[idx] = val</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, idx, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tree[node] = val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= mid) update(node * <span class="number">2</span>, l, mid, idx, val);</span><br><span class="line">            <span class="keyword">else</span> update(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, idx, val);</span><br><span class="line">            tree[node] = tree[node * <span class="number">2</span>] + tree[node * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印树（调试用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[i] != <span class="number">0</span>) System.out.println(<span class="string">&quot;node &quot;</span> + i + <span class="string">&quot;: &quot;</span> + tree[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="type">SegmentTree</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SegmentTree</span>(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;query(1,3) = &quot;</span> + st.query(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// 3+5+7 = 15</span></span><br><span class="line">        st.update(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// arr[1] = 10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;query(1,3) = &quot;</span> + st.query(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// 10+5+7 = 22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度</p>
<ul>
<li><strong>构建</strong>：O(n)</li>
<li><strong>查询 (区间和/最值/最小值)</strong>：O(log n)</li>
<li><strong>单点更新</strong>：O(log n)</li>
</ul>
<hr />
<h3 id="树状数组-fenwick-tree-binary-indexed-tree">4. 树状数组 (Fenwick
Tree / Binary Indexed Tree)</h3>
<ul>
<li><strong>特点</strong>：数组实现，维护前缀和。</li>
<li><strong>操作复杂度</strong>：O(log n)。</li>
<li><strong>场景</strong>：动态数组求前缀和，区间和。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FenwickTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FenwickTree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">            tree[i] += delta;</span><br><span class="line">            i += i &amp; -i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[i];</span><br><span class="line">            i -= i &amp; -i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法">算法</h1>
<h2 id="排序算法sorting">1. 排序算法（Sorting）</h2>
<ul>
<li><strong>基础排序</strong>：冒泡排序、选择排序、插入排序</li>
<li><strong>高效排序</strong>：快速排序、归并排序、堆排序</li>
<li><strong>线性排序</strong>：计数排序、桶排序、基数排序</li>
<li><strong>要点</strong>：时间复杂度、空间复杂度、稳定性、适用场景</li>
</ul>
<hr />
<h2 id="查找与搜索searching">2. 查找与搜索（Searching）</h2>
<ul>
<li><strong>二分查找</strong>：标准二分、变种二分（左边界/右边界）</li>
<li><strong>DFS / BFS</strong>：树和图的遍历，最短路径搜索</li>
<li><strong>回溯算法</strong>：全排列、组合、子集、N 皇后、数独</li>
<li><strong>剪枝优化</strong>：约束满足、状态缓存</li>
</ul>
<hr />
<h2 id="分治与递归divide-and-conquer">3. 分治与递归（Divide and
Conquer）</h2>
<ul>
<li><strong>分治思想</strong>：快速排序、归并排序</li>
<li><strong>矩阵乘法</strong>：Strassen 算法</li>
<li><strong>递归与递推</strong>：递归树分析、递归优化</li>
</ul>
<hr />
<h2 id="动态规划dynamic-programming-dp">4. 动态规划（Dynamic
Programming, DP）</h2>
<ul>
<li><strong>一维 DP</strong>：斐波那契数列、爬楼梯</li>
<li><strong>背包问题</strong>：01 背包、完全背包、多重背包</li>
<li><strong>序列
DP</strong>：最长上升子序列、最长公共子序列、编辑距离</li>
<li><strong>区间 DP</strong>：石子合并、矩阵链乘</li>
<li><strong>状态压缩 DP</strong>：旅行商问题、集合覆盖问题</li>
<li><strong>树形 DP</strong>：树的直径、树形背包</li>
</ul>
<hr />
<h2 id="贪心算法greedy">5. 贪心算法（Greedy）</h2>
<ul>
<li><strong>区间调度问题</strong></li>
<li><strong>最优装载问题</strong></li>
<li><strong>哈夫曼编码</strong></li>
<li><strong>最小生成树 (Kruskal / Prim)</strong></li>
</ul>
<hr />
<h2 id="图论算法graph-algorithms">6. 图论算法（Graph Algorithms）</h2>
<ul>
<li><strong>最短路径</strong>：Dijkstra、Bellman-Ford、Floyd-Warshall、SPFA</li>
<li><strong>最小生成树</strong>：Prim、Kruskal</li>
<li><strong>拓扑排序</strong>：Kahn 算法、DFS 逆后序</li>
<li><strong>强连通分量</strong>：Kosaraju、Tarjan</li>
<li><strong>二分图</strong>：最大匹配、染色判定</li>
<li><strong>最大流最小割</strong>：Edmonds-Karp、Dinic</li>
</ul>
<hr />
<h2 id="字符串算法string-algorithms">7. 字符串算法（String
Algorithms）</h2>
<ul>
<li><strong>模式匹配</strong>：KMP、Rabin-Karp</li>
<li><strong>字典树 (Trie)</strong></li>
<li><strong>AC 自动机</strong>（多模式匹配）</li>
<li><strong>Manacher 算法</strong>（最长回文子串）</li>
<li><strong>后缀数组 / 后缀自动机</strong></li>
</ul>
<hr />
<h2 id="数学与数论math-number-theory">8. 数学与数论（Math &amp; Number
Theory）</h2>
<ul>
<li><strong>最大公约数 /
最小公倍数</strong>：欧几里得、扩展欧几里得</li>
<li><strong>快速幂</strong>：快速模幂</li>
<li><strong>素数</strong>：埃氏筛、线性筛</li>
<li><strong>同余与逆元</strong>：费马小定理、中国剩余定理</li>
<li><strong>组合数学</strong>：排列组合、卡特兰数</li>
<li><strong>矩阵快速幂</strong>：递推数列优化</li>
</ul>
<hr />
<h2 id="高级算法思想advanced-paradigms">9. 高级算法思想（Advanced
Paradigms）</h2>
<ul>
<li><strong>分治</strong></li>
<li><strong>动态规划</strong></li>
<li><strong>贪心</strong></li>
<li><strong>搜索 + 剪枝</strong></li>
<li><strong>随机化算法</strong>（跳表、随机快排）</li>
<li><strong>启发式搜索</strong>（A*）</li>
</ul>
<hr />
<h2 id="经典综合问题">10. 经典综合问题</h2>
<ul>
<li><strong>排序 + 二分</strong>：区间问题、查找问题</li>
<li><strong>DP + 贪心</strong>：背包类优化</li>
<li><strong>图 + 并查集</strong>：连通分量、MST</li>
<li><strong>搜索 + 剪枝</strong>：数独、八皇后</li>
<li><strong>字符串 + DP</strong>：最长回文子串、编辑距离</li>
</ul>
<hr />
<h2 id="算法技巧algorithmic-techniques">11. 算法技巧（Algorithmic
Techniques）</h2>
<ul>
<li><strong>双指针 (Two Pointers)</strong>
<ul>
<li>快慢指针（链表环检测、找中点）</li>
<li>左右指针（两数之和、盛最多水的容器）</li>
</ul></li>
<li><strong>滑动窗口 (Sliding Window)</strong>
<ul>
<li>固定窗口（区间和、最大平均数）</li>
<li>可变窗口（最小覆盖子串、最长无重复子串）</li>
<li>单调队列优化（滑动窗口最大值）</li>
</ul></li>
<li><strong>前缀和 / 差分数组</strong>
<ul>
<li>区间和快速计算</li>
<li>区间更新优化</li>
</ul></li>
<li><strong>位运算技巧</strong>
<ul>
<li>子集枚举</li>
<li>lowbit 运算（树状数组）</li>
</ul></li>
<li><strong>双端队列优化</strong>
<ul>
<li>单调队列（维护区间最值）</li>
</ul></li>
<li><strong>哈希 + 枚举</strong>
<ul>
<li>两数之和、四数之和</li>
</ul></li>
<li><strong>排序 + 双指针 / 二分结合</strong>
<ul>
<li>区间查找、两数之和、三数之和</li>
</ul></li>
</ul>
<h2 id="总结-2">总结</h2>
<p><strong>算法范式</strong>：分治、动态规划、贪心、搜索</p>
<p><strong>算法领域</strong>：排序、图论、字符串、数论</p>
<p><strong>算法技巧</strong>：双指针、滑动窗口、前缀和、位运算</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Bruce Yao
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://cmder.github.io/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" title="算法和数据结构">https://cmder.github.io/算法/算法和数据结构.html</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" rel="prev" title="设计模式">
                  <i class="fa fa-angle-left"></i> 设计模式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Android/Framework/Android-Framework-%E5%BC%80%E5%8F%91.html" rel="next" title="Android Framework 开发">
                  Android Framework 开发 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2022 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bruce Yao</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/cmder" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: false,
  label: '🌓',
  autoMatchOsTheme: false
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
if (window.darkmode && !window.darkmode.isActivated()) {
  window.darkmode.toggle();
  var toggleButtons = document.getElementsByClassName("darkmode-toggle");
  if (toggleButtons && toggleButtons.length > 0) {
    for (i = 0; i < toggleButtons.length; i++) {
      toggleButtons[i].classList.add("darkmode-toggle--white");
    }
  }
}
</script>

</body>
</html>
