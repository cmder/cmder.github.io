<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cmder.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="采集">
<meta property="og:type" content="article">
<meta property="og:title" content="音视频面试题集锦">
<meta property="og:url" content="https://cmder.github.io/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6.html">
<meta property="og:site_name" content="说码解字">
<meta property="og:description" content="采集">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-07T10:57:46.000Z">
<meta property="article:modified_time" content="2025-10-14T14:00:23.772Z">
<meta property="article:author" content="Bruce Yao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://cmder.github.io/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6.html">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://cmder.github.io/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6.html","path":"音视频/音视频面试题集锦.html","title":"音视频面试题集锦"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>音视频面试题集锦 | 说码解字</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"forest","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">说码解字</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%87%E9%9B%86"><span class="nav-number">1.</span> <span class="nav-text">采集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9C%E6%99%9A%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%E6%89%93%E5%BC%80%E6%89%8B%E7%94%B5%E7%AD%92"><span class="nav-number">1.1.</span> <span class="nav-text">iOS
如何实现夜晚自动提示打开手电筒？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88-ios-%E9%9F%B3%E8%A7%86%E9%A2%91%E9%87%87%E9%9B%86%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.</span> <span class="nav-text">谈谈 iOS
音视频采集相关接口和数据结构的设计？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9F%B3%E9%A2%91%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">音频算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E5%AF%B9%E8%A7%86%E9%A2%91%E5%80%8D%E9%80%9F%E6%92%AD%E6%94%BE%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%90%A6%E6%9C%89%E6%94%B9%E5%8F%98%E9%9F%B3%E8%B0%83"><span class="nav-number">2.1.</span> <span class="nav-text">你对视频倍速播放的时候，是否有改变音调？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E4%B8%AD%E5%8F%91%E7%8E%B0%E6%9C%89%E5%9B%9E%E5%A3%B0%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.2.</span> <span class="nav-text">直播中发现有回声，可能的原因是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%8A%E8%81%8A%E5%AF%B9%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.3.</span> <span class="nav-text">聊聊对音视频同步的理解？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">图像算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-yuv-%E8%BD%AC-rgb-%E8%BD%AC%E6%8D%A2%E4%B8%AD-uv-%E5%88%86%E9%87%8F%E8%A6%81%E5%87%8F%E5%8E%BB-0.5"><span class="nav-number">3.1.</span> <span class="nav-text">为什么在 YUV 转
RGB 转换中 UV 分量要减去 0.5？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E6%8A%97%E9%94%AF%E9%BD%BF%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%E5%90%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%A9%E5%BC%8A"><span class="nav-number">3.2.</span> <span class="nav-text">纹理抗锯齿有哪些算法？各有哪些利弊?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%95%88"><span class="nav-number">4.</span> <span class="nav-text">特效</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#opengl-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E5%B1%8F%E6%95%88%E6%9E%9C"><span class="nav-number">4.1.</span> <span class="nav-text">OpenGL 如何实现二分屏效果？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="nav-number">5.</span> <span class="nav-text">编解码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-dts-%E5%92%8C-pts%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">什么是 DTS 和
PTS？它们有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-idr-%E5%B8%A7%E5%AE%83%E5%92%8C-i-%E5%B8%A7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.</span> <span class="nav-text">什么是 IDR 帧？它和 I
帧有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-sps-%E5%92%8C-pps%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">什么是 SPS 和
PPS？它们有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-sei%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%AE%83%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">5.4.</span> <span class="nav-text">什么是
SEI？我们可以用它来做什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE-nalu-%E8%A3%B8%E6%B5%81%E6%95%B0%E6%8D%AE%E6%9D%A5%E5%88%A4%E6%96%AD%E5%85%B6%E6%98%AF-h.264-%E7%BC%96%E7%A0%81%E8%BF%98%E6%98%AF-h.265-%E7%BC%96%E7%A0%81"><span class="nav-number">5.5.</span> <span class="nav-text">如何根据
NALU 裸流数据来判断其是 H.264 编码还是 H.265 编码？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-open-gop%E4%BB%80%E4%B9%88%E6%98%AF-closed-gop"><span class="nav-number">5.6.</span> <span class="nav-text">什么是 Open GOP？什么是 Closed
GOP ?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-yuv-%E8%BF%99%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%AE%83%E7%9B%B8%E6%AF%94-rgb-%E6%95%B0%E6%8D%AE%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="nav-number">5.7.</span> <span class="nav-text">为什么会有 YUV
这种数据？它相比 RGB 数据有什么优点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9-yuv-%E6%A0%BC%E5%BC%8F%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97yuv-%E6%95%B0%E6%8D%AE%E5%81%9A%E8%BD%AC%E6%8D%A2%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%AF%94%E5%A6%82%E8%AF%B4-yuv422-%E8%BD%AC%E4%B8%BA-yuv420"><span class="nav-number">5.8.</span> <span class="nav-text">对
YUV 格式有了解吗？YUV 数据做转换是怎样实现的，比如说 YUV422 转为
YUV420？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pcm-%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%84%E7%BB%87%E7%9A%84"><span class="nav-number">5.9.</span> <span class="nav-text">PCM 音频数据是怎么组织的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9%E4%BF%A1%E5%8F%B7%E6%97%B6%E5%9F%9F%E9%A2%91%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">5.10.</span> <span class="nav-text">说一下对信号时域、频域的理解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pcm-%E6%95%B0%E6%8D%AE%E7%BB%8F%E8%BF%87-aac-%E7%BC%96%E7%A0%81%E5%99%A8%E7%BC%96%E7%A0%81%E5%90%8E%E7%9B%B4%E6%8E%A5%E5%86%99-.aac-%E6%96%87%E4%BB%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="nav-number">5.11.</span> <span class="nav-text">PCM
数据经过 AAC 编码器编码后，直接写 .aac 文件会怎么样？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pcm-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8D%95%E5%85%83%E6%98%AF%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82"><span class="nav-number">5.12.</span> <span class="nav-text">PCM
数据操作的最小单元是多少字节？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AF%B9-h.264-%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">5.13.</span> <span class="nav-text">简要介绍一下对 H.264 的了解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#h.264-%E7%BC%96%E7%A0%81%E6%A1%86%E6%9E%B6%E5%88%86%E5%B1%82%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.14.</span> <span class="nav-text">H.264
编码框架分层目的是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#h.264-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE-nalu-%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%A7%86%E9%A2%91%E5%B8%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.15.</span> <span class="nav-text">H.264 如何根据 NALU
判断当前视频帧的类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-ipb-%E5%B8%A7%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%98%BE%E7%A4%BA%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.16.</span> <span class="nav-text">介绍一下 I、P、B
帧编码、解码、显示顺序？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#h.264-%E4%B8%8E-h.265-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.17.</span> <span class="nav-text">H.264 与 H.265 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-psnr-%E6%9D%A5%E8%AF%84%E4%BC%B0%E7%BC%96%E7%A0%81%E8%B4%A8%E9%87%8F"><span class="nav-number">5.18.</span> <span class="nav-text">如何代码实现 PSNR
来评估编码质量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E7%A0%81%E7%8E%87%E8%B4%A8%E9%87%8F%E7%94%9C%E7%82%B9"><span class="nav-number">5.19.</span> <span class="nav-text">如何测试码率质量甜点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#android-surface-%E8%A7%A3%E7%A0%81%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E5%B8%A6%E8%A7%92%E5%BA%A6%E8%A7%86%E9%A2%91"><span class="nav-number">5.20.</span> <span class="nav-text">Android Surface
解码如何支持带角度视频？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-hdr-%E8%BD%AC-sdr"><span class="nav-number">5.21.</span> <span class="nav-text">iOS 如何实现 HDR 转 SDR？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-ffmpeg-%E4%B8%AD%E5%85%B3%E4%BA%8E-timebase-%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">5.22.</span> <span class="nav-text">介绍一下
FFmpeg 中关于 timebase 的基础知识与应用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E4%B8%80%E4%B8%AA%E8%A7%86%E9%A2%91%E6%98%AF-hdr-%E8%A7%86%E9%A2%91"><span class="nav-number">5.23.</span> <span class="nav-text">如何识别一个视频是 HDR 视频？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E9%97%AE-android-%E4%B8%8A%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E4%B8%80%E4%B8%AA%E8%A7%86%E9%A2%91%E6%98%AF%E5%93%AA%E7%A7%8D%E6%A0%BC%E5%BC%8F%E7%9A%84-hdr-%E8%A7%86%E9%A2%91hdr10dolbyvisionhlghdr10"><span class="nav-number">5.24.</span> <span class="nav-text">请问
Android 上如何识别一个视频是哪种格式的 HDR
视频：HDR10+&#x2F;DolbyVision&#x2F;HLG&#x2F;HDR10？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hevc-opengop-%E7%9A%84%E6%96%B0%E5%A2%9E%E7%9A%84%E5%B8%A7%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="nav-number">5.25.</span> <span class="nav-text">HEVC
OpenGOP 的新增的帧类型有哪些，在开发中需要注意什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-android-14-%E5%BC%95%E5%85%A5%E4%BA%86-ultra-hdr-image-%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.26.</span> <span class="nav-text">介绍一下
Android 14 引入了 Ultra HDR Image 格式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E5%B9%B3%E5%8F%B0%E4%B8%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-videotoolbox-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%9F%90%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8Fh.264hevc-%E7%AD%89%E6%88%96%E8%80%85%E6%9F%90%E7%A7%8D%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E5%91%A2"><span class="nav-number">5.27.</span> <span class="nav-text">iOS
平台上如何判断 VideoToolbox 是否支持某种编码格式（H.264、HEVC
等）或者某种颜色空间呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#android-%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%BF%E7%94%A8-mediacodec-%E7%BC%96%E7%A0%81%E5%A6%82%E4%BD%95%E5%91%8A%E7%9F%A5%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E6%9D%9F%E7%BC%96%E7%A0%81"><span class="nav-number">5.28.</span> <span class="nav-text">Android
平台上使用 MediaCodec 编码，如何告知编码器结束编码？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#android-%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%BF%E7%94%A8-mediacodec-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A0%81%E4%BD%BF%E7%94%A8-surface-%E4%BD%9C%E4%B8%BA%E7%BC%96%E7%A0%81%E8%BE%93%E5%85%A5%E6%BA%90%E7%9A%84%E6%B5%81%E7%A8%8B%E5%92%8C%E4%BD%BF%E7%94%A8-bytebuffer-%E4%BD%9C%E4%B8%BA%E7%BC%96%E7%A0%81%E8%BE%93%E5%85%A5%E6%BA%90%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.29.</span> <span class="nav-text">Android
平台上使用 MediaCodec 异步编码，使用 Surface 作为编码输入源的流程和使用
ByteBuffer 作为编码输入源有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%8A%E8%81%8A-ios-cvpixelbufferref-%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">5.30.</span> <span class="nav-text">聊聊 iOS CVPixelBufferRef
相关的细节？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%A7%86%E9%A2%91%E6%B5%81%E4%B8%AD%E7%9A%84-qp-%E5%80%BC"><span class="nav-number">5.31.</span> <span class="nav-text">如何获取视频流中的 QP 值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%AF%B9-qp-%E5%80%BC%E7%9A%84%E6%8E%A7%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">5.32.</span> <span class="nav-text">视频编码对 QP
值的控制有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%88%86%E6%AE%B5%E8%BD%AC%E7%A0%81%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%88%86%E7%89%87%E5%A4%A7%E5%B0%8F"><span class="nav-number">5.33.</span> <span class="nav-text">iOS
如何使用分段转码，如何设置分片大小？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#videotoolbox-%E4%B8%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%B9%B3%E9%9D%A2%E6%A0%BC%E5%BC%8Fplanar%E5%AF%B9%E5%BA%94%E7%9A%84-yuv420yuv422-%E5%92%8C-yuv444-%E7%9A%84-ostype-%E5%B8%B8%E9%87%8F"><span class="nav-number">5.34.</span> <span class="nav-text">VideoToolbox
中是不是不存在平面格式（planar）对应的 YUV420、YUV422 和 YUV444 的
OSType 常量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E4%B8%AD%E7%B3%BB%E7%BB%9F-api-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">5.35.</span> <span class="nav-text">iOS 中系统 API
提供了哪些视频编码的方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#videotoolbox-%E8%A7%86%E9%A2%91%E5%B8%A7%E8%A7%A3%E7%A0%81%E5%A4%B1%E8%B4%A5%E4%BB%A5%E5%90%8E%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%87%8D%E8%AF%95"><span class="nav-number">5.36.</span> <span class="nav-text">Videotoolbox
视频帧解码失败以后应该如何重试？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-psnr-%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81%E8%B4%A8%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%AF%84%E4%BC%B0"><span class="nav-number">5.37.</span> <span class="nav-text">如何使用 PSNR
对视频转码质量进行评估？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#videotoolbox-%E9%81%B5%E5%BE%AA%E5%93%AA%E7%A7%8D%E8%A7%86%E9%A2%91%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE"><span class="nav-number">5.38.</span> <span class="nav-text">VideoToolbox
遵循哪种视频码率控制策略？如何设置？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#annex-b-%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%E4%B8%BA-avcc"><span class="nav-number">5.39.</span> <span class="nav-text">Annex B 如何转换为 AVCC？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E8%A7%86%E9%A2%91%E5%B8%A7%E6%98%AF%E4%B8%8D%E6%98%AF%E5%85%B3%E9%94%AE%E5%B8%A7"><span class="nav-number">5.40.</span> <span class="nav-text">iOS
中如何判断一个视频帧是不是关键帧？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ffmpeg-%E7%BC%96%E7%A0%81%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.41.</span> <span class="nav-text">FFmpeg 编码的流程是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E9%9F%B3%E9%A2%91%E5%B8%A7-cmsamplebufferref-%E4%B8%AD%E7%9A%84-kcmformatdescriptionextension_verbatimisosampleentry-%E4%BF%9D%E5%AD%98%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%8E%89"><span class="nav-number">5.42.</span> <span class="nav-text">iOS
音频帧 CMSampleBufferRef 中的
kCMFormatDescriptionExtension_VerbatimISOSampleEntry
保存哪些信息，是否可以去掉？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AA%92%E4%BD%93%E5%B0%81%E8%A3%85"><span class="nav-number">6.</span> <span class="nav-text">媒体封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-mp4-%E7%9A%84-moov-box%E6%88%91%E4%BB%AC%E5%9C%A8%E5%B0%81%E8%A3%85-mp4-%E6%97%B6%E9%80%9A%E5%B8%B8%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%AE%83%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">6.1.</span> <span class="nav-text">什么是
MP4 的 moov Box？我们在封装 MP4 时通常怎么处理它？为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aac-%E5%B0%81%E8%A3%85%E5%88%B0-mp4-%E4%B8%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E4%B8%BA%E6%AF%8F%E4%B8%AA-aac-packet-%E6%B7%BB%E5%8A%A0-adts"><span class="nav-number">6.2.</span> <span class="nav-text">AAC 封装到
MP4 中，是否需要为每个 AAC packet 添加 ADTS？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E5%B0%81%E8%A3%85-fmp4-%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.3.</span> <span class="nav-text">iOS 如何支持封装 FMP4 格式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ffmpeg-%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E5%B0%81%E8%A3%85-fmp4-%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.4.</span> <span class="nav-text">FFmpeg 如何支持封装 FMP4
格式？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AA%92%E4%BD%93%E4%BC%A0%E8%BE%93"><span class="nav-number">7.</span> <span class="nav-text">媒体传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rtmp-%E6%B6%88%E6%81%AF%E5%88%86%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="nav-number">7.1.</span> <span class="nav-text">RTMP
消息分优先级的设计有什么好处？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cdn-%E5%9C%A8%E7%9B%B4%E6%92%AD%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%90%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">CDN 在直播中有哪些运用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE%E7%94%A8-udp%E5%A6%82%E6%9E%9C%E7%94%A8-tcp-%E5%AE%9E%E7%8E%B0%E9%9F%B3%E8%A7%86%E9%A2%91%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E5%87%A0%E6%AC%A1%E8%BF%9E%E6%8E%A5%E7%94%A8-udp-%E5%AE%9E%E7%8E%B0%E9%9F%B3%E8%A7%86%E9%A2%91%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E9%80%9A%E8%AF%9D%E8%B4%A8%E9%87%8F"><span class="nav-number">7.3.</span> <span class="nav-text">为什么视频会议用
UDP？如果用 TCP 实现音视频，需要建立几次连接？用 UDP
实现音视频，有什么方法可以保证通话质量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rtmp-%E5%92%8C-rtsp-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%BD%BF%E7%94%A8-rtsp-%E6%98%AF%E5%9F%BA%E4%BA%8E-udp-%E4%BC%A0%E8%BE%93%E7%9A%84%E8%AF%9D%E6%88%91%E4%BB%AC%E6%80%8E%E6%A0%B7%E8%BF%9B%E8%A1%8C%E4%B9%B1%E5%BA%8F%E9%87%8D%E6%8E%92"><span class="nav-number">7.4.</span> <span class="nav-text">RTMP
和 RTSP 有什么区别？使用 RTSP 是基于 UDP
传输的话，我们怎样进行乱序重排？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%87%E5%A6%82%E7%BB%99%E4%BD%A0%E4%B8%80%E5%A0%86%E4%B9%B1%E5%BA%8F%E7%9A%84-rtp-%E5%8C%85%E5%BA%94%E8%AF%A5%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E4%B9%B1%E5%BA%8F%E9%87%8D%E6%8E%92"><span class="nav-number">7.5.</span> <span class="nav-text">假如给你一堆乱序的
RTP 包，应该怎样实现乱序重排？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E9%99%8D%E4%BD%8E%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E5%BB%B6%E6%97%B6%E7%9A%84"><span class="nav-number">7.6.</span> <span class="nav-text">你在项目中是怎么降低端到端的延时的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93"><span class="nav-number">8.</span> <span class="nav-text">渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#opengl-%E6%98%AF%E6%8C%89%E7%85%A7%E4%BB%80%E4%B9%88%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84"><span class="nav-number">8.1.</span> <span class="nav-text">OpenGL 是按照什么架构设计的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B2%E6%9F%93%E4%B8%8A%E4%B8%8B%E6%96%87context"><span class="nav-number">8.2.</span> <span class="nav-text">什么是渲染上下文（Context）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93"><span class="nav-number">8.3.</span> <span class="nav-text">什么是离屏渲染？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E4%BC%9A%E9%80%A0%E6%88%90%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97"><span class="nav-number">8.4.</span> <span class="nav-text">为什么离屏渲染会造成性能损耗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-opengl-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BFpipeline"><span class="nav-number">8.5.</span> <span class="nav-text">什么是 OpenGL
渲染管线（Pipeline）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#opengl-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86"><span class="nav-number">8.6.</span> <span class="nav-text">OpenGL
渲染管线主要包含哪些部分？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-opengl-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E7%9A%84%E7%9D%80%E8%89%B2%E5%99%A8shader%E6%98%AF%E5%8F%AF%E7%BC%96%E7%A8%8B%E7%AE%A1%E7%BA%BF"><span class="nav-number">8.7.</span> <span class="nav-text">为什么说
OpenGL 渲染管线中的着色器（Shader）是可编程管线？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%AF%E4%BB%A5%E7%94%B1%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A8%8B"><span class="nav-number">8.8.</span> <span class="nav-text">有哪些着色器可以由程序员进行编程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-vboebo-%E5%92%8C-vao"><span class="nav-number">8.9.</span> <span class="nav-text">什么是 VBO、EBO 和 VAO？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vertex-buffer-object-%E7%9A%84%E5%B8%83%E5%B1%80%E6%A0%BC%E5%BC%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">8.10.</span> <span class="nav-text">Vertex Buffer Object
的布局格式是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vertex-array-object-%E7%9A%84%E5%B8%83%E5%B1%80%E6%A0%BC%E5%BC%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">8.11.</span> <span class="nav-text">Vertex Array Object
的布局格式是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%87-sdl-%E8%BF%9B%E8%A1%8C%E6%B8%B2%E6%9F%93%E8%83%BD%E5%90%A6%E8%AE%B2%E4%B8%80%E4%B8%8B-sdl-%E6%B8%B2%E6%9F%93"><span class="nav-number">8.12.</span> <span class="nav-text">你在项目中使用过
SDL 进行渲染，能否讲一下 SDL 渲染？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#opengl-%E7%9A%84%E5%8F%8C%E7%BC%93%E5%86%B2%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88eglcreatewindowsurfaceeglcreatepbufffersurface-%E5%92%8C%E5%8F%8C%E7%BC%93%E5%86%B2%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E8%81%94%E5%90%97"><span class="nav-number">8.13.</span> <span class="nav-text">OpenGL
的双缓冲机制是什么？eglCreateWindowSurface、eglCreatePbuffferSurface
和双缓冲机制有什么关联吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%B3%E8%A6%81%E6%8A%8A-iosandroid-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%AD-opengl-es-%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%9D%97%E4%B8%8B%E6%B2%89%E5%88%B0-c-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%AB%AF%E5%85%B1%E7%94%A8%E8%A6%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.14.</span> <span class="nav-text">想要把
iOS、Android 应用开发中 OpenGL ES 渲染相关模块下沉到 C++
实现双端共用要怎么实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-opengl-%E7%BB%98%E5%88%B6%E6%97%B6%E5%AF%B9%E4%BA%8E%E4%BA%8C%E7%BB%B4%E5%9D%90%E6%A0%87%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="nav-number">8.15.</span> <span class="nav-text">使用 OpenGL
绘制时对于二维坐标需要注意什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%8A%E8%81%8A-opengl-glflush-%E5%92%8C-glfinish-%E5%8C%BA%E5%88%AB"><span class="nav-number">8.16.</span> <span class="nav-text">聊聊 OpenGL glFlush 和
glFinish 区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-opengl-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">8.17.</span> <span class="nav-text">怎么实现 OpenGL 多线程同步？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-opengl-%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="nav-number">8.18.</span> <span class="nav-text">如何实现 OpenGL 资源共享？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#opengl-%E7%BA%B9%E7%90%86%E7%BC%93%E5%AD%98%E8%A6%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.19.</span> <span class="nav-text">OpenGL 纹理缓存要如何设计？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-glreadpixels"><span class="nav-number">8.20.</span> <span class="nav-text">介绍一下 glReadPixels？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-imagereader"><span class="nav-number">8.21.</span> <span class="nav-text">介绍一下 ImageReader？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-pbopixel-buffer-object"><span class="nav-number">8.22.</span> <span class="nav-text">介绍一下 PBO（Pixel Buffer
Object）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-hardwarebuffer"><span class="nav-number">8.23.</span> <span class="nav-text">介绍一下 HardwareBuffer？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-opengl-pbo-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87"><span class="nav-number">8.24.</span> <span class="nav-text">使用 OpenGL PBO
为什么能提高效率？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-vao%E4%BB%80%E4%B9%88%E6%98%AF-vbo%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">8.25.</span> <span class="nav-text">什么是 VAO，什么是
VBO，它们的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8E%AF%E7%BB%95%E6%96%B9%E5%BC%8Fwrapping"><span class="nav-number">8.26.</span> <span class="nav-text">纹理有哪些环绕方式（wrapping）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-opengl-%E7%89%B9%E6%95%88%E7%9A%84%E6%97%B6%E5%80%99%E5%9B%BE%E5%83%8F%E4%B8%8D%E5%AF%B9%E6%9C%89%E4%BB%80%E4%B9%88%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E8%83%BD%E5%BF%AB%E9%80%9F%E6%8E%92%E6%9F%A5%E5%8E%9F%E5%9B%A0"><span class="nav-number">8.27.</span> <span class="nav-text">调试
OpenGL 特效的时候图像不对，有什么调试技巧能快速排查原因？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%92%AD%E6%94%BE%E5%99%A8%E6%97%B6%E5%88%A9%E7%94%A8-ffmpeg-%E6%8B%BF%E5%88%B0%E8%A7%A3%E7%A0%81%E5%90%8E%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E6%88%90-cvpixelbuffer-%E7%BC%93%E5%AD%98%E7%94%A8%E4%BA%8E%E6%B8%B2%E6%9F%93%E4%BD%86%E6%98%AF%E7%BC%93%E5%AD%98%E5%90%8E%E6%95%B0%E6%8D%AE%E5%8F%AA%E6%9C%89%E5%87%A0%E5%B8%A7%E4%BD%86%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E6%9C%89%E5%87%A0%E7%99%BE%E5%85%86"><span class="nav-number">8.28.</span> <span class="nav-text">自己实现播放器时利用
FFmpeg 拿到解码后数据封装成 CVPixelbuffer
缓存用于渲染，但是缓存后数据只有几帧，但为什么内存占用有时候会有几百兆？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81"><span class="nav-number">9.</span> <span class="nav-text">直播推流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E6%89%93%E5%BC%80%E6%88%90%E5%8A%9F%E7%8E%87%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">9.1.</span> <span class="nav-text">直播打开成功率如何优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E6%92%AD%E6%94%BE%E7%A7%92%E5%BC%80%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">9.2.</span> <span class="nav-text">直播播放秒开如何优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E6%92%AD%E6%94%BE%E5%8D%A1%E9%A1%BF%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">9.3.</span> <span class="nav-text">直播播放卡顿如何优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E5%BB%B6%E6%97%B6%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">9.4.</span> <span class="nav-text">直播延时如何优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E7%BE%8E%E9%A2%9C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.5.</span> <span class="nav-text">直播美颜如何实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E9%97%B4%E7%A4%BC%E7%89%A9%E7%89%B9%E6%95%88%E7%9A%84%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.6.</span> <span class="nav-text">直播间礼物特效的如何实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E8%BF%9E%E9%BA%A6%E7%9A%84%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.7.</span> <span class="nav-text">直播连麦的如何实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E9%97%B4%E7%9A%84%E5%9B%9E%E5%A3%B0%E6%B6%88%E9%99%A4%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.8.</span> <span class="nav-text">直播间的回声消除如何实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC-obs-%E7%9A%84%E5%AE%9E%E6%97%B6%E7%9A%84%E5%9B%BE%E7%89%87gif-%E8%B4%B4%E7%89%87%E5%8F%A0%E5%8A%A0%E5%92%8C%E6%9B%BF%E6%8D%A2%E6%95%88%E6%9E%9C%E6%97%B6%E9%81%87%E5%88%B0%E4%BA%86%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E7%9A%84-gif-%E8%B4%B4%E7%89%87%E5%8F%A0%E5%8A%A0%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="nav-number">9.9.</span> <span class="nav-text">在实现类似
OBS 的实时的图片、GIF
贴片叠加和替换效果时遇到了性能瓶颈，请问如何实现快速的 GIF
贴片叠加和替换？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E7%94%9F%E4%BA%A7%E5%8F%8A%E7%BC%96%E8%BE%91"><span class="nav-number">10.</span> <span class="nav-text">视频生产及编辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E5%80%92%E6%94%BE"><span class="nav-number">10.1.</span> <span class="nav-text">视频编辑中如何实现视频倒放？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%8D%E7%9F%AD%E8%A7%86%E9%A2%91%E6%83%B3%E6%8A%8A%E5%90%8C%E6%97%B6%E6%92%AD%E6%94%BE%E7%9A%84%E9%9F%B3%E4%B9%90%E5%BD%95%E5%88%B6%E4%B8%8B%E6%9D%A5%E4%B8%80%E8%88%AC%E8%A6%81%E7%BB%8F%E8%BF%87%E6%80%8E%E6%A0%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">10.2.</span> <span class="nav-text">拍短视频想把同时播放的音乐录制下来一般要经过怎样的处理流程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#android-camera-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6%E7%9A%84%E5%8D%A1%E9%A1%BF"><span class="nav-number">10.3.</span> <span class="nav-text">Android Camera
如何优化视频录制的卡顿？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E7%A0%81%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE"><span class="nav-number">10.4.</span> <span class="nav-text">转码速度优化的几点建议？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#seek-%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE"><span class="nav-number">10.5.</span> <span class="nav-text">Seek 优化的几点建议？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91-sdk-%E4%B8%80%E8%88%AC%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97%E5%90%84%E6%A8%A1%E5%9D%97%E6%98%AF%E4%BB%80%E4%B9%88%E8%81%8C%E8%B4%A3"><span class="nav-number">10.6.</span> <span class="nav-text">音视频编辑 SDK
一般包含哪些模块？各模块是什么职责？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91%E4%B8%AD%E8%BD%AC%E7%A0%81%E6%B5%81%E7%A8%8B-pipeline-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E8%A6%81%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.7.</span> <span class="nav-text">音视频编辑中转码流程
pipeline 的线程模型和缓冲区要怎么设计？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E5%A4%84%E7%90%86%E9%9F%B3%E8%A7%86%E9%A2%91%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%B3%B0%E5%80%BC"><span class="nav-number">10.8.</span> <span class="nav-text">如何降低处理音视频链路中的内存峰值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%BC%96%E8%BE%91-sdk-%E4%B8%AD%E7%9A%84%E6%92%AD%E6%94%BE%E5%99%A8%E5%92%8C%E6%92%AD%E6%94%BE-sdk-%E4%B8%AD%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%E5%91%A2%E7%BC%96%E8%BE%91%E5%9C%BA%E6%99%AF%E7%9A%84%E6%92%AD%E6%94%BE%E5%99%A8%E5%AF%B9-opengl-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%9B%E9%98%B6%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">10.9.</span> <span class="nav-text">在编辑
SDK 中的播放器和播放 SDK 中的视频播放存在哪些区别呢？编辑场景的播放器对
OpenGL 的使用有哪些进阶的用法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E5%8A%A8%E6%80%81%E5%9B%BE%E7%89%87%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%A7%8B%E8%A7%86%E9%A2%91"><span class="nav-number">10.10.</span> <span class="nav-text">iOS
动态图片如何获取原始视频？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%87%AA%E5%88%B6%E7%9A%84%E5%8A%A8%E6%80%81%E5%9B%BE%E7%89%87%E5%AF%BC%E5%87%BA%E5%88%B0%E7%9B%B8%E5%86%8C%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E6%88%90%E5%8A%A8%E6%80%81%E5%9B%BE%E7%89%87"><span class="nav-number">10.11.</span> <span class="nav-text">为什么自制的动态图片导出到相册无法识别成动态图片？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E5%86%85%E5%BD%95%E5%BD%95%E5%88%B6%E5%BD%93%E5%89%8D%E6%89%80%E6%9C%89%E6%89%8B%E6%9C%BA%E7%9A%84%E5%A3%B0%E9%9F%B3%E9%9B%86%E5%90%88"><span class="nav-number">10.12.</span> <span class="nav-text">iOS
如何实现音频内录，录制当前所有手机的声音集合？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E8%AF%A5%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E5%A4%8D%E6%9D%82%E5%AD%97%E4%BD%93%E6%B8%B2%E6%9F%93%E7%9A%84%E6%96%B9%E6%A1%88-%E9%9D%9E-uiview-%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="nav-number">10.13.</span> <span class="nav-text">应该选择哪种复杂字体渲染的方案
(非 UIView 的能力)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ios-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E8%A7%A3%E7%A0%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%BB%99%E8%A7%86%E9%A2%91%E6%B7%BB%E5%8A%A0-metadata"><span class="nav-number">10.14.</span> <span class="nav-text">iOS
如何在不解码的情况下给视频添加 Metadata？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%92%AD%E6%94%BE%E5%99%A8"><span class="nav-number">11.</span> <span class="nav-text">播放器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E6%92%AD%E7%9A%84%E5%80%8D%E9%80%9F%E6%92%AD%E6%94%BE%E8%A6%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.1.</span> <span class="nav-text">点播的倍速播放要如何实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%AD%E6%94%BE%E5%99%A8%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%80%E8%88%AC%E8%AE%BE%E7%BD%AE%E5%A4%9A%E5%A4%A7%E5%90%88%E9%80%82"><span class="nav-number">11.2.</span> <span class="nav-text">播放器解码后的帧缓冲区一般设置多大合适？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E9%BB%91%E5%B1%8F%E8%8A%B1%E5%B1%8F%E7%BB%BF%E5%B1%8F%E7%AD%89%E5%BC%82%E5%B8%B8"><span class="nav-number">11.3.</span> <span class="nav-text">如何监控视频播放黑屏、花屏、绿屏等异常？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%BC%98%E5%8C%96%E6%92%AD%E6%94%BE%E5%99%A8%E6%9D%A5%E4%BC%98%E5%8C%96%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E4%BD%93%E9%AA%8C%E6%AF%94%E5%A6%82%E6%8F%90%E5%8D%87%E9%9F%B3%E8%B4%A8%E6%88%96%E9%9F%B3%E6%95%88"><span class="nav-number">11.4.</span> <span class="nav-text">如何通过优化播放器来优化音乐播放体验，比如提升音质或音效？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%92%AD%E6%94%BE%E5%99%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%BC%9A%E5%88%86%E5%93%AA%E5%87%A0%E5%B1%82"><span class="nav-number">11.5.</span> <span class="nav-text">如果让你设计一个播放器的架构，你会分哪几层？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ffmpeg-%E4%B8%AD-avformat_open_input-%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%E6%AD%A5%E9%AA%A4"><span class="nav-number">11.6.</span> <span class="nav-text">FFmpeg 中
avformat_open_input() 经历了什么步骤？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%9C%8D%E5%8A%A1"><span class="nav-number">12.</span> <span class="nav-text">综合多媒体框架及服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#webrtc-%E4%B8%AD%E7%9A%84-ice-%E4%BD%9C%E7%94%A8"><span class="nav-number">12.1.</span> <span class="nav-text">WebRTC 中的 ICE 作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webrtc-%E4%B8%AD%E5%AA%92%E4%BD%93%E5%8D%8F%E5%95%86%E8%BF%87%E7%A8%8B"><span class="nav-number">12.2.</span> <span class="nav-text">WebRTC 中媒体协商过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webrtc-nat-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">12.3.</span> <span class="nav-text">WebRTC NAT 有几种类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webrtc-%E4%B8%AD%E7%9A%84-gcc-%E6%9C%BA%E5%88%B6"><span class="nav-number">12.4.</span> <span class="nav-text">WebRTC 中的 GCC 机制？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7"><span class="nav-number">13.</span> <span class="nav-text">工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-simd-%E4%BB%A5%E5%8F%8A%E5%AE%83%E5%9C%A8%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">13.1.</span> <span class="nav-text">介绍一下 SIMD
以及它在音视频处理中的应用？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF"><span class="nav-number">14.</span> <span class="nav-text">业务场景</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Yao"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Yao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cmder" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cmder" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cmd100000@gmail.com" title="E-Mail → mailto:cmd100000@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cmder.github.io/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Bruce Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="说码解字">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="音视频面试题集锦 | 说码解字">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          音视频面试题集锦
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-07 18:57:46" itemprop="dateCreated datePublished" datetime="2025-08-07T18:57:46+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-14 22:00:23" itemprop="dateModified" datetime="2025-10-14T22:00:23+08:00">2025-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/" itemprop="url" rel="index"><span itemprop="name">音视频</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="采集">采集</h2>
<h3 id="ios-如何实现夜晚自动提示打开手电筒">iOS
如何实现夜晚自动提示打开手电筒？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA">https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA</a></p></li>
<li><p>当夜晚使用共享单车扫码时，应该都见过提示“打开手电筒”，在
<code>iOS</code>
中我们如何实现呢？主要基于图像环境光参数，参考如下代码。</p></li>
<li><p><code>iOS</code> 视频采集设置
<code>AVCaptureVideoDataOutput AVCaptureVideoDataOutputSampleBufferDelegate</code>，通过获取
<code>CMSampleBufferRef</code>
每一帧视频数据环境参数进行判断即可。</p></li>
</ul>
<h3 id="谈谈-ios-音视频采集相关接口和数据结构的设计">谈谈 iOS
音视频采集相关接口和数据结构的设计？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-cwQbkbHqmMKRPk0YhBG6g</p></li>
<li><p>通常我们通过 AVCaptureSession 相关的 API
来进行音视频的采集，其中主要组件分为 Input、Output、Session
几个部分</p></li>
<li><p>对于视频采集，一般直接使用 AVCaptureSession 的 API 即可</p></li>
<li><p>对于音频采集，除了可以使用 AVCaptureSession
来进行音频采集外，还可以使用 AudioUnit。</p></li>
</ul>
<h2 id="音频算法">音频算法</h2>
<h3
id="你对视频倍速播放的时候是否有改变音调">你对视频倍速播放的时候，是否有改变音调？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>倍速变大和变小都会带来变调的问题，目前流行的开源项目有 soundtouch
和 sonic
来达到变速不变调的效果，最经典的就是使用时域压扩（TSM）的算法。</p></li>
</ul>
<h3
id="直播中发现有回声可能的原因是什么">直播中发现有回声，可能的原因是什么？</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA">https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA</a></li>
</ul>
<h3 id="聊聊对音视频同步的理解">聊聊对音视频同步的理解？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/Ampeeb15Wk2WfgLWMkHywg</p></li>
<li><p>音视频对齐方式有三种：</p>
<ul>
<li><p>以音频时钟为基准</p></li>
<li><p>以视频时钟为基准</p></li>
<li><p>以第三方时钟为基准</p></li>
</ul></li>
<li><p>实际情况下，如果用上面那种简单的方式，慢慢的就会出现音视频不同步的情况，主要原因是同步时，时间粒度太大了，难以精准控制。所以需要引入一个参考时钟（要求参考时钟上的时间是恒定线性递增的）来提高音频时钟的时间粒度，比如：系统时间，进而进行精准时钟对齐。最后以音频时钟为准，视频放快了就减慢播放速度，播放快了就丢帧或加快播放的速度。</p></li>
</ul>
<h2 id="图像算法">图像算法</h2>
<h3 id="为什么在-yuv-转-rgb-转换中-uv-分量要减去-0.5">为什么在 YUV 转
RGB 转换中 UV 分量要减去 0.5？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/HlLwri7rFNSs9C6rxZ90gw</p></li>
<li><p>在进行 YUV 到 RGB 的转换时，为了将 U 和 V 的取值范围从对称的 -128
到 127 归一化为非对称的 0 到 255，并且将中心点从 128 移动到 0，需要对 U
和 V 进行偏移量的减法操作。具体来说，通过减去 0.5（或 128
对应的小数形式），可以将 U 和 V 的取值范围转换为 0 到 255，从而与 RGB
的取值范围相匹配。</p></li>
</ul>
<h3
id="纹理抗锯齿有哪些算法各有哪些利弊">纹理抗锯齿有哪些算法？各有哪些利弊?</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/N-PzPA4rSHGtE6KIjnEX4Q</p></li>
<li><p>FXAA（快速近似抗锯齿）</p></li>
<li><p>SSAA（超级采样抗锯齿）</p></li>
<li><p>MSAA（多重采样抗锯齿）</p></li>
</ul>
<h2 id="特效">特效</h2>
<h3 id="opengl-如何实现二分屏效果">OpenGL 如何实现二分屏效果？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-cwQbkbHqmMKRPk0YhBG6g</p></li>
<li><p>以纹理 y 坐标中间分屏为例，代码如下：</p>
<ul>
<li>precision highp float; varying lowp vec2 varyTextCoord; uniform
sampler2D inputTexture;</li>
</ul></li>
</ul>
<p>void main() { float y; if (varyTextCoord.y &gt;= 0.0 &amp;&amp;
varyTextCoord.y &lt;= 0.5) { y = varyTextCoord.y + 0.25; } else { y =
varyTextCoord.y - 0.25; } gl_FragColor = texture2D(inputTexture,
vec2(varyTextCoord.x, y)); }</p>
<h2 id="编解码">编解码</h2>
<h3 id="什么是-dts-和-pts它们有什么区别">什么是 DTS 和
PTS？它们有什么区别？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>DTS 是解码时间戳；PTS 是显示时间戳。 虽然 DTS、PTS
是用于指导播放端的行为，但它们是在编码的时候由编码器生成的。
当视频流中没有 B 帧时，通常 DTS 和 PTS 的顺序是一致的。但如果有 B
帧时，就回到了我们前面说的问题：解码顺序和播放顺序不一致了。DTS
告诉我们该按什么顺序解码这几帧图像，PTS
告诉我们该按什么顺序显示这几帧图像。</p></li>
</ul>
<h3 id="什么是-idr-帧它和-i-帧有什么区别">什么是 IDR 帧？它和 I
帧有什么区别？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>IDR 帧全称叫做 Instantaneous Decoder Refresh，是 I 帧的一种。IDR
帧的作用是立刻刷新，重新算一个新的序列开始编码，使错误不致传播。 IDR
帧有如下特性：</p></li>
<li><p>IDR 帧一定是 I 帧，严格来说 I 帧不一定是 IDR 帧（但一般 I 帧就是
IDR 帧）；</p></li>
<li><p>对于 IDR 帧来说，在 IDR 帧之后的所有帧都不能引用任何 IDR
帧之前的帧的内容。与此相反，对于普通的 I 帧来说，位于其之后的 B 和 P
帧可以引用位于普通 I 帧之前的 I 帧（普通 I
帧有被跨帧参考的可能）；</p></li>
<li><p>播放器永远可以从一个 IDR
帧播放，因为在它之后没有任何帧引用之前的帧。因此，视频开头的 I 帧一定是
IDR 帧；一个封闭类 GOP 的开头的 I 帧也一定是 IDR 帧。
所以，在直播场景通常每个 I 帧都是 IDR
帧，这样服务端下发流数据的时候总是从一个 I
帧开始，播放器就可以立即开始播放。</p></li>
</ul>
<h3 id="什么是-sps-和-pps它们有什么区别">什么是 SPS 和
PPS？它们有什么区别？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>SPS，Sequence Paramater
Set，保存了一组编码后的图像序列所依赖的全局参数。 PPS，Picture Paramater
Set，保存了每一帧编码后的图像所依赖的参数。 SPS
中的信息至关重要，如果其中的数据丢失，解码过程就可能失败。SPS 和 PPS
通常作为解码器的初始化参数。一般情况，SPS 和 PPS 所在的 NAL
单元位于整个码流的起始位置，但是在某些场景下，在码率中间也可能出现这两种结构：</p></li>
<li><p>解码器要在码流中间开始解码。比如，直播流。</p></li>
<li><p>编码器在编码过程中改变了码率的参数。比如，图像的分辨率。</p></li>
</ul>
<h3 id="什么是-sei我们可以用它来做什么">什么是
SEI？我们可以用它来做什么？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>SEI 即补充增强信息（Supplemental Enhancement
Information），属于码流范畴，它提供了向视频码流中加入额外信息的方法，是
H.264 标准的特性之一。 SEI的基本特征如下：</p></li>
<li><p>并非解码过程的必须选项；</p></li>
<li><p>可能对解码过程（容错、纠错）有帮助；</p></li>
<li><p>集成在视频码流中。 在直播场景，我们通常使用 SEI
来携带推流端的信息，一直随着直播流传输到播放端。由于 SEI
是绑定着视频帧，所以它可以支持诸如：</p></li>
<li><p>统计直播推流端到播放端延时。</p></li>
<li><p>支持和视频帧绑定的内容交互。比如，直播答题在播放端的弹窗等。</p></li>
</ul>
<h3
id="如何根据-nalu-裸流数据来判断其是-h.264-编码还是-h.265-编码">如何根据
NALU 裸流数据来判断其是 H.264 编码还是 H.265 编码？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q">https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q</a></p></li>
<li><p>1）通常在处理音视频数据时，我们如何选择解码器？ 通常我们不是根据
NALU
裸流数据中的信息来选择解码器，而是根据媒体封装层的信息来确定解码器。
媒体封装层是表示媒体数据是什么封装格式的，比如
MP4、FLV。在这层信息里，通常会携带码流编码格式的信息。 拿 MP4
来说，我们可以根据 Sample Description Box(moov/trak/mdia/minf/stbl/stsd)
中的信息来确定其封装的码流的编码格式。 对于 FLV，我们可以根据
VideoTagHeader 中的 CodecID 等信息来确定其封装的码流的编码格式。
这样的好处是效率比较高，解封装的时候就可以确定选择何种解码器了。
2）怎么识别 NALU 裸流数据的编码格式是 H.264 还是 H.265？
但是，如果出现题目中的情况，没有对码流进行封装，而是直接传输码流时，这时候
NALU
中有什么字段能标识自己的编码格式吗？答案是，没有这样明确的字段能标识码流的编码格式。
但是这个问题也不是不能解决，因为 H.264、H.265
码流本身也是遵循一定格式规范的，我们可以按照它的格式规范进行探测，如果能解析出来正确的信息，那也可以确定它的编码格式。
比如，拿 H.265 来说，FFmpeg 中 hevcdec.c 就有对其码流数据进行探测的函数
hevc_probe(…)。 所以，我们可以按照编码格式规范探测，比如 H.265
如果解析出了 pps、sps、vps 的各字段信息符合规范，就认为它是 H.265
的编码；如果不是，在你们的码流格式范围中就只剩 H.264
了；接下来将码流数据交给对应的解码器解码即可。</p></li>
</ul>
<h3 id="什么是-open-gop什么是-closed-gop">什么是 Open GOP？什么是 Closed
GOP ?</h3>
<ul>
<li>这里说的封闭类 GOP，也就是我们常说的 Closed GOP。 Closed GOP
即只允许 GOP 中的帧参考当前 GOP 中的其他帧。 相对与 Closed GOP，还存在
Open Gop，Open Gop 允许一个 Gop 中的帧跨 GOP 参考其他 GOP 中的帧。
在实际应用中，如果是在 HLS、DASH
等自适应流媒体的场景下，为了实现码流之间的无缝切换，也必须使用 ClosedGOP
。 在 x264 中，Open GOP 是默认关闭的。 在 x265 中，Open GOP
则是默认开启的，如果要关闭 Open GOP选项，则需要在你的 x265
配置中加入以下代码 open-gop=0。</li>
</ul>
<h3 id="为什么会有-yuv-这种数据它相比-rgb-数据有什么优点">为什么会有 YUV
这种数据？它相比 RGB 数据有什么优点？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q">https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q</a></p></li>
<li><p>RGB 工业显示器要求一幅彩色图像由分开的 R、G、B
信号组成，而电视显示器则需要混合信号输入，为了实现对这两种标准的兼容，NTSC（美国国家电视系统委员会）制定了
YIQ
颜色模型，它的主要优点是可以实现对彩色电视和黑白电视的兼容，即可以用黑白电视收看彩色电视信号。YUV
颜色模型则是在 YIQ 的基础上发展而来。 YUV
颜色模型中用亮度、色度来表示颜色。它的亮度信息和色度信息是分离的，其中 Y
表示亮度通道，U 和 V 则表示色度通道。如果只有 Y 信息，没有 U、V
信息，那么表示的图像就是灰度图像。YUV 常用在各种影像处理场景中。YUV
在对照片或视频编码时，考虑到人眼对亮度信息的敏感度高于色度信息，允许降低色度的带宽。这样一来就可以对色度信息进行压缩，所以
YUV 可以相对 RGB
使用更少的数据带宽。比如常见的采样格式有：4:2:1、4:1:1、4:2:0
等，它们分别相对 RGB 压缩了 33.3%、50%、50% 的数据量。</p></li>
</ul>
<h3
id="对-yuv-格式有了解吗yuv-数据做转换是怎样实现的比如说-yuv422-转为-yuv420">对
YUV 格式有了解吗？YUV 数据做转换是怎样实现的，比如说 YUV422 转为
YUV420？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>YUV 格式是传输视频常用的格式，因为相对于 RGB
格式它可以节省更多空间。</p></li>
<li><p>YUV 的格式有很多，例如：YUV444、YUV422、YUV420，常用的 YUV 格式是
YUV420 格式。Y 表示亮度信息，是人眼最敏感的分量，UV
则表示色度信息。</p></li>
<li><p>YUV420 表示采样方式：UV 分量具有 2:1 的水平采样，2:1
的垂直采样，这里并不是指只有 U，没有 V，而是对于每一行，只有一个 U 或者
V 分量，如果第一行是 4:2:0，那么下一行就是 4:0:2。</p></li>
<li><p>可以用工具 YUVView 直接打开 YUV 格式的数据。</p></li>
<li><p>YUV 数据因为计算量大和数据量大可以都放到 GPU 存储和计算，YUV422
转 YUV420 可以利用 OpenGL 将 YUV422 的 UV 数据转换成 texture 纹理，编写
shader 做格式转换逻辑继而生成 YUV420 的 UV texture，再通过 readPixel
将显存的 UV 数据读取出来。转换逻辑即将纹理 UV 分量隔行采样。</p></li>
</ul>
<h3 id="pcm-音频数据是怎么组织的">PCM 音频数据是怎么组织的？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ">https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ</a></p></li>
<li><p>模拟数据 → 采样 → 量化 → 编码 → 数字信号</p></li>
</ul>
<h3 id="说一下对信号时域频域的理解">说一下对信号时域、频域的理解？</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ">https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ</a></li>
</ul>
<h3 id="pcm-数据经过-aac-编码器编码后直接写-.aac-文件会怎么样">PCM
数据经过 AAC 编码器编码后，直接写 .aac 文件会怎么样？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ">https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ</a></p></li>
<li><p>正常播放器会没法识别播放（因为不知道声道数，采样率等信息）。一般要这样做：正常需要在编码每帧数据后，结合编码后的数据生成
ADTS 头，然后将 <code>ADTS 头 + 编码后的数据</code>
整体写入文件，循环往复，才能生成可正常播放的 .aac
文件（当然也可以是：<code>1 个 ADTS + 多帧编码数据</code>
这样的组合）。</p></li>
</ul>
<h3 id="pcm-数据操作的最小单元是多少字节">PCM
数据操作的最小单元是多少字节？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/lYKGrt4rOISncyFwYRM2cQ</p></li>
<li><p>音频 PCM
数据，如果要进行编辑，那么其最小操作单元是：<code>声道数 * 位数 / 8 * 1 个采样点</code>。</p></li>
</ul>
<h3 id="简要介绍一下对-h.264-的了解">简要介绍一下对 H.264 的了解？</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw">https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw</a></li>
</ul>
<h3 id="h.264-编码框架分层目的是什么">H.264
编码框架分层目的是什么？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw">https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw</a></p></li>
<li><p>对 H.264
编码框架进行分层的主要目标是为了有高的视频压缩比和良好的网络亲和性。</p></li>
<li><p>VCL 层负责视频的信号处理，包含压缩，量化等处理，NAL
层则负责解决编码后数据的网络传输。</p></li>
<li><p>这样可以将 VCL 和 NAL
的处理放到不同平台来处理，可以减少因为网络环境不同对 VCL
的比特流进行重构和重编码。</p></li>
<li><p>这样将编码和网络传输进行隔离，使功能单一、便于维护。</p></li>
</ul>
<h3 id="h.264-如何根据-nalu-判断当前视频帧的类型">H.264 如何根据 NALU
判断当前视频帧的类型？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw">https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw</a></p></li>
<li><p>NALU
结构一般为：<code>[NALU Header][NALU Payload]</code>，可以根据
<code>[NALU Header]</code> 这 1 个字节来获取帧类型</p></li>
</ul>
<h3 id="介绍一下-ipb-帧编码解码显示顺序">介绍一下 I、P、B
帧编码、解码、显示顺序？</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw">https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw</a></li>
</ul>
<h3 id="h.264-与-h.265-有什么区别">H.264 与 H.265 有什么区别？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw">https://mp.weixin.qq.com/s/eI0q38YL1DJcou7tm2IDkw</a></p></li>
<li><ul>
<li>H.265 也称为高效视频编码 (HEVC)，是 H.264
的升级和更高级的版本；</li>
</ul></li>
<li><ul>
<li>H.265 的编码架构大致上 和 H.264
的架构相似，主要也包含：帧内预测（intra prediction）、帧间预测（inter
prediction）、转换（transform）、量化（quantization）、去区块滤波器（deblocking
filter）、熵编码（entropy coding）等模块。但在 H.265
编码架构中，整体被分为了三个基本单位，分别是编码单位（coding unit,
CU）、预测单位（predict unit, PU）和转换单位（transform unit,
TU）；</li>
</ul></li>
<li><ul>
<li>比起 H.264，H.265
提供了更多不同的工具来降低码率，以编码单位来说，H.264
中每个宏块（macroblock/MB）大小最大为 16x16 像素，而 H.265
的编码单位最大为 64x64；</li>
</ul></li>
<li><ul>
<li>H.265 的帧内预测模式支持 35 种方向（而 H.264 只支持 8
种），并且提供了更好的运动补偿处理和矢量预测方法。</li>
</ul></li>
</ul>
<h3 id="如何代码实现-psnr-来评估编码质量">如何代码实现 PSNR
来评估编码质量？</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA">https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA</a></li>
</ul>
<h3 id="如何测试码率质量甜点">如何测试码率质量甜点？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA">https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA</a></p></li>
<li><p>在视频领域，质量甜点指的是在既定的码率和屏幕大小下通过设定合理的分辨率和帧率来得到最佳视频主观质量体验。因为编码复杂度和编解码质量亦不是线性关系，两者之间也存在一个<em>质量甜点</em>。在音频领域也有类似的情况，针对具体的情况，我们可以测试手机的编码质量来选择指定分辨率、帧率时对应的码率甜点。</p></li>
</ul>
<h3 id="android-surface-解码如何支持带角度视频">Android Surface
解码如何支持带角度视频？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA">https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA</a></p></li>
<li><p><strong>1）直接解码到 Surface</strong></p>
<ul>
<li>需要通过 <code>MediaFormat</code> 设置解码参，通过
<code>MediaFormat.KEY_ROTATION</code>
配置旋转角度，则可以正确显示。</li>
</ul></li>
<li><p><strong>2）解码到 SurfaceTexture</strong></p>
<ul>
<li>解码到 <code>SurfaceTexture</code>，通过
<code>MediaFormat.KEY_ROTATION</code>
配置旋转角度，但输出纹理提供接口获取旋转矩阵，<code>mSurfaceTexture.getSurfaceTexture().getTransformMatrix</code>，拿到旋转矩阵后通过
<code>FBO</code>
渲染调整为正确尺寸，这种模式好处可以将解码后数据经过自定义处理传递给编码层与渲染上屏。</li>
</ul></li>
</ul>
<h3 id="ios-如何实现-hdr-转-sdr">iOS 如何实现 HDR 转 SDR？</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A">https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A</a></li>
</ul>
<h3 id="介绍一下-ffmpeg-中关于-timebase-的基础知识与应用">介绍一下
FFmpeg 中关于 timebase 的基础知识与应用？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg">https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg</a></p></li>
<li><p>timebase 在 FFmpeg 的定义是一个 AVRational
结构体，用分子和分母表示。</p></li>
</ul>
<h3 id="如何识别一个视频是-hdr-视频">如何识别一个视频是 HDR 视频？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg">https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg</a></p></li>
<li><p>iOS 判断一个视频是否是 HDR 视频的方法：判断是否带有 HDR 特征的
track 即可。</p>
<ul>
<li>NSArray&lt;AVAssetTrack <em>&gt; </em>hdrTracks = [asset
tracksWithMediaCharacteristic:AVMediaCharacteristicContainsHDRVideo]; if
(hdrTracks.count &gt; 0){ return YES; }</li>
</ul></li>
<li><p>Android 需要我们自己解析出
colortransforfunction和ccolorStandard。</p></li>
</ul>
<h3
id="请问-android-上如何识别一个视频是哪种格式的-hdr-视频hdr10dolbyvisionhlghdr10">请问
Android 上如何识别一个视频是哪种格式的 HDR
视频：HDR10+/DolbyVision/HLG/HDR10？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA">https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA</a></p></li>
<li><p>Dolby：MediaExtractor 可以解析出 minetype，如果是
video/dolby-vision 则格式为 Dolby 视频；</p></li>
<li><p>HLG：解析出 METADATA_KEY_COLOR_TRANSFER，如果颜色转换函数是 HLG
则格式为 HLG 视频；</p></li>
<li><p>HDR10/HDR10+：可以通过硬件解码出来的 mediaFormat 变化回调
onOutputFormatChanged 来判断，代码如下： public void
onOutputFormatChanged(<span class="citation"
data-cites="NonNull">@NonNull</span> MediaCodec mediaCodec, <span
class="citation" data-cites="NonNull">@NonNull</span> MediaFormat
mediaFormat) { if (format.containsKey(MediaFormat.KEY_HDR10_PLUS_INFO)){
Log.d(TAG, “hdr10”); } else if
(format.containsKey(MediaFormat.KEY_HDR_STATIC_INFO)){ Log.d(TAG,
“hdr10+”); } }</p></li>
</ul>
<h3 id="hevc-opengop-的新增的帧类型有哪些在开发中需要注意什么">HEVC
OpenGOP 的新增的帧类型有哪些，在开发中需要注意什么？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA">https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA</a></p></li>
<li><p>IRAP（Intra Random Access
Pictures）：随机访问帧。解码器可以从该帧开始解码。IRAP
包含三种帧类型：瞬时解码器刷新帧（IDR）、干净随机访问帧（CRA）、断开链路访问帧（BLA）。视频的解码过程始终要从
IRAP 帧开始。</p></li>
<li><p>前导帧（Leading
pictures）：按输出顺序位于随机访问点图片之前，但在编码视频序列中在随机访问点图片之后进行编码。</p>
<ul>
<li><p>RADL（Random Access Decodable Leading
pictures）：按照编码顺序独立于随机访问点之前的图片的引导帧被称为随机访问可解码前导帧。</p></li>
<li><p>RASL（Random Access Skipped Leading
pictures）：按照编码顺序使用随机访问点之前的图片进行预测的前导帧可能会被损坏。这些被称为随机访问跳过前导帧。</p></li>
</ul></li>
<li><p>尾随帧（Trailing pictures）：在输出和解码顺序上均在 IRAP
和前导图片之后。</p></li>
<li><p>TSA（Temporal Sublayer Access）和 STSA（Stepwise Temporal
Sublayer
Access）：标记解码器需要切换视频分辨率的帧，也是编码分层逻辑里面的分层转换点。</p></li>
</ul>
<h3 id="介绍一下-android-14-引入了-ultra-hdr-image-格式">介绍一下
Android 14 引入了 Ultra HDR Image 格式？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA">https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA</a></p></li>
<li><p>Ultra HDR 图片格式的原理是结合了标准 8-bit JPEG
基础图像与一个较低分辨率的、带有增益映射的 JPEG 图像以及用于 HDR
重建的元数据。首先，它通过加入一个标准 8-bit 的 JPEG
压缩图像，这个图像提供了基础的色彩和细节。然后，它关联了一个较低分辨率的
JPEG
图像，这个图像带有增益映射，可以提供额外的细节和动态范围。最后，它还包含了用于
HDR 重建的元数据，这些元数据可以用来创建 HDR 图像。</p></li>
</ul>
<h3
id="ios-平台上如何判断-videotoolbox-是否支持某种编码格式h.264hevc-等或者某种颜色空间呢">iOS
平台上如何判断 VideoToolbox 是否支持某种编码格式（H.264、HEVC
等）或者某种颜色空间呢？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ">https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ</a></p></li>
<li><p>1）判断 VideoToolbox 是否支持一种编码格式，首先可以查一下
<code>CMFormatDescription.h</code> 文件的 <code>CMVideoCodecType</code>
枚举中有没有对应的编码格式。对于具体的设备是否支持某种编码格式，可以用类似下面的代码检查：</p></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BOOL</span> supportHEVC = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">	<span class="keyword">if</span> (&amp;VTIsHardwareDecodeSupported) &#123;</span><br><span class="line">		supportHEVC = VTIsHardwareDecodeSupported(kCMVideoCodecType_HEVC);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2）判断是否支持某一种类型的颜色空间，可以先看看
<code>CVPixelBuffer.h</code> 文件中的 <code>kCVPixelFormatType</code>
关于颜色空间的声明。</li>
</ul>
<h3
id="android-平台上使用-mediacodec-编码如何告知编码器结束编码">Android
平台上使用 MediaCodec 编码，如何告知编码器结束编码？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ">https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ</a></p></li>
<li><p>当我们想要告知编码器结束编码的时候，其实是在 Executing 状态中，从
Running 子状态中流转到 End-of-Stream 子状态中，并且在 MediaCodec
使用结束后，调用 <code>release()</code> 方法将其释放。</p></li>
<li><p>当 MediaCodec 的输入队列中接受了一个带有
<code>_BUFFER_FLAG_END_OF_STREAM_</code> 标志的输入帧时，MediaCodec
会继续输出剩余的编码数据。直到收到 End-of-Stream
的编码帧后，可以认为编码器已经从之前的 Running 状态运行到 End-of-Stream
状态。</p></li>
<li><p>在输入带有 <code>_BUFFER_FLAG_END_OF_STREAM_</code>
标志的输入帧后，不可再继续向 MediaCodec 输入数据，除非 MediaCodec 已经被
Flush、Stop 或 Restart。</p></li>
</ul>
<h3
id="android-平台上使用-mediacodec-异步编码使用-surface-作为编码输入源的流程和使用-bytebuffer-作为编码输入源有什么区别">Android
平台上使用 MediaCodec 异步编码，使用 Surface 作为编码输入源的流程和使用
ByteBuffer 作为编码输入源有什么区别？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ">https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ</a></p></li>
<li><p>使用 ByteBuffer 异步编码的时候，Surface 和 ByteBuffer 都需要设置
MediaCodec 的 <code>setCallback</code>
方法设置相关的回调。区别在于：</p></li>
<li><ul>
<li>在使用 ByteBuffer 作为输入源的时候，我们需要在
<code>onInputBufferAvailable</code> 的时候根据 index 拿到空闲的
ByteBuffer，塞入有效的数据后，再调用 <code>queueInputBuffer</code>
传回给 codec 进行编码。</li>
</ul></li>
<li><ul>
<li>在使用 Surface 作为输入源的时候，Surface 会自己管理
buffer，<code>dequeueInputBuffer</code> 和 <code>getInputBuffers</code>
的调用都被认为是非法的。因此 <code>onInputBufferAvailable</code>
方法不会回调，我们需要把数据直接送到 Surface 上进行渲染。</li>
</ul></li>
</ul>
<h3 id="聊聊-ios-cvpixelbufferref-相关的细节">聊聊 iOS CVPixelBufferRef
相关的细节？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/Ampeeb15Wk2WfgLWMkHywg</p></li>
<li><p>CVPixelBufferRef 像素缓冲区，是 iOS
平台进行视频编解码及图像处理相关最重要的数据结构之一。它的定义是 typedef
CVImageBufferRef CVPixelBufferRef。CVPixelBuffer 是在 CVImageBuffer
的基础上实现了内存存储。并且，CVPixelBuffer 还可以实现 CPU 和 GPU
共享内存，为图像处理提供更高的效率。</p></li>
</ul>
<h3 id="如何获取视频流中的-qp-值">如何获取视频流中的 QP 值？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/HlLwri7rFNSs9C6rxZ90gw</li>
</ul>
<h3 id="视频编码对-qp-值的控制有哪些">视频编码对 QP
值的控制有哪些？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/HlLwri7rFNSs9C6rxZ90gw</li>
</ul>
<h3 id="ios-如何使用分段转码如何设置分片大小">iOS
如何使用分段转码，如何设置分片大小？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/N-PzPA4rSHGtE6KIjnEX4Q</p></li>
<li><p>初始化 AVAssetWriter 时可以设置 outputFileTypeProfile =
AVFileTypeProfileMPEG4AppleHLS 即可打开 MP4 分段转码。</p></li>
<li><p>通过 preferredOutputSegmentInterval
设置转码后的每片大小。如果想手动切片，需要设置
preferredOutputSegmentInterval =
kCMTimeIndefinite，并且在每次想要切片的位置调用 flushSegment
接口强制分片，注意调用接口的时机必须是 Sync 帧前。即每片的开始帧都是
Sync 帧。</p></li>
</ul>
<h3
id="videotoolbox-中是不是不存在平面格式planar对应的-yuv420yuv422-和-yuv444-的-ostype-常量">VideoToolbox
中是不是不存在平面格式（planar）对应的 YUV420、YUV422 和 YUV444 的
OSType 常量？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/N-PzPA4rSHGtE6KIjnEX4Q</p></li>
<li><p>iOS 的 API
中能找到的平面格式有：kCVPixelFormatType_420YpCbCr8Planar、kCVPixelFormatType_420YpCbCr8PlanarFullRange，这两种平面格式分别对应
y420 和
f420。对这两种格式测试下来，目前系统播放器支持，系统相机不支持。yuv422
和 yuv444 的平面格式目前没找到。</p></li>
</ul>
<h3 id="ios-中系统-api-提供了哪些视频编码的方式">iOS 中系统 API
提供了哪些视频编码的方式？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/sKvPn2pLRYdJzx6RepKp1Q</p></li>
<li><p>AVFoundation 框架：通过 AVFoundation 框架，可以使用 AVAssetWriter
和 AVAssetWriterInput 类来实现编码视频。</p></li>
<li><p>VideoToolbox 框架：使用 VideoToolbox，可以利用 iOS
设备上的硬件编码器来实现高效的视频编码。</p></li>
</ul>
<h3 id="videotoolbox-视频帧解码失败以后应该如何重试">Videotoolbox
视频帧解码失败以后应该如何重试？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/sKvPn2pLRYdJzx6RepKp1Q</p></li>
<li><p>1、重新初始化解码器：尝试重新初始化 Videotoolbox
解码器，有时候重新初始化可以解决解码过程中的一些临时问题。</p></li>
<li><p>2、检查视频文件：确保视频文件没有损坏或者格式不正确。有时候解码失败是因为视频文件本身的问题，可以尝试使用其他工具或者重新获取视频文件。</p></li>
<li><p>3、检查当前内存：在解码过程中如果 CMSampleBuffer
不及时释放，可能会导致内存过高导致解码器报 -11800 通用错误。</p></li>
<li><p>4、尝试重新解码当前帧：将当前帧以及当前 gop
内前序帧都重新输入给解码器。</p></li>
</ul>
<h3 id="如何使用-psnr-对视频转码质量进行评估">如何使用 PSNR
对视频转码质量进行评估？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/sKvPn2pLRYdJzx6RepKp1Q</p></li>
<li><p>1、计算图像差异：获得原始视频帧和转码后的未经过任何图像效果处理的视频帧使用同一解码器解码，并将它们的每一帧转换成相同的格式（比如
YUV 格式）。</p></li>
<li><p>2、计算 PSNR 值：使用以下公式计算每一帧的 PSNR 值。</p></li>
<li><p>3、计算平均 PSNR：将所有帧的 PSNR 值求平均，得到视频的平均 PSNR
值。</p></li>
<li><p>4、分析结果：根据平均 PSNR 值来评估转码后视频的质量。较高的 PSNR
值表示转码后的视频质量与原始视频相似度较高，而较低的 PSNR
值则表示质量损失较大。</p></li>
</ul>
<h3 id="videotoolbox-遵循哪种视频码率控制策略如何设置">VideoToolbox
遵循哪种视频码率控制策略？如何设置？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/JbEGcM95fL3i7g30dTDtOw</p></li>
<li><p>CBR（Constant Bit
Rate）恒定码率：一定时间范围内比特率基本保持的恒定。</p></li>
<li><p>VBR（Variable Bit
Rate）可变码率：码率分配根据图像内容的复杂度进行。</p></li>
<li><p>ABR（Average
Bitrate）平均目标码率：控制一段时间内的编码平均码率。</p></li>
</ul>
<h3 id="annex-b-如何转换为-avcc">Annex B 如何转换为 AVCC？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/JbEGcM95fL3i7g30dTDtOw</p></li>
<li><p>1、解析 Annex B 格式：读取字节流，识别每个 NAL
单元的起始码，确定每个 NAL 单元的开始和结束位置。</p></li>
<li><p>2、去除起始码：去除每个 NAL 单元的起始码。</p></li>
<li><p>3、计算长度：对于每个 NAL
单元，计算其长度（以字节为单位）。</p></li>
<li><p>4、写入长度前缀：将每个 NAL 单元的长度作为字节序列写入到 AVCC
格式的流中，可能 1 个字节，2 字节或者 4 字节（较为常见），NAL
单元长度会存储在 AVCC 的 extradata 中。</p></li>
<li><p>5、根据 Annex B 的 SPS 和 PPS 生成对应的 extradata。</p></li>
<li><p>6、写入 NAL 单元数据：在长度字段后面写入去除起始码后的 NAL
单元数据。</p></li>
</ul>
<h3 id="ios-中如何判断一个视频帧是不是关键帧">iOS
中如何判断一个视频帧是不是关键帧？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/JbEGcM95fL3i7g30dTDtOw</p></li>
<li><p>在 VideoToolbox 中，可以通过检查给定的
<code>CMSampleBuffer</code> 是否是视频帧，并且是否是关键帧。</p></li>
</ul>
<h3 id="ffmpeg-编码的流程是什么">FFmpeg 编码的流程是什么？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/lYKGrt4rOISncyFwYRM2cQ</p></li>
<li><p><code>av_register_all()</code>：注册 FFmpeg
所有编解码器。</p></li>
<li><p><code>avformat_alloc_context()</code>：初始化输出码流的
AVFormatContext。</p></li>
<li><p><code>avio_open()</code>：打开输出文件。</p></li>
<li><p><code>av_new_stream()</code>：创建输出码流的 AVStream。</p></li>
<li><p><code>avcodec_find_encoder()</code>：查找编码器。</p></li>
<li><p><code>avcodec_open2()</code>：打开编码器。</p></li>
<li><p><code>avformat_write_header()</code>：写文件头（对于某些没有文件头的封装格式，不需要此函数，比如
MPEG2TS）。</p></li>
<li><p><code>avcodec_send_frame()</code>：编码核心接口新接口，发送一帧视频给编码器。即是
AVFrame（存储YUV像素数据）。</p></li>
<li><p><code>avcodec_receive_packet()</code>：编码核心接口新接口，接收编码器编码后的一帧视频，AVPacket（存储
H.264 等格式的码流数据）。</p></li>
<li><p><code>av_write_frame()</code>：将编码后的视频码流写入文件。</p></li>
<li><p><code>flush_encoder()</code>：输入的像素数据读取完成后调用此函数。用于输出编码器中剩余的
AVPacket。</p></li>
<li><p><code>av_write_trailer()</code>：写文件尾（对于某些没有文件头的封装格式，不需要此函数，比如
MPEG2TS）。</p></li>
</ul>
<h3
id="ios-音频帧-cmsamplebufferref-中的-kcmformatdescriptionextension_verbatimisosampleentry-保存哪些信息是否可以去掉">iOS
音频帧 CMSampleBufferRef 中的
kCMFormatDescriptionExtension_VerbatimISOSampleEntry
保存哪些信息，是否可以去掉？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/lYKGrt4rOISncyFwYRM2cQ</li>
</ul>
<h2 id="媒体封装">媒体封装</h2>
<h3
id="什么是-mp4-的-moov-box我们在封装-mp4-时通常怎么处理它为什么">什么是
MP4 的 moov Box？我们在封装 MP4 时通常怎么处理它？为什么？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>moov Box 即 Movie Box，MP4 中存储所有媒体数据的索引信息的
Box。moov Box 可以说是 MP4 文件中最重要的
Box，一般播放器的实现都需要读取到 moov 的数据才能开始播放流程。
对于通过网络播放 MP4 视频的场景，都建议将视频处理为 moov 前置。因为 moov
前置后，从网络读取和播放 MP4 文件时，就可以较快获取到 moov
的数据并开始播放。</p></li>
</ul>
<h3 id="aac-封装到-mp4-中是否需要为每个-aac-packet-添加-adts">AAC 封装到
MP4 中，是否需要为每个 AAC packet 添加 ADTS？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ">https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ</a></p></li>
<li><p>不需要，原因如下：</p></li>
<li><p>1）我们所说的 AAC 文件实际是 AAC 封装格式，其实在 AAC
编码格式的基础上添加了 ADTS 头等信息，组装成 AAC 封装格式的；</p></li>
<li><p>2）将 AAC 编码后的数据存放到 MP4 中，就需要按照 MP4
的封装格式来进行存储；</p></li>
<li><p>3）MP4 中实际将类似 ADTS 这些信息存放到了 moov 中的音频通道对应的
box 中了。</p></li>
</ul>
<h3 id="ios-如何支持封装-fmp4-格式">iOS 如何支持封装 FMP4 格式？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A">https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A</a></p></li>
<li><p><code>AVAssetWriter</code>
设置以下参数即可，系统会按照设置的切片时长回调
<code>didOutputSegmentData</code> 返回数据，仅 iOS 14
系统以上才可以。</p></li>
</ul>
<h3 id="ffmpeg-如何支持封装-fmp4-格式">FFmpeg 如何支持封装 FMP4
格式？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A">https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A</a></p></li>
<li><p><code>FMP4</code> 数据格式参考第 2 题，<code>FFmpeg</code> 实现
<code>FMP4</code> 需要通过 <code>Muxer</code> 配置参数，设置
<code>avio_alloc_context</code> 回调数据，具体分片通过控制
<code>av_write_frame(formatContext, NULL)</code>
调用时机执行相关策略。</p></li>
</ul>
<h2 id="媒体传输">媒体传输</h2>
<h3 id="rtmp-消息分优先级的设计有什么好处">RTMP
消息分优先级的设计有什么好处？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg">https://mp.weixin.qq.com/s/y6M7DptDUhTpTBwwIqTgJg</a></p></li>
<li><p>RTMP 的消息优先级是：控制消息 &gt; 音频消息 &gt;
视频消息。当网络传输能力受限时，优先传输高优先级消息的数据。
要使优先级能够有效执行，分块也很关键：将大消息切割成小块，可以避免大的低优先级的消息（如视频消息）堵塞了发送缓冲从而阻塞了小的高优先级的消息（如音频消息或控制消息）。</p></li>
</ul>
<h3 id="cdn-在直播中有哪些运用">CDN 在直播中有哪些运用？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q">https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q</a></p></li>
<li><p>CDN 的全称为 Content Delivery
Network，即内容分发网络，是一个策略性部署的整体系统，主要用来解决由于网络带宽小、用户访问量大、网点分布不均匀等导致用户访问网站速度慢的问题。这中间就有了很多的
CDN 节点。
具体实现是通过在现有的网络中，增加一层新的网络架构，将网站的内容发布到离用户最近的网络节点上，这样用户可以就近获取所需的内容，解决之前网络拥塞、访问延迟高的问题，提高用户体验。
CDN 直播中常用的流媒体协议包括 RTMP、HLS、HTTP FLV 等。RTMP（Real Time
Messaging Protocol）是基于 TCP 的，由 Adobe 公司为 Flash
播放器和服务器之间音频、视频传输开发的开放协议。HLS（HTTP Live
Streaming）是基于 HTTP 的，是 Apple 公司开放的音视频传输协议。HTTP FLV
则是将 RTMP 封装在 HTTP 协议之上的，可以更好的穿透防火墙等。 CDN
架构设计比较复杂，不同的 CDN
厂商，也在对其架构进行不断的优化，所以架构不能统一而论。这里只是对一些基本的架构进行简单的剖析。CDN
主要包含：源站、缓存服务器、智能
DNS、客户端等几个主要组成部分。</p></li>
</ul>
<p>-源站：是指发布内容的原始站点。添加、删除和更改网站的文件，都是在源站上进行的；另外缓存服务器所抓取的对象也全部来自于源站。对于直播来说，源站为主播客户端。</p>
<p>-缓存服务器：是直接提供给用户访问的站点资源，由一台或数台服务器组成；当用户发起访问时，他的访问请求被智能
DNS
定位到离他较近的缓存服务器。如果用户所请求的内容刚好在缓存里面，则直接把内容返还给用户；如果访问所需的内容没有被缓存，则缓存服务器向邻近的缓存服务器或直接向源站抓取内容，然后再返还给用户。</p>
<p>-智能 DNS：是整个 CDN
技术的核心，它主要根据用户的来源，以及当前缓存服务器的负载情况等，将其访问请求指向离用户比较近且负载较小的缓存服务器。通过智能
DNS
解析，让用户访问同服务商下、负载较小的服务器，可以消除网络访问慢的问题，达到加速作用。</p>
<p>-客户端：即发起访问的普通用户。对于直播来说，就是观众客户端，例如手机客户端，PC
客户端。</p>
<h3
id="为什么视频会议用-udp如果用-tcp-实现音视频需要建立几次连接用-udp-实现音视频有什么方法可以保证通话质量">为什么视频会议用
UDP？如果用 TCP 实现音视频，需要建立几次连接？用 UDP
实现音视频，有什么方法可以保证通话质量？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q">https://mp.weixin.qq.com/s/ZdnIxpQkloRH8tvQ0z5Q5Q</a></p></li>
<li><p>1）为什么视频会议用 UDP？
视频会议场景最重要的体验指标一般是『通话延时』和『语音音质』两方面。
在传输层使用 UDP 的主要考虑是为了降低通话延时。因为 UDP 的不需要 TCP
那样的面向连接、可靠传输、拥塞控制等机制，这些机制（比如三次握手建连、丢包重传等）通常都会带来相对
UDP 更高的延时。
当然，另外一方面原因是人们对视频会议中图像信息的损失容忍度是比较高的，这样即使
UDP 无法保证可靠性，有时候还是可以接受的。 2）如果用 TCP
实现音视频，需要建立几次连接？ 可以做到只建连一次，多路复用。
也可以音频和视频各使用一路连接。 3）用 UDP
实现音视频，有什么方法可以保证通话质量？ 使用 UDP
享受了低延时，牺牲了可靠性。但可靠性牺牲太多导致不可用也是不可接受的，所以还需要做一些机制来保证一定的可靠性，比如我们可以参考
WebRTC 的机制： -NACK：通过丢包重传解决丢包问题，会增加延时。
-FEC：通过冗余数据解决丢包问题，会增加带宽占用。
-JitterBuffer：通过队列对接收到的数据进行缓冲，出队时将数据包均匀平滑的取出，解决视频的乱序与抖动。
-NetEQ：类似 JitterBuffer，解决音频的乱序与抖动。</p></li>
</ul>
<h3
id="rtmp-和-rtsp-有什么区别使用-rtsp-是基于-udp-传输的话我们怎样进行乱序重排">RTMP
和 RTSP 有什么区别？使用 RTSP 是基于 UDP
传输的话，我们怎样进行乱序重排？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>RTMP 和 RTSP 的区别:</p></li>
<li><p>RTMP 使用 TCP
作为传输层协议，能保证不丢包和接收顺序，传输质量高。</p></li>
<li><p>RTSP 使用 RTP 格式协议和 RTCP
控制协议，命令与数据分离。传输层协议一般会选择
UDP，延迟比较低，传输效率高。</p></li>
<li><p>RTSP 中的 RTP 格式头中有 SequenceNumber
字段，可以通过这个序号实现排序。</p></li>
</ul>
<h3
id="假如给你一堆乱序的-rtp-包应该怎样实现乱序重排">假如给你一堆乱序的
RTP 包，应该怎样实现乱序重排？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>可以利用接收 RTP 包缓冲队列使用包的序号进行排序。</p></li>
<li><p>在丢包情况下为保证传输质量会引入 NACK 和 FEC 机制。</p></li>
<li><p>NACK 表示接收端通知发送端一些包丢失，发送 NACK 包请求重传；FEC
前向纠错值的是每个包携带一些冗余信息可以在部分包丢失的时候利用其他包进行重建。</p></li>
<li><p>如果重传次数过多，包无法重建，或者丢的包过多，此时可以丢帧直接跳过丢失的部分。</p></li>
</ul>
<h3
id="你在项目中是怎么降低端到端的延时的">你在项目中是怎么降低端到端的延时的？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>下面是直播走 RTMP 推流、HTTP-FLV
播放方案降低端到端延迟的思路：</p></li>
<li><p>推流端的延迟包含编码延迟和发送缓存队列引入的延迟。可以通过调节编码参数（B
帧、码率、帧率）减小编码延迟但会影响画质。另外可以提高上传的传输性能来减小传输时长。</p></li>
<li><p>CDN
链路上的传输延迟。包括推流的链路和播放回源的链路，这部分延迟不是太大，但依旧会引入几百
ms 的延迟。</p></li>
<li><p>CDN 拉流边缘节点的吐流策略会直接影响延迟的大小。直播流编码的 GOP
的长度，CDN 在客户端拉流时吐几秒的数据、按照 GOP
分隔如何丢数据，这些策略都会影响延时。</p></li>
<li><p>播放端可以通过对当前已下载的 buffer
进行倍速播放和跳帧来降低缓存从而达到降低延迟。注意如果倍速过大，声音是会明显变调的，需要通过算法来调整。跳帧一定要注意视频跳到
I 帧，音频对齐视频进行丢弃。</p></li>
</ul>
<h2 id="渲染">渲染</h2>
<h3 id="opengl-是按照什么架构设计的">OpenGL 是按照什么架构设计的？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>OpenGL 的渲染架构是 Client/Server
模式：Client（客户端）指的是我们在 CPU 上运行的一些代码，比如我们会编写
OC/C++/Java 代码调用 OpenGL 的一些 API；而
Server（服务端）则对应的是图形渲染管线，会调用 GPU
芯片。我们开发的过程就是不断用 Client 通过 OpenGL 提供的通道去向 Server
端传输渲染指令，来间接的操作 GPU 芯片。</p>
<ul>
<li></li>
</ul></li>
</ul>
<h3 id="什么是渲染上下文context">什么是渲染上下文（Context）？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>OpenGL 自身是一个巨大的状态机（State Machine）：一系列的变量描述
OpenGL 此刻应当如何运行。OpenGL 的状态通常被称为 OpenGL
上下文（Context）。我们通过改变上下文中的状态来改变接下来绘画的属性和操作的缓冲对象，然后
OpenGL
利用当前的上下文（Context）的状态去渲染。因此状态的改变要非常小心，因为是状态是全局，会影响接下来的所有渲染操作。</p></li>
</ul>
<h3 id="什么是离屏渲染">什么是离屏渲染？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>GPU 渲染机制：CPU 计算好显示内容提交到 GPU，GPU
渲染完成后将渲染结果放入帧缓冲区，随后屏幕控制器会按照 VSync
信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p></li>
<li><p>当前屏幕渲染，指的是 GPU
的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p></li>
<li><p>离屏渲染，指的是 GPU
在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p></li>
<li><p>特殊的离屏渲染：如果将不在 GPU
的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的离屏渲染方式：CPU
渲染。</p></li>
</ul>
<h3
id="为什么离屏渲染会造成性能损耗">为什么离屏渲染会造成性能损耗？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>当使用离屏渲染的时候会很容易造成性能消耗，因为离屏渲染会单独在内存中创建一个屏幕外缓冲区并进行渲染，而屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的。</p></li>
<li><p>由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU
没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p></li>
</ul>
<h3 id="什么是-opengl-渲染管线pipeline">什么是 OpenGL
渲染管线（Pipeline）？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>OpenGL 渲染管线就是 OpenGL
的工作流程，指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。</p></li>
<li><p>图形渲染管线可以大致被划分为两个主要部分：第一部分把你的 3D
坐标转换为 2D 坐标；第二部分是把 2D
坐标转变为实际的有颜色的像素。</p></li>
</ul>
<h3 id="opengl-渲染管线主要包含哪些部分">OpenGL
渲染管线主要包含哪些部分？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>OpenGL 的渲染管线其实也是类似的一个过程，它的工序包括：顶点着色器
→ 图元装配 → 几何着色器 → 光栅化 → 片段着色器 → 测试与混合。</p>
<ul>
<li></li>
</ul></li>
</ul>
<h3 id="为什么说-opengl-渲染管线中的着色器shader是可编程管线">为什么说
OpenGL 渲染管线中的着色器（Shader）是可编程管线？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>OpenGL 渲染管线中着色器允许开发者自己配置，这样我们就可以使用
GLSL（OpenGL Shading
Language）来编写自己的着色器替换默认的着色器，从而更细致地控制图形渲染管线中的特定部分。</p></li>
</ul>
<h3
id="有哪些着色器可以由程序员进行编程">有哪些着色器可以由程序员进行编程？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>可编程的着色器有：顶点着色器（Vertex
Shader）、几何着色器（Geometry Shader）、片段着色器（Fragment
Shader）。常用的是顶点着色器和片段着色器。</p></li>
</ul>
<h3 id="什么是-vboebo-和-vao">什么是 VBO、EBO 和 VAO？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>可以认为它们是在 OpenGL 中处理数据的三大类缓冲内存对象。</p></li>
<li><p>VBO（Vertex Buffer Objects）顶点缓冲区对象，指的是在 GPU
显存里面存储的顶点数据（位置、颜色）。</p></li>
<li><p>EBO（Element Buffer
Object）图元索引缓冲区对象，指的是为了更高效的利用数据，存储索引来达到减少重复数据的索引数据。</p></li>
<li><p>VAO（Vertex Array Object）顶点数组对象，主要作用是用于管理 VBO 或
EBO，减少 glBindBuffer、glEnableVertexAttribArray、glVertexAttribPointer
这些调用操作，高效地实现在顶点数组配置之间切换。</p></li>
</ul>
<h3 id="vertex-buffer-object-的布局格式是怎样的">Vertex Buffer Object
的布局格式是怎样的？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>如图</p>
<ul>
<li></li>
</ul></li>
</ul>
<h3 id="vertex-array-object-的布局格式是怎样的">Vertex Array Object
的布局格式是怎样的？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw">https://mp.weixin.qq.com/s/65TgwYrDG493omh8aSFcUw</a></p></li>
<li><p>当 VAO 只管理 VBO 时，布局格式如下图所示：</p>
<ul>
<li></li>
</ul></li>
<li><p>当 VAO 管理 VBO 和 EBO 时，布局格式如下图所示：</p>
<ul>
<li></li>
</ul></li>
</ul>
<h3
id="你在项目中使用过-sdl-进行渲染能否讲一下-sdl-渲染">你在项目中使用过
SDL 进行渲染，能否讲一下 SDL 渲染？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA">https://mp.weixin.qq.com/s/aX6M0YAgFJS1kXvZnqjVnA</a></p></li>
<li><p>SDL（Simple DirectMedia
Layer）是一套开放源代码的跨平台多媒体开发库，使用 C
语言写成。其主要用于游戏开发中的多媒体处理，如：视频渲染、音频播放、鼠标键盘控制等操作。它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层
API 库。</p></li>
<li><p>SDL 的基本流程如下：</p>
<ul>
<li><p>1、初始化 SDL</p></li>
<li><p>2、创建窗口</p></li>
<li><p>3、创建渲染器</p></li>
<li><p>4、清空缓冲区</p></li>
<li><p>5、绘制要显示的内容</p></li>
<li><p>6、最终将缓冲区内容渲染到 Window 窗口上</p></li>
<li><p>7、销毁渲染器</p></li>
<li><p>8、销毁窗口</p></li>
<li><p>9、退出 SDL</p></li>
</ul></li>
</ul>
<h3
id="opengl-的双缓冲机制是什么eglcreatewindowsurfaceeglcreatepbufffersurface-和双缓冲机制有什么关联吗">OpenGL
的双缓冲机制是什么？eglCreateWindowSurface、eglCreatePbuffferSurface
和双缓冲机制有什么关联吗？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA">https://mp.weixin.qq.com/s/7Ou0o3Vxige9VzRcR6ZBwA</a></p></li>
<li><p>双缓冲机制主要目的是为了解决计算机图形学中的屏幕闪烁和画面流畅性问题。该机制通过在内存中创建两个缓冲区：一个用于绘制图像的后缓冲区，一个用于显示图像的前缓冲区，来避免因为输入输出速度不匹配造成的界面闪烁、卡顿等现象。这个问题是很老的问题了，目前的系统基本都已经支持双缓冲了。</p></li>
<li><p>双缓冲机制与的 eglCreateWindowSurface、eglCreatePbuffferSurface
这两个方法没有直接的关系。这两个方法是为了实现当前屏幕渲染和离屏渲染的功能，eglCreateWindowSurface
是创建屏幕上的渲染区域来实现屏幕渲染，eglCreatePbuffferSurface
是创建屏幕外的渲染区域来实现离屏渲染。也就是说你创建
eglCreateWindowSurface 就自动支持双缓冲机制了。</p></li>
</ul>
<h3
id="想要把-iosandroid-应用开发中-opengl-es-渲染相关模块下沉到-c-实现双端共用要怎么实现">想要把
iOS、Android 应用开发中 OpenGL ES 渲染相关模块下沉到 C++
实现双端共用要怎么实现？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ">https://mp.weixin.qq.com/s/2BHXcF80ueqUwAicxJ5ZlQ</a></p></li>
<li><ul>
<li>1、创建一个 C++ 的渲染引擎模块。该模块将负责处理 OpenGL ES
的渲染逻辑。您可以使用现有的 C++ 图形库，如 Angle、Diligent Engine
等，或者自己编写一个。</li>
</ul></li>
<li><ul>
<li>2、将渲染逻辑从 iOS 和 Android 应用中移动到 C++
渲染业务模块。包括创建 OpenGL ES
上下文、编译和链接着色器程序、设置渲染状态、绘制图形等。</li>
</ul></li>
<li><ul>
<li>3、封装 C++ 接口层。为了在 iOS 和 Android 应用中使用 C++
渲染模块，您需要封装 C++ 接口层，该接口层需要定义 iOS 和 Android
业务层代码与渲染模块交互的函数和方法。这样，应用程序可以通过调用这些接口来使用
C++ 渲染模块。</li>
</ul></li>
<li><ul>
<li>4、处理平台特定的差异。由于 iOS 和 Android
平台的差异，您可能需要处理一些平台特定的差异，例如，处理不同的输入事件、处理不同的窗口管理等。在
C++ 接口中，可以定义平台特定的函数，然后在 iOS 和 Android
应用中实现这些函数。</li>
</ul></li>
</ul>
<h3 id="使用-opengl-绘制时对于二维坐标需要注意什么">使用 OpenGL
绘制时对于二维坐标需要注意什么？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-cwQbkbHqmMKRPk0YhBG6g</p></li>
<li><p>搞清楚顶点坐标与纹理坐标</p></li>
<li><p>FBO 与 glViewport</p></li>
</ul>
<h3 id="聊聊-opengl-glflush-和-glfinish-区别">聊聊 OpenGL glFlush 和
glFinish 区别？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-oC7782W_Sh0qxTQAZ7Y8g</p></li>
<li><p>一般来说，我们在使用 OpenGL
的时候，指令不是立即执行的。它们首先被送到指令缓冲区，然后才被送到硬件执行。glFinish
和 glFlush 都是强制将命令缓冲区的内容提交给硬件执行。</p></li>
<li><p>一般使用 glFlush 的目的是确保在调用之后，CPU 没有 OpenGL
相关的事情需要做，命令会送到硬件执行。调用 glFinish
的目的是确保当返回之后，没有相关工作留下需要继续做。</p></li>
</ul>
<h3 id="怎么实现-opengl-多线程同步">怎么实现 OpenGL 多线程同步？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-oC7782W_Sh0qxTQAZ7Y8g</p></li>
<li><p>一般情况下我们调用 OpenGL 方法后，并不是马上有效果的，如果在 B
线程使用 A 线程的纹理有概率出现渲染异常，因为 A
纹理还没有渲染完成。</p></li>
<li><p>glFinish 同步方案</p></li>
<li><p>Fence 同步方案</p></li>
</ul>
<h3 id="如何实现-opengl-资源共享">如何实现 OpenGL 资源共享？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-oC7782W_Sh0qxTQAZ7Y8g</p></li>
<li><p>在使用 eglCreateContext 时， 可以传入一个已创建成功的上下文，
这样就可以得到一个共享的上下文 (Shared Context)。</p></li>
<li><p>可以共享的资源：</p>
<ul>
<li><p>纹理；</p></li>
<li><p>shader；</p></li>
<li><p>program 着色器程序；</p></li>
<li><p>buffer 类对象，如 VBO、 EBO、 RBO 等 。</p></li>
</ul></li>
<li><p>不可以共享的资源：</p>
<ul>
<li>FBO 帧缓冲区对象（不属于 buffer 类）； VAO 顶点数组对象（不属于
buffer 类）。 在不可以共享的资源中，FBO 和 VAO 属于资源管理型对象，FBO
负责管理几种缓冲区，本身不占用资源，VAO 负责管理 VBO 或 EBO
，本身也不占用资源。</li>
</ul></li>
</ul>
<h3 id="opengl-纹理缓存要如何设计">OpenGL 纹理缓存要如何设计？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-oC7782W_Sh0qxTQAZ7Y8g</p></li>
<li><p>需要一个可复用的纹理数组，设置一个最大上限。</p></li>
<li><p>每个纹理需要忙碌或空闲的状态，当空闲情况下可以进行复用。</p></li>
<li><p>一个 FBO
频繁更换绑定不同的纹理，将内容数据刷新到指定纹理上。</p></li>
<li><p>外层纹理使用完成后将纹理状态设置为空闲。</p></li>
</ul>
<h3 id="介绍一下-glreadpixels">介绍一下 glReadPixels？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/QyK-l2LX-xbauRop3AJ9xQ</p></li>
<li><p>glReadPixels 是 OpenGL ES 的
API，通常用于从帧缓冲区中读取像素数据，OpenGL ES 2.0 和 3.0
均支持。使用非常方便，但是效率也是最低的。</p></li>
</ul>
<h3 id="介绍一下-imagereader">介绍一下 ImageReader？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/QyK-l2LX-xbauRop3AJ9xQ</p></li>
<li><p>ImageReader 是 Android
中的一个类，用于获取相机设备的图像数据。它可以用于捕获相机拍摄的静态图像或实时预览帧，并提供对图像数据的访问和处理。</p></li>
</ul>
<h3 id="介绍一下-pbopixel-buffer-object">介绍一下 PBO（Pixel Buffer
Object）？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/QyK-l2LX-xbauRop3AJ9xQ</p></li>
<li><p>OpenGL PBO（Pixel Buffer
Object），被称为像素缓冲区对象，主要被用于异步像素传输操作。PBO
仅用于执行像素传输，不连接到纹理，且与 FBO （帧缓冲区对象）无关。OpenGL
PBO（像素缓冲区对象） 类似于 VBO（顶点缓冲区对象），PBO 开辟的也是 GPU
缓存，而存储的是图像数据。PBO 是 OpenGL ES 3.0
开始提供的一种方式，主要应用于从内存快速复制纹理到显存，或从显存复制像素数据到内存。</p></li>
</ul>
<h3 id="介绍一下-hardwarebuffer">介绍一下 HardwareBuffer？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/QyK-l2LX-xbauRop3AJ9xQ</p></li>
<li><p>HardwareBuffer 官方介绍为一种底层的内存 buffer
对象，可在不同进程间共享，可映射到不同硬件系统，如
GPU、传感器等，从构造函数可以看出，其可以指定 format 和
usage，用来让底层选择最合适的实现，目前 format
主要是渲染相关的纹理格式，Android 11 之后支持了 BLOB 格式，可用来做 NN
相关的数据共享。</p></li>
</ul>
<h3 id="使用-opengl-pbo-为什么能提高效率">使用 OpenGL PBO
为什么能提高效率？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/N-PzPA4rSHGtE6KIjnEX4Q</p></li>
<li><p>减少 CPU 等待：PBO 支持异步传输，这意味着 CPU
在发起传输请求后不必等待 GPU 完成传输，可以继续执行其他任务。</p></li>
<li><p>减少数据拷贝：使用 PBO 可以减少从 CPU 内存到 GPU
内存的数据拷贝次数。例如，当更新纹理时，可以先将数据复制到 PBO，然后由
GPU 直接从 PBO 读取，而不是每次都从 CPU 内存中复制。</p></li>
<li><p>提高带宽利用：PBO 允许更有效地利用内存带宽，因为它减少了 CPU 和
GPU 之间的数据传输量。</p></li>
<li><p>优化显存利用：使用 PBO
可以避免在每次更新纹理时销毁和重新创建纹理内存，从而优化显存的利用率。</p></li>
<li><p>双缓冲或多缓冲技术：通过使用两个或多个 PBO，可以在一个 PBO 进行
GPU 操作的同时，使用 CPU 填充另一个
PBO，从而实现更高效的流水线操作。</p></li>
</ul>
<h3 id="什么是-vao什么是-vbo它们的作用是什么">什么是 VAO，什么是
VBO，它们的作用是什么？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/sKvPn2pLRYdJzx6RepKp1Q</p></li>
<li><p>VBO</p>
<ul>
<li><p>VBO 主要用于存储顶点数据，如顶点坐标、法线、颜色等。</p></li>
<li><p>通过将顶点数据存储在 GPU 的显存中，可以提高渲染效率，因为 GPU
能够更快地访问这些数据，而无需反复从 CPU 内存中读取。</p></li>
</ul></li>
<li><p>VAO</p>
<ul>
<li><p>VAO（Vertex Array Object）顶点数组对象，主要作用是用于管理 VBO 或
EBO。</p></li>
<li><p>VBO
保存了一个模型的顶点属性信息，每次绘制模型之前需要绑定顶点的所有信息，当数据量很大时，重复这样的动作变得非常麻烦。VAO
可以把这些所有的配置都存储在一个对象中，每次绘制模型时，只需要绑定这个
VAO 对象就可以了，可以减少 glBindBuffer 、glEnableVertexAttribArray、
glVertexAttribPointer
这些调用操作，高效地实现在顶点数组配置之间切换。</p></li>
</ul></li>
</ul>
<h3
id="纹理有哪些环绕方式wrapping">纹理有哪些环绕方式（wrapping）？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/JbEGcM95fL3i7g30dTDtOw</p></li>
<li><p>重复（GL_Repeat）</p></li>
<li><p>镜像重复（GL_MIRRORED_REPEAT）</p></li>
<li><p>夹取到边缘（GL_CLAMP_TO_EDGE）</p></li>
<li><p>夹取到边框（GL_CLAMP_TO_BORDER）</p></li>
</ul>
<h3 id="调试-opengl-特效的时候图像不对有什么调试技巧能快速排查原因">调试
OpenGL 特效的时候图像不对，有什么调试技巧能快速排查原因？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/ktWZ0kTtVO8iqhTIYqTJ3w</li>
</ul>
<h3
id="自己实现播放器时利用-ffmpeg-拿到解码后数据封装成-cvpixelbuffer-缓存用于渲染但是缓存后数据只有几帧但为什么内存占用有时候会有几百兆">自己实现播放器时利用
FFmpeg 拿到解码后数据封装成 CVPixelbuffer
缓存用于渲染，但是缓存后数据只有几帧，但为什么内存占用有时候会有几百兆？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/ktWZ0kTtVO8iqhTIYqTJ3w</p></li>
<li><p>自己创建 <code>CVPixelBuffer</code>
缓存即使你在程序中及时释放但是系统真正释放的时机可能会延迟，导致占用内存过高。</p></li>
</ul>
<h2 id="直播推流">直播推流</h2>
<h3 id="直播打开成功率如何优化">直播打开成功率如何优化？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/xjChNR6Y0zgJzmyS-2n8gQ</li>
</ul>
<h3 id="直播播放秒开如何优化">直播播放秒开如何优化？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/xjChNR6Y0zgJzmyS-2n8gQ</li>
</ul>
<h3 id="直播播放卡顿如何优化">直播播放卡顿如何优化？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/xjChNR6Y0zgJzmyS-2n8gQ</li>
</ul>
<h3 id="直播延时如何优化">直播延时如何优化？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/xjChNR6Y0zgJzmyS-2n8gQ</li>
</ul>
<h3 id="直播美颜如何实现">直播美颜如何实现？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/IKDY_slQg_J_01xyE_wENA</li>
</ul>
<h3 id="直播间礼物特效的如何实现">直播间礼物特效的如何实现？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/IKDY_slQg_J_01xyE_wENA</li>
</ul>
<h3 id="直播连麦的如何实现">直播连麦的如何实现？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/IKDY_slQg_J_01xyE_wENA</li>
</ul>
<h3 id="直播间的回声消除如何实现">直播间的回声消除如何实现？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/IKDY_slQg_J_01xyE_wENA</li>
</ul>
<h3
id="在实现类似-obs-的实时的图片gif-贴片叠加和替换效果时遇到了性能瓶颈请问如何实现快速的-gif-贴片叠加和替换">在实现类似
OBS 的实时的图片、GIF
贴片叠加和替换效果时遇到了性能瓶颈，请问如何实现快速的 GIF
贴片叠加和替换？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/ktWZ0kTtVO8iqhTIYqTJ3w</li>
</ul>
<h2 id="视频生产及编辑">视频生产及编辑</h2>
<h3 id="视频编辑中如何实现视频倒放">视频编辑中如何实现视频倒放？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw">https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw</a></p></li>
<li><p>如果用最直接的思路去实现视频倒放，那就是把视频中的每一帧图像都解码出来逆排序一下，然后将原视频的
pts
时间戳一一对应的关联上逆排序后的每一帧，再重新编码就可以了。</p></li>
<li><p>这个思路在实际实现时会有几个问题：解码后的视频帧放在内存或磁盘可能都还挺大的；完整的解码、逆排序、编码一整个视频可能耗时较长。</p></li>
<li><p>对于这些问题我们可以采取分而治之、并行提效的思路。因为视频本身可以按照
GOP 单元独立编解码，所以我们可以把视频的每一个 GOP
单元取出来分别做解码、逆排序、编码，最后再把处理后的所有 GOP 重新 remux
封装起来即可。</p></li>
<li><p>其中逆排序过程中，对于一个 GOP
的各帧处理流程大致是这样的：比如一个 GOP 的各视频帧及对应的 pts 分别是
<code>1(0), 2(30), 3(60), 4(90)</code>，那逆排序后就是
<code>4(0), 3(30), 2(60), 1(90)</code>。</p></li>
</ul>
<h3
id="拍短视频想把同时播放的音乐录制下来一般要经过怎样的处理流程">拍短视频想把同时播放的音乐录制下来一般要经过怎样的处理流程？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ">https://mp.weixin.qq.com/s/JImt0IDqhzQcGs7YXUJmXQ</a></p></li>
<li><p>有一种方案是把麦克风采集声音中的外放音乐声进行回声消除，然后再添加上音乐的原始音轨。一般在
iOS 设备上可以考虑这种方案。但是在 Android
设备上我们通常不这样做，原因有下面几点：</p></li>
<li><p>对音乐进行回声消除的同时也会对麦克风采集到的其他声音有抑制效果，导致最后整体的声音效果不好；</p></li>
<li><p>手机播放音乐到麦克风采集到声音之间有一定的延时，不同的 Android
设备的延时差异较大，这个延时估算不准确会影响回声消除的效果。</p></li>
<li><p>一般情况我们可以按照下面的流程来处理：</p></li>
<li><p>1）音乐外放的情况，直接通过外放播放音乐，声音通过麦克风录制下来；</p></li>
<li><p>2）戴耳机或手机静音的情况，音乐不会被麦克风录制下来；</p></li>
<li><p>3）录制完成时，将录制得到的视频中的音轨（这里面可能包含已经和其他外音被采集下来的音乐）和音乐原始的音轨进行叠加增强。</p></li>
</ul>
<h3 id="android-camera-如何优化视频录制的卡顿">Android Camera
如何优化视频录制的卡顿？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA">https://mp.weixin.qq.com/s/0TXTPyAh6f7sKBxJzOJmHA</a></p></li>
<li><p><strong>1）视频录制流程</strong></p>
<ul>
<li><ul>
<li>打开 <code>Camera</code>。</li>
</ul></li>
<li><ul>
<li>创建 <code>SurfaceTextue</code> ，将 <code>Camera</code>
输出的数据渲染到 <code>SurfaceTextue</code>。</li>
</ul></li>
<li><ul>
<li><code>SurfaceTexture</code> 拿到的结果进行特效处理。</li>
</ul></li>
<li><ul>
<li>特效处理的结果异步分发给 <code>RenderView</code> 预览与
<code>MediaCodec</code> 编码。</li>
</ul></li>
<li><ul>
<li>编码后的结果进行 <code>Muxer</code> 合成 <code>MP4</code>
视频。</li>
</ul></li>
</ul></li>
<li><p><strong>2）视频录制流程优化</strong></p>
<ul>
<li><ul>
<li>相机、编码根据不同机型控制不同帧率、分辨率。</li>
</ul></li>
<li><ul>
<li>实现丢帧模块，将采集后的帧进入丢帧模块进行控制帧率，降低渲染以及编码性能。</li>
</ul></li>
<li><ul>
<li>采集、渲染、编码按照多个线程处理，每个模块发挥最优性能。</li>
</ul></li>
<li><ul>
<li>预览视图优先采用 <code>SurfaceView</code>，少量使用
<code>TextureView</code>，因为 <code>TextureView</code>
占用主线程渲染。</li>
</ul></li>
<li><ul>
<li>编码优先使用 <code>Surface</code> 异步编码。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="转码速度优化的几点建议">转码速度优化的几点建议？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A">https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A</a></p></li>
<li><p><strong>1）解码</strong></p>
<ul>
<li><ul>
<li>优先使用系统硬件解码，软件解码仅兜底使用。</li>
</ul></li>
<li><ul>
<li>解码方式优先使用异步。</li>
</ul></li>
<li><ul>
<li>解码器可以创建复用池。</li>
</ul></li>
<li><ul>
<li>Android 解码优先考虑 <code>Surface</code> 解码方式。</li>
</ul></li>
</ul></li>
<li><p><strong>2）多线程并发</strong></p>
<ul>
<li><ul>
<li>转码分为解码与编码，通常编码更加耗时，这样解码线程可保持几帧
<code>Cache</code> 数据供编码获取。</li>
</ul></li>
<li><ul>
<li>同一个视频可以分片转码为 <code>FMP4</code> ，最终拼接为一个
<code>FMP4</code>，并发数目设置参考 2-5。</li>
</ul></li>
</ul></li>
<li><p><strong>3）其它</strong></p>
<ul>
<li><ul>
<li>码率不高的视频无需转码。</li>
</ul></li>
<li><ul>
<li>对于帧率过高、码率过高视频可降低相关参数，提高转码速度。</li>
</ul></li>
<li><ul>
<li>视频转码与发布可结合优化策略，例如一边分片转码一边上传。</li>
</ul></li>
<li><ul>
<li>针对不同场景进行指定策略处理，例如添加了音乐仅转码音频，仅转换封装格式使用
<code>Remuxer</code>。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="seek-优化的几点建议">Seek 优化的几点建议？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A">https://mp.weixin.qq.com/s/dNvvoaEsnAEY-fd2xydQ0A</a></p></li>
<li><p><strong>1）解码</strong></p>
<ul>
<li><ul>
<li>优先使用系统硬件解码，软件解码仅兜底使用。</li>
</ul></li>
<li><ul>
<li>解码方式优先使用异步。</li>
</ul></li>
<li><ul>
<li>解码器可以创建复用池。</li>
</ul></li>
<li><ul>
<li>Android 解码优先考虑 <code>Surface</code> 。</li>
</ul></li>
<li><ul>
<li>对于 Seek 过程中的帧可以不输出数据，例如 iOS
<code>kVTDecodeFrame_DoNotOutputFrame</code>。</li>
</ul></li>
</ul></li>
<li><p><strong>2）其它</strong></p>
<ul>
<li><ul>
<li>对于 Seek 过程中的帧可以丢弃非参考帧。</li>
</ul></li>
<li><ul>
<li>优先判断 Seek 帧是否命中缓存。</li>
</ul></li>
<li><ul>
<li>优先找到 Seek 帧最近的关键帧。</li>
</ul></li>
<li><ul>
<li>对于向右侧 Seek 优先判断是否与当前解码帧同一个
<code>GOP</code>，同一个 <code>GOP</code> 无需
<code>Flush</code>，继续解码即可。</li>
</ul></li>
<li><ul>
<li>对于 Seek 位置精准度可以给一点空隙，例如 100ms
内偏差用户无感，这样可以利用缓存优势以及最近关键帧。</li>
</ul></li>
<li><ul>
<li>对于 Seek 超级频繁可以选择丢弃某些帧。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="音视频编辑-sdk-一般包含哪些模块各模块是什么职责">音视频编辑 SDK
一般包含哪些模块？各模块是什么职责？</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA">https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA</a></li>
</ul>
<h3
id="音视频编辑中转码流程-pipeline-的线程模型和缓冲区要怎么设计">音视频编辑中转码流程
pipeline 的线程模型和缓冲区要怎么设计？</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA">https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA</a></li>
</ul>
<h3
id="如何降低处理音视频链路中的内存峰值">如何降低处理音视频链路中的内存峰值？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-cwQbkbHqmMKRPk0YhBG6g</p></li>
<li><p>降低采集参数：</p>
<ul>
<li><p>降低采集视频分辨率</p></li>
<li><p>降低采集视频帧率</p></li>
</ul></li>
<li><p>降低并发任务数量：</p>
<ul>
<li>将任务分优先级，按照优先级串行执行，这样既能降低内存峰值，也会降低
CPU 峰值</li>
</ul></li>
</ul>
<h3
id="在编辑-sdk-中的播放器和播放-sdk-中的视频播放存在哪些区别呢编辑场景的播放器对-opengl-的使用有哪些进阶的用法">在编辑
SDK 中的播放器和播放 SDK 中的视频播放存在哪些区别呢？编辑场景的播放器对
OpenGL 的使用有哪些进阶的用法？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/HlLwri7rFNSs9C6rxZ90gw</p></li>
<li><p>剪辑方向的视频播放与播放器的视频播放相比最大的区别就是：需要处理更复杂渲染场景。</p></li>
<li><p>处理复杂的输入和渲染。</p></li>
<li><p>处理多线程渲染。</p></li>
<li><p>渲染流程结构可以做优化设计。</p></li>
<li><p>调试和报错。</p></li>
</ul>
<h3 id="ios-动态图片如何获取原始视频">iOS
动态图片如何获取原始视频？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/ktWZ0kTtVO8iqhTIYqTJ3w</li>
</ul>
<h3
id="为什么自制的动态图片导出到相册无法识别成动态图片">为什么自制的动态图片导出到相册无法识别成动态图片？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/-MeeGfwy3MDiZsuxL-VKHw</li>
</ul>
<h3 id="ios-如何实现音频内录录制当前所有手机的声音集合">iOS
如何实现音频内录，录制当前所有手机的声音集合？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/-MeeGfwy3MDiZsuxL-VKHw</p></li>
<li><p>使用 ReplayKit。</p></li>
</ul>
<h3
id="应该选择哪种复杂字体渲染的方案-非-uiview-的能力">应该选择哪种复杂字体渲染的方案
(非 UIView 的能力)？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/-MeeGfwy3MDiZsuxL-VKHw</li>
</ul>
<h3 id="ios-如何在不解码的情况下给视频添加-metadata">iOS
如何在不解码的情况下给视频添加 Metadata？</h3>
<ul>
<li>https://mp.weixin.qq.com/s/-MeeGfwy3MDiZsuxL-VKHw</li>
</ul>
<h2 id="播放器">播放器</h2>
<h3 id="点播的倍速播放要如何实现">点播的倍速播放要如何实现？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw">https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw</a></p></li>
<li><p>点播的倍速播放分为视频处理和音频处理部分。</p></li>
<li><p>1）视频处理</p>
<ul>
<li><p>对应视频数据的处理，核心逻辑就是按照倍速重新计算各视频帧的 pts
时间戳。</p></li>
<li><p>比如，对一个视频做 2 倍速播放，假设原来各视频帧的 pts 依次是
<code>0, 30, 60, 90 ...</code>，倍速处理及将它们除以 2 变成
<code>0, 15, 30, 45 ...</code>。这样处理后，视频的帧率和总时长相应的也发生了变化，帧率变为原来的
2 倍，总时长变为原来的 1/2。</p></li>
<li><p>但是，如果对视频进行高倍速播放，比如 10 倍速，这时候如果只处理
pts，原视频的时间戳除以 10 变成 <code>0, 3, 6, 9 ...</code>，这时候 3ms
一帧，帧率达到了
333fps，已经超过了屏幕硬件的刷新率，根本渲染不过来。所以对于高倍速播放：第一步，我们像上面一样在处理完
pts；第二步，我们还需要设定最大帧率的限制，并按照这个最大帧率来进行丢帧。</p></li>
<li><p>假如我们设定最大帧率是 60fps，这时候我们每 17ms
只需要一帧，上面的 <code>0, 3, 6, 9, 12, 15, 18 ...</code>
经过丢帧和帧率处理可能就变成了
<code>0, 17(18→17), 34(33→34) ...</code>。</p></li>
<li><p>高倍速播放还有另外的问题：解码性能是否跟得上、网络视频的下载速度是否跟得上等等。对于这些问题，我们可能还需要其他方案来解决，比如：在客户端在解码前就要丢弃非参考帧，对不需要解码的帧直接丢弃等等；在服务端对高倍速视频进行预处理，提前做好时间戳和丢帧处理，当用户切换高倍速时，帮用户切换资源即可。</p></li>
</ul></li>
<li><p>2）音频处理</p>
<ul>
<li>音频是每秒几 K 到几十 K
的采样点，对于音频数据的处理，如果只是跟视频一样，简单的处理 pts
时间戳会出现噪音、杂音，体验很差。音频一般需要进行重采样处理。比如，原来的音频是
48K 的采样率，播放设置了使用 48K 的采样率进行音频渲染，这时候要对音频做
2 倍速播放，可以将音频数据每秒 48K 个采样点重采样降低到 24K
个（把音频数据的采样率处理为 24K），当播放还是使用 48K
的采样率来播放时，每秒需要 48K 个采样点，这时候就需要 2s
的数据，这时候音频的播放速度就变成了原来的 2
倍。使用这样的方式来实现音频倍速，可以解决只简单处理 pts
带来的噪音、杂音问题，但是音频的播放会变调：快播时，声调会变高，听起来尖细；慢播时，声调会变低，听起来低沉。</li>
</ul></li>
</ul>
<h3
id="播放器解码后的帧缓冲区一般设置多大合适">播放器解码后的帧缓冲区一般设置多大合适？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw">https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw</a></p></li>
<li><p>对于播放器来说，在渲染之前一般会有一个解码后的帧缓冲区用于后续渲染。</p></li>
<li><p>使用 FFmpeg 软解码、Android MediaCodec
硬解码时，给编码器的数据是按照 dts 顺序输入的，解码器输出数据是按照 pts
输出的。但是使用 iOS VideoToolbox 硬解码时，解码器输出数据并没有按照 pts
顺序，而是解一帧出一帧，需要我们自己排序。</p></li>
<li><p>这样在使用 iOS VideoToolbox
硬解码时，还可以在这个缓冲区还可以用来对解码后的帧按 pts
做重排来保证正确的渲染顺序。</p></li>
<li><p>这个重排主要是针对 B 帧，因为 B
帧可能会依赖后面的帧才能完成解码，如果解码后的帧缓冲区太小，可能导致按照渲染顺序本该渲染的
B
帧由于依赖帧还未解码而出现播放卡顿。但是解码后的帧缓冲区也不是越大越好，因为解码后的视频帧数据是比较大的，会占用不少内存，缓冲区过大会造成播放器的内存占用过大。</p></li>
<li><p>那么这个缓冲区应该设置多大比较合适呢？这个其实取决于解码器需要的重排窗口大小，解码后的帧缓冲区大小只要不超过这个重排窗口尺寸即可。要计算重排窗口的大小通常可能会用到下面这几个参数：</p></li>
<li><p><code>max_ref_frames</code></p></li>
<li><p><code>max_num_reorder_frames</code></p></li>
</ul>
<h3
id="如何监控视频播放黑屏花屏绿屏等异常">如何监控视频播放黑屏、花屏、绿屏等异常？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw">https://mp.weixin.qq.com/s/ULj7zyfBHgMxvyxytoVjqw</a></p></li>
<li><p>视频播放时如果遇到黑屏、花屏、绿屏通常会伴有解码器的报错或异常信息，我们可以上报这些异常信息来实现对这些情况的监控。</p></li>
<li><p>但是也有一些情况，即使出现黑屏、花屏、绿屏的情况了，解码器也没有报错或异常，这时候就需要我们对解码后的画面进行检测来识别这些问题。一般可以这样：</p></li>
<li><ul>
<li>用传统的图像处理算法来识别。对于黑屏、绿屏可以用传统图像处理算法来进行识别，但这里也会有一些误识别的问题，比如视频本身就有些亮度较低、正常全黑帧、正常全绿帧的情况，可能也会被识别为异常。</li>
</ul></li>
<li><ul>
<li>训练 AI 模型类识别。对于花屏，可以训练 AI
模型来进行识别。训练过程可以通过人工构造丢帧视频的方法来生成花屏样本，同时筛选出无花屏问题的正常样本，基于这两类样本来做二分类模型的训练。</li>
</ul></li>
</ul>
<h3
id="如何通过优化播放器来优化音乐播放体验比如提升音质或音效">如何通过优化播放器来优化音乐播放体验，比如提升音质或音效？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg">https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg</a></p></li>
<li><p>在播放侧可以使用自动增益控制算法（AGC）来提升音效。AGC
算法通过自动调整音频信号的增益，使其保持在一定的范围内，这种算法可以避免因音频信号的幅度变化而引起的声音过大或过小的问题，保证了音频信号的稳定性和可听性，目前有开源的实现例如
webrtcagc，可以把算法移植到自己的项目中。</p></li>
</ul>
<h3
id="如果让你设计一个播放器的架构你会分哪几层">如果让你设计一个播放器的架构，你会分哪几层？</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA">https://mp.weixin.qq.com/s/h1FnjZlg3fb2Iw61ilNCXA</a></li>
</ul>
<h3 id="ffmpeg-中-avformat_open_input-经历了什么步骤">FFmpeg 中
avformat_open_input() 经历了什么步骤？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/lYKGrt4rOISncyFwYRM2cQ</p></li>
<li><p>打开输入媒体流</p></li>
<li><p>初始化输入媒体流</p></li>
<li><p>探测输入格式，根据当前参数进行打分，最终根据分数最高的那个配置作为最终格式</p></li>
<li><p>打开 avio</p></li>
</ul>
<h2 id="综合多媒体框架及服务">综合多媒体框架及服务</h2>
<h3 id="webrtc-中的-ice-作用">WebRTC 中的 ICE 作用？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/zujLvqBgOadxcZuer7uXJA</p></li>
<li><p>主要负责帮助位于不同网络环境（尤其是 NAT
之后）的两个端点建立直接的连接。</p></li>
</ul>
<h3 id="webrtc-中媒体协商过程">WebRTC 中媒体协商过程？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/zujLvqBgOadxcZuer7uXJA</p></li>
<li><p>创建 Offer</p></li>
<li><p>设置 Local Description</p></li>
<li><p>发送 Offer</p></li>
<li><p>接收 Offer 和创建 Answer</p></li>
<li><p>设置 Remote Description</p></li>
<li><p>设置 Answer 的 Local Description</p></li>
<li><p>发送 Answer</p></li>
<li><p>接收 Answer 和设置 Remote Description</p></li>
<li><p>ICE Candidate 交换</p></li>
<li><p>连接建立和媒体流传输</p></li>
</ul>
<h3 id="webrtc-nat-有几种类型">WebRTC NAT 有几种类型？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/zujLvqBgOadxcZuer7uXJA</p></li>
<li><p>完全锥型（Full Cone NAT）</p></li>
<li><p>地址限制锥型（Address-Restricted Cone NAT）</p></li>
<li><p>端口限制锥型（Port-Restricted Cone NAT）</p></li>
<li><p>对称型 NAT（Symmetric NAT）</p></li>
</ul>
<h3 id="webrtc-中的-gcc-机制">WebRTC 中的 GCC 机制？</h3>
<ul>
<li><p>https://mp.weixin.qq.com/s/zujLvqBgOadxcZuer7uXJA</p></li>
<li><p>一种重要的拥塞控制机制，用于自适应地调整视频流的码率，以适应网络条件的变化，确保音视频通信的流畅性和清晰度。</p></li>
<li><p>基于RTCP反馈的码率控制</p></li>
<li><p>REMB（Receiver Estimated Maximum Bitrate）</p></li>
<li><p>发送端的码率控制</p></li>
</ul>
<h2 id="工具">工具</h2>
<h3 id="介绍一下-simd-以及它在音视频处理中的应用">介绍一下 SIMD
以及它在音视频处理中的应用？</h3>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg">https://mp.weixin.qq.com/s/Iqlxn2B8Oxa98olHpsvfOg</a></p></li>
<li><p>SIMD（Single Instruction Multiple
Data）是一种并行计算的技术，它允许在单个指令中同时处理多个数据元素。SIMD
指令集通常由处理器提供，用于加速向量化计算，从而提高程序的性能。</p></li>
<li><p>1）在音频处理中，SIMD
可以用于实时音频效果处理，如均衡器、压缩器、混响器等，通过同时处理多个音频样本，可以提高音频处理的效率和实时性。</p></li>
<li><p>2）在视频处理中，SIMD
可以用于加速图像处理算法，如图像滤波、边缘检测、图像压缩等，通过同时处理多个像素，可以提高图像处理的速度和质量。</p></li>
<li><p>3）在视频编码中，SIMD 可以用于加速压缩和解压算法，如 H.264、H.265
编码器一些实现中，可以通过并行处理视频数据来提高视频编解码的效率和性能。</p></li>
</ul>
<h2 id="业务场景">业务场景</h2>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Bruce Yao
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://cmder.github.io/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6.html" title="音视频面试题集锦">https://cmder.github.io/音视频/音视频面试题集锦.html</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Android/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/RxJava/RxJava-%E8%AF%AD%E6%B3%95%E9%80%9F%E8%A7%88.html" rel="prev" title="RxJava 语法速览">
                  <i class="fa fa-angle-left"></i> RxJava 语法速览
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Android/Framework/Android-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%A1%86%E6%9E%B6.html" rel="next" title="Android 图形渲染框架">
                  Android 图形渲染框架 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2022 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bruce Yao</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/cmder" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: false,
  label: '🌓',
  autoMatchOsTheme: false
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
if (window.darkmode && !window.darkmode.isActivated()) {
  window.darkmode.toggle();
  var toggleButtons = document.getElementsByClassName("darkmode-toggle");
  if (toggleButtons && toggleButtons.length > 0) {
    for (i = 0; i < toggleButtons.length; i++) {
      toggleButtons[i].classList.add("darkmode-toggle--white");
    }
  }
}
</script>

</body>
</html>
